/**
 * @license Angular v12.2.12
 * Copyright Google LLC All Rights Reserved.
 * License: MIT
 */

let $deferred;
function define(modules, callback) {
  $deferred = {modules, callback};
}
module.exports = function(provided) {
  const ts = provided['typescript'];
  if (!ts) {
    throw new Error('Caller does not provide typescript module');
  }
  const results = {};
  const resolvedModules = $deferred.modules.map(m => {
    if (m === 'exports') {
      return results;
    }
    if (m === 'typescript' || m === 'typescript/lib/tsserverlibrary') {
      return ts;
    }
    return require(m);
  });
  $deferred.callback(...resolvedModules);
  return results;
};

define(['exports', 'typescript/lib/tsserverlibrary', 'os', 'typescript', 'fs', 'path'], function (exports, ts, os, ts$1, fs$1, path) { 'use strict';

    /**
     * The default `FileSystem` that will always fail.
     *
     * This is a way of ensuring that the developer consciously chooses and
     * configures the `FileSystem` before using it; particularly important when
     * considering static functions like `absoluteFrom()` which rely on
     * the `FileSystem` under the hood.
     */
    class InvalidFileSystem {
        exists(path) {
            throw makeError();
        }
        readFile(path) {
            throw makeError();
        }
        readFileBuffer(path) {
            throw makeError();
        }
        writeFile(path, data, exclusive) {
            throw makeError();
        }
        removeFile(path) {
            throw makeError();
        }
        symlink(target, path) {
            throw makeError();
        }
        readdir(path) {
            throw makeError();
        }
        lstat(path) {
            throw makeError();
        }
        stat(path) {
            throw makeError();
        }
        pwd() {
            throw makeError();
        }
        chdir(path) {
            throw makeError();
        }
        extname(path) {
            throw makeError();
        }
        copyFile(from, to) {
            throw makeError();
        }
        moveFile(from, to) {
            throw makeError();
        }
        ensureDir(path) {
            throw makeError();
        }
        removeDeep(path) {
            throw makeError();
        }
        isCaseSensitive() {
            throw makeError();
        }
        resolve(...paths) {
            throw makeError();
        }
        dirname(file) {
            throw makeError();
        }
        join(basePath, ...paths) {
            throw makeError();
        }
        isRoot(path) {
            throw makeError();
        }
        isRooted(path) {
            throw makeError();
        }
        relative(from, to) {
            throw makeError();
        }
        basename(filePath, extension) {
            throw makeError();
        }
        realpath(filePath) {
            throw makeError();
        }
        getDefaultLibLocation() {
            throw makeError();
        }
        normalize(path) {
            throw makeError();
        }
    }
    function makeError() {
        return new Error('FileSystem has not been configured. Please call `setFileSystem()` before calling this method.');
    }

    const TS_DTS_JS_EXTENSION = /(?:\.d)?\.ts$|\.js$/;
    /**
     * Remove a .ts, .d.ts, or .js extension from a file name.
     */
    function stripExtension(path) {
        return path.replace(TS_DTS_JS_EXTENSION, '');
    }
    function getSourceFileOrError(program, fileName) {
        const sf = program.getSourceFile(fileName);
        if (sf === undefined) {
            throw new Error(`Program does not contain "${fileName}" - available files are ${program.getSourceFiles().map(sf => sf.fileName).join(', ')}`);
        }
        return sf;
    }

    let fs = new InvalidFileSystem();
    function getFileSystem() {
        return fs;
    }
    function setFileSystem(fileSystem) {
        fs = fileSystem;
    }
    /**
     * Convert the path `path` to an `AbsoluteFsPath`, throwing an error if it's not an absolute path.
     */
    function absoluteFrom(path) {
        if (!fs.isRooted(path)) {
            throw new Error(`Internal Error: absoluteFrom(${path}): path is not absolute`);
        }
        return fs.resolve(path);
    }
    const ABSOLUTE_PATH = Symbol('AbsolutePath');
    /**
     * Extract an `AbsoluteFsPath` from a `ts.SourceFile`-like object.
     */
    function absoluteFromSourceFile(sf) {
        const sfWithPatch = sf;
        if (sfWithPatch[ABSOLUTE_PATH] === undefined) {
            sfWithPatch[ABSOLUTE_PATH] = fs.resolve(sfWithPatch.fileName);
        }
        // Non-null assertion needed since TS doesn't narrow the type of fields that use a symbol as a key
        // apparently.
        return sfWithPatch[ABSOLUTE_PATH];
    }
    /**
     * Static access to `dirname`.
     */
    function dirname(file) {
        return fs.dirname(file);
    }
    /**
     * Static access to `join`.
     */
    function join(basePath, ...paths) {
        return fs.join(basePath, ...paths);
    }
    /**
     * Static access to `resolve`s.
     */
    function resolve(basePath, ...paths) {
        return fs.resolve(basePath, ...paths);
    }
    /**
     * Static access to `isRooted`.
     */
    function isRooted(path) {
        return fs.isRooted(path);
    }
    /**
     * Static access to `relative`.
     */
    function relative(from, to) {
        return fs.relative(from, to);
    }
    /**
     * Returns true if the given path is locally relative.
     *
     * This is used to work out if the given path is relative (i.e. not absolute) but also is not
     * escaping the current directory.
     */
    function isLocalRelativePath(relativePath) {
        return !isRooted(relativePath) && !relativePath.startsWith('..');
    }
    /**
     * Converts a path to a form suitable for use as a relative module import specifier.
     *
     * In other words it adds the `./` to the path if it is locally relative.
     */
    function toRelativeImport(relativePath) {
        return isLocalRelativePath(relativePath) ? `./${relativePath}` : relativePath;
    }

    const LogicalProjectPath = {
        /**
         * Get the relative path between two `LogicalProjectPath`s.
         *
         * This will return a `PathSegment` which would be a valid module specifier to use in `from` when
         * importing from `to`.
         */
        relativePathBetween: function (from, to) {
            const relativePath = relative(dirname(resolve(from)), resolve(to));
            return toRelativeImport(relativePath);
        },
    };
    /**
     * A utility class which can translate absolute paths to source files into logical paths in
     * TypeScript's logical file system, based on the root directories of the project.
     */
    class LogicalFileSystem {
        constructor(rootDirs, compilerHost) {
            this.compilerHost = compilerHost;
            /**
             * A cache of file paths to project paths, because computation of these paths is slightly
             * expensive.
             */
            this.cache = new Map();
            // Make a copy and sort it by length in reverse order (longest first). This speeds up lookups,
            // since there's no need to keep going through the array once a match is found.
            this.rootDirs = rootDirs.concat([]).sort((a, b) => b.length - a.length);
            this.canonicalRootDirs =
                this.rootDirs.map(dir => this.compilerHost.getCanonicalFileName(dir));
        }
        /**
         * Get the logical path in the project of a `ts.SourceFile`.
         *
         * This method is provided as a convenient alternative to calling
         * `logicalPathOfFile(absoluteFromSourceFile(sf))`.
         */
        logicalPathOfSf(sf) {
            return this.logicalPathOfFile(absoluteFrom(sf.fileName));
        }
        /**
         * Get the logical path in the project of a source file.
         *
         * @returns A `LogicalProjectPath` to the source file, or `null` if the source file is not in any
         * of the TS project's root directories.
         */
        logicalPathOfFile(physicalFile) {
            const canonicalFilePath = this.compilerHost.getCanonicalFileName(physicalFile);
            if (!this.cache.has(canonicalFilePath)) {
                let logicalFile = null;
                for (let i = 0; i < this.rootDirs.length; i++) {
                    const rootDir = this.rootDirs[i];
                    const canonicalRootDir = this.canonicalRootDirs[i];
                    if (isWithinBasePath(canonicalRootDir, canonicalFilePath)) {
                        // Note that we match against canonical paths but then create the logical path from
                        // original paths.
                        logicalFile = this.createLogicalProjectPath(physicalFile, rootDir);
                        // The logical project does not include any special "node_modules" nested directories.
                        if (logicalFile.indexOf('/node_modules/') !== -1) {
                            logicalFile = null;
                        }
                        else {
                            break;
                        }
                    }
                }
                this.cache.set(canonicalFilePath, logicalFile);
            }
            return this.cache.get(canonicalFilePath);
        }
        createLogicalProjectPath(file, rootDir) {
            const logicalPath = stripExtension(file.substr(rootDir.length));
            return (logicalPath.startsWith('/') ? logicalPath : '/' + logicalPath);
        }
    }
    /**
     * Is the `path` a descendant of the `base`?
     * E.g. `foo/bar/zee` is within `foo/bar` but not within `foo/car`.
     */
    function isWithinBasePath(base, path) {
        return isLocalRelativePath(relative(base, path));
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A wrapper around the Node.js file-system that supports path manipulation.
     */
    class NodeJSPathManipulation {
        pwd() {
            return this.normalize(process.cwd());
        }
        chdir(dir) {
            process.chdir(dir);
        }
        resolve(...paths) {
            return this.normalize(path.resolve(...paths));
        }
        dirname(file) {
            return this.normalize(path.dirname(file));
        }
        join(basePath, ...paths) {
            return this.normalize(path.join(basePath, ...paths));
        }
        isRoot(path) {
            return this.dirname(path) === this.normalize(path);
        }
        isRooted(path$1) {
            return path.isAbsolute(path$1);
        }
        relative(from, to) {
            return this.normalize(path.relative(from, to));
        }
        basename(filePath, extension) {
            return path.basename(filePath, extension);
        }
        extname(path$1) {
            return path.extname(path$1);
        }
        normalize(path) {
            // Convert backslashes to forward slashes
            return path.replace(/\\/g, '/');
        }
    }
    /**
     * A wrapper around the Node.js file-system that supports readonly operations and path manipulation.
     */
    class NodeJSReadonlyFileSystem extends NodeJSPathManipulation {
        constructor() {
            super(...arguments);
            this._caseSensitive = undefined;
        }
        isCaseSensitive() {
            if (this._caseSensitive === undefined) {
                // Note the use of the real file-system is intentional:
                // `this.exists()` relies upon `isCaseSensitive()` so that would cause an infinite recursion.
                this._caseSensitive = !fs$1.existsSync(this.normalize(toggleCase(__filename)));
            }
            return this._caseSensitive;
        }
        exists(path) {
            return fs$1.existsSync(path);
        }
        readFile(path) {
            return fs$1.readFileSync(path, 'utf8');
        }
        readFileBuffer(path) {
            return fs$1.readFileSync(path);
        }
        readdir(path) {
            return fs$1.readdirSync(path);
        }
        lstat(path) {
            return fs$1.lstatSync(path);
        }
        stat(path) {
            return fs$1.statSync(path);
        }
        realpath(path) {
            return this.resolve(fs$1.realpathSync(path));
        }
        getDefaultLibLocation() {
            return this.resolve(require.resolve('typescript'), '..');
        }
    }
    /**
     * A wrapper around the Node.js file-system (i.e. the `fs` package).
     */
    class NodeJSFileSystem extends NodeJSReadonlyFileSystem {
        writeFile(path, data, exclusive = false) {
            fs$1.writeFileSync(path, data, exclusive ? { flag: 'wx' } : undefined);
        }
        removeFile(path) {
            fs$1.unlinkSync(path);
        }
        symlink(target, path) {
            fs$1.symlinkSync(target, path);
        }
        copyFile(from, to) {
            fs$1.copyFileSync(from, to);
        }
        moveFile(from, to) {
            fs$1.renameSync(from, to);
        }
        ensureDir(path) {
            const parents = [];
            while (!this.isRoot(path) && !this.exists(path)) {
                parents.push(path);
                path = this.dirname(path);
            }
            while (parents.length) {
                this.safeMkdir(parents.pop());
            }
        }
        removeDeep(path) {
            fs$1.rmdirSync(path, { recursive: true });
        }
        safeMkdir(path) {
            try {
                fs$1.mkdirSync(path);
            }
            catch (err) {
                // Ignore the error, if the path already exists and points to a directory.
                // Re-throw otherwise.
                if (!this.exists(path) || !this.stat(path).isDirectory()) {
                    throw err;
                }
            }
        }
    }
    /**
     * Toggle the case of each character in a string.
     */
    function toggleCase(str) {
        return str.replace(/\w/g, ch => ch.toUpperCase() === ch ? ch.toLowerCase() : ch.toUpperCase());
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var TagContentType;
    (function (TagContentType) {
        TagContentType[TagContentType["RAW_TEXT"] = 0] = "RAW_TEXT";
        TagContentType[TagContentType["ESCAPABLE_RAW_TEXT"] = 1] = "ESCAPABLE_RAW_TEXT";
        TagContentType[TagContentType["PARSABLE_DATA"] = 2] = "PARSABLE_DATA";
    })(TagContentType || (TagContentType = {}));
    function splitNsName(elementName) {
        if (elementName[0] != ':') {
            return [null, elementName];
        }
        const colonIndex = elementName.indexOf(':', 1);
        if (colonIndex === -1) {
            throw new Error(`Unsupported format "${elementName}" expecting ":namespace:name"`);
        }
        return [elementName.slice(1, colonIndex), elementName.slice(colonIndex + 1)];
    }
    // `<ng-container>` tags work the same regardless the namespace
    function isNgContainer(tagName) {
        return splitNsName(tagName)[1] === 'ng-container';
    }
    // `<ng-content>` tags work the same regardless the namespace
    function isNgContent(tagName) {
        return splitNsName(tagName)[1] === 'ng-content';
    }
    // `<ng-template>` tags work the same regardless the namespace
    function isNgTemplate(tagName) {
        return splitNsName(tagName)[1] === 'ng-template';
    }
    function getNsPrefix(fullName) {
        return fullName === null ? null : splitNsName(fullName)[0];
    }
    function mergeNsAndName(prefix, localName) {
        return prefix ? `:${prefix}:${localName}` : localName;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class HtmlTagDefinition {
        constructor({ closedByChildren, implicitNamespacePrefix, contentType = TagContentType.PARSABLE_DATA, closedByParent = false, isVoid = false, ignoreFirstLf = false, preventNamespaceInheritance = false } = {}) {
            this.closedByChildren = {};
            this.closedByParent = false;
            this.canSelfClose = false;
            if (closedByChildren && closedByChildren.length > 0) {
                closedByChildren.forEach(tagName => this.closedByChildren[tagName] = true);
            }
            this.isVoid = isVoid;
            this.closedByParent = closedByParent || isVoid;
            this.implicitNamespacePrefix = implicitNamespacePrefix || null;
            this.contentType = contentType;
            this.ignoreFirstLf = ignoreFirstLf;
            this.preventNamespaceInheritance = preventNamespaceInheritance;
        }
        isClosedByChild(name) {
            return this.isVoid || name.toLowerCase() in this.closedByChildren;
        }
        getContentType(prefix) {
            if (typeof this.contentType === 'object') {
                const overrideType = prefix === undefined ? undefined : this.contentType[prefix];
                return overrideType !== null && overrideType !== void 0 ? overrideType : this.contentType.default;
            }
            return this.contentType;
        }
    }
    let _DEFAULT_TAG_DEFINITION;
    // see https://www.w3.org/TR/html51/syntax.html#optional-tags
    // This implementation does not fully conform to the HTML5 spec.
    let TAG_DEFINITIONS;
    function getHtmlTagDefinition(tagName) {
        var _a, _b;
        if (!TAG_DEFINITIONS) {
            _DEFAULT_TAG_DEFINITION = new HtmlTagDefinition();
            TAG_DEFINITIONS = {
                'base': new HtmlTagDefinition({ isVoid: true }),
                'meta': new HtmlTagDefinition({ isVoid: true }),
                'area': new HtmlTagDefinition({ isVoid: true }),
                'embed': new HtmlTagDefinition({ isVoid: true }),
                'link': new HtmlTagDefinition({ isVoid: true }),
                'img': new HtmlTagDefinition({ isVoid: true }),
                'input': new HtmlTagDefinition({ isVoid: true }),
                'param': new HtmlTagDefinition({ isVoid: true }),
                'hr': new HtmlTagDefinition({ isVoid: true }),
                'br': new HtmlTagDefinition({ isVoid: true }),
                'source': new HtmlTagDefinition({ isVoid: true }),
                'track': new HtmlTagDefinition({ isVoid: true }),
                'wbr': new HtmlTagDefinition({ isVoid: true }),
                'p': new HtmlTagDefinition({
                    closedByChildren: [
                        'address', 'article', 'aside', 'blockquote', 'div', 'dl', 'fieldset',
                        'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5',
                        'h6', 'header', 'hgroup', 'hr', 'main', 'nav', 'ol',
                        'p', 'pre', 'section', 'table', 'ul'
                    ],
                    closedByParent: true
                }),
                'thead': new HtmlTagDefinition({ closedByChildren: ['tbody', 'tfoot'] }),
                'tbody': new HtmlTagDefinition({ closedByChildren: ['tbody', 'tfoot'], closedByParent: true }),
                'tfoot': new HtmlTagDefinition({ closedByChildren: ['tbody'], closedByParent: true }),
                'tr': new HtmlTagDefinition({ closedByChildren: ['tr'], closedByParent: true }),
                'td': new HtmlTagDefinition({ closedByChildren: ['td', 'th'], closedByParent: true }),
                'th': new HtmlTagDefinition({ closedByChildren: ['td', 'th'], closedByParent: true }),
                'col': new HtmlTagDefinition({ isVoid: true }),
                'svg': new HtmlTagDefinition({ implicitNamespacePrefix: 'svg' }),
                'foreignObject': new HtmlTagDefinition({
                    // Usually the implicit namespace here would be redundant since it will be inherited from
                    // the parent `svg`, but we have to do it for `foreignObject`, because the way the parser
                    // works is that the parent node of an end tag is its own start tag which means that
                    // the `preventNamespaceInheritance` on `foreignObject` would have it default to the
                    // implicit namespace which is `html`, unless specified otherwise.
                    implicitNamespacePrefix: 'svg',
                    // We want to prevent children of foreignObject from inheriting its namespace, because
                    // the point of the element is to allow nodes from other namespaces to be inserted.
                    preventNamespaceInheritance: true,
                }),
                'math': new HtmlTagDefinition({ implicitNamespacePrefix: 'math' }),
                'li': new HtmlTagDefinition({ closedByChildren: ['li'], closedByParent: true }),
                'dt': new HtmlTagDefinition({ closedByChildren: ['dt', 'dd'] }),
                'dd': new HtmlTagDefinition({ closedByChildren: ['dt', 'dd'], closedByParent: true }),
                'rb': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),
                'rt': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),
                'rtc': new HtmlTagDefinition({ closedByChildren: ['rb', 'rtc', 'rp'], closedByParent: true }),
                'rp': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),
                'optgroup': new HtmlTagDefinition({ closedByChildren: ['optgroup'], closedByParent: true }),
                'option': new HtmlTagDefinition({ closedByChildren: ['option', 'optgroup'], closedByParent: true }),
                'pre': new HtmlTagDefinition({ ignoreFirstLf: true }),
                'listing': new HtmlTagDefinition({ ignoreFirstLf: true }),
                'style': new HtmlTagDefinition({ contentType: TagContentType.RAW_TEXT }),
                'script': new HtmlTagDefinition({ contentType: TagContentType.RAW_TEXT }),
                'title': new HtmlTagDefinition({
                    // The browser supports two separate `title` tags which have to use
                    // a different content type: `HTMLTitleElement` and `SVGTitleElement`
                    contentType: { default: TagContentType.ESCAPABLE_RAW_TEXT, svg: TagContentType.PARSABLE_DATA }
                }),
                'textarea': new HtmlTagDefinition({ contentType: TagContentType.ESCAPABLE_RAW_TEXT, ignoreFirstLf: true }),
            };
        }
        // We have to make both a case-sensitive and a case-insesitive lookup, because
        // HTML tag names are case insensitive, whereas some SVG tags are case sensitive.
        return (_b = (_a = TAG_DEFINITIONS[tagName]) !== null && _a !== void 0 ? _a : TAG_DEFINITIONS[tagName.toLowerCase()]) !== null && _b !== void 0 ? _b : _DEFAULT_TAG_DEFINITION;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const _SELECTOR_REGEXP = new RegExp('(\\:not\\()|' + // 1: ":not("
        '(([\\.\\#]?)[-\\w]+)|' + // 2: "tag"; 3: "."/"#";
        // "-" should appear first in the regexp below as FF31 parses "[.-\w]" as a range
        // 4: attribute; 5: attribute_string; 6: attribute_value
        '(?:\\[([-.\\w*\\\\$]+)(?:=([\"\']?)([^\\]\"\']*)\\5)?\\])|' + // "[name]", "[name=value]",
        // "[name="value"]",
        // "[name='value']"
        '(\\))|' + // 7: ")"
        '(\\s*,\\s*)', // 8: ","
    'g');
    /**
     * A css selector contains an element name,
     * css classes and attribute/value pairs with the purpose
     * of selecting subsets out of them.
     */
    class CssSelector {
        constructor() {
            this.element = null;
            this.classNames = [];
            /**
             * The selectors are encoded in pairs where:
             * - even locations are attribute names
             * - odd locations are attribute values.
             *
             * Example:
             * Selector: `[key1=value1][key2]` would parse to:
             * ```
             * ['key1', 'value1', 'key2', '']
             * ```
             */
            this.attrs = [];
            this.notSelectors = [];
        }
        static parse(selector) {
            const results = [];
            const _addResult = (res, cssSel) => {
                if (cssSel.notSelectors.length > 0 && !cssSel.element && cssSel.classNames.length == 0 &&
                    cssSel.attrs.length == 0) {
                    cssSel.element = '*';
                }
                res.push(cssSel);
            };
            let cssSelector = new CssSelector();
            let match;
            let current = cssSelector;
            let inNot = false;
            _SELECTOR_REGEXP.lastIndex = 0;
            while (match = _SELECTOR_REGEXP.exec(selector)) {
                if (match[1 /* NOT */]) {
                    if (inNot) {
                        throw new Error('Nesting :not in a selector is not allowed');
                    }
                    inNot = true;
                    current = new CssSelector();
                    cssSelector.notSelectors.push(current);
                }
                const tag = match[2 /* TAG */];
                if (tag) {
                    const prefix = match[3 /* PREFIX */];
                    if (prefix === '#') {
                        // #hash
                        current.addAttribute('id', tag.substr(1));
                    }
                    else if (prefix === '.') {
                        // Class
                        current.addClassName(tag.substr(1));
                    }
                    else {
                        // Element
                        current.setElement(tag);
                    }
                }
                const attribute = match[4 /* ATTRIBUTE */];
                if (attribute) {
                    current.addAttribute(current.unescapeAttribute(attribute), match[6 /* ATTRIBUTE_VALUE */]);
                }
                if (match[7 /* NOT_END */]) {
                    inNot = false;
                    current = cssSelector;
                }
                if (match[8 /* SEPARATOR */]) {
                    if (inNot) {
                        throw new Error('Multiple selectors in :not are not supported');
                    }
                    _addResult(results, cssSelector);
                    cssSelector = current = new CssSelector();
                }
            }
            _addResult(results, cssSelector);
            return results;
        }
        /**
         * Unescape `\$` sequences from the CSS attribute selector.
         *
         * This is needed because `$` can have a special meaning in CSS selectors,
         * but we might want to match an attribute that contains `$`.
         * [MDN web link for more
         * info](https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors).
         * @param attr the attribute to unescape.
         * @returns the unescaped string.
         */
        unescapeAttribute(attr) {
            let result = '';
            let escaping = false;
            for (let i = 0; i < attr.length; i++) {
                const char = attr.charAt(i);
                if (char === '\\') {
                    escaping = true;
                    continue;
                }
                if (char === '$' && !escaping) {
                    throw new Error(`Error in attribute selector "${attr}". ` +
                        `Unescaped "$" is not supported. Please escape with "\\$".`);
                }
                escaping = false;
                result += char;
            }
            return result;
        }
        /**
         * Escape `$` sequences from the CSS attribute selector.
         *
         * This is needed because `$` can have a special meaning in CSS selectors,
         * with this method we are escaping `$` with `\$'.
         * [MDN web link for more
         * info](https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors).
         * @param attr the attribute to escape.
         * @returns the escaped string.
         */
        escapeAttribute(attr) {
            return attr.replace(/\\/g, '\\\\').replace(/\$/g, '\\$');
        }
        isElementSelector() {
            return this.hasElementSelector() && this.classNames.length == 0 && this.attrs.length == 0 &&
                this.notSelectors.length === 0;
        }
        hasElementSelector() {
            return !!this.element;
        }
        setElement(element = null) {
            this.element = element;
        }
        /** Gets a template string for an element that matches the selector. */
        getMatchingElementTemplate() {
            const tagName = this.element || 'div';
            const classAttr = this.classNames.length > 0 ? ` class="${this.classNames.join(' ')}"` : '';
            let attrs = '';
            for (let i = 0; i < this.attrs.length; i += 2) {
                const attrName = this.attrs[i];
                const attrValue = this.attrs[i + 1] !== '' ? `="${this.attrs[i + 1]}"` : '';
                attrs += ` ${attrName}${attrValue}`;
            }
            return getHtmlTagDefinition(tagName).isVoid ? `<${tagName}${classAttr}${attrs}/>` :
                `<${tagName}${classAttr}${attrs}></${tagName}>`;
        }
        getAttrs() {
            const result = [];
            if (this.classNames.length > 0) {
                result.push('class', this.classNames.join(' '));
            }
            return result.concat(this.attrs);
        }
        addAttribute(name, value = '') {
            this.attrs.push(name, value && value.toLowerCase() || '');
        }
        addClassName(name) {
            this.classNames.push(name.toLowerCase());
        }
        toString() {
            let res = this.element || '';
            if (this.classNames) {
                this.classNames.forEach(klass => res += `.${klass}`);
            }
            if (this.attrs) {
                for (let i = 0; i < this.attrs.length; i += 2) {
                    const name = this.escapeAttribute(this.attrs[i]);
                    const value = this.attrs[i + 1];
                    res += `[${name}${value ? '=' + value : ''}]`;
                }
            }
            this.notSelectors.forEach(notSelector => res += `:not(${notSelector})`);
            return res;
        }
    }
    /**
     * Reads a list of CssSelectors and allows to calculate which ones
     * are contained in a given CssSelector.
     */
    class SelectorMatcher {
        constructor() {
            this._elementMap = new Map();
            this._elementPartialMap = new Map();
            this._classMap = new Map();
            this._classPartialMap = new Map();
            this._attrValueMap = new Map();
            this._attrValuePartialMap = new Map();
            this._listContexts = [];
        }
        static createNotMatcher(notSelectors) {
            const notMatcher = new SelectorMatcher();
            notMatcher.addSelectables(notSelectors, null);
            return notMatcher;
        }
        addSelectables(cssSelectors, callbackCtxt) {
            let listContext = null;
            if (cssSelectors.length > 1) {
                listContext = new SelectorListContext(cssSelectors);
                this._listContexts.push(listContext);
            }
            for (let i = 0; i < cssSelectors.length; i++) {
                this._addSelectable(cssSelectors[i], callbackCtxt, listContext);
            }
        }
        /**
         * Add an object that can be found later on by calling `match`.
         * @param cssSelector A css selector
         * @param callbackCtxt An opaque object that will be given to the callback of the `match` function
         */
        _addSelectable(cssSelector, callbackCtxt, listContext) {
            let matcher = this;
            const element = cssSelector.element;
            const classNames = cssSelector.classNames;
            const attrs = cssSelector.attrs;
            const selectable = new SelectorContext(cssSelector, callbackCtxt, listContext);
            if (element) {
                const isTerminal = attrs.length === 0 && classNames.length === 0;
                if (isTerminal) {
                    this._addTerminal(matcher._elementMap, element, selectable);
                }
                else {
                    matcher = this._addPartial(matcher._elementPartialMap, element);
                }
            }
            if (classNames) {
                for (let i = 0; i < classNames.length; i++) {
                    const isTerminal = attrs.length === 0 && i === classNames.length - 1;
                    const className = classNames[i];
                    if (isTerminal) {
                        this._addTerminal(matcher._classMap, className, selectable);
                    }
                    else {
                        matcher = this._addPartial(matcher._classPartialMap, className);
                    }
                }
            }
            if (attrs) {
                for (let i = 0; i < attrs.length; i += 2) {
                    const isTerminal = i === attrs.length - 2;
                    const name = attrs[i];
                    const value = attrs[i + 1];
                    if (isTerminal) {
                        const terminalMap = matcher._attrValueMap;
                        let terminalValuesMap = terminalMap.get(name);
                        if (!terminalValuesMap) {
                            terminalValuesMap = new Map();
                            terminalMap.set(name, terminalValuesMap);
                        }
                        this._addTerminal(terminalValuesMap, value, selectable);
                    }
                    else {
                        const partialMap = matcher._attrValuePartialMap;
                        let partialValuesMap = partialMap.get(name);
                        if (!partialValuesMap) {
                            partialValuesMap = new Map();
                            partialMap.set(name, partialValuesMap);
                        }
                        matcher = this._addPartial(partialValuesMap, value);
                    }
                }
            }
        }
        _addTerminal(map, name, selectable) {
            let terminalList = map.get(name);
            if (!terminalList) {
                terminalList = [];
                map.set(name, terminalList);
            }
            terminalList.push(selectable);
        }
        _addPartial(map, name) {
            let matcher = map.get(name);
            if (!matcher) {
                matcher = new SelectorMatcher();
                map.set(name, matcher);
            }
            return matcher;
        }
        /**
         * Find the objects that have been added via `addSelectable`
         * whose css selector is contained in the given css selector.
         * @param cssSelector A css selector
         * @param matchedCallback This callback will be called with the object handed into `addSelectable`
         * @return boolean true if a match was found
         */
        match(cssSelector, matchedCallback) {
            let result = false;
            const element = cssSelector.element;
            const classNames = cssSelector.classNames;
            const attrs = cssSelector.attrs;
            for (let i = 0; i < this._listContexts.length; i++) {
                this._listContexts[i].alreadyMatched = false;
            }
            result = this._matchTerminal(this._elementMap, element, cssSelector, matchedCallback) || result;
            result = this._matchPartial(this._elementPartialMap, element, cssSelector, matchedCallback) ||
                result;
            if (classNames) {
                for (let i = 0; i < classNames.length; i++) {
                    const className = classNames[i];
                    result =
                        this._matchTerminal(this._classMap, className, cssSelector, matchedCallback) || result;
                    result =
                        this._matchPartial(this._classPartialMap, className, cssSelector, matchedCallback) ||
                            result;
                }
            }
            if (attrs) {
                for (let i = 0; i < attrs.length; i += 2) {
                    const name = attrs[i];
                    const value = attrs[i + 1];
                    const terminalValuesMap = this._attrValueMap.get(name);
                    if (value) {
                        result =
                            this._matchTerminal(terminalValuesMap, '', cssSelector, matchedCallback) || result;
                    }
                    result =
                        this._matchTerminal(terminalValuesMap, value, cssSelector, matchedCallback) || result;
                    const partialValuesMap = this._attrValuePartialMap.get(name);
                    if (value) {
                        result = this._matchPartial(partialValuesMap, '', cssSelector, matchedCallback) || result;
                    }
                    result =
                        this._matchPartial(partialValuesMap, value, cssSelector, matchedCallback) || result;
                }
            }
            return result;
        }
        /** @internal */
        _matchTerminal(map, name, cssSelector, matchedCallback) {
            if (!map || typeof name !== 'string') {
                return false;
            }
            let selectables = map.get(name) || [];
            const starSelectables = map.get('*');
            if (starSelectables) {
                selectables = selectables.concat(starSelectables);
            }
            if (selectables.length === 0) {
                return false;
            }
            let selectable;
            let result = false;
            for (let i = 0; i < selectables.length; i++) {
                selectable = selectables[i];
                result = selectable.finalize(cssSelector, matchedCallback) || result;
            }
            return result;
        }
        /** @internal */
        _matchPartial(map, name, cssSelector, matchedCallback) {
            if (!map || typeof name !== 'string') {
                return false;
            }
            const nestedSelector = map.get(name);
            if (!nestedSelector) {
                return false;
            }
            // TODO(perf): get rid of recursion and measure again
            // TODO(perf): don't pass the whole selector into the recursion,
            // but only the not processed parts
            return nestedSelector.match(cssSelector, matchedCallback);
        }
    }
    class SelectorListContext {
        constructor(selectors) {
            this.selectors = selectors;
            this.alreadyMatched = false;
        }
    }
    // Store context to pass back selector and context when a selector is matched
    class SelectorContext {
        constructor(selector, cbContext, listContext) {
            this.selector = selector;
            this.cbContext = cbContext;
            this.listContext = listContext;
            this.notSelectors = selector.notSelectors;
        }
        finalize(cssSelector, callback) {
            let result = true;
            if (this.notSelectors.length > 0 && (!this.listContext || !this.listContext.alreadyMatched)) {
                const notMatcher = SelectorMatcher.createNotMatcher(this.notSelectors);
                result = !notMatcher.match(cssSelector, null);
            }
            if (result && callback && (!this.listContext || !this.listContext.alreadyMatched)) {
                if (this.listContext) {
                    this.listContext.alreadyMatched = true;
                }
                callback(this.selector, this.cbContext);
            }
            return result;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    // Stores the default value of `emitDistinctChangesOnly` when the `emitDistinctChangesOnly` is not
    // explicitly set.
    const emitDistinctChangesOnlyDefaultValue = true;
    var ViewEncapsulation;
    (function (ViewEncapsulation) {
        ViewEncapsulation[ViewEncapsulation["Emulated"] = 0] = "Emulated";
        // Historically the 1 value was for `Native` encapsulation which has been removed as of v11.
        ViewEncapsulation[ViewEncapsulation["None"] = 2] = "None";
        ViewEncapsulation[ViewEncapsulation["ShadowDom"] = 3] = "ShadowDom";
    })(ViewEncapsulation || (ViewEncapsulation = {}));
    var ChangeDetectionStrategy;
    (function (ChangeDetectionStrategy) {
        ChangeDetectionStrategy[ChangeDetectionStrategy["OnPush"] = 0] = "OnPush";
        ChangeDetectionStrategy[ChangeDetectionStrategy["Default"] = 1] = "Default";
    })(ChangeDetectionStrategy || (ChangeDetectionStrategy = {}));
    const CUSTOM_ELEMENTS_SCHEMA = {
        name: 'custom-elements'
    };
    const NO_ERRORS_SCHEMA = {
        name: 'no-errors-schema'
    };
    var SecurityContext;
    (function (SecurityContext) {
        SecurityContext[SecurityContext["NONE"] = 0] = "NONE";
        SecurityContext[SecurityContext["HTML"] = 1] = "HTML";
        SecurityContext[SecurityContext["STYLE"] = 2] = "STYLE";
        SecurityContext[SecurityContext["SCRIPT"] = 3] = "SCRIPT";
        SecurityContext[SecurityContext["URL"] = 4] = "URL";
        SecurityContext[SecurityContext["RESOURCE_URL"] = 5] = "RESOURCE_URL";
    })(SecurityContext || (SecurityContext = {}));
    var MissingTranslationStrategy;
    (function (MissingTranslationStrategy) {
        MissingTranslationStrategy[MissingTranslationStrategy["Error"] = 0] = "Error";
        MissingTranslationStrategy[MissingTranslationStrategy["Warning"] = 1] = "Warning";
        MissingTranslationStrategy[MissingTranslationStrategy["Ignore"] = 2] = "Ignore";
    })(MissingTranslationStrategy || (MissingTranslationStrategy = {}));
    function parserSelectorToSimpleSelector(selector) {
        const classes = selector.classNames && selector.classNames.length ?
            [8 /* CLASS */, ...selector.classNames] :
            [];
        const elementName = selector.element && selector.element !== '*' ? selector.element : '';
        return [elementName, ...selector.attrs, ...classes];
    }
    function parserSelectorToNegativeSelector(selector) {
        const classes = selector.classNames && selector.classNames.length ?
            [8 /* CLASS */, ...selector.classNames] :
            [];
        if (selector.element) {
            return [
                1 /* NOT */ | 4 /* ELEMENT */, selector.element, ...selector.attrs, ...classes
            ];
        }
        else if (selector.attrs.length) {
            return [1 /* NOT */ | 2 /* ATTRIBUTE */, ...selector.attrs, ...classes];
        }
        else {
            return selector.classNames && selector.classNames.length ?
                [1 /* NOT */ | 8 /* CLASS */, ...selector.classNames] :
                [];
        }
    }
    function parserSelectorToR3Selector(selector) {
        const positive = parserSelectorToSimpleSelector(selector);
        const negative = selector.notSelectors && selector.notSelectors.length ?
            selector.notSelectors.map(notSelector => parserSelectorToNegativeSelector(notSelector)) :
            [];
        return positive.concat(...negative);
    }
    function parseSelectorToR3Selector(selector) {
        return selector ? CssSelector.parse(selector).map(parserSelectorToR3Selector) : [];
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    //// Types
    var TypeModifier;
    (function (TypeModifier) {
        TypeModifier[TypeModifier["Const"] = 0] = "Const";
    })(TypeModifier || (TypeModifier = {}));
    class Type {
        constructor(modifiers = []) {
            this.modifiers = modifiers;
        }
        hasModifier(modifier) {
            return this.modifiers.indexOf(modifier) !== -1;
        }
    }
    var BuiltinTypeName;
    (function (BuiltinTypeName) {
        BuiltinTypeName[BuiltinTypeName["Dynamic"] = 0] = "Dynamic";
        BuiltinTypeName[BuiltinTypeName["Bool"] = 1] = "Bool";
        BuiltinTypeName[BuiltinTypeName["String"] = 2] = "String";
        BuiltinTypeName[BuiltinTypeName["Int"] = 3] = "Int";
        BuiltinTypeName[BuiltinTypeName["Number"] = 4] = "Number";
        BuiltinTypeName[BuiltinTypeName["Function"] = 5] = "Function";
        BuiltinTypeName[BuiltinTypeName["Inferred"] = 6] = "Inferred";
        BuiltinTypeName[BuiltinTypeName["None"] = 7] = "None";
    })(BuiltinTypeName || (BuiltinTypeName = {}));
    class BuiltinType extends Type {
        constructor(name, modifiers) {
            super(modifiers);
            this.name = name;
        }
        visitType(visitor, context) {
            return visitor.visitBuiltinType(this, context);
        }
    }
    class ExpressionType extends Type {
        constructor(value, modifiers, typeParams = null) {
            super(modifiers);
            this.value = value;
            this.typeParams = typeParams;
        }
        visitType(visitor, context) {
            return visitor.visitExpressionType(this, context);
        }
    }
    const DYNAMIC_TYPE = new BuiltinType(BuiltinTypeName.Dynamic);
    const INFERRED_TYPE = new BuiltinType(BuiltinTypeName.Inferred);
    const BOOL_TYPE = new BuiltinType(BuiltinTypeName.Bool);
    const INT_TYPE = new BuiltinType(BuiltinTypeName.Int);
    const NUMBER_TYPE = new BuiltinType(BuiltinTypeName.Number);
    const STRING_TYPE = new BuiltinType(BuiltinTypeName.String);
    const FUNCTION_TYPE = new BuiltinType(BuiltinTypeName.Function);
    const NONE_TYPE = new BuiltinType(BuiltinTypeName.None);
    ///// Expressions
    var UnaryOperator;
    (function (UnaryOperator) {
        UnaryOperator[UnaryOperator["Minus"] = 0] = "Minus";
        UnaryOperator[UnaryOperator["Plus"] = 1] = "Plus";
    })(UnaryOperator || (UnaryOperator = {}));
    var BinaryOperator;
    (function (BinaryOperator) {
        BinaryOperator[BinaryOperator["Equals"] = 0] = "Equals";
        BinaryOperator[BinaryOperator["NotEquals"] = 1] = "NotEquals";
        BinaryOperator[BinaryOperator["Identical"] = 2] = "Identical";
        BinaryOperator[BinaryOperator["NotIdentical"] = 3] = "NotIdentical";
        BinaryOperator[BinaryOperator["Minus"] = 4] = "Minus";
        BinaryOperator[BinaryOperator["Plus"] = 5] = "Plus";
        BinaryOperator[BinaryOperator["Divide"] = 6] = "Divide";
        BinaryOperator[BinaryOperator["Multiply"] = 7] = "Multiply";
        BinaryOperator[BinaryOperator["Modulo"] = 8] = "Modulo";
        BinaryOperator[BinaryOperator["And"] = 9] = "And";
        BinaryOperator[BinaryOperator["Or"] = 10] = "Or";
        BinaryOperator[BinaryOperator["BitwiseAnd"] = 11] = "BitwiseAnd";
        BinaryOperator[BinaryOperator["Lower"] = 12] = "Lower";
        BinaryOperator[BinaryOperator["LowerEquals"] = 13] = "LowerEquals";
        BinaryOperator[BinaryOperator["Bigger"] = 14] = "Bigger";
        BinaryOperator[BinaryOperator["BiggerEquals"] = 15] = "BiggerEquals";
        BinaryOperator[BinaryOperator["NullishCoalesce"] = 16] = "NullishCoalesce";
    })(BinaryOperator || (BinaryOperator = {}));
    function nullSafeIsEquivalent(base, other) {
        if (base == null || other == null) {
            return base == other;
        }
        return base.isEquivalent(other);
    }
    function areAllEquivalentPredicate(base, other, equivalentPredicate) {
        const len = base.length;
        if (len !== other.length) {
            return false;
        }
        for (let i = 0; i < len; i++) {
            if (!equivalentPredicate(base[i], other[i])) {
                return false;
            }
        }
        return true;
    }
    function areAllEquivalent(base, other) {
        return areAllEquivalentPredicate(base, other, (baseElement, otherElement) => baseElement.isEquivalent(otherElement));
    }
    class Expression {
        constructor(type, sourceSpan) {
            this.type = type || null;
            this.sourceSpan = sourceSpan || null;
        }
        prop(name, sourceSpan) {
            return new ReadPropExpr(this, name, null, sourceSpan);
        }
        key(index, type, sourceSpan) {
            return new ReadKeyExpr(this, index, type, sourceSpan);
        }
        callMethod(name, params, sourceSpan) {
            return new InvokeMethodExpr(this, name, params, null, sourceSpan);
        }
        callFn(params, sourceSpan, pure) {
            return new InvokeFunctionExpr(this, params, null, sourceSpan, pure);
        }
        instantiate(params, type, sourceSpan) {
            return new InstantiateExpr(this, params, type, sourceSpan);
        }
        conditional(trueCase, falseCase = null, sourceSpan) {
            return new ConditionalExpr(this, trueCase, falseCase, null, sourceSpan);
        }
        equals(rhs, sourceSpan) {
            return new BinaryOperatorExpr(BinaryOperator.Equals, this, rhs, null, sourceSpan);
        }
        notEquals(rhs, sourceSpan) {
            return new BinaryOperatorExpr(BinaryOperator.NotEquals, this, rhs, null, sourceSpan);
        }
        identical(rhs, sourceSpan) {
            return new BinaryOperatorExpr(BinaryOperator.Identical, this, rhs, null, sourceSpan);
        }
        notIdentical(rhs, sourceSpan) {
            return new BinaryOperatorExpr(BinaryOperator.NotIdentical, this, rhs, null, sourceSpan);
        }
        minus(rhs, sourceSpan) {
            return new BinaryOperatorExpr(BinaryOperator.Minus, this, rhs, null, sourceSpan);
        }
        plus(rhs, sourceSpan) {
            return new BinaryOperatorExpr(BinaryOperator.Plus, this, rhs, null, sourceSpan);
        }
        divide(rhs, sourceSpan) {
            return new BinaryOperatorExpr(BinaryOperator.Divide, this, rhs, null, sourceSpan);
        }
        multiply(rhs, sourceSpan) {
            return new BinaryOperatorExpr(BinaryOperator.Multiply, this, rhs, null, sourceSpan);
        }
        modulo(rhs, sourceSpan) {
            return new BinaryOperatorExpr(BinaryOperator.Modulo, this, rhs, null, sourceSpan);
        }
        and(rhs, sourceSpan) {
            return new BinaryOperatorExpr(BinaryOperator.And, this, rhs, null, sourceSpan);
        }
        bitwiseAnd(rhs, sourceSpan, parens = true) {
            return new BinaryOperatorExpr(BinaryOperator.BitwiseAnd, this, rhs, null, sourceSpan, parens);
        }
        or(rhs, sourceSpan) {
            return new BinaryOperatorExpr(BinaryOperator.Or, this, rhs, null, sourceSpan);
        }
        lower(rhs, sourceSpan) {
            return new BinaryOperatorExpr(BinaryOperator.Lower, this, rhs, null, sourceSpan);
        }
        lowerEquals(rhs, sourceSpan) {
            return new BinaryOperatorExpr(BinaryOperator.LowerEquals, this, rhs, null, sourceSpan);
        }
        bigger(rhs, sourceSpan) {
            return new BinaryOperatorExpr(BinaryOperator.Bigger, this, rhs, null, sourceSpan);
        }
        biggerEquals(rhs, sourceSpan) {
            return new BinaryOperatorExpr(BinaryOperator.BiggerEquals, this, rhs, null, sourceSpan);
        }
        isBlank(sourceSpan) {
            // Note: We use equals by purpose here to compare to null and undefined in JS.
            // We use the typed null to allow strictNullChecks to narrow types.
            return this.equals(TYPED_NULL_EXPR, sourceSpan);
        }
        cast(type, sourceSpan) {
            return new CastExpr(this, type, sourceSpan);
        }
        nullishCoalesce(rhs, sourceSpan) {
            return new BinaryOperatorExpr(BinaryOperator.NullishCoalesce, this, rhs, null, sourceSpan);
        }
        toStmt() {
            return new ExpressionStatement(this, null);
        }
    }
    var BuiltinVar;
    (function (BuiltinVar) {
        BuiltinVar[BuiltinVar["This"] = 0] = "This";
        BuiltinVar[BuiltinVar["Super"] = 1] = "Super";
        BuiltinVar[BuiltinVar["CatchError"] = 2] = "CatchError";
        BuiltinVar[BuiltinVar["CatchStack"] = 3] = "CatchStack";
    })(BuiltinVar || (BuiltinVar = {}));
    class ReadVarExpr extends Expression {
        constructor(name, type, sourceSpan) {
            super(type, sourceSpan);
            if (typeof name === 'string') {
                this.name = name;
                this.builtin = null;
            }
            else {
                this.name = null;
                this.builtin = name;
            }
        }
        isEquivalent(e) {
            return e instanceof ReadVarExpr && this.name === e.name && this.builtin === e.builtin;
        }
        isConstant() {
            return false;
        }
        visitExpression(visitor, context) {
            return visitor.visitReadVarExpr(this, context);
        }
        set(value) {
            if (!this.name) {
                throw new Error(`Built in variable ${this.builtin} can not be assigned to.`);
            }
            return new WriteVarExpr(this.name, value, null, this.sourceSpan);
        }
    }
    class TypeofExpr extends Expression {
        constructor(expr, type, sourceSpan) {
            super(type, sourceSpan);
            this.expr = expr;
        }
        visitExpression(visitor, context) {
            return visitor.visitTypeofExpr(this, context);
        }
        isEquivalent(e) {
            return e instanceof TypeofExpr && e.expr.isEquivalent(this.expr);
        }
        isConstant() {
            return this.expr.isConstant();
        }
    }
    class WrappedNodeExpr extends Expression {
        constructor(node, type, sourceSpan) {
            super(type, sourceSpan);
            this.node = node;
        }
        isEquivalent(e) {
            return e instanceof WrappedNodeExpr && this.node === e.node;
        }
        isConstant() {
            return false;
        }
        visitExpression(visitor, context) {
            return visitor.visitWrappedNodeExpr(this, context);
        }
    }
    class WriteVarExpr extends Expression {
        constructor(name, value, type, sourceSpan) {
            super(type || value.type, sourceSpan);
            this.name = name;
            this.value = value;
        }
        isEquivalent(e) {
            return e instanceof WriteVarExpr && this.name === e.name && this.value.isEquivalent(e.value);
        }
        isConstant() {
            return false;
        }
        visitExpression(visitor, context) {
            return visitor.visitWriteVarExpr(this, context);
        }
        toDeclStmt(type, modifiers) {
            return new DeclareVarStmt(this.name, this.value, type, modifiers, this.sourceSpan);
        }
        toConstDecl() {
            return this.toDeclStmt(INFERRED_TYPE, [StmtModifier.Final]);
        }
    }
    class WriteKeyExpr extends Expression {
        constructor(receiver, index, value, type, sourceSpan) {
            super(type || value.type, sourceSpan);
            this.receiver = receiver;
            this.index = index;
            this.value = value;
        }
        isEquivalent(e) {
            return e instanceof WriteKeyExpr && this.receiver.isEquivalent(e.receiver) &&
                this.index.isEquivalent(e.index) && this.value.isEquivalent(e.value);
        }
        isConstant() {
            return false;
        }
        visitExpression(visitor, context) {
            return visitor.visitWriteKeyExpr(this, context);
        }
    }
    class WritePropExpr extends Expression {
        constructor(receiver, name, value, type, sourceSpan) {
            super(type || value.type, sourceSpan);
            this.receiver = receiver;
            this.name = name;
            this.value = value;
        }
        isEquivalent(e) {
            return e instanceof WritePropExpr && this.receiver.isEquivalent(e.receiver) &&
                this.name === e.name && this.value.isEquivalent(e.value);
        }
        isConstant() {
            return false;
        }
        visitExpression(visitor, context) {
            return visitor.visitWritePropExpr(this, context);
        }
    }
    var BuiltinMethod;
    (function (BuiltinMethod) {
        BuiltinMethod[BuiltinMethod["ConcatArray"] = 0] = "ConcatArray";
        BuiltinMethod[BuiltinMethod["SubscribeObservable"] = 1] = "SubscribeObservable";
        BuiltinMethod[BuiltinMethod["Bind"] = 2] = "Bind";
    })(BuiltinMethod || (BuiltinMethod = {}));
    class InvokeMethodExpr extends Expression {
        constructor(receiver, method, args, type, sourceSpan) {
            super(type, sourceSpan);
            this.receiver = receiver;
            this.args = args;
            if (typeof method === 'string') {
                this.name = method;
                this.builtin = null;
            }
            else {
                this.name = null;
                this.builtin = method;
            }
        }
        isEquivalent(e) {
            return e instanceof InvokeMethodExpr && this.receiver.isEquivalent(e.receiver) &&
                this.name === e.name && this.builtin === e.builtin && areAllEquivalent(this.args, e.args);
        }
        isConstant() {
            return false;
        }
        visitExpression(visitor, context) {
            return visitor.visitInvokeMethodExpr(this, context);
        }
    }
    class InvokeFunctionExpr extends Expression {
        constructor(fn, args, type, sourceSpan, pure = false) {
            super(type, sourceSpan);
            this.fn = fn;
            this.args = args;
            this.pure = pure;
        }
        isEquivalent(e) {
            return e instanceof InvokeFunctionExpr && this.fn.isEquivalent(e.fn) &&
                areAllEquivalent(this.args, e.args) && this.pure === e.pure;
        }
        isConstant() {
            return false;
        }
        visitExpression(visitor, context) {
            return visitor.visitInvokeFunctionExpr(this, context);
        }
    }
    class TaggedTemplateExpr extends Expression {
        constructor(tag, template, type, sourceSpan) {
            super(type, sourceSpan);
            this.tag = tag;
            this.template = template;
        }
        isEquivalent(e) {
            return e instanceof TaggedTemplateExpr && this.tag.isEquivalent(e.tag) &&
                areAllEquivalentPredicate(this.template.elements, e.template.elements, (a, b) => a.text === b.text) &&
                areAllEquivalent(this.template.expressions, e.template.expressions);
        }
        isConstant() {
            return false;
        }
        visitExpression(visitor, context) {
            return visitor.visitTaggedTemplateExpr(this, context);
        }
    }
    class InstantiateExpr extends Expression {
        constructor(classExpr, args, type, sourceSpan) {
            super(type, sourceSpan);
            this.classExpr = classExpr;
            this.args = args;
        }
        isEquivalent(e) {
            return e instanceof InstantiateExpr && this.classExpr.isEquivalent(e.classExpr) &&
                areAllEquivalent(this.args, e.args);
        }
        isConstant() {
            return false;
        }
        visitExpression(visitor, context) {
            return visitor.visitInstantiateExpr(this, context);
        }
    }
    class LiteralExpr extends Expression {
        constructor(value, type, sourceSpan) {
            super(type, sourceSpan);
            this.value = value;
        }
        isEquivalent(e) {
            return e instanceof LiteralExpr && this.value === e.value;
        }
        isConstant() {
            return true;
        }
        visitExpression(visitor, context) {
            return visitor.visitLiteralExpr(this, context);
        }
    }
    class TemplateLiteral {
        constructor(elements, expressions) {
            this.elements = elements;
            this.expressions = expressions;
        }
    }
    class TemplateLiteralElement {
        constructor(text, sourceSpan, rawText) {
            var _a;
            this.text = text;
            this.sourceSpan = sourceSpan;
            // If `rawText` is not provided, try to extract the raw string from its
            // associated `sourceSpan`. If that is also not available, "fake" the raw
            // string instead by escaping the following control sequences:
            // - "\" would otherwise indicate that the next character is a control character.
            // - "`" and "${" are template string control sequences that would otherwise prematurely
            // indicate the end of the template literal element.
            this.rawText =
                (_a = rawText !== null && rawText !== void 0 ? rawText : sourceSpan === null || sourceSpan === void 0 ? void 0 : sourceSpan.toString()) !== null && _a !== void 0 ? _a : escapeForTemplateLiteral(escapeSlashes(text));
        }
    }
    class MessagePiece {
        constructor(text, sourceSpan) {
            this.text = text;
            this.sourceSpan = sourceSpan;
        }
    }
    class LiteralPiece extends MessagePiece {
    }
    class PlaceholderPiece extends MessagePiece {
    }
    class LocalizedString extends Expression {
        constructor(metaBlock, messageParts, placeHolderNames, expressions, sourceSpan) {
            super(STRING_TYPE, sourceSpan);
            this.metaBlock = metaBlock;
            this.messageParts = messageParts;
            this.placeHolderNames = placeHolderNames;
            this.expressions = expressions;
        }
        isEquivalent(e) {
            // return e instanceof LocalizedString && this.message === e.message;
            return false;
        }
        isConstant() {
            return false;
        }
        visitExpression(visitor, context) {
            return visitor.visitLocalizedString(this, context);
        }
        /**
         * Serialize the given `meta` and `messagePart` into "cooked" and "raw" strings that can be used
         * in a `$localize` tagged string. The format of the metadata is the same as that parsed by
         * `parseI18nMeta()`.
         *
         * @param meta The metadata to serialize
         * @param messagePart The first part of the tagged string
         */
        serializeI18nHead() {
            const MEANING_SEPARATOR = '|';
            const ID_SEPARATOR = '@@';
            const LEGACY_ID_INDICATOR = '';
            let metaBlock = this.metaBlock.description || '';
            if (this.metaBlock.meaning) {
                metaBlock = `${this.metaBlock.meaning}${MEANING_SEPARATOR}${metaBlock}`;
            }
            if (this.metaBlock.customId) {
                metaBlock = `${metaBlock}${ID_SEPARATOR}${this.metaBlock.customId}`;
            }
            if (this.metaBlock.legacyIds) {
                this.metaBlock.legacyIds.forEach(legacyId => {
                    metaBlock = `${metaBlock}${LEGACY_ID_INDICATOR}${legacyId}`;
                });
            }
            return createCookedRawString(metaBlock, this.messageParts[0].text, this.getMessagePartSourceSpan(0));
        }
        getMessagePartSourceSpan(i) {
            var _a, _b;
            return (_b = (_a = this.messageParts[i]) === null || _a === void 0 ? void 0 : _a.sourceSpan) !== null && _b !== void 0 ? _b : this.sourceSpan;
        }
        getPlaceholderSourceSpan(i) {
            var _a, _b, _c, _d;
            return (_d = (_b = (_a = this.placeHolderNames[i]) === null || _a === void 0 ? void 0 : _a.sourceSpan) !== null && _b !== void 0 ? _b : (_c = this.expressions[i]) === null || _c === void 0 ? void 0 : _c.sourceSpan) !== null && _d !== void 0 ? _d : this.sourceSpan;
        }
        /**
         * Serialize the given `placeholderName` and `messagePart` into "cooked" and "raw" strings that
         * can be used in a `$localize` tagged string.
         *
         * @param placeholderName The placeholder name to serialize
         * @param messagePart The following message string after this placeholder
         */
        serializeI18nTemplatePart(partIndex) {
            const placeholderName = this.placeHolderNames[partIndex - 1].text;
            const messagePart = this.messageParts[partIndex];
            return createCookedRawString(placeholderName, messagePart.text, this.getMessagePartSourceSpan(partIndex));
        }
    }
    const escapeSlashes = (str) => str.replace(/\\/g, '\\\\');
    const escapeStartingColon = (str) => str.replace(/^:/, '\\:');
    const escapeColons = (str) => str.replace(/:/g, '\\:');
    const escapeForTemplateLiteral = (str) => str.replace(/`/g, '\\`').replace(/\${/g, '$\\{');
    /**
     * Creates a `{cooked, raw}` object from the `metaBlock` and `messagePart`.
     *
     * The `raw` text must have various character sequences escaped:
     * * "\" would otherwise indicate that the next character is a control character.
     * * "`" and "${" are template string control sequences that would otherwise prematurely indicate
     *   the end of a message part.
     * * ":" inside a metablock would prematurely indicate the end of the metablock.
     * * ":" at the start of a messagePart with no metablock would erroneously indicate the start of a
     *   metablock.
     *
     * @param metaBlock Any metadata that should be prepended to the string
     * @param messagePart The message part of the string
     */
    function createCookedRawString(metaBlock, messagePart, range) {
        if (metaBlock === '') {
            return {
                cooked: messagePart,
                raw: escapeForTemplateLiteral(escapeStartingColon(escapeSlashes(messagePart))),
                range,
            };
        }
        else {
            return {
                cooked: `:${metaBlock}:${messagePart}`,
                raw: escapeForTemplateLiteral(`:${escapeColons(escapeSlashes(metaBlock))}:${escapeSlashes(messagePart)}`),
                range,
            };
        }
    }
    class ExternalExpr extends Expression {
        constructor(value, type, typeParams = null, sourceSpan) {
            super(type, sourceSpan);
            this.value = value;
            this.typeParams = typeParams;
        }
        isEquivalent(e) {
            return e instanceof ExternalExpr && this.value.name === e.value.name &&
                this.value.moduleName === e.value.moduleName && this.value.runtime === e.value.runtime;
        }
        isConstant() {
            return false;
        }
        visitExpression(visitor, context) {
            return visitor.visitExternalExpr(this, context);
        }
    }
    class ExternalReference {
        constructor(moduleName, name, runtime) {
            this.moduleName = moduleName;
            this.name = name;
            this.runtime = runtime;
        }
    }
    class ConditionalExpr extends Expression {
        constructor(condition, trueCase, falseCase = null, type, sourceSpan) {
            super(type || trueCase.type, sourceSpan);
            this.condition = condition;
            this.falseCase = falseCase;
            this.trueCase = trueCase;
        }
        isEquivalent(e) {
            return e instanceof ConditionalExpr && this.condition.isEquivalent(e.condition) &&
                this.trueCase.isEquivalent(e.trueCase) && nullSafeIsEquivalent(this.falseCase, e.falseCase);
        }
        isConstant() {
            return false;
        }
        visitExpression(visitor, context) {
            return visitor.visitConditionalExpr(this, context);
        }
    }
    class NotExpr extends Expression {
        constructor(condition, sourceSpan) {
            super(BOOL_TYPE, sourceSpan);
            this.condition = condition;
        }
        isEquivalent(e) {
            return e instanceof NotExpr && this.condition.isEquivalent(e.condition);
        }
        isConstant() {
            return false;
        }
        visitExpression(visitor, context) {
            return visitor.visitNotExpr(this, context);
        }
    }
    class AssertNotNull extends Expression {
        constructor(condition, sourceSpan) {
            super(condition.type, sourceSpan);
            this.condition = condition;
        }
        isEquivalent(e) {
            return e instanceof AssertNotNull && this.condition.isEquivalent(e.condition);
        }
        isConstant() {
            return false;
        }
        visitExpression(visitor, context) {
            return visitor.visitAssertNotNullExpr(this, context);
        }
    }
    class CastExpr extends Expression {
        constructor(value, type, sourceSpan) {
            super(type, sourceSpan);
            this.value = value;
        }
        isEquivalent(e) {
            return e instanceof CastExpr && this.value.isEquivalent(e.value);
        }
        isConstant() {
            return false;
        }
        visitExpression(visitor, context) {
            return visitor.visitCastExpr(this, context);
        }
    }
    class FnParam {
        constructor(name, type = null) {
            this.name = name;
            this.type = type;
        }
        isEquivalent(param) {
            return this.name === param.name;
        }
    }
    class FunctionExpr extends Expression {
        constructor(params, statements, type, sourceSpan, name) {
            super(type, sourceSpan);
            this.params = params;
            this.statements = statements;
            this.name = name;
        }
        isEquivalent(e) {
            return e instanceof FunctionExpr && areAllEquivalent(this.params, e.params) &&
                areAllEquivalent(this.statements, e.statements);
        }
        isConstant() {
            return false;
        }
        visitExpression(visitor, context) {
            return visitor.visitFunctionExpr(this, context);
        }
        toDeclStmt(name, modifiers) {
            return new DeclareFunctionStmt(name, this.params, this.statements, this.type, modifiers, this.sourceSpan);
        }
    }
    class UnaryOperatorExpr extends Expression {
        constructor(operator, expr, type, sourceSpan, parens = true) {
            super(type || NUMBER_TYPE, sourceSpan);
            this.operator = operator;
            this.expr = expr;
            this.parens = parens;
        }
        isEquivalent(e) {
            return e instanceof UnaryOperatorExpr && this.operator === e.operator &&
                this.expr.isEquivalent(e.expr);
        }
        isConstant() {
            return false;
        }
        visitExpression(visitor, context) {
            return visitor.visitUnaryOperatorExpr(this, context);
        }
    }
    class BinaryOperatorExpr extends Expression {
        constructor(operator, lhs, rhs, type, sourceSpan, parens = true) {
            super(type || lhs.type, sourceSpan);
            this.operator = operator;
            this.rhs = rhs;
            this.parens = parens;
            this.lhs = lhs;
        }
        isEquivalent(e) {
            return e instanceof BinaryOperatorExpr && this.operator === e.operator &&
                this.lhs.isEquivalent(e.lhs) && this.rhs.isEquivalent(e.rhs);
        }
        isConstant() {
            return false;
        }
        visitExpression(visitor, context) {
            return visitor.visitBinaryOperatorExpr(this, context);
        }
    }
    class ReadPropExpr extends Expression {
        constructor(receiver, name, type, sourceSpan) {
            super(type, sourceSpan);
            this.receiver = receiver;
            this.name = name;
        }
        isEquivalent(e) {
            return e instanceof ReadPropExpr && this.receiver.isEquivalent(e.receiver) &&
                this.name === e.name;
        }
        isConstant() {
            return false;
        }
        visitExpression(visitor, context) {
            return visitor.visitReadPropExpr(this, context);
        }
        set(value) {
            return new WritePropExpr(this.receiver, this.name, value, null, this.sourceSpan);
        }
    }
    class ReadKeyExpr extends Expression {
        constructor(receiver, index, type, sourceSpan) {
            super(type, sourceSpan);
            this.receiver = receiver;
            this.index = index;
        }
        isEquivalent(e) {
            return e instanceof ReadKeyExpr && this.receiver.isEquivalent(e.receiver) &&
                this.index.isEquivalent(e.index);
        }
        isConstant() {
            return false;
        }
        visitExpression(visitor, context) {
            return visitor.visitReadKeyExpr(this, context);
        }
        set(value) {
            return new WriteKeyExpr(this.receiver, this.index, value, null, this.sourceSpan);
        }
    }
    class LiteralArrayExpr extends Expression {
        constructor(entries, type, sourceSpan) {
            super(type, sourceSpan);
            this.entries = entries;
        }
        isConstant() {
            return this.entries.every(e => e.isConstant());
        }
        isEquivalent(e) {
            return e instanceof LiteralArrayExpr && areAllEquivalent(this.entries, e.entries);
        }
        visitExpression(visitor, context) {
            return visitor.visitLiteralArrayExpr(this, context);
        }
    }
    class LiteralMapEntry {
        constructor(key, value, quoted) {
            this.key = key;
            this.value = value;
            this.quoted = quoted;
        }
        isEquivalent(e) {
            return this.key === e.key && this.value.isEquivalent(e.value);
        }
    }
    class LiteralMapExpr extends Expression {
        constructor(entries, type, sourceSpan) {
            super(type, sourceSpan);
            this.entries = entries;
            this.valueType = null;
            if (type) {
                this.valueType = type.valueType;
            }
        }
        isEquivalent(e) {
            return e instanceof LiteralMapExpr && areAllEquivalent(this.entries, e.entries);
        }
        isConstant() {
            return this.entries.every(e => e.value.isConstant());
        }
        visitExpression(visitor, context) {
            return visitor.visitLiteralMapExpr(this, context);
        }
    }
    const THIS_EXPR = new ReadVarExpr(BuiltinVar.This, null, null);
    const SUPER_EXPR = new ReadVarExpr(BuiltinVar.Super, null, null);
    const CATCH_ERROR_VAR = new ReadVarExpr(BuiltinVar.CatchError, null, null);
    const CATCH_STACK_VAR = new ReadVarExpr(BuiltinVar.CatchStack, null, null);
    const NULL_EXPR = new LiteralExpr(null, null, null);
    const TYPED_NULL_EXPR = new LiteralExpr(null, INFERRED_TYPE, null);
    //// Statements
    var StmtModifier;
    (function (StmtModifier) {
        StmtModifier[StmtModifier["Final"] = 0] = "Final";
        StmtModifier[StmtModifier["Private"] = 1] = "Private";
        StmtModifier[StmtModifier["Exported"] = 2] = "Exported";
        StmtModifier[StmtModifier["Static"] = 3] = "Static";
    })(StmtModifier || (StmtModifier = {}));
    class LeadingComment {
        constructor(text, multiline, trailingNewline) {
            this.text = text;
            this.multiline = multiline;
            this.trailingNewline = trailingNewline;
        }
        toString() {
            return this.multiline ? ` ${this.text} ` : this.text;
        }
    }
    class JSDocComment extends LeadingComment {
        constructor(tags) {
            super('', /* multiline */ true, /* trailingNewline */ true);
            this.tags = tags;
        }
        toString() {
            return serializeTags(this.tags);
        }
    }
    class Statement {
        constructor(modifiers = [], sourceSpan = null, leadingComments) {
            this.modifiers = modifiers;
            this.sourceSpan = sourceSpan;
            this.leadingComments = leadingComments;
        }
        hasModifier(modifier) {
            return this.modifiers.indexOf(modifier) !== -1;
        }
        addLeadingComment(leadingComment) {
            var _a;
            this.leadingComments = (_a = this.leadingComments) !== null && _a !== void 0 ? _a : [];
            this.leadingComments.push(leadingComment);
        }
    }
    class DeclareVarStmt extends Statement {
        constructor(name, value, type, modifiers, sourceSpan, leadingComments) {
            super(modifiers, sourceSpan, leadingComments);
            this.name = name;
            this.value = value;
            this.type = type || (value && value.type) || null;
        }
        isEquivalent(stmt) {
            return stmt instanceof DeclareVarStmt && this.name === stmt.name &&
                (this.value ? !!stmt.value && this.value.isEquivalent(stmt.value) : !stmt.value);
        }
        visitStatement(visitor, context) {
            return visitor.visitDeclareVarStmt(this, context);
        }
    }
    class DeclareFunctionStmt extends Statement {
        constructor(name, params, statements, type, modifiers, sourceSpan, leadingComments) {
            super(modifiers, sourceSpan, leadingComments);
            this.name = name;
            this.params = params;
            this.statements = statements;
            this.type = type || null;
        }
        isEquivalent(stmt) {
            return stmt instanceof DeclareFunctionStmt && areAllEquivalent(this.params, stmt.params) &&
                areAllEquivalent(this.statements, stmt.statements);
        }
        visitStatement(visitor, context) {
            return visitor.visitDeclareFunctionStmt(this, context);
        }
    }
    class ExpressionStatement extends Statement {
        constructor(expr, sourceSpan, leadingComments) {
            super([], sourceSpan, leadingComments);
            this.expr = expr;
        }
        isEquivalent(stmt) {
            return stmt instanceof ExpressionStatement && this.expr.isEquivalent(stmt.expr);
        }
        visitStatement(visitor, context) {
            return visitor.visitExpressionStmt(this, context);
        }
    }
    class ReturnStatement extends Statement {
        constructor(value, sourceSpan = null, leadingComments) {
            super([], sourceSpan, leadingComments);
            this.value = value;
        }
        isEquivalent(stmt) {
            return stmt instanceof ReturnStatement && this.value.isEquivalent(stmt.value);
        }
        visitStatement(visitor, context) {
            return visitor.visitReturnStmt(this, context);
        }
    }
    class IfStmt extends Statement {
        constructor(condition, trueCase, falseCase = [], sourceSpan, leadingComments) {
            super([], sourceSpan, leadingComments);
            this.condition = condition;
            this.trueCase = trueCase;
            this.falseCase = falseCase;
        }
        isEquivalent(stmt) {
            return stmt instanceof IfStmt && this.condition.isEquivalent(stmt.condition) &&
                areAllEquivalent(this.trueCase, stmt.trueCase) &&
                areAllEquivalent(this.falseCase, stmt.falseCase);
        }
        visitStatement(visitor, context) {
            return visitor.visitIfStmt(this, context);
        }
    }
    function jsDocComment(tags = []) {
        return new JSDocComment(tags);
    }
    function variable(name, type, sourceSpan) {
        return new ReadVarExpr(name, type, sourceSpan);
    }
    function importExpr(id, typeParams = null, sourceSpan) {
        return new ExternalExpr(id, null, typeParams, sourceSpan);
    }
    function expressionType(expr, typeModifiers, typeParams) {
        return new ExpressionType(expr, typeModifiers, typeParams);
    }
    function typeofExpr(expr) {
        return new TypeofExpr(expr);
    }
    function literalArr(values, type, sourceSpan) {
        return new LiteralArrayExpr(values, type, sourceSpan);
    }
    function literalMap(values, type = null) {
        return new LiteralMapExpr(values.map(e => new LiteralMapEntry(e.key, e.value, e.quoted)), type, null);
    }
    function not(expr, sourceSpan) {
        return new NotExpr(expr, sourceSpan);
    }
    function assertNotNull(expr, sourceSpan) {
        return new AssertNotNull(expr, sourceSpan);
    }
    function fn(params, body, type, sourceSpan, name) {
        return new FunctionExpr(params, body, type, sourceSpan, name);
    }
    function ifStmt(condition, thenClause, elseClause, sourceSpan, leadingComments) {
        return new IfStmt(condition, thenClause, elseClause, sourceSpan, leadingComments);
    }
    function taggedTemplate(tag, template, type, sourceSpan) {
        return new TaggedTemplateExpr(tag, template, type, sourceSpan);
    }
    function literal(value, type, sourceSpan) {
        return new LiteralExpr(value, type, sourceSpan);
    }
    function localizedString(metaBlock, messageParts, placeholderNames, expressions, sourceSpan) {
        return new LocalizedString(metaBlock, messageParts, placeholderNames, expressions, sourceSpan);
    }
    function isNull(exp) {
        return exp instanceof LiteralExpr && exp.value === null;
    }
    /*
     * Serializes a `Tag` into a string.
     * Returns a string like " @foo {bar} baz" (note the leading whitespace before `@foo`).
     */
    function tagToString(tag) {
        let out = '';
        if (tag.tagName) {
            out += ` @${tag.tagName}`;
        }
        if (tag.text) {
            if (tag.text.match(/\/\*|\*\//)) {
                throw new Error('JSDoc text cannot contain "/*" and "*/"');
            }
            out += ' ' + tag.text.replace(/@/g, '\\@');
        }
        return out;
    }
    function serializeTags(tags) {
        if (tags.length === 0)
            return '';
        if (tags.length === 1 && tags[0].tagName && !tags[0].text) {
            // The JSDOC comment is a single simple tag: e.g `/** @tagname */`.
            return `*${tagToString(tags[0])} `;
        }
        let out = '*\n';
        for (const tag of tags) {
            out += ' *';
            // If the tagToString is multi-line, insert " * " prefixes on lines.
            out += tagToString(tag).replace(/\n/g, '\n * ');
            out += '\n';
        }
        out += ' ';
        return out;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const CONSTANT_PREFIX = '_c';
    /**
     * `ConstantPool` tries to reuse literal factories when two or more literals are identical.
     * We determine whether literals are identical by creating a key out of their AST using the
     * `KeyVisitor`. This constant is used to replace dynamic expressions which can't be safely
     * converted into a key. E.g. given an expression `{foo: bar()}`, since we don't know what
     * the result of `bar` will be, we create a key that looks like `{foo: <unknown>}`. Note
     * that we use a variable, rather than something like `null` in order to avoid collisions.
     */
    const UNKNOWN_VALUE_KEY = variable('<unknown>');
    /**
     * Context to use when producing a key.
     *
     * This ensures we see the constant not the reference variable when producing
     * a key.
     */
    const KEY_CONTEXT = {};
    /**
     * Generally all primitive values are excluded from the `ConstantPool`, but there is an exclusion
     * for strings that reach a certain length threshold. This constant defines the length threshold for
     * strings.
     */
    const POOL_INCLUSION_LENGTH_THRESHOLD_FOR_STRINGS = 50;
    /**
     * A node that is a place-holder that allows the node to be replaced when the actual
     * node is known.
     *
     * This allows the constant pool to change an expression from a direct reference to
     * a constant to a shared constant. It returns a fix-up node that is later allowed to
     * change the referenced expression.
     */
    class FixupExpression extends Expression {
        constructor(resolved) {
            super(resolved.type);
            this.resolved = resolved;
            this.original = resolved;
        }
        visitExpression(visitor, context) {
            if (context === KEY_CONTEXT) {
                // When producing a key we want to traverse the constant not the
                // variable used to refer to it.
                return this.original.visitExpression(visitor, context);
            }
            else {
                return this.resolved.visitExpression(visitor, context);
            }
        }
        isEquivalent(e) {
            return e instanceof FixupExpression && this.resolved.isEquivalent(e.resolved);
        }
        isConstant() {
            return true;
        }
        fixup(expression) {
            this.resolved = expression;
            this.shared = true;
        }
    }
    /**
     * A constant pool allows a code emitter to share constant in an output context.
     *
     * The constant pool also supports sharing access to ivy definitions references.
     */
    class ConstantPool {
        constructor(isClosureCompilerEnabled = false) {
            this.isClosureCompilerEnabled = isClosureCompilerEnabled;
            this.statements = [];
            this.literals = new Map();
            this.literalFactories = new Map();
            this.injectorDefinitions = new Map();
            this.directiveDefinitions = new Map();
            this.componentDefinitions = new Map();
            this.pipeDefinitions = new Map();
            this.nextNameIndex = 0;
        }
        getConstLiteral(literal, forceShared) {
            if ((literal instanceof LiteralExpr && !isLongStringLiteral(literal)) ||
                literal instanceof FixupExpression) {
                // Do no put simple literals into the constant pool or try to produce a constant for a
                // reference to a constant.
                return literal;
            }
            const key = this.keyOf(literal);
            let fixup = this.literals.get(key);
            let newValue = false;
            if (!fixup) {
                fixup = new FixupExpression(literal);
                this.literals.set(key, fixup);
                newValue = true;
            }
            if ((!newValue && !fixup.shared) || (newValue && forceShared)) {
                // Replace the expression with a variable
                const name = this.freshName();
                let definition;
                let usage;
                if (this.isClosureCompilerEnabled && isLongStringLiteral(literal)) {
                    // For string literals, Closure will **always** inline the string at
                    // **all** usages, duplicating it each time. For large strings, this
                    // unnecessarily bloats bundle size. To work around this restriction, we
                    // wrap the string in a function, and call that function for each usage.
                    // This tricks Closure into using inline logic for functions instead of
                    // string literals. Function calls are only inlined if the body is small
                    // enough to be worth it. By doing this, very large strings will be
                    // shared across multiple usages, rather than duplicating the string at
                    // each usage site.
                    //
                    // const myStr = function() { return "very very very long string"; };
                    // const usage1 = myStr();
                    // const usage2 = myStr();
                    definition = variable(name).set(new FunctionExpr([], // Params.
                    [
                        // Statements.
                        new ReturnStatement(literal),
                    ]));
                    usage = variable(name).callFn([]);
                }
                else {
                    // Just declare and use the variable directly, without a function call
                    // indirection. This saves a few bytes and avoids an unncessary call.
                    definition = variable(name).set(literal);
                    usage = variable(name);
                }
                this.statements.push(definition.toDeclStmt(INFERRED_TYPE, [StmtModifier.Final]));
                fixup.fixup(usage);
            }
            return fixup;
        }
        getDefinition(type, kind, ctx, forceShared = false) {
            const definitions = this.definitionsOf(kind);
            let fixup = definitions.get(type);
            let newValue = false;
            if (!fixup) {
                const property = this.propertyNameOf(kind);
                fixup = new FixupExpression(ctx.importExpr(type).prop(property));
                definitions.set(type, fixup);
                newValue = true;
            }
            if ((!newValue && !fixup.shared) || (newValue && forceShared)) {
                const name = this.freshName();
                this.statements.push(variable(name).set(fixup.resolved).toDeclStmt(INFERRED_TYPE, [StmtModifier.Final]));
                fixup.fixup(variable(name));
            }
            return fixup;
        }
        getLiteralFactory(literal) {
            // Create a pure function that builds an array of a mix of constant and variable expressions
            if (literal instanceof LiteralArrayExpr) {
                const argumentsForKey = literal.entries.map(e => e.isConstant() ? e : UNKNOWN_VALUE_KEY);
                const key = this.keyOf(literalArr(argumentsForKey));
                return this._getLiteralFactory(key, literal.entries, entries => literalArr(entries));
            }
            else {
                const expressionForKey = literalMap(literal.entries.map(e => ({
                    key: e.key,
                    value: e.value.isConstant() ? e.value : UNKNOWN_VALUE_KEY,
                    quoted: e.quoted
                })));
                const key = this.keyOf(expressionForKey);
                return this._getLiteralFactory(key, literal.entries.map(e => e.value), entries => literalMap(entries.map((value, index) => ({
                    key: literal.entries[index].key,
                    value,
                    quoted: literal.entries[index].quoted
                }))));
            }
        }
        _getLiteralFactory(key, values, resultMap) {
            let literalFactory = this.literalFactories.get(key);
            const literalFactoryArguments = values.filter((e => !e.isConstant()));
            if (!literalFactory) {
                const resultExpressions = values.map((e, index) => e.isConstant() ? this.getConstLiteral(e, true) : variable(`a${index}`));
                const parameters = resultExpressions.filter(isVariable).map(e => new FnParam(e.name, DYNAMIC_TYPE));
                const pureFunctionDeclaration = fn(parameters, [new ReturnStatement(resultMap(resultExpressions))], INFERRED_TYPE);
                const name = this.freshName();
                this.statements.push(variable(name).set(pureFunctionDeclaration).toDeclStmt(INFERRED_TYPE, [
                    StmtModifier.Final
                ]));
                literalFactory = variable(name);
                this.literalFactories.set(key, literalFactory);
            }
            return { literalFactory, literalFactoryArguments };
        }
        /**
         * Produce a unique name.
         *
         * The name might be unique among different prefixes if any of the prefixes end in
         * a digit so the prefix should be a constant string (not based on user input) and
         * must not end in a digit.
         */
        uniqueName(prefix) {
            return `${prefix}${this.nextNameIndex++}`;
        }
        definitionsOf(kind) {
            switch (kind) {
                case 2 /* Component */:
                    return this.componentDefinitions;
                case 1 /* Directive */:
                    return this.directiveDefinitions;
                case 0 /* Injector */:
                    return this.injectorDefinitions;
                case 3 /* Pipe */:
                    return this.pipeDefinitions;
            }
        }
        propertyNameOf(kind) {
            switch (kind) {
                case 2 /* Component */:
                    return 'cmp';
                case 1 /* Directive */:
                    return 'dir';
                case 0 /* Injector */:
                    return 'inj';
                case 3 /* Pipe */:
                    return 'pipe';
            }
        }
        freshName() {
            return this.uniqueName(CONSTANT_PREFIX);
        }
        keyOf(expression) {
            return expression.visitExpression(new KeyVisitor(), KEY_CONTEXT);
        }
    }
    /**
     * Visitor used to determine if 2 expressions are equivalent and can be shared in the
     * `ConstantPool`.
     *
     * When the id (string) generated by the visitor is equal, expressions are considered equivalent.
     */
    class KeyVisitor {
        constructor() {
            this.visitWrappedNodeExpr = invalid;
            this.visitWriteVarExpr = invalid;
            this.visitWriteKeyExpr = invalid;
            this.visitWritePropExpr = invalid;
            this.visitInvokeMethodExpr = invalid;
            this.visitInvokeFunctionExpr = invalid;
            this.visitTaggedTemplateExpr = invalid;
            this.visitInstantiateExpr = invalid;
            this.visitConditionalExpr = invalid;
            this.visitNotExpr = invalid;
            this.visitAssertNotNullExpr = invalid;
            this.visitCastExpr = invalid;
            this.visitFunctionExpr = invalid;
            this.visitUnaryOperatorExpr = invalid;
            this.visitBinaryOperatorExpr = invalid;
            this.visitReadPropExpr = invalid;
            this.visitReadKeyExpr = invalid;
            this.visitCommaExpr = invalid;
            this.visitLocalizedString = invalid;
        }
        visitLiteralExpr(ast) {
            return `${typeof ast.value === 'string' ? '"' + ast.value + '"' : ast.value}`;
        }
        visitLiteralArrayExpr(ast, context) {
            return `[${ast.entries.map(entry => entry.visitExpression(this, context)).join(',')}]`;
        }
        visitLiteralMapExpr(ast, context) {
            const mapKey = (entry) => {
                const quote = entry.quoted ? '"' : '';
                return `${quote}${entry.key}${quote}`;
            };
            const mapEntry = (entry) => `${mapKey(entry)}:${entry.value.visitExpression(this, context)}`;
            return `{${ast.entries.map(mapEntry).join(',')}`;
        }
        visitExternalExpr(ast) {
            return ast.value.moduleName ? `EX:${ast.value.moduleName}:${ast.value.name}` :
                `EX:${ast.value.runtime.name}`;
        }
        visitReadVarExpr(node) {
            return `VAR:${node.name}`;
        }
        visitTypeofExpr(node, context) {
            return `TYPEOF:${node.expr.visitExpression(this, context)}`;
        }
    }
    function invalid(arg) {
        throw new Error(`Invalid state: Visitor ${this.constructor.name} doesn't handle ${arg.constructor.name}`);
    }
    function isVariable(e) {
        return e instanceof ReadVarExpr;
    }
    function isLongStringLiteral(expr) {
        return expr instanceof LiteralExpr && typeof expr.value === 'string' &&
            expr.value.length >= POOL_INCLUSION_LENGTH_THRESHOLD_FOR_STRINGS;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const CORE = '@angular/core';
    class Identifiers {
    }
    /* Methods */
    Identifiers.NEW_METHOD = 'factory';
    Identifiers.TRANSFORM_METHOD = 'transform';
    Identifiers.PATCH_DEPS = 'patchedDeps';
    Identifiers.core = { name: null, moduleName: CORE };
    /* Instructions */
    Identifiers.namespaceHTML = { name: 'namespaceHTML', moduleName: CORE };
    Identifiers.namespaceMathML = { name: 'namespaceMathML', moduleName: CORE };
    Identifiers.namespaceSVG = { name: 'namespaceSVG', moduleName: CORE };
    Identifiers.element = { name: 'element', moduleName: CORE };
    Identifiers.elementStart = { name: 'elementStart', moduleName: CORE };
    Identifiers.elementEnd = { name: 'elementEnd', moduleName: CORE };
    Identifiers.advance = { name: 'advance', moduleName: CORE };
    Identifiers.syntheticHostProperty = { name: 'syntheticHostProperty', moduleName: CORE };
    Identifiers.syntheticHostListener = { name: 'syntheticHostListener', moduleName: CORE };
    Identifiers.attribute = { name: 'attribute', moduleName: CORE };
    Identifiers.attributeInterpolate1 = { name: 'attributeInterpolate1', moduleName: CORE };
    Identifiers.attributeInterpolate2 = { name: 'attributeInterpolate2', moduleName: CORE };
    Identifiers.attributeInterpolate3 = { name: 'attributeInterpolate3', moduleName: CORE };
    Identifiers.attributeInterpolate4 = { name: 'attributeInterpolate4', moduleName: CORE };
    Identifiers.attributeInterpolate5 = { name: 'attributeInterpolate5', moduleName: CORE };
    Identifiers.attributeInterpolate6 = { name: 'attributeInterpolate6', moduleName: CORE };
    Identifiers.attributeInterpolate7 = { name: 'attributeInterpolate7', moduleName: CORE };
    Identifiers.attributeInterpolate8 = { name: 'attributeInterpolate8', moduleName: CORE };
    Identifiers.attributeInterpolateV = { name: 'attributeInterpolateV', moduleName: CORE };
    Identifiers.classProp = { name: 'classProp', moduleName: CORE };
    Identifiers.elementContainerStart = { name: 'elementContainerStart', moduleName: CORE };
    Identifiers.elementContainerEnd = { name: 'elementContainerEnd', moduleName: CORE };
    Identifiers.elementContainer = { name: 'elementContainer', moduleName: CORE };
    Identifiers.styleMap = { name: 'styleMap', moduleName: CORE };
    Identifiers.styleMapInterpolate1 = { name: 'styleMapInterpolate1', moduleName: CORE };
    Identifiers.styleMapInterpolate2 = { name: 'styleMapInterpolate2', moduleName: CORE };
    Identifiers.styleMapInterpolate3 = { name: 'styleMapInterpolate3', moduleName: CORE };
    Identifiers.styleMapInterpolate4 = { name: 'styleMapInterpolate4', moduleName: CORE };
    Identifiers.styleMapInterpolate5 = { name: 'styleMapInterpolate5', moduleName: CORE };
    Identifiers.styleMapInterpolate6 = { name: 'styleMapInterpolate6', moduleName: CORE };
    Identifiers.styleMapInterpolate7 = { name: 'styleMapInterpolate7', moduleName: CORE };
    Identifiers.styleMapInterpolate8 = { name: 'styleMapInterpolate8', moduleName: CORE };
    Identifiers.styleMapInterpolateV = { name: 'styleMapInterpolateV', moduleName: CORE };
    Identifiers.classMap = { name: 'classMap', moduleName: CORE };
    Identifiers.classMapInterpolate1 = { name: 'classMapInterpolate1', moduleName: CORE };
    Identifiers.classMapInterpolate2 = { name: 'classMapInterpolate2', moduleName: CORE };
    Identifiers.classMapInterpolate3 = { name: 'classMapInterpolate3', moduleName: CORE };
    Identifiers.classMapInterpolate4 = { name: 'classMapInterpolate4', moduleName: CORE };
    Identifiers.classMapInterpolate5 = { name: 'classMapInterpolate5', moduleName: CORE };
    Identifiers.classMapInterpolate6 = { name: 'classMapInterpolate6', moduleName: CORE };
    Identifiers.classMapInterpolate7 = { name: 'classMapInterpolate7', moduleName: CORE };
    Identifiers.classMapInterpolate8 = { name: 'classMapInterpolate8', moduleName: CORE };
    Identifiers.classMapInterpolateV = { name: 'classMapInterpolateV', moduleName: CORE };
    Identifiers.styleProp = { name: 'styleProp', moduleName: CORE };
    Identifiers.stylePropInterpolate1 = { name: 'stylePropInterpolate1', moduleName: CORE };
    Identifiers.stylePropInterpolate2 = { name: 'stylePropInterpolate2', moduleName: CORE };
    Identifiers.stylePropInterpolate3 = { name: 'stylePropInterpolate3', moduleName: CORE };
    Identifiers.stylePropInterpolate4 = { name: 'stylePropInterpolate4', moduleName: CORE };
    Identifiers.stylePropInterpolate5 = { name: 'stylePropInterpolate5', moduleName: CORE };
    Identifiers.stylePropInterpolate6 = { name: 'stylePropInterpolate6', moduleName: CORE };
    Identifiers.stylePropInterpolate7 = { name: 'stylePropInterpolate7', moduleName: CORE };
    Identifiers.stylePropInterpolate8 = { name: 'stylePropInterpolate8', moduleName: CORE };
    Identifiers.stylePropInterpolateV = { name: 'stylePropInterpolateV', moduleName: CORE };
    Identifiers.nextContext = { name: 'nextContext', moduleName: CORE };
    Identifiers.templateCreate = { name: 'template', moduleName: CORE };
    Identifiers.text = { name: 'text', moduleName: CORE };
    Identifiers.enableBindings = { name: 'enableBindings', moduleName: CORE };
    Identifiers.disableBindings = { name: 'disableBindings', moduleName: CORE };
    Identifiers.getCurrentView = { name: 'getCurrentView', moduleName: CORE };
    Identifiers.textInterpolate = { name: 'textInterpolate', moduleName: CORE };
    Identifiers.textInterpolate1 = { name: 'textInterpolate1', moduleName: CORE };
    Identifiers.textInterpolate2 = { name: 'textInterpolate2', moduleName: CORE };
    Identifiers.textInterpolate3 = { name: 'textInterpolate3', moduleName: CORE };
    Identifiers.textInterpolate4 = { name: 'textInterpolate4', moduleName: CORE };
    Identifiers.textInterpolate5 = { name: 'textInterpolate5', moduleName: CORE };
    Identifiers.textInterpolate6 = { name: 'textInterpolate6', moduleName: CORE };
    Identifiers.textInterpolate7 = { name: 'textInterpolate7', moduleName: CORE };
    Identifiers.textInterpolate8 = { name: 'textInterpolate8', moduleName: CORE };
    Identifiers.textInterpolateV = { name: 'textInterpolateV', moduleName: CORE };
    Identifiers.restoreView = { name: 'restoreView', moduleName: CORE };
    Identifiers.pureFunction0 = { name: 'pureFunction0', moduleName: CORE };
    Identifiers.pureFunction1 = { name: 'pureFunction1', moduleName: CORE };
    Identifiers.pureFunction2 = { name: 'pureFunction2', moduleName: CORE };
    Identifiers.pureFunction3 = { name: 'pureFunction3', moduleName: CORE };
    Identifiers.pureFunction4 = { name: 'pureFunction4', moduleName: CORE };
    Identifiers.pureFunction5 = { name: 'pureFunction5', moduleName: CORE };
    Identifiers.pureFunction6 = { name: 'pureFunction6', moduleName: CORE };
    Identifiers.pureFunction7 = { name: 'pureFunction7', moduleName: CORE };
    Identifiers.pureFunction8 = { name: 'pureFunction8', moduleName: CORE };
    Identifiers.pureFunctionV = { name: 'pureFunctionV', moduleName: CORE };
    Identifiers.pipeBind1 = { name: 'pipeBind1', moduleName: CORE };
    Identifiers.pipeBind2 = { name: 'pipeBind2', moduleName: CORE };
    Identifiers.pipeBind3 = { name: 'pipeBind3', moduleName: CORE };
    Identifiers.pipeBind4 = { name: 'pipeBind4', moduleName: CORE };
    Identifiers.pipeBindV = { name: 'pipeBindV', moduleName: CORE };
    Identifiers.hostProperty = { name: 'hostProperty', moduleName: CORE };
    Identifiers.property = { name: 'property', moduleName: CORE };
    Identifiers.propertyInterpolate = { name: 'propertyInterpolate', moduleName: CORE };
    Identifiers.propertyInterpolate1 = { name: 'propertyInterpolate1', moduleName: CORE };
    Identifiers.propertyInterpolate2 = { name: 'propertyInterpolate2', moduleName: CORE };
    Identifiers.propertyInterpolate3 = { name: 'propertyInterpolate3', moduleName: CORE };
    Identifiers.propertyInterpolate4 = { name: 'propertyInterpolate4', moduleName: CORE };
    Identifiers.propertyInterpolate5 = { name: 'propertyInterpolate5', moduleName: CORE };
    Identifiers.propertyInterpolate6 = { name: 'propertyInterpolate6', moduleName: CORE };
    Identifiers.propertyInterpolate7 = { name: 'propertyInterpolate7', moduleName: CORE };
    Identifiers.propertyInterpolate8 = { name: 'propertyInterpolate8', moduleName: CORE };
    Identifiers.propertyInterpolateV = { name: 'propertyInterpolateV', moduleName: CORE };
    Identifiers.i18n = { name: 'i18n', moduleName: CORE };
    Identifiers.i18nAttributes = { name: 'i18nAttributes', moduleName: CORE };
    Identifiers.i18nExp = { name: 'i18nExp', moduleName: CORE };
    Identifiers.i18nStart = { name: 'i18nStart', moduleName: CORE };
    Identifiers.i18nEnd = { name: 'i18nEnd', moduleName: CORE };
    Identifiers.i18nApply = { name: 'i18nApply', moduleName: CORE };
    Identifiers.i18nPostprocess = { name: 'i18nPostprocess', moduleName: CORE };
    Identifiers.pipe = { name: 'pipe', moduleName: CORE };
    Identifiers.projection = { name: 'projection', moduleName: CORE };
    Identifiers.projectionDef = { name: 'projectionDef', moduleName: CORE };
    Identifiers.reference = { name: 'reference', moduleName: CORE };
    Identifiers.inject = { name: 'inject', moduleName: CORE };
    Identifiers.injectAttribute = { name: 'injectAttribute', moduleName: CORE };
    Identifiers.directiveInject = { name: 'directiveInject', moduleName: CORE };
    Identifiers.invalidFactory = { name: 'invalidFactory', moduleName: CORE };
    Identifiers.invalidFactoryDep = { name: 'invalidFactoryDep', moduleName: CORE };
    Identifiers.templateRefExtractor = { name: 'templateRefExtractor', moduleName: CORE };
    Identifiers.forwardRef = { name: 'forwardRef', moduleName: CORE };
    Identifiers.resolveForwardRef = { name: 'resolveForwardRef', moduleName: CORE };
    Identifiers.defineInjectable = { name: 'defineInjectable', moduleName: CORE };
    Identifiers.declareInjectable = { name: 'ngDeclareInjectable', moduleName: CORE };
    Identifiers.InjectableDeclaration = { name: 'InjectableDeclaration', moduleName: CORE };
    Identifiers.resolveWindow = { name: 'resolveWindow', moduleName: CORE };
    Identifiers.resolveDocument = { name: 'resolveDocument', moduleName: CORE };
    Identifiers.resolveBody = { name: 'resolveBody', moduleName: CORE };
    Identifiers.defineComponent = { name: 'defineComponent', moduleName: CORE };
    Identifiers.declareComponent = { name: 'ngDeclareComponent', moduleName: CORE };
    Identifiers.setComponentScope = { name: 'setComponentScope', moduleName: CORE };
    Identifiers.ChangeDetectionStrategy = {
        name: 'ChangeDetectionStrategy',
        moduleName: CORE,
    };
    Identifiers.ViewEncapsulation = {
        name: 'ViewEncapsulation',
        moduleName: CORE,
    };
    Identifiers.ComponentDeclaration = {
        name: 'ComponentDeclaration',
        moduleName: CORE,
    };
    Identifiers.FactoryDeclaration = {
        name: 'FactoryDeclaration',
        moduleName: CORE,
    };
    Identifiers.declareFactory = { name: 'ngDeclareFactory', moduleName: CORE };
    Identifiers.FactoryTarget = { name: 'FactoryTarget', moduleName: CORE };
    Identifiers.defineDirective = { name: 'defineDirective', moduleName: CORE };
    Identifiers.declareDirective = { name: 'ngDeclareDirective', moduleName: CORE };
    Identifiers.DirectiveDeclaration = {
        name: 'DirectiveDeclaration',
        moduleName: CORE,
    };
    Identifiers.InjectorDef = { name: 'InjectorDef', moduleName: CORE };
    Identifiers.InjectorDeclaration = { name: 'InjectorDeclaration', moduleName: CORE };
    Identifiers.defineInjector = { name: 'defineInjector', moduleName: CORE };
    Identifiers.declareInjector = { name: 'ngDeclareInjector', moduleName: CORE };
    Identifiers.NgModuleDeclaration = {
        name: 'NgModuleDeclaration',
        moduleName: CORE,
    };
    Identifiers.ModuleWithProviders = {
        name: 'ModuleWithProviders',
        moduleName: CORE,
    };
    Identifiers.defineNgModule = { name: 'defineNgModule', moduleName: CORE };
    Identifiers.declareNgModule = { name: 'ngDeclareNgModule', moduleName: CORE };
    Identifiers.setNgModuleScope = { name: 'setNgModuleScope', moduleName: CORE };
    Identifiers.PipeDeclaration = { name: 'PipeDeclaration', moduleName: CORE };
    Identifiers.definePipe = { name: 'definePipe', moduleName: CORE };
    Identifiers.declarePipe = { name: 'ngDeclarePipe', moduleName: CORE };
    Identifiers.declareClassMetadata = { name: 'ngDeclareClassMetadata', moduleName: CORE };
    Identifiers.setClassMetadata = { name: 'setClassMetadata', moduleName: CORE };
    Identifiers.queryRefresh = { name: 'queryRefresh', moduleName: CORE };
    Identifiers.viewQuery = { name: 'viewQuery', moduleName: CORE };
    Identifiers.loadQuery = { name: 'loadQuery', moduleName: CORE };
    Identifiers.contentQuery = { name: 'contentQuery', moduleName: CORE };
    Identifiers.NgOnChangesFeature = { name: 'NgOnChangesFeature', moduleName: CORE };
    Identifiers.InheritDefinitionFeature = { name: 'InheritDefinitionFeature', moduleName: CORE };
    Identifiers.CopyDefinitionFeature = { name: 'CopyDefinitionFeature', moduleName: CORE };
    Identifiers.ProvidersFeature = { name: 'ProvidersFeature', moduleName: CORE };
    Identifiers.listener = { name: 'listener', moduleName: CORE };
    Identifiers.getInheritedFactory = {
        name: 'getInheritedFactory',
        moduleName: CORE,
    };
    // sanitization-related functions
    Identifiers.sanitizeHtml = { name: 'sanitizeHtml', moduleName: CORE };
    Identifiers.sanitizeStyle = { name: 'sanitizeStyle', moduleName: CORE };
    Identifiers.sanitizeResourceUrl = { name: 'sanitizeResourceUrl', moduleName: CORE };
    Identifiers.sanitizeScript = { name: 'sanitizeScript', moduleName: CORE };
    Identifiers.sanitizeUrl = { name: 'sanitizeUrl', moduleName: CORE };
    Identifiers.sanitizeUrlOrResourceUrl = { name: 'sanitizeUrlOrResourceUrl', moduleName: CORE };
    Identifiers.trustConstantHtml = { name: 'trustConstantHtml', moduleName: CORE };
    Identifiers.trustConstantResourceUrl = { name: 'trustConstantResourceUrl', moduleName: CORE };

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const DASH_CASE_REGEXP = /-+([a-z0-9])/g;
    function dashCaseToCamelCase(input) {
        return input.replace(DASH_CASE_REGEXP, (...m) => m[1].toUpperCase());
    }
    function splitAtColon(input, defaultValues) {
        return _splitAt(input, ':', defaultValues);
    }
    function splitAtPeriod(input, defaultValues) {
        return _splitAt(input, '.', defaultValues);
    }
    function _splitAt(input, character, defaultValues) {
        const characterIndex = input.indexOf(character);
        if (characterIndex == -1)
            return defaultValues;
        return [input.slice(0, characterIndex).trim(), input.slice(characterIndex + 1).trim()];
    }
    function error(msg) {
        throw new Error(`Internal Error: ${msg}`);
    }
    function utf8Encode(str) {
        let encoded = [];
        for (let index = 0; index < str.length; index++) {
            let codePoint = str.charCodeAt(index);
            // decode surrogate
            // see https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
            if (codePoint >= 0xd800 && codePoint <= 0xdbff && str.length > (index + 1)) {
                const low = str.charCodeAt(index + 1);
                if (low >= 0xdc00 && low <= 0xdfff) {
                    index++;
                    codePoint = ((codePoint - 0xd800) << 10) + low - 0xdc00 + 0x10000;
                }
            }
            if (codePoint <= 0x7f) {
                encoded.push(codePoint);
            }
            else if (codePoint <= 0x7ff) {
                encoded.push(((codePoint >> 6) & 0x1F) | 0xc0, (codePoint & 0x3f) | 0x80);
            }
            else if (codePoint <= 0xffff) {
                encoded.push((codePoint >> 12) | 0xe0, ((codePoint >> 6) & 0x3f) | 0x80, (codePoint & 0x3f) | 0x80);
            }
            else if (codePoint <= 0x1fffff) {
                encoded.push(((codePoint >> 18) & 0x07) | 0xf0, ((codePoint >> 12) & 0x3f) | 0x80, ((codePoint >> 6) & 0x3f) | 0x80, (codePoint & 0x3f) | 0x80);
            }
        }
        return encoded;
    }
    function stringify(token) {
        if (typeof token === 'string') {
            return token;
        }
        if (Array.isArray(token)) {
            return '[' + token.map(stringify).join(', ') + ']';
        }
        if (token == null) {
            return '' + token;
        }
        if (token.overriddenName) {
            return `${token.overriddenName}`;
        }
        if (token.name) {
            return `${token.name}`;
        }
        if (!token.toString) {
            return 'object';
        }
        // WARNING: do not try to `JSON.stringify(token)` here
        // see https://github.com/angular/angular/issues/23440
        const res = token.toString();
        if (res == null) {
            return '' + res;
        }
        const newLineIndex = res.indexOf('\n');
        return newLineIndex === -1 ? res : res.substring(0, newLineIndex);
    }
    class Version {
        constructor(full) {
            this.full = full;
            const splits = full.split('.');
            this.major = splits[0];
            this.minor = splits[1];
            this.patch = splits.slice(2).join('.');
        }
    }
    const __window = typeof window !== 'undefined' && window;
    const __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&
        self instanceof WorkerGlobalScope && self;
    const __global = typeof global !== 'undefined' && global;
    // Check __global first, because in Node tests both __global and __window may be defined and _global
    // should be __global in that case.
    const _global = __global || __window || __self;
    function newArray(size, value) {
        const list = [];
        for (let i = 0; i < size; i++) {
            list.push(value);
        }
        return list;
    }
    /**
     * Partitions a given array into 2 arrays, based on a boolean value returned by the condition
     * function.
     *
     * @param arr Input array that should be partitioned
     * @param conditionFn Condition function that is called for each item in a given array and returns a
     * boolean value.
     */
    function partitionArray(arr, conditionFn) {
        const truthy = [];
        const falsy = [];
        for (const item of arr) {
            (conditionFn(item) ? truthy : falsy).push(item);
        }
        return [truthy, falsy];
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * This is an R3 `Node`-like wrapper for a raw `html.Comment` node. We do not currently
     * require the implementation of a visitor for Comments as they are only collected at
     * the top-level of the R3 AST, and only if `Render3ParseOptions['collectCommentNodes']`
     * is true.
     */
    class Comment {
        constructor(value, sourceSpan) {
            this.value = value;
            this.sourceSpan = sourceSpan;
        }
        visit(_visitor) {
            throw new Error('visit() not implemented for Comment');
        }
    }
    class Text {
        constructor(value, sourceSpan) {
            this.value = value;
            this.sourceSpan = sourceSpan;
        }
        visit(visitor) {
            return visitor.visitText(this);
        }
    }
    class BoundText {
        constructor(value, sourceSpan, i18n) {
            this.value = value;
            this.sourceSpan = sourceSpan;
            this.i18n = i18n;
        }
        visit(visitor) {
            return visitor.visitBoundText(this);
        }
    }
    /**
     * Represents a text attribute in the template.
     *
     * `valueSpan` may not be present in cases where there is no value `<div a></div>`.
     * `keySpan` may also not be present for synthetic attributes from ICU expansions.
     */
    class TextAttribute {
        constructor(name, value, sourceSpan, keySpan, valueSpan, i18n) {
            this.name = name;
            this.value = value;
            this.sourceSpan = sourceSpan;
            this.keySpan = keySpan;
            this.valueSpan = valueSpan;
            this.i18n = i18n;
        }
        visit(visitor) {
            return visitor.visitTextAttribute(this);
        }
    }
    class BoundAttribute {
        constructor(name, type, securityContext, value, unit, sourceSpan, keySpan, valueSpan, i18n) {
            this.name = name;
            this.type = type;
            this.securityContext = securityContext;
            this.value = value;
            this.unit = unit;
            this.sourceSpan = sourceSpan;
            this.keySpan = keySpan;
            this.valueSpan = valueSpan;
            this.i18n = i18n;
        }
        static fromBoundElementProperty(prop, i18n) {
            if (prop.keySpan === undefined) {
                throw new Error(`Unexpected state: keySpan must be defined for bound attributes but was not for ${prop.name}: ${prop.sourceSpan}`);
            }
            return new BoundAttribute(prop.name, prop.type, prop.securityContext, prop.value, prop.unit, prop.sourceSpan, prop.keySpan, prop.valueSpan, i18n);
        }
        visit(visitor) {
            return visitor.visitBoundAttribute(this);
        }
    }
    class BoundEvent {
        constructor(name, type, handler, target, phase, sourceSpan, handlerSpan, keySpan) {
            this.name = name;
            this.type = type;
            this.handler = handler;
            this.target = target;
            this.phase = phase;
            this.sourceSpan = sourceSpan;
            this.handlerSpan = handlerSpan;
            this.keySpan = keySpan;
        }
        static fromParsedEvent(event) {
            const target = event.type === 0 /* Regular */ ? event.targetOrPhase : null;
            const phase = event.type === 1 /* Animation */ ? event.targetOrPhase : null;
            if (event.keySpan === undefined) {
                throw new Error(`Unexpected state: keySpan must be defined for bound event but was not for ${event.name}: ${event.sourceSpan}`);
            }
            return new BoundEvent(event.name, event.type, event.handler, target, phase, event.sourceSpan, event.handlerSpan, event.keySpan);
        }
        visit(visitor) {
            return visitor.visitBoundEvent(this);
        }
    }
    class Element {
        constructor(name, attributes, inputs, outputs, children, references, sourceSpan, startSourceSpan, endSourceSpan, i18n) {
            this.name = name;
            this.attributes = attributes;
            this.inputs = inputs;
            this.outputs = outputs;
            this.children = children;
            this.references = references;
            this.sourceSpan = sourceSpan;
            this.startSourceSpan = startSourceSpan;
            this.endSourceSpan = endSourceSpan;
            this.i18n = i18n;
        }
        visit(visitor) {
            return visitor.visitElement(this);
        }
    }
    class Template {
        constructor(tagName, attributes, inputs, outputs, templateAttrs, children, references, variables, sourceSpan, startSourceSpan, endSourceSpan, i18n) {
            this.tagName = tagName;
            this.attributes = attributes;
            this.inputs = inputs;
            this.outputs = outputs;
            this.templateAttrs = templateAttrs;
            this.children = children;
            this.references = references;
            this.variables = variables;
            this.sourceSpan = sourceSpan;
            this.startSourceSpan = startSourceSpan;
            this.endSourceSpan = endSourceSpan;
            this.i18n = i18n;
        }
        visit(visitor) {
            return visitor.visitTemplate(this);
        }
    }
    class Content {
        constructor(selector, attributes, sourceSpan, i18n) {
            this.selector = selector;
            this.attributes = attributes;
            this.sourceSpan = sourceSpan;
            this.i18n = i18n;
            this.name = 'ng-content';
        }
        visit(visitor) {
            return visitor.visitContent(this);
        }
    }
    class Variable {
        constructor(name, value, sourceSpan, keySpan, valueSpan) {
            this.name = name;
            this.value = value;
            this.sourceSpan = sourceSpan;
            this.keySpan = keySpan;
            this.valueSpan = valueSpan;
        }
        visit(visitor) {
            return visitor.visitVariable(this);
        }
    }
    class Reference {
        constructor(name, value, sourceSpan, keySpan, valueSpan) {
            this.name = name;
            this.value = value;
            this.sourceSpan = sourceSpan;
            this.keySpan = keySpan;
            this.valueSpan = valueSpan;
        }
        visit(visitor) {
            return visitor.visitReference(this);
        }
    }
    class Icu {
        constructor(vars, placeholders, sourceSpan, i18n) {
            this.vars = vars;
            this.placeholders = placeholders;
            this.sourceSpan = sourceSpan;
            this.i18n = i18n;
        }
        visit(visitor) {
            return visitor.visitIcu(this);
        }
    }
    class RecursiveVisitor {
        visitElement(element) {
            visitAll(this, element.attributes);
            visitAll(this, element.inputs);
            visitAll(this, element.outputs);
            visitAll(this, element.children);
            visitAll(this, element.references);
        }
        visitTemplate(template) {
            visitAll(this, template.attributes);
            visitAll(this, template.inputs);
            visitAll(this, template.outputs);
            visitAll(this, template.children);
            visitAll(this, template.references);
            visitAll(this, template.variables);
        }
        visitContent(content) { }
        visitVariable(variable) { }
        visitReference(reference) { }
        visitTextAttribute(attribute) { }
        visitBoundAttribute(attribute) { }
        visitBoundEvent(attribute) { }
        visitText(text) { }
        visitBoundText(text) { }
        visitIcu(icu) { }
    }
    function visitAll(visitor, nodes) {
        const result = [];
        if (visitor.visit) {
            for (const node of nodes) {
                const newNode = visitor.visit(node) || node.visit(visitor);
            }
        }
        else {
            for (const node of nodes) {
                const newNode = node.visit(visitor);
                if (newNode) {
                    result.push(newNode);
                }
            }
        }
        return result;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class Message {
        /**
         * @param nodes message AST
         * @param placeholders maps placeholder names to static content and their source spans
         * @param placeholderToMessage maps placeholder names to messages (used for nested ICU messages)
         * @param meaning
         * @param description
         * @param customId
         */
        constructor(nodes, placeholders, placeholderToMessage, meaning, description, customId) {
            this.nodes = nodes;
            this.placeholders = placeholders;
            this.placeholderToMessage = placeholderToMessage;
            this.meaning = meaning;
            this.description = description;
            this.customId = customId;
            this.id = this.customId;
            /** The ids to use if there are no custom id and if `i18nLegacyMessageIdFormat` is not empty */
            this.legacyIds = [];
            if (nodes.length) {
                this.sources = [{
                        filePath: nodes[0].sourceSpan.start.file.url,
                        startLine: nodes[0].sourceSpan.start.line + 1,
                        startCol: nodes[0].sourceSpan.start.col + 1,
                        endLine: nodes[nodes.length - 1].sourceSpan.end.line + 1,
                        endCol: nodes[0].sourceSpan.start.col + 1
                    }];
            }
            else {
                this.sources = [];
            }
        }
    }
    class Text$1 {
        constructor(value, sourceSpan) {
            this.value = value;
            this.sourceSpan = sourceSpan;
        }
        visit(visitor, context) {
            return visitor.visitText(this, context);
        }
    }
    // TODO(vicb): do we really need this node (vs an array) ?
    class Container {
        constructor(children, sourceSpan) {
            this.children = children;
            this.sourceSpan = sourceSpan;
        }
        visit(visitor, context) {
            return visitor.visitContainer(this, context);
        }
    }
    class Icu$1 {
        constructor(expression, type, cases, sourceSpan) {
            this.expression = expression;
            this.type = type;
            this.cases = cases;
            this.sourceSpan = sourceSpan;
        }
        visit(visitor, context) {
            return visitor.visitIcu(this, context);
        }
    }
    class TagPlaceholder {
        constructor(tag, attrs, startName, closeName, children, isVoid, 
        // TODO sourceSpan should cover all (we need a startSourceSpan and endSourceSpan)
        sourceSpan, startSourceSpan, endSourceSpan) {
            this.tag = tag;
            this.attrs = attrs;
            this.startName = startName;
            this.closeName = closeName;
            this.children = children;
            this.isVoid = isVoid;
            this.sourceSpan = sourceSpan;
            this.startSourceSpan = startSourceSpan;
            this.endSourceSpan = endSourceSpan;
        }
        visit(visitor, context) {
            return visitor.visitTagPlaceholder(this, context);
        }
    }
    class Placeholder {
        constructor(value, name, sourceSpan) {
            this.value = value;
            this.name = name;
            this.sourceSpan = sourceSpan;
        }
        visit(visitor, context) {
            return visitor.visitPlaceholder(this, context);
        }
    }
    class IcuPlaceholder {
        constructor(value, name, sourceSpan) {
            this.value = value;
            this.name = name;
            this.sourceSpan = sourceSpan;
        }
        visit(visitor, context) {
            return visitor.visitIcuPlaceholder(this, context);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Represents a big integer using a buffer of its individual digits, with the least significant
     * digit stored at the beginning of the array (little endian).
     *
     * For performance reasons, each instance is mutable. The addition operation can be done in-place
     * to reduce memory pressure of allocation for the digits array.
     */
    class BigInteger {
        /**
         * Creates a big integer using its individual digits in little endian storage.
         */
        constructor(digits) {
            this.digits = digits;
        }
        static zero() {
            return new BigInteger([0]);
        }
        static one() {
            return new BigInteger([1]);
        }
        /**
         * Creates a clone of this instance.
         */
        clone() {
            return new BigInteger(this.digits.slice());
        }
        /**
         * Returns a new big integer with the sum of `this` and `other` as its value. This does not mutate
         * `this` but instead returns a new instance, unlike `addToSelf`.
         */
        add(other) {
            const result = this.clone();
            result.addToSelf(other);
            return result;
        }
        /**
         * Adds `other` to the instance itself, thereby mutating its value.
         */
        addToSelf(other) {
            const maxNrOfDigits = Math.max(this.digits.length, other.digits.length);
            let carry = 0;
            for (let i = 0; i < maxNrOfDigits; i++) {
                let digitSum = carry;
                if (i < this.digits.length) {
                    digitSum += this.digits[i];
                }
                if (i < other.digits.length) {
                    digitSum += other.digits[i];
                }
                if (digitSum >= 10) {
                    this.digits[i] = digitSum - 10;
                    carry = 1;
                }
                else {
                    this.digits[i] = digitSum;
                    carry = 0;
                }
            }
            // Apply a remaining carry if needed.
            if (carry > 0) {
                this.digits[maxNrOfDigits] = 1;
            }
        }
        /**
         * Builds the decimal string representation of the big integer. As this is stored in
         * little endian, the digits are concatenated in reverse order.
         */
        toString() {
            let res = '';
            for (let i = this.digits.length - 1; i >= 0; i--) {
                res += this.digits[i];
            }
            return res;
        }
    }
    /**
     * Represents a big integer which is optimized for multiplication operations, as its power-of-twos
     * are memoized. See `multiplyBy()` for details on the multiplication algorithm.
     */
    class BigIntForMultiplication {
        constructor(value) {
            this.powerOfTwos = [value];
        }
        /**
         * Returns the big integer itself.
         */
        getValue() {
            return this.powerOfTwos[0];
        }
        /**
         * Computes the value for `num * b`, where `num` is a JS number and `b` is a big integer. The
         * value for `b` is represented by a storage model that is optimized for this computation.
         *
         * This operation is implemented in N(log2(num)) by continuous halving of the number, where the
         * least-significant bit (LSB) is tested in each iteration. If the bit is set, the bit's index is
         * used as exponent into the power-of-two multiplication of `b`.
         *
         * As an example, consider the multiplication num=42, b=1337. In binary 42 is 0b00101010 and the
         * algorithm unrolls into the following iterations:
         *
         *  Iteration | num        | LSB  | b * 2^iter | Add? | product
         * -----------|------------|------|------------|------|--------
         *  0         | 0b00101010 | 0    | 1337       | No   | 0
         *  1         | 0b00010101 | 1    | 2674       | Yes  | 2674
         *  2         | 0b00001010 | 0    | 5348       | No   | 2674
         *  3         | 0b00000101 | 1    | 10696      | Yes  | 13370
         *  4         | 0b00000010 | 0    | 21392      | No   | 13370
         *  5         | 0b00000001 | 1    | 42784      | Yes  | 56154
         *  6         | 0b00000000 | 0    | 85568      | No   | 56154
         *
         * The computed product of 56154 is indeed the correct result.
         *
         * The `BigIntForMultiplication` representation for a big integer provides memoized access to the
         * power-of-two values to reduce the workload in computing those values.
         */
        multiplyBy(num) {
            const product = BigInteger.zero();
            this.multiplyByAndAddTo(num, product);
            return product;
        }
        /**
         * See `multiplyBy()` for details. This function allows for the computed product to be added
         * directly to the provided result big integer.
         */
        multiplyByAndAddTo(num, result) {
            for (let exponent = 0; num !== 0; num = num >>> 1, exponent++) {
                if (num & 1) {
                    const value = this.getMultipliedByPowerOfTwo(exponent);
                    result.addToSelf(value);
                }
            }
        }
        /**
         * Computes and memoizes the big integer value for `this.number * 2^exponent`.
         */
        getMultipliedByPowerOfTwo(exponent) {
            // Compute the powers up until the requested exponent, where each value is computed from its
            // predecessor. This is simple as `this.number * 2^(exponent - 1)` only has to be doubled (i.e.
            // added to itself) to reach `this.number * 2^exponent`.
            for (let i = this.powerOfTwos.length; i <= exponent; i++) {
                const previousPower = this.powerOfTwos[i - 1];
                this.powerOfTwos[i] = previousPower.add(previousPower);
            }
            return this.powerOfTwos[exponent];
        }
    }
    /**
     * Represents an exponentiation operation for the provided base, of which exponents are computed and
     * memoized. The results are represented by a `BigIntForMultiplication` which is tailored for
     * multiplication operations by memoizing the power-of-twos. This effectively results in a matrix
     * representation that is lazily computed upon request.
     */
    class BigIntExponentiation {
        constructor(base) {
            this.base = base;
            this.exponents = [new BigIntForMultiplication(BigInteger.one())];
        }
        /**
         * Compute the value for `this.base^exponent`, resulting in a big integer that is optimized for
         * further multiplication operations.
         */
        toThePowerOf(exponent) {
            // Compute the results up until the requested exponent, where every value is computed from its
            // predecessor. This is because `this.base^(exponent - 1)` only has to be multiplied by `base`
            // to reach `this.base^exponent`.
            for (let i = this.exponents.length; i <= exponent; i++) {
                const value = this.exponents[i - 1].multiplyBy(this.base);
                this.exponents[i] = new BigIntForMultiplication(value);
            }
            return this.exponents[exponent];
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Compute the message id using the XLIFF1 digest.
     */
    function computeDigest(message) {
        return sha1(serializeNodes(message.nodes).join('') + `[${message.meaning}]`);
    }
    /**
     * Return the message id or compute it using the XLIFF2/XMB/$localize digest.
     */
    function decimalDigest(message) {
        return message.id || computeDecimalDigest(message);
    }
    /**
     * Compute the message id using the XLIFF2/XMB/$localize digest.
     */
    function computeDecimalDigest(message) {
        const visitor = new _SerializerIgnoreIcuExpVisitor();
        const parts = message.nodes.map(a => a.visit(visitor, null));
        return computeMsgId(parts.join(''), message.meaning);
    }
    /**
     * Serialize the i18n ast to something xml-like in order to generate an UID.
     *
     * The visitor is also used in the i18n parser tests
     *
     * @internal
     */
    class _SerializerVisitor {
        visitText(text, context) {
            return text.value;
        }
        visitContainer(container, context) {
            return `[${container.children.map(child => child.visit(this)).join(', ')}]`;
        }
        visitIcu(icu, context) {
            const strCases = Object.keys(icu.cases).map((k) => `${k} {${icu.cases[k].visit(this)}}`);
            return `{${icu.expression}, ${icu.type}, ${strCases.join(', ')}}`;
        }
        visitTagPlaceholder(ph, context) {
            return ph.isVoid ?
                `<ph tag name="${ph.startName}"/>` :
                `<ph tag name="${ph.startName}">${ph.children.map(child => child.visit(this)).join(', ')}</ph name="${ph.closeName}">`;
        }
        visitPlaceholder(ph, context) {
            return ph.value ? `<ph name="${ph.name}">${ph.value}</ph>` : `<ph name="${ph.name}"/>`;
        }
        visitIcuPlaceholder(ph, context) {
            return `<ph icu name="${ph.name}">${ph.value.visit(this)}</ph>`;
        }
    }
    const serializerVisitor = new _SerializerVisitor();
    function serializeNodes(nodes) {
        return nodes.map(a => a.visit(serializerVisitor, null));
    }
    /**
     * Serialize the i18n ast to something xml-like in order to generate an UID.
     *
     * Ignore the ICU expressions so that message IDs stays identical if only the expression changes.
     *
     * @internal
     */
    class _SerializerIgnoreIcuExpVisitor extends _SerializerVisitor {
        visitIcu(icu, context) {
            let strCases = Object.keys(icu.cases).map((k) => `${k} {${icu.cases[k].visit(this)}}`);
            // Do not take the expression into account
            return `{${icu.type}, ${strCases.join(', ')}}`;
        }
    }
    /**
     * Compute the SHA1 of the given string
     *
     * see https://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf
     *
     * WARNING: this function has not been designed not tested with security in mind.
     *          DO NOT USE IT IN A SECURITY SENSITIVE CONTEXT.
     */
    function sha1(str) {
        const utf8 = utf8Encode(str);
        const words32 = bytesToWords32(utf8, Endian.Big);
        const len = utf8.length * 8;
        const w = newArray(80);
        let a = 0x67452301, b = 0xefcdab89, c = 0x98badcfe, d = 0x10325476, e = 0xc3d2e1f0;
        words32[len >> 5] |= 0x80 << (24 - len % 32);
        words32[((len + 64 >> 9) << 4) + 15] = len;
        for (let i = 0; i < words32.length; i += 16) {
            const h0 = a, h1 = b, h2 = c, h3 = d, h4 = e;
            for (let j = 0; j < 80; j++) {
                if (j < 16) {
                    w[j] = words32[i + j];
                }
                else {
                    w[j] = rol32(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);
                }
                const fkVal = fk(j, b, c, d);
                const f = fkVal[0];
                const k = fkVal[1];
                const temp = [rol32(a, 5), f, e, k, w[j]].reduce(add32);
                e = d;
                d = c;
                c = rol32(b, 30);
                b = a;
                a = temp;
            }
            a = add32(a, h0);
            b = add32(b, h1);
            c = add32(c, h2);
            d = add32(d, h3);
            e = add32(e, h4);
        }
        return bytesToHexString(words32ToByteString([a, b, c, d, e]));
    }
    function fk(index, b, c, d) {
        if (index < 20) {
            return [(b & c) | (~b & d), 0x5a827999];
        }
        if (index < 40) {
            return [b ^ c ^ d, 0x6ed9eba1];
        }
        if (index < 60) {
            return [(b & c) | (b & d) | (c & d), 0x8f1bbcdc];
        }
        return [b ^ c ^ d, 0xca62c1d6];
    }
    /**
     * Compute the fingerprint of the given string
     *
     * The output is 64 bit number encoded as a decimal string
     *
     * based on:
     * https://github.com/google/closure-compiler/blob/master/src/com/google/javascript/jscomp/GoogleJsMessageIdGenerator.java
     */
    function fingerprint(str) {
        const utf8 = utf8Encode(str);
        let hi = hash32(utf8, 0);
        let lo = hash32(utf8, 102072);
        if (hi == 0 && (lo == 0 || lo == 1)) {
            hi = hi ^ 0x130f9bef;
            lo = lo ^ -0x6b5f56d8;
        }
        return [hi, lo];
    }
    function computeMsgId(msg, meaning = '') {
        let msgFingerprint = fingerprint(msg);
        if (meaning) {
            const meaningFingerprint = fingerprint(meaning);
            msgFingerprint = add64(rol64(msgFingerprint, 1), meaningFingerprint);
        }
        const hi = msgFingerprint[0];
        const lo = msgFingerprint[1];
        return wordsToDecimalString(hi & 0x7fffffff, lo);
    }
    function hash32(bytes, c) {
        let a = 0x9e3779b9, b = 0x9e3779b9;
        let i;
        const len = bytes.length;
        for (i = 0; i + 12 <= len; i += 12) {
            a = add32(a, wordAt(bytes, i, Endian.Little));
            b = add32(b, wordAt(bytes, i + 4, Endian.Little));
            c = add32(c, wordAt(bytes, i + 8, Endian.Little));
            const res = mix(a, b, c);
            a = res[0], b = res[1], c = res[2];
        }
        a = add32(a, wordAt(bytes, i, Endian.Little));
        b = add32(b, wordAt(bytes, i + 4, Endian.Little));
        // the first byte of c is reserved for the length
        c = add32(c, len);
        c = add32(c, wordAt(bytes, i + 8, Endian.Little) << 8);
        return mix(a, b, c)[2];
    }
    // clang-format off
    function mix(a, b, c) {
        a = sub32(a, b);
        a = sub32(a, c);
        a ^= c >>> 13;
        b = sub32(b, c);
        b = sub32(b, a);
        b ^= a << 8;
        c = sub32(c, a);
        c = sub32(c, b);
        c ^= b >>> 13;
        a = sub32(a, b);
        a = sub32(a, c);
        a ^= c >>> 12;
        b = sub32(b, c);
        b = sub32(b, a);
        b ^= a << 16;
        c = sub32(c, a);
        c = sub32(c, b);
        c ^= b >>> 5;
        a = sub32(a, b);
        a = sub32(a, c);
        a ^= c >>> 3;
        b = sub32(b, c);
        b = sub32(b, a);
        b ^= a << 10;
        c = sub32(c, a);
        c = sub32(c, b);
        c ^= b >>> 15;
        return [a, b, c];
    }
    // clang-format on
    // Utils
    var Endian;
    (function (Endian) {
        Endian[Endian["Little"] = 0] = "Little";
        Endian[Endian["Big"] = 1] = "Big";
    })(Endian || (Endian = {}));
    function add32(a, b) {
        return add32to64(a, b)[1];
    }
    function add32to64(a, b) {
        const low = (a & 0xffff) + (b & 0xffff);
        const high = (a >>> 16) + (b >>> 16) + (low >>> 16);
        return [high >>> 16, (high << 16) | (low & 0xffff)];
    }
    function add64(a, b) {
        const ah = a[0], al = a[1];
        const bh = b[0], bl = b[1];
        const result = add32to64(al, bl);
        const carry = result[0];
        const l = result[1];
        const h = add32(add32(ah, bh), carry);
        return [h, l];
    }
    function sub32(a, b) {
        const low = (a & 0xffff) - (b & 0xffff);
        const high = (a >> 16) - (b >> 16) + (low >> 16);
        return (high << 16) | (low & 0xffff);
    }
    // Rotate a 32b number left `count` position
    function rol32(a, count) {
        return (a << count) | (a >>> (32 - count));
    }
    // Rotate a 64b number left `count` position
    function rol64(num, count) {
        const hi = num[0], lo = num[1];
        const h = (hi << count) | (lo >>> (32 - count));
        const l = (lo << count) | (hi >>> (32 - count));
        return [h, l];
    }
    function bytesToWords32(bytes, endian) {
        const size = (bytes.length + 3) >>> 2;
        const words32 = [];
        for (let i = 0; i < size; i++) {
            words32[i] = wordAt(bytes, i * 4, endian);
        }
        return words32;
    }
    function byteAt(bytes, index) {
        return index >= bytes.length ? 0 : bytes[index];
    }
    function wordAt(bytes, index, endian) {
        let word = 0;
        if (endian === Endian.Big) {
            for (let i = 0; i < 4; i++) {
                word += byteAt(bytes, index + i) << (24 - 8 * i);
            }
        }
        else {
            for (let i = 0; i < 4; i++) {
                word += byteAt(bytes, index + i) << 8 * i;
            }
        }
        return word;
    }
    function words32ToByteString(words32) {
        return words32.reduce((bytes, word) => bytes.concat(word32ToByteString(word)), []);
    }
    function word32ToByteString(word) {
        let bytes = [];
        for (let i = 0; i < 4; i++) {
            bytes.push((word >>> 8 * (3 - i)) & 0xff);
        }
        return bytes;
    }
    function bytesToHexString(bytes) {
        let hex = '';
        for (let i = 0; i < bytes.length; i++) {
            const b = byteAt(bytes, i);
            hex += (b >>> 4).toString(16) + (b & 0x0f).toString(16);
        }
        return hex.toLowerCase();
    }
    /**
     * Create a shared exponentiation pool for base-256 computations. This shared pool provides memoized
     * power-of-256 results with memoized power-of-two computations for efficient multiplication.
     *
     * For our purposes, this can be safely stored as a global without memory concerns. The reason is
     * that we encode two words, so only need the 0th (for the low word) and 4th (for the high word)
     * exponent.
     */
    const base256 = new BigIntExponentiation(256);
    /**
     * Represents two 32-bit words as a single decimal number. This requires a big integer storage
     * model as JS numbers are not accurate enough to represent the 64-bit number.
     *
     * Based on https://www.danvk.org/hex2dec.html
     */
    function wordsToDecimalString(hi, lo) {
        // Encode the four bytes in lo in the lower digits of the decimal number.
        // Note: the multiplication results in lo itself but represented by a big integer using its
        // decimal digits.
        const decimal = base256.toThePowerOf(0).multiplyBy(lo);
        // Encode the four bytes in hi above the four lo bytes. lo is a maximum of (2^8)^4, which is why
        // this multiplication factor is applied.
        base256.toThePowerOf(4).multiplyByAndAddTo(hi, decimal);
        return decimal.toString();
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    // XMB/XTB placeholders can only contain A-Z, 0-9 and _
    function toPublicName(internalName) {
        return internalName.toUpperCase().replace(/[^A-Z0-9_]/g, '_');
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /* Closure variables holding messages must be named `MSG_[A-Z0-9]+` */
    const CLOSURE_TRANSLATION_VAR_PREFIX = 'MSG_';
    /**
     * Prefix for non-`goog.getMsg` i18n-related vars.
     * Note: the prefix uses lowercase characters intentionally due to a Closure behavior that
     * considers variables like `I18N_0` as constants and throws an error when their value changes.
     */
    const TRANSLATION_VAR_PREFIX = 'i18n_';
    /** Name of the i18n attributes **/
    const I18N_ATTR = 'i18n';
    const I18N_ATTR_PREFIX = 'i18n-';
    /** Prefix of var expressions used in ICUs */
    const I18N_ICU_VAR_PREFIX = 'VAR_';
    /** Prefix of ICU expressions for post processing */
    const I18N_ICU_MAPPING_PREFIX = 'I18N_EXP_';
    /** Placeholder wrapper for i18n expressions **/
    const I18N_PLACEHOLDER_SYMBOL = '';
    function isI18nAttribute(name) {
        return name === I18N_ATTR || name.startsWith(I18N_ATTR_PREFIX);
    }
    function isI18nRootNode(meta) {
        return meta instanceof Message;
    }
    function isSingleI18nIcu(meta) {
        return isI18nRootNode(meta) && meta.nodes.length === 1 && meta.nodes[0] instanceof Icu$1;
    }
    function hasI18nMeta(node) {
        return !!node.i18n;
    }
    function hasI18nAttrs(element) {
        return element.attrs.some((attr) => isI18nAttribute(attr.name));
    }
    function icuFromI18nMessage(message) {
        return message.nodes[0];
    }
    function wrapI18nPlaceholder(content, contextId = 0) {
        const blockId = contextId > 0 ? `:${contextId}` : '';
        return `${I18N_PLACEHOLDER_SYMBOL}${content}${blockId}${I18N_PLACEHOLDER_SYMBOL}`;
    }
    function assembleI18nBoundString(strings, bindingStartIndex = 0, contextId = 0) {
        if (!strings.length)
            return '';
        let acc = '';
        const lastIdx = strings.length - 1;
        for (let i = 0; i < lastIdx; i++) {
            acc += `${strings[i]}${wrapI18nPlaceholder(bindingStartIndex + i, contextId)}`;
        }
        acc += strings[lastIdx];
        return acc;
    }
    function getSeqNumberGenerator(startsAt = 0) {
        let current = startsAt;
        return () => current++;
    }
    function placeholdersToParams(placeholders) {
        const params = {};
        placeholders.forEach((values, key) => {
            params[key] = literal(values.length > 1 ? `[${values.join('|')}]` : values[0]);
        });
        return params;
    }
    function updatePlaceholderMap(map, name, ...values) {
        const current = map.get(name) || [];
        current.push(...values);
        map.set(name, current);
    }
    function assembleBoundTextPlaceholders(meta, bindingStartIndex = 0, contextId = 0) {
        const startIdx = bindingStartIndex;
        const placeholders = new Map();
        const node = meta instanceof Message ? meta.nodes.find(node => node instanceof Container) : meta;
        if (node) {
            node
                .children
                .filter((child) => child instanceof Placeholder)
                .forEach((child, idx) => {
                const content = wrapI18nPlaceholder(startIdx + idx, contextId);
                updatePlaceholderMap(placeholders, child.name, content);
            });
        }
        return placeholders;
    }
    /**
     * Format the placeholder names in a map of placeholders to expressions.
     *
     * The placeholder names are converted from "internal" format (e.g. `START_TAG_DIV_1`) to "external"
     * format (e.g. `startTagDiv_1`).
     *
     * @param params A map of placeholder names to expressions.
     * @param useCamelCase whether to camelCase the placeholder name when formatting.
     * @returns A new map of formatted placeholder names to expressions.
     */
    function i18nFormatPlaceholderNames(params = {}, useCamelCase) {
        const _params = {};
        if (params && Object.keys(params).length) {
            Object.keys(params).forEach(key => _params[formatI18nPlaceholderName(key, useCamelCase)] = params[key]);
        }
        return _params;
    }
    /**
     * Converts internal placeholder names to public-facing format
     * (for example to use in goog.getMsg call).
     * Example: `START_TAG_DIV_1` is converted to `startTagDiv_1`.
     *
     * @param name The placeholder name that should be formatted
     * @returns Formatted placeholder name
     */
    function formatI18nPlaceholderName(name, useCamelCase = true) {
        const publicName = toPublicName(name);
        if (!useCamelCase) {
            return publicName;
        }
        const chunks = publicName.split('_');
        if (chunks.length === 1) {
            // if no "_" found - just lowercase the value
            return name.toLowerCase();
        }
        let postfix;
        // eject last element if it's a number
        if (/^\d+$/.test(chunks[chunks.length - 1])) {
            postfix = chunks.pop();
        }
        let raw = chunks.shift().toLowerCase();
        if (chunks.length) {
            raw += chunks.map(c => c.charAt(0).toUpperCase() + c.slice(1).toLowerCase()).join('');
        }
        return postfix ? `${raw}_${postfix}` : raw;
    }
    /**
     * Generates a prefix for translation const name.
     *
     * @param extra Additional local prefix that should be injected into translation var name
     * @returns Complete translation const prefix
     */
    function getTranslationConstPrefix(extra) {
        return `${CLOSURE_TRANSLATION_VAR_PREFIX}${extra}`.toUpperCase();
    }
    /**
     * Generate AST to declare a variable. E.g. `var I18N_1;`.
     * @param variable the name of the variable to declare.
     */
    function declareI18nVariable(variable) {
        return new DeclareVarStmt(variable.name, undefined, INFERRED_TYPE, undefined, variable.sourceSpan);
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Checks whether an object key contains potentially unsafe chars, thus the key should be wrapped in
     * quotes. Note: we do not wrap all keys into quotes, as it may have impact on minification and may
     * bot work in some cases when object keys are mangled by minifier.
     *
     * TODO(FW-1136): this is a temporary solution, we need to come up with a better way of working with
     * inputs that contain potentially unsafe chars.
     */
    const UNSAFE_OBJECT_KEY_NAME_REGEXP = /[-.]/;
    /** Name of the temporary to use during data binding */
    const TEMPORARY_NAME = '_t';
    /** Name of the context parameter passed into a template function */
    const CONTEXT_NAME = 'ctx';
    /** Name of the RenderFlag passed into a template function */
    const RENDER_FLAGS = 'rf';
    /** The prefix reference variables */
    const REFERENCE_PREFIX = '_r';
    /** The name of the implicit context reference */
    const IMPLICIT_REFERENCE = '$implicit';
    /** Non bindable attribute name **/
    const NON_BINDABLE_ATTR = 'ngNonBindable';
    /** Name for the variable keeping track of the context returned by `restoreView`. */
    const RESTORED_VIEW_CONTEXT_NAME = 'restoredCtx';
    /**
     * Creates an allocator for a temporary variable.
     *
     * A variable declaration is added to the statements the first time the allocator is invoked.
     */
    function temporaryAllocator(statements, name) {
        let temp = null;
        return () => {
            if (!temp) {
                statements.push(new DeclareVarStmt(TEMPORARY_NAME, undefined, DYNAMIC_TYPE));
                temp = variable(name);
            }
            return temp;
        };
    }
    function unsupported(feature) {
        if (this) {
            throw new Error(`Builder ${this.constructor.name} doesn't support ${feature} yet`);
        }
        throw new Error(`Feature ${feature} is not supported yet`);
    }
    function invalid$1(arg) {
        throw new Error(`Invalid state: Visitor ${this.constructor.name} doesn't handle ${arg.constructor.name}`);
    }
    function asLiteral(value) {
        if (Array.isArray(value)) {
            return literalArr(value.map(asLiteral));
        }
        return literal(value, INFERRED_TYPE);
    }
    function conditionallyCreateMapObjectLiteral(keys, keepDeclared) {
        if (Object.getOwnPropertyNames(keys).length > 0) {
            return mapToExpression(keys, keepDeclared);
        }
        return null;
    }
    function mapToExpression(map, keepDeclared) {
        return literalMap(Object.getOwnPropertyNames(map).map(key => {
            // canonical syntax: `dirProp: publicProp`
            // if there is no `:`, use dirProp = elProp
            const value = map[key];
            let declaredName;
            let publicName;
            let minifiedName;
            let needsDeclaredName;
            if (Array.isArray(value)) {
                [publicName, declaredName] = value;
                minifiedName = key;
                needsDeclaredName = publicName !== declaredName;
            }
            else {
                [declaredName, publicName] = splitAtColon(key, [key, value]);
                minifiedName = declaredName;
                // Only include the declared name if extracted from the key, i.e. the key contains a colon.
                // Otherwise the declared name should be omitted even if it is different from the public name,
                // as it may have already been minified.
                needsDeclaredName = publicName !== declaredName && key.includes(':');
            }
            return {
                key: minifiedName,
                // put quotes around keys that contain potentially unsafe characters
                quoted: UNSAFE_OBJECT_KEY_NAME_REGEXP.test(minifiedName),
                value: (keepDeclared && needsDeclaredName) ?
                    literalArr([asLiteral(publicName), asLiteral(declaredName)]) :
                    asLiteral(publicName)
            };
        }));
    }
    /**
     *  Remove trailing null nodes as they are implied.
     */
    function trimTrailingNulls(parameters) {
        while (isNull(parameters[parameters.length - 1])) {
            parameters.pop();
        }
        return parameters;
    }
    function getQueryPredicate(query, constantPool) {
        if (Array.isArray(query.predicate)) {
            let predicate = [];
            query.predicate.forEach((selector) => {
                // Each item in predicates array may contain strings with comma-separated refs
                // (for ex. 'ref, ref1, ..., refN'), thus we extract individual refs and store them
                // as separate array entities
                const selectors = selector.split(',').map(token => literal(token.trim()));
                predicate.push(...selectors);
            });
            return constantPool.getConstLiteral(literalArr(predicate), true);
        }
        else {
            return query.predicate;
        }
    }
    /**
     * A representation for an object literal used during codegen of definition objects. The generic
     * type `T` allows to reference a documented type of the generated structure, such that the
     * property names that are set can be resolved to their documented declaration.
     */
    class DefinitionMap {
        constructor() {
            this.values = [];
        }
        set(key, value) {
            if (value) {
                this.values.push({ key: key, value, quoted: false });
            }
        }
        toLiteralMap() {
            return literalMap(this.values);
        }
    }
    /**
     * Extract a map of properties to values for a given element or template node, which can be used
     * by the directive matching machinery.
     *
     * @param elOrTpl the element or template in question
     * @return an object set up for directive matching. For attributes on the element/template, this
     * object maps a property name to its (static) value. For any bindings, this map simply maps the
     * property name to an empty string.
     */
    function getAttrsForDirectiveMatching(elOrTpl) {
        const attributesMap = {};
        if (elOrTpl instanceof Template && elOrTpl.tagName !== 'ng-template') {
            elOrTpl.templateAttrs.forEach(a => attributesMap[a.name] = '');
        }
        else {
            elOrTpl.attributes.forEach(a => {
                if (!isI18nAttribute(a.name)) {
                    attributesMap[a.name] = a.value;
                }
            });
            elOrTpl.inputs.forEach(i => {
                attributesMap[i.name] = '';
            });
            elOrTpl.outputs.forEach(o => {
                attributesMap[o.name] = '';
            });
        }
        return attributesMap;
    }
    /** Returns a call expression to a chained instruction, e.g. `property(params[0])(params[1])`. */
    function chainedInstruction(reference, calls, span) {
        let expression = importExpr(reference, null, span);
        if (calls.length > 0) {
            for (let i = 0; i < calls.length; i++) {
                expression = expression.callFn(calls[i], span);
            }
        }
        else {
            // Add a blank invocation, in case the `calls` array is empty.
            expression = expression.callFn([], span);
        }
        return expression;
    }
    /**
     * Gets the number of arguments expected to be passed to a generated instruction in the case of
     * interpolation instructions.
     * @param interpolation An interpolation ast
     */
    function getInterpolationArgsLength(interpolation) {
        const { expressions, strings } = interpolation;
        if (expressions.length === 1 && strings.length === 2 && strings[0] === '' && strings[1] === '') {
            // If the interpolation has one interpolated value, but the prefix and suffix are both empty
            // strings, we only pass one argument, to a special instruction like `propertyInterpolate` or
            // `textInterpolate`.
            return 1;
        }
        else {
            return expressions.length + strings.length;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Creates an array literal expression from the given array, mapping all values to an expression
     * using the provided mapping function. If the array is empty or null, then null is returned.
     *
     * @param values The array to transfer into literal array expression.
     * @param mapper The logic to use for creating an expression for the array's values.
     * @returns An array literal expression representing `values`, or null if `values` is empty or
     * is itself null.
     */
    function toOptionalLiteralArray(values, mapper) {
        if (values === null || values.length === 0) {
            return null;
        }
        return literalArr(values.map(value => mapper(value)));
    }
    /**
     * Creates an object literal expression from the given object, mapping all values to an expression
     * using the provided mapping function. If the object has no keys, then null is returned.
     *
     * @param object The object to transfer into an object literal expression.
     * @param mapper The logic to use for creating an expression for the object's values.
     * @returns An object literal expression representing `object`, or null if `object` does not have
     * any keys.
     */
    function toOptionalLiteralMap(object, mapper) {
        const entries = Object.keys(object).map(key => {
            const value = object[key];
            return { key, value: mapper(value), quoted: true };
        });
        if (entries.length > 0) {
            return literalMap(entries);
        }
        else {
            return null;
        }
    }
    function compileDependencies(deps) {
        if (deps === 'invalid') {
            // The `deps` can be set to the string "invalid"  by the `unwrapConstructorDependencies()`
            // function, which tries to convert `ConstructorDeps` into `R3DependencyMetadata[]`.
            return literal('invalid');
        }
        else if (deps === null) {
            return literal(null);
        }
        else {
            return literalArr(deps.map(compileDependency));
        }
    }
    function compileDependency(dep) {
        const depMeta = new DefinitionMap();
        depMeta.set('token', dep.token);
        if (dep.attributeNameType !== null) {
            depMeta.set('attribute', literal(true));
        }
        if (dep.host) {
            depMeta.set('host', literal(true));
        }
        if (dep.optional) {
            depMeta.set('optional', literal(true));
        }
        if (dep.self) {
            depMeta.set('self', literal(true));
        }
        if (dep.skipSelf) {
            depMeta.set('skipSelf', literal(true));
        }
        return depMeta.toLiteralMap();
    }
    /**
     * Generate an expression that has the given `expr` wrapped in the following form:
     *
     * ```
     * forwardRef(() => expr)
     * ```
     */
    function generateForwardRef(expr) {
        return importExpr(Identifiers.forwardRef).callFn([fn([], [new ReturnStatement(expr)])]);
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    // https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit
    const VERSION = 3;
    const JS_B64_PREFIX = '# sourceMappingURL=data:application/json;base64,';
    class SourceMapGenerator {
        constructor(file = null) {
            this.file = file;
            this.sourcesContent = new Map();
            this.lines = [];
            this.lastCol0 = 0;
            this.hasMappings = false;
        }
        // The content is `null` when the content is expected to be loaded using the URL
        addSource(url, content = null) {
            if (!this.sourcesContent.has(url)) {
                this.sourcesContent.set(url, content);
            }
            return this;
        }
        addLine() {
            this.lines.push([]);
            this.lastCol0 = 0;
            return this;
        }
        addMapping(col0, sourceUrl, sourceLine0, sourceCol0) {
            if (!this.currentLine) {
                throw new Error(`A line must be added before mappings can be added`);
            }
            if (sourceUrl != null && !this.sourcesContent.has(sourceUrl)) {
                throw new Error(`Unknown source file "${sourceUrl}"`);
            }
            if (col0 == null) {
                throw new Error(`The column in the generated code must be provided`);
            }
            if (col0 < this.lastCol0) {
                throw new Error(`Mapping should be added in output order`);
            }
            if (sourceUrl && (sourceLine0 == null || sourceCol0 == null)) {
                throw new Error(`The source location must be provided when a source url is provided`);
            }
            this.hasMappings = true;
            this.lastCol0 = col0;
            this.currentLine.push({ col0, sourceUrl, sourceLine0, sourceCol0 });
            return this;
        }
        /**
         * @internal strip this from published d.ts files due to
         * https://github.com/microsoft/TypeScript/issues/36216
         */
        get currentLine() {
            return this.lines.slice(-1)[0];
        }
        toJSON() {
            if (!this.hasMappings) {
                return null;
            }
            const sourcesIndex = new Map();
            const sources = [];
            const sourcesContent = [];
            Array.from(this.sourcesContent.keys()).forEach((url, i) => {
                sourcesIndex.set(url, i);
                sources.push(url);
                sourcesContent.push(this.sourcesContent.get(url) || null);
            });
            let mappings = '';
            let lastCol0 = 0;
            let lastSourceIndex = 0;
            let lastSourceLine0 = 0;
            let lastSourceCol0 = 0;
            this.lines.forEach(segments => {
                lastCol0 = 0;
                mappings += segments
                    .map(segment => {
                    // zero-based starting column of the line in the generated code
                    let segAsStr = toBase64VLQ(segment.col0 - lastCol0);
                    lastCol0 = segment.col0;
                    if (segment.sourceUrl != null) {
                        // zero-based index into the sources list
                        segAsStr +=
                            toBase64VLQ(sourcesIndex.get(segment.sourceUrl) - lastSourceIndex);
                        lastSourceIndex = sourcesIndex.get(segment.sourceUrl);
                        // the zero-based starting line in the original source
                        segAsStr += toBase64VLQ(segment.sourceLine0 - lastSourceLine0);
                        lastSourceLine0 = segment.sourceLine0;
                        // the zero-based starting column in the original source
                        segAsStr += toBase64VLQ(segment.sourceCol0 - lastSourceCol0);
                        lastSourceCol0 = segment.sourceCol0;
                    }
                    return segAsStr;
                })
                    .join(',');
                mappings += ';';
            });
            mappings = mappings.slice(0, -1);
            return {
                'file': this.file || '',
                'version': VERSION,
                'sourceRoot': '',
                'sources': sources,
                'sourcesContent': sourcesContent,
                'mappings': mappings,
            };
        }
        toJsComment() {
            return this.hasMappings ? '//' + JS_B64_PREFIX + toBase64String(JSON.stringify(this, null, 0)) :
                '';
        }
    }
    function toBase64String(value) {
        let b64 = '';
        const encoded = utf8Encode(value);
        for (let i = 0; i < encoded.length;) {
            const i1 = encoded[i++];
            const i2 = i < encoded.length ? encoded[i++] : null;
            const i3 = i < encoded.length ? encoded[i++] : null;
            b64 += toBase64Digit(i1 >> 2);
            b64 += toBase64Digit(((i1 & 3) << 4) | (i2 === null ? 0 : i2 >> 4));
            b64 += i2 === null ? '=' : toBase64Digit(((i2 & 15) << 2) | (i3 === null ? 0 : i3 >> 6));
            b64 += i2 === null || i3 === null ? '=' : toBase64Digit(i3 & 63);
        }
        return b64;
    }
    function toBase64VLQ(value) {
        value = value < 0 ? ((-value) << 1) + 1 : value << 1;
        let out = '';
        do {
            let digit = value & 31;
            value = value >> 5;
            if (value > 0) {
                digit = digit | 32;
            }
            out += toBase64Digit(digit);
        } while (value > 0);
        return out;
    }
    const B64_DIGITS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    function toBase64Digit(value) {
        if (value < 0 || value >= 64) {
            throw new Error(`Can only encode value in the range [0, 63]`);
        }
        return B64_DIGITS[value];
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const _SINGLE_QUOTE_ESCAPE_STRING_RE = /'|\\|\n|\r|\$/g;
    const _LEGAL_IDENTIFIER_RE = /^[$A-Z_][0-9A-Z_$]*$/i;
    const _INDENT_WITH = '  ';
    const CATCH_ERROR_VAR$1 = variable('error', null, null);
    const CATCH_STACK_VAR$1 = variable('stack', null, null);
    class _EmittedLine {
        constructor(indent) {
            this.indent = indent;
            this.partsLength = 0;
            this.parts = [];
            this.srcSpans = [];
        }
    }
    class EmitterVisitorContext {
        constructor(_indent) {
            this._indent = _indent;
            this._classes = [];
            this._preambleLineCount = 0;
            this._lines = [new _EmittedLine(_indent)];
        }
        static createRoot() {
            return new EmitterVisitorContext(0);
        }
        /**
         * @internal strip this from published d.ts files due to
         * https://github.com/microsoft/TypeScript/issues/36216
         */
        get _currentLine() {
            return this._lines[this._lines.length - 1];
        }
        println(from, lastPart = '') {
            this.print(from || null, lastPart, true);
        }
        lineIsEmpty() {
            return this._currentLine.parts.length === 0;
        }
        lineLength() {
            return this._currentLine.indent * _INDENT_WITH.length + this._currentLine.partsLength;
        }
        print(from, part, newLine = false) {
            if (part.length > 0) {
                this._currentLine.parts.push(part);
                this._currentLine.partsLength += part.length;
                this._currentLine.srcSpans.push(from && from.sourceSpan || null);
            }
            if (newLine) {
                this._lines.push(new _EmittedLine(this._indent));
            }
        }
        removeEmptyLastLine() {
            if (this.lineIsEmpty()) {
                this._lines.pop();
            }
        }
        incIndent() {
            this._indent++;
            if (this.lineIsEmpty()) {
                this._currentLine.indent = this._indent;
            }
        }
        decIndent() {
            this._indent--;
            if (this.lineIsEmpty()) {
                this._currentLine.indent = this._indent;
            }
        }
        pushClass(clazz) {
            this._classes.push(clazz);
        }
        popClass() {
            return this._classes.pop();
        }
        get currentClass() {
            return this._classes.length > 0 ? this._classes[this._classes.length - 1] : null;
        }
        toSource() {
            return this.sourceLines
                .map(l => l.parts.length > 0 ? _createIndent(l.indent) + l.parts.join('') : '')
                .join('\n');
        }
        toSourceMapGenerator(genFilePath, startsAtLine = 0) {
            const map = new SourceMapGenerator(genFilePath);
            let firstOffsetMapped = false;
            const mapFirstOffsetIfNeeded = () => {
                if (!firstOffsetMapped) {
                    // Add a single space so that tools won't try to load the file from disk.
                    // Note: We are using virtual urls like `ng:///`, so we have to
                    // provide a content here.
                    map.addSource(genFilePath, ' ').addMapping(0, genFilePath, 0, 0);
                    firstOffsetMapped = true;
                }
            };
            for (let i = 0; i < startsAtLine; i++) {
                map.addLine();
                mapFirstOffsetIfNeeded();
            }
            this.sourceLines.forEach((line, lineIdx) => {
                map.addLine();
                const spans = line.srcSpans;
                const parts = line.parts;
                let col0 = line.indent * _INDENT_WITH.length;
                let spanIdx = 0;
                // skip leading parts without source spans
                while (spanIdx < spans.length && !spans[spanIdx]) {
                    col0 += parts[spanIdx].length;
                    spanIdx++;
                }
                if (spanIdx < spans.length && lineIdx === 0 && col0 === 0) {
                    firstOffsetMapped = true;
                }
                else {
                    mapFirstOffsetIfNeeded();
                }
                while (spanIdx < spans.length) {
                    const span = spans[spanIdx];
                    const source = span.start.file;
                    const sourceLine = span.start.line;
                    const sourceCol = span.start.col;
                    map.addSource(source.url, source.content)
                        .addMapping(col0, source.url, sourceLine, sourceCol);
                    col0 += parts[spanIdx].length;
                    spanIdx++;
                    // assign parts without span or the same span to the previous segment
                    while (spanIdx < spans.length && (span === spans[spanIdx] || !spans[spanIdx])) {
                        col0 += parts[spanIdx].length;
                        spanIdx++;
                    }
                }
            });
            return map;
        }
        setPreambleLineCount(count) {
            return this._preambleLineCount = count;
        }
        spanOf(line, column) {
            const emittedLine = this._lines[line - this._preambleLineCount];
            if (emittedLine) {
                let columnsLeft = column - _createIndent(emittedLine.indent).length;
                for (let partIndex = 0; partIndex < emittedLine.parts.length; partIndex++) {
                    const part = emittedLine.parts[partIndex];
                    if (part.length > columnsLeft) {
                        return emittedLine.srcSpans[partIndex];
                    }
                    columnsLeft -= part.length;
                }
            }
            return null;
        }
        /**
         * @internal strip this from published d.ts files due to
         * https://github.com/microsoft/TypeScript/issues/36216
         */
        get sourceLines() {
            if (this._lines.length && this._lines[this._lines.length - 1].parts.length === 0) {
                return this._lines.slice(0, -1);
            }
            return this._lines;
        }
    }
    class AbstractEmitterVisitor {
        constructor(_escapeDollarInStrings) {
            this._escapeDollarInStrings = _escapeDollarInStrings;
        }
        printLeadingComments(stmt, ctx) {
            if (stmt.leadingComments === undefined) {
                return;
            }
            for (const comment of stmt.leadingComments) {
                if (comment instanceof JSDocComment) {
                    ctx.print(stmt, `/*${comment.toString()}*/`, comment.trailingNewline);
                }
                else {
                    if (comment.multiline) {
                        ctx.print(stmt, `/* ${comment.text} */`, comment.trailingNewline);
                    }
                    else {
                        comment.text.split('\n').forEach((line) => {
                            ctx.println(stmt, `// ${line}`);
                        });
                    }
                }
            }
        }
        visitExpressionStmt(stmt, ctx) {
            this.printLeadingComments(stmt, ctx);
            stmt.expr.visitExpression(this, ctx);
            ctx.println(stmt, ';');
            return null;
        }
        visitReturnStmt(stmt, ctx) {
            this.printLeadingComments(stmt, ctx);
            ctx.print(stmt, `return `);
            stmt.value.visitExpression(this, ctx);
            ctx.println(stmt, ';');
            return null;
        }
        visitIfStmt(stmt, ctx) {
            this.printLeadingComments(stmt, ctx);
            ctx.print(stmt, `if (`);
            stmt.condition.visitExpression(this, ctx);
            ctx.print(stmt, `) {`);
            const hasElseCase = stmt.falseCase != null && stmt.falseCase.length > 0;
            if (stmt.trueCase.length <= 1 && !hasElseCase) {
                ctx.print(stmt, ` `);
                this.visitAllStatements(stmt.trueCase, ctx);
                ctx.removeEmptyLastLine();
                ctx.print(stmt, ` `);
            }
            else {
                ctx.println();
                ctx.incIndent();
                this.visitAllStatements(stmt.trueCase, ctx);
                ctx.decIndent();
                if (hasElseCase) {
                    ctx.println(stmt, `} else {`);
                    ctx.incIndent();
                    this.visitAllStatements(stmt.falseCase, ctx);
                    ctx.decIndent();
                }
            }
            ctx.println(stmt, `}`);
            return null;
        }
        visitThrowStmt(stmt, ctx) {
            this.printLeadingComments(stmt, ctx);
            ctx.print(stmt, `throw `);
            stmt.error.visitExpression(this, ctx);
            ctx.println(stmt, `;`);
            return null;
        }
        visitWriteVarExpr(expr, ctx) {
            const lineWasEmpty = ctx.lineIsEmpty();
            if (!lineWasEmpty) {
                ctx.print(expr, '(');
            }
            ctx.print(expr, `${expr.name} = `);
            expr.value.visitExpression(this, ctx);
            if (!lineWasEmpty) {
                ctx.print(expr, ')');
            }
            return null;
        }
        visitWriteKeyExpr(expr, ctx) {
            const lineWasEmpty = ctx.lineIsEmpty();
            if (!lineWasEmpty) {
                ctx.print(expr, '(');
            }
            expr.receiver.visitExpression(this, ctx);
            ctx.print(expr, `[`);
            expr.index.visitExpression(this, ctx);
            ctx.print(expr, `] = `);
            expr.value.visitExpression(this, ctx);
            if (!lineWasEmpty) {
                ctx.print(expr, ')');
            }
            return null;
        }
        visitWritePropExpr(expr, ctx) {
            const lineWasEmpty = ctx.lineIsEmpty();
            if (!lineWasEmpty) {
                ctx.print(expr, '(');
            }
            expr.receiver.visitExpression(this, ctx);
            ctx.print(expr, `.${expr.name} = `);
            expr.value.visitExpression(this, ctx);
            if (!lineWasEmpty) {
                ctx.print(expr, ')');
            }
            return null;
        }
        visitInvokeMethodExpr(expr, ctx) {
            expr.receiver.visitExpression(this, ctx);
            let name = expr.name;
            if (expr.builtin != null) {
                name = this.getBuiltinMethodName(expr.builtin);
                if (name == null) {
                    // some builtins just mean to skip the call.
                    return null;
                }
            }
            ctx.print(expr, `.${name}(`);
            this.visitAllExpressions(expr.args, ctx, `,`);
            ctx.print(expr, `)`);
            return null;
        }
        visitInvokeFunctionExpr(expr, ctx) {
            expr.fn.visitExpression(this, ctx);
            ctx.print(expr, `(`);
            this.visitAllExpressions(expr.args, ctx, ',');
            ctx.print(expr, `)`);
            return null;
        }
        visitTaggedTemplateExpr(expr, ctx) {
            expr.tag.visitExpression(this, ctx);
            ctx.print(expr, '`' + expr.template.elements[0].rawText);
            for (let i = 1; i < expr.template.elements.length; i++) {
                ctx.print(expr, '${');
                expr.template.expressions[i - 1].visitExpression(this, ctx);
                ctx.print(expr, `}${expr.template.elements[i].rawText}`);
            }
            ctx.print(expr, '`');
            return null;
        }
        visitWrappedNodeExpr(ast, ctx) {
            throw new Error('Abstract emitter cannot visit WrappedNodeExpr.');
        }
        visitTypeofExpr(expr, ctx) {
            ctx.print(expr, 'typeof ');
            expr.expr.visitExpression(this, ctx);
        }
        visitReadVarExpr(ast, ctx) {
            let varName = ast.name;
            if (ast.builtin != null) {
                switch (ast.builtin) {
                    case BuiltinVar.Super:
                        varName = 'super';
                        break;
                    case BuiltinVar.This:
                        varName = 'this';
                        break;
                    case BuiltinVar.CatchError:
                        varName = CATCH_ERROR_VAR$1.name;
                        break;
                    case BuiltinVar.CatchStack:
                        varName = CATCH_STACK_VAR$1.name;
                        break;
                    default:
                        throw new Error(`Unknown builtin variable ${ast.builtin}`);
                }
            }
            ctx.print(ast, varName);
            return null;
        }
        visitInstantiateExpr(ast, ctx) {
            ctx.print(ast, `new `);
            ast.classExpr.visitExpression(this, ctx);
            ctx.print(ast, `(`);
            this.visitAllExpressions(ast.args, ctx, ',');
            ctx.print(ast, `)`);
            return null;
        }
        visitLiteralExpr(ast, ctx) {
            const value = ast.value;
            if (typeof value === 'string') {
                ctx.print(ast, escapeIdentifier(value, this._escapeDollarInStrings));
            }
            else {
                ctx.print(ast, `${value}`);
            }
            return null;
        }
        visitLocalizedString(ast, ctx) {
            const head = ast.serializeI18nHead();
            ctx.print(ast, '$localize `' + head.raw);
            for (let i = 1; i < ast.messageParts.length; i++) {
                ctx.print(ast, '${');
                ast.expressions[i - 1].visitExpression(this, ctx);
                ctx.print(ast, `}${ast.serializeI18nTemplatePart(i).raw}`);
            }
            ctx.print(ast, '`');
            return null;
        }
        visitConditionalExpr(ast, ctx) {
            ctx.print(ast, `(`);
            ast.condition.visitExpression(this, ctx);
            ctx.print(ast, '? ');
            ast.trueCase.visitExpression(this, ctx);
            ctx.print(ast, ': ');
            ast.falseCase.visitExpression(this, ctx);
            ctx.print(ast, `)`);
            return null;
        }
        visitNotExpr(ast, ctx) {
            ctx.print(ast, '!');
            ast.condition.visitExpression(this, ctx);
            return null;
        }
        visitAssertNotNullExpr(ast, ctx) {
            ast.condition.visitExpression(this, ctx);
            return null;
        }
        visitUnaryOperatorExpr(ast, ctx) {
            let opStr;
            switch (ast.operator) {
                case UnaryOperator.Plus:
                    opStr = '+';
                    break;
                case UnaryOperator.Minus:
                    opStr = '-';
                    break;
                default:
                    throw new Error(`Unknown operator ${ast.operator}`);
            }
            if (ast.parens)
                ctx.print(ast, `(`);
            ctx.print(ast, opStr);
            ast.expr.visitExpression(this, ctx);
            if (ast.parens)
                ctx.print(ast, `)`);
            return null;
        }
        visitBinaryOperatorExpr(ast, ctx) {
            let opStr;
            switch (ast.operator) {
                case BinaryOperator.Equals:
                    opStr = '==';
                    break;
                case BinaryOperator.Identical:
                    opStr = '===';
                    break;
                case BinaryOperator.NotEquals:
                    opStr = '!=';
                    break;
                case BinaryOperator.NotIdentical:
                    opStr = '!==';
                    break;
                case BinaryOperator.And:
                    opStr = '&&';
                    break;
                case BinaryOperator.BitwiseAnd:
                    opStr = '&';
                    break;
                case BinaryOperator.Or:
                    opStr = '||';
                    break;
                case BinaryOperator.Plus:
                    opStr = '+';
                    break;
                case BinaryOperator.Minus:
                    opStr = '-';
                    break;
                case BinaryOperator.Divide:
                    opStr = '/';
                    break;
                case BinaryOperator.Multiply:
                    opStr = '*';
                    break;
                case BinaryOperator.Modulo:
                    opStr = '%';
                    break;
                case BinaryOperator.Lower:
                    opStr = '<';
                    break;
                case BinaryOperator.LowerEquals:
                    opStr = '<=';
                    break;
                case BinaryOperator.Bigger:
                    opStr = '>';
                    break;
                case BinaryOperator.BiggerEquals:
                    opStr = '>=';
                    break;
                case BinaryOperator.NullishCoalesce:
                    opStr = '??';
                    break;
                default:
                    throw new Error(`Unknown operator ${ast.operator}`);
            }
            if (ast.parens)
                ctx.print(ast, `(`);
            ast.lhs.visitExpression(this, ctx);
            ctx.print(ast, ` ${opStr} `);
            ast.rhs.visitExpression(this, ctx);
            if (ast.parens)
                ctx.print(ast, `)`);
            return null;
        }
        visitReadPropExpr(ast, ctx) {
            ast.receiver.visitExpression(this, ctx);
            ctx.print(ast, `.`);
            ctx.print(ast, ast.name);
            return null;
        }
        visitReadKeyExpr(ast, ctx) {
            ast.receiver.visitExpression(this, ctx);
            ctx.print(ast, `[`);
            ast.index.visitExpression(this, ctx);
            ctx.print(ast, `]`);
            return null;
        }
        visitLiteralArrayExpr(ast, ctx) {
            ctx.print(ast, `[`);
            this.visitAllExpressions(ast.entries, ctx, ',');
            ctx.print(ast, `]`);
            return null;
        }
        visitLiteralMapExpr(ast, ctx) {
            ctx.print(ast, `{`);
            this.visitAllObjects(entry => {
                ctx.print(ast, `${escapeIdentifier(entry.key, this._escapeDollarInStrings, entry.quoted)}:`);
                entry.value.visitExpression(this, ctx);
            }, ast.entries, ctx, ',');
            ctx.print(ast, `}`);
            return null;
        }
        visitCommaExpr(ast, ctx) {
            ctx.print(ast, '(');
            this.visitAllExpressions(ast.parts, ctx, ',');
            ctx.print(ast, ')');
            return null;
        }
        visitAllExpressions(expressions, ctx, separator) {
            this.visitAllObjects(expr => expr.visitExpression(this, ctx), expressions, ctx, separator);
        }
        visitAllObjects(handler, expressions, ctx, separator) {
            let incrementedIndent = false;
            for (let i = 0; i < expressions.length; i++) {
                if (i > 0) {
                    if (ctx.lineLength() > 80) {
                        ctx.print(null, separator, true);
                        if (!incrementedIndent) {
                            // continuation are marked with double indent.
                            ctx.incIndent();
                            ctx.incIndent();
                            incrementedIndent = true;
                        }
                    }
                    else {
                        ctx.print(null, separator, false);
                    }
                }
                handler(expressions[i]);
            }
            if (incrementedIndent) {
                // continuation are marked with double indent.
                ctx.decIndent();
                ctx.decIndent();
            }
        }
        visitAllStatements(statements, ctx) {
            statements.forEach((stmt) => stmt.visitStatement(this, ctx));
        }
    }
    function escapeIdentifier(input, escapeDollar, alwaysQuote = true) {
        if (input == null) {
            return null;
        }
        const body = input.replace(_SINGLE_QUOTE_ESCAPE_STRING_RE, (...match) => {
            if (match[0] == '$') {
                return escapeDollar ? '\\$' : '$';
            }
            else if (match[0] == '\n') {
                return '\\n';
            }
            else if (match[0] == '\r') {
                return '\\r';
            }
            else {
                return `\\${match[0]}`;
            }
        });
        const requiresQuotes = alwaysQuote || !_LEGAL_IDENTIFIER_RE.test(body);
        return requiresQuotes ? `'${body}'` : body;
    }
    function _createIndent(count) {
        let res = '';
        for (let i = 0; i < count; i++) {
            res += _INDENT_WITH;
        }
        return res;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function typeWithParameters(type, numParams) {
        if (numParams === 0) {
            return expressionType(type);
        }
        const params = [];
        for (let i = 0; i < numParams; i++) {
            params.push(DYNAMIC_TYPE);
        }
        return expressionType(type, undefined, params);
    }
    const ANIMATE_SYMBOL_PREFIX = '@';
    function prepareSyntheticPropertyName(name) {
        return `${ANIMATE_SYMBOL_PREFIX}${name}`;
    }
    function prepareSyntheticListenerName(name, phase) {
        return `${ANIMATE_SYMBOL_PREFIX}${name}.${phase}`;
    }
    function getSafePropertyAccessString(accessor, name) {
        const escapedName = escapeIdentifier(name, false, false);
        return escapedName !== name ? `${accessor}[${escapedName}]` : `${accessor}.${name}`;
    }
    function prepareSyntheticListenerFunctionName(name, phase) {
        return `animation_${name}_${phase}`;
    }
    function jitOnlyGuardedExpression(expr) {
        return guardedExpression('ngJitMode', expr);
    }
    function devOnlyGuardedExpression(expr) {
        return guardedExpression('ngDevMode', expr);
    }
    function guardedExpression(guard, expr) {
        const guardExpr = new ExternalExpr({ name: guard, moduleName: null });
        const guardNotDefined = new BinaryOperatorExpr(BinaryOperator.Identical, new TypeofExpr(guardExpr), literal('undefined'));
        const guardUndefinedOrTrue = new BinaryOperatorExpr(BinaryOperator.Or, guardNotDefined, guardExpr, /* type */ undefined, 
        /* sourceSpan */ undefined, true);
        return new BinaryOperatorExpr(BinaryOperator.And, guardUndefinedOrTrue, expr);
    }
    function wrapReference(value) {
        const wrapped = new WrappedNodeExpr(value);
        return { value: wrapped, type: wrapped };
    }
    function refsToArray(refs, shouldForwardDeclare) {
        const values = literalArr(refs.map(ref => ref.value));
        return shouldForwardDeclare ? fn([], [new ReturnStatement(values)]) : values;
    }

    var R3FactoryDelegateType;
    (function (R3FactoryDelegateType) {
        R3FactoryDelegateType[R3FactoryDelegateType["Class"] = 0] = "Class";
        R3FactoryDelegateType[R3FactoryDelegateType["Function"] = 1] = "Function";
    })(R3FactoryDelegateType || (R3FactoryDelegateType = {}));
    var FactoryTarget;
    (function (FactoryTarget) {
        FactoryTarget[FactoryTarget["Directive"] = 0] = "Directive";
        FactoryTarget[FactoryTarget["Component"] = 1] = "Component";
        FactoryTarget[FactoryTarget["Injectable"] = 2] = "Injectable";
        FactoryTarget[FactoryTarget["Pipe"] = 3] = "Pipe";
        FactoryTarget[FactoryTarget["NgModule"] = 4] = "NgModule";
    })(FactoryTarget || (FactoryTarget = {}));
    /**
     * Construct a factory function expression for the given `R3FactoryMetadata`.
     */
    function compileFactoryFunction(meta) {
        const t = variable('t');
        let baseFactoryVar = null;
        // The type to instantiate via constructor invocation. If there is no delegated factory, meaning
        // this type is always created by constructor invocation, then this is the type-to-create
        // parameter provided by the user (t) if specified, or the current type if not. If there is a
        // delegated factory (which is used to create the current type) then this is only the type-to-
        // create parameter (t).
        const typeForCtor = !isDelegatedFactoryMetadata(meta) ?
            new BinaryOperatorExpr(BinaryOperator.Or, t, meta.internalType) :
            t;
        let ctorExpr = null;
        if (meta.deps !== null) {
            // There is a constructor (either explicitly or implicitly defined).
            if (meta.deps !== 'invalid') {
                ctorExpr = new InstantiateExpr(typeForCtor, injectDependencies(meta.deps, meta.target));
            }
        }
        else {
            // There is no constructor, use the base class' factory to construct typeForCtor.
            baseFactoryVar = variable(`${meta.name}_BaseFactory`);
            ctorExpr = baseFactoryVar.callFn([typeForCtor]);
        }
        const body = [];
        let retExpr = null;
        function makeConditionalFactory(nonCtorExpr) {
            const r = variable('r');
            body.push(r.set(NULL_EXPR).toDeclStmt());
            const ctorStmt = ctorExpr !== null ? r.set(ctorExpr).toStmt() :
                importExpr(Identifiers.invalidFactory).callFn([]).toStmt();
            body.push(ifStmt(t, [ctorStmt], [r.set(nonCtorExpr).toStmt()]));
            return r;
        }
        if (isDelegatedFactoryMetadata(meta)) {
            // This type is created with a delegated factory. If a type parameter is not specified, call
            // the factory instead.
            const delegateArgs = injectDependencies(meta.delegateDeps, meta.target);
            // Either call `new delegate(...)` or `delegate(...)` depending on meta.delegateType.
            const factoryExpr = new (meta.delegateType === R3FactoryDelegateType.Class ?
                InstantiateExpr :
                InvokeFunctionExpr)(meta.delegate, delegateArgs);
            retExpr = makeConditionalFactory(factoryExpr);
        }
        else if (isExpressionFactoryMetadata(meta)) {
            // TODO(alxhub): decide whether to lower the value here or in the caller
            retExpr = makeConditionalFactory(meta.expression);
        }
        else {
            retExpr = ctorExpr;
        }
        if (retExpr === null) {
            // The expression cannot be formed so render an `invalidFactory()` call.
            body.push(importExpr(Identifiers.invalidFactory).callFn([]).toStmt());
        }
        else if (baseFactoryVar !== null) {
            // This factory uses a base factory, so call `getInheritedFactory()` to compute it.
            const getInheritedFactoryCall = importExpr(Identifiers.getInheritedFactory).callFn([meta.internalType]);
            // Memoize the base factoryFn: `baseFactory || (baseFactory = getInheritedFactory(...))`
            const baseFactory = new BinaryOperatorExpr(BinaryOperator.Or, baseFactoryVar, baseFactoryVar.set(getInheritedFactoryCall));
            body.push(new ReturnStatement(baseFactory.callFn([typeForCtor])));
        }
        else {
            // This is straightforward factory, just return it.
            body.push(new ReturnStatement(retExpr));
        }
        let factoryFn = fn([new FnParam('t', DYNAMIC_TYPE)], body, INFERRED_TYPE, undefined, `${meta.name}_Factory`);
        if (baseFactoryVar !== null) {
            // There is a base factory variable so wrap its declaration along with the factory function into
            // an IIFE.
            factoryFn = fn([], [
                new DeclareVarStmt(baseFactoryVar.name), new ReturnStatement(factoryFn)
            ]).callFn([], /* sourceSpan */ undefined, /* pure */ true);
        }
        return {
            expression: factoryFn,
            statements: [],
            type: createFactoryType(meta),
        };
    }
    function createFactoryType(meta) {
        const ctorDepsType = meta.deps !== null && meta.deps !== 'invalid' ? createCtorDepsType(meta.deps) : NONE_TYPE;
        return expressionType(importExpr(Identifiers.FactoryDeclaration, [typeWithParameters(meta.type.type, meta.typeArgumentCount), ctorDepsType]));
    }
    function injectDependencies(deps, target) {
        return deps.map((dep, index) => compileInjectDependency(dep, target, index));
    }
    function compileInjectDependency(dep, target, index) {
        // Interpret the dependency according to its resolved type.
        if (dep.token === null) {
            return importExpr(Identifiers.invalidFactoryDep).callFn([literal(index)]);
        }
        else if (dep.attributeNameType === null) {
            // Build up the injection flags according to the metadata.
            const flags = 0 /* Default */ | (dep.self ? 2 /* Self */ : 0) |
                (dep.skipSelf ? 4 /* SkipSelf */ : 0) | (dep.host ? 1 /* Host */ : 0) |
                (dep.optional ? 8 /* Optional */ : 0) |
                (target === FactoryTarget.Pipe ? 16 /* ForPipe */ : 0);
            // If this dependency is optional or otherwise has non-default flags, then additional
            // parameters describing how to inject the dependency must be passed to the inject function
            // that's being used.
            let flagsParam = (flags !== 0 /* Default */ || dep.optional) ? literal(flags) : null;
            // Build up the arguments to the injectFn call.
            const injectArgs = [dep.token];
            if (flagsParam) {
                injectArgs.push(flagsParam);
            }
            const injectFn = getInjectFn(target);
            return importExpr(injectFn).callFn(injectArgs);
        }
        else {
            // The `dep.attributeTypeName` value is defined, which indicates that this is an `@Attribute()`
            // type dependency. For the generated JS we still want to use the `dep.token` value in case the
            // name given for the attribute is not a string literal. For example given `@Attribute(foo())`,
            // we want to generate `injectAttribute(foo())`.
            //
            // The `dep.attributeTypeName` is only actually used (in `createCtorDepType()`) to generate
            // typings.
            return importExpr(Identifiers.injectAttribute).callFn([dep.token]);
        }
    }
    function createCtorDepsType(deps) {
        let hasTypes = false;
        const attributeTypes = deps.map(dep => {
            const type = createCtorDepType(dep);
            if (type !== null) {
                hasTypes = true;
                return type;
            }
            else {
                return literal(null);
            }
        });
        if (hasTypes) {
            return expressionType(literalArr(attributeTypes));
        }
        else {
            return NONE_TYPE;
        }
    }
    function createCtorDepType(dep) {
        const entries = [];
        if (dep.attributeNameType !== null) {
            entries.push({ key: 'attribute', value: dep.attributeNameType, quoted: false });
        }
        if (dep.optional) {
            entries.push({ key: 'optional', value: literal(true), quoted: false });
        }
        if (dep.host) {
            entries.push({ key: 'host', value: literal(true), quoted: false });
        }
        if (dep.self) {
            entries.push({ key: 'self', value: literal(true), quoted: false });
        }
        if (dep.skipSelf) {
            entries.push({ key: 'skipSelf', value: literal(true), quoted: false });
        }
        return entries.length > 0 ? literalMap(entries) : null;
    }
    function isDelegatedFactoryMetadata(meta) {
        return meta.delegateType !== undefined;
    }
    function isExpressionFactoryMetadata(meta) {
        return meta.expression !== undefined;
    }
    function getInjectFn(target) {
        switch (target) {
            case FactoryTarget.Component:
            case FactoryTarget.Directive:
            case FactoryTarget.Pipe:
                return Identifiers.directiveInject;
            case FactoryTarget.NgModule:
            case FactoryTarget.Injectable:
            default:
                return Identifiers.inject;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function createR3ProviderExpression(expression, isForwardRef) {
        return { expression, isForwardRef };
    }
    function compileInjectable(meta, resolveForwardRefs) {
        let result = null;
        const factoryMeta = {
            name: meta.name,
            type: meta.type,
            internalType: meta.internalType,
            typeArgumentCount: meta.typeArgumentCount,
            deps: [],
            target: FactoryTarget.Injectable,
        };
        if (meta.useClass !== undefined) {
            // meta.useClass has two modes of operation. Either deps are specified, in which case `new` is
            // used to instantiate the class with dependencies injected, or deps are not specified and
            // the factory of the class is used to instantiate it.
            //
            // A special case exists for useClass: Type where Type is the injectable type itself and no
            // deps are specified, in which case 'useClass' is effectively ignored.
            const useClassOnSelf = meta.useClass.expression.isEquivalent(meta.internalType);
            let deps = undefined;
            if (meta.deps !== undefined) {
                deps = meta.deps;
            }
            if (deps !== undefined) {
                // factory: () => new meta.useClass(...deps)
                result = compileFactoryFunction(Object.assign(Object.assign({}, factoryMeta), { delegate: meta.useClass.expression, delegateDeps: deps, delegateType: R3FactoryDelegateType.Class }));
            }
            else if (useClassOnSelf) {
                result = compileFactoryFunction(factoryMeta);
            }
            else {
                result = {
                    statements: [],
                    expression: delegateToFactory(meta.type.value, meta.useClass.expression, resolveForwardRefs)
                };
            }
        }
        else if (meta.useFactory !== undefined) {
            if (meta.deps !== undefined) {
                result = compileFactoryFunction(Object.assign(Object.assign({}, factoryMeta), { delegate: meta.useFactory, delegateDeps: meta.deps || [], delegateType: R3FactoryDelegateType.Function }));
            }
            else {
                result = {
                    statements: [],
                    expression: fn([], [new ReturnStatement(meta.useFactory.callFn([]))])
                };
            }
        }
        else if (meta.useValue !== undefined) {
            // Note: it's safe to use `meta.useValue` instead of the `USE_VALUE in meta` check used for
            // client code because meta.useValue is an Expression which will be defined even if the actual
            // value is undefined.
            result = compileFactoryFunction(Object.assign(Object.assign({}, factoryMeta), { expression: meta.useValue.expression }));
        }
        else if (meta.useExisting !== undefined) {
            // useExisting is an `inject` call on the existing token.
            result = compileFactoryFunction(Object.assign(Object.assign({}, factoryMeta), { expression: importExpr(Identifiers.inject).callFn([meta.useExisting.expression]) }));
        }
        else {
            result = {
                statements: [],
                expression: delegateToFactory(meta.type.value, meta.internalType, resolveForwardRefs)
            };
        }
        const token = meta.internalType;
        const injectableProps = new DefinitionMap();
        injectableProps.set('token', token);
        injectableProps.set('factory', result.expression);
        // Only generate providedIn property if it has a non-null value
        if (meta.providedIn.expression.value !== null) {
            injectableProps.set('providedIn', meta.providedIn.isForwardRef ? generateForwardRef(meta.providedIn.expression) :
                meta.providedIn.expression);
        }
        const expression = importExpr(Identifiers.defineInjectable)
            .callFn([injectableProps.toLiteralMap()], undefined, true);
        return {
            expression,
            type: createInjectableType(meta),
            statements: result.statements,
        };
    }
    function createInjectableType(meta) {
        return new ExpressionType(importExpr(Identifiers.InjectableDeclaration, [typeWithParameters(meta.type.type, meta.typeArgumentCount)]));
    }
    function delegateToFactory(type, internalType, unwrapForwardRefs) {
        if (type.node === internalType.node) {
            // The types are the same, so we can simply delegate directly to the type's factory.
            // ```
            // factory: type.fac
            // ```
            return internalType.prop('fac');
        }
        if (!unwrapForwardRefs) {
            // The type is not wrapped in a `forwardRef()`, so we create a simple factory function that
            // accepts a sub-type as an argument.
            // ```
            // factory: function(t) { return internalType.fac(t); }
            // ```
            return createFactoryFunction(internalType);
        }
        // The internalType is actually wrapped in a `forwardRef()` so we need to resolve that before
        // calling its factory.
        // ```
        // factory: function(t) { return core.resolveForwardRef(type).fac(t); }
        // ```
        const unwrappedType = importExpr(Identifiers.resolveForwardRef).callFn([internalType]);
        return createFactoryFunction(unwrappedType);
    }
    function createFactoryFunction(type) {
        return fn([new FnParam('t', DYNAMIC_TYPE)], [new ReturnStatement(type.callMethod('fac', [variable('t')]))]);
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const UNUSABLE_INTERPOLATION_REGEXPS = [
        /^\s*$/,
        /[<>]/,
        /^[{}]$/,
        /&(#|[a-z])/i,
        /^\/\//, // comment
    ];
    function assertInterpolationSymbols(identifier, value) {
        if (value != null && !(Array.isArray(value) && value.length == 2)) {
            throw new Error(`Expected '${identifier}' to be an array, [start, end].`);
        }
        else if (value != null) {
            const start = value[0];
            const end = value[1];
            // Check for unusable interpolation symbols
            UNUSABLE_INTERPOLATION_REGEXPS.forEach(regexp => {
                if (regexp.test(start) || regexp.test(end)) {
                    throw new Error(`['${start}', '${end}'] contains unusable interpolation symbol.`);
                }
            });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class InterpolationConfig {
        constructor(start, end) {
            this.start = start;
            this.end = end;
        }
        static fromArray(markers) {
            if (!markers) {
                return DEFAULT_INTERPOLATION_CONFIG;
            }
            assertInterpolationSymbols('interpolation', markers);
            return new InterpolationConfig(markers[0], markers[1]);
        }
    }
    const DEFAULT_INTERPOLATION_CONFIG = new InterpolationConfig('{{', '}}');

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A token representing the a reference to a static type.
     *
     * This token is unique for a filePath and name and can be used as a hash table key.
     */
    class StaticSymbol {
        constructor(filePath, name, members) {
            this.filePath = filePath;
            this.name = name;
            this.members = members;
        }
        assertNoMembers() {
            if (this.members.length) {
                throw new Error(`Illegal state: symbol without members expected, but got ${JSON.stringify(this)}.`);
            }
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const $EOF = 0;
    const $BSPACE = 8;
    const $TAB = 9;
    const $LF = 10;
    const $VTAB = 11;
    const $FF = 12;
    const $CR = 13;
    const $SPACE = 32;
    const $BANG = 33;
    const $DQ = 34;
    const $HASH = 35;
    const $$ = 36;
    const $PERCENT = 37;
    const $AMPERSAND = 38;
    const $SQ = 39;
    const $LPAREN = 40;
    const $RPAREN = 41;
    const $STAR = 42;
    const $PLUS = 43;
    const $COMMA = 44;
    const $MINUS = 45;
    const $PERIOD = 46;
    const $SLASH = 47;
    const $COLON = 58;
    const $SEMICOLON = 59;
    const $LT = 60;
    const $EQ = 61;
    const $GT = 62;
    const $QUESTION = 63;
    const $0 = 48;
    const $7 = 55;
    const $9 = 57;
    const $A = 65;
    const $E = 69;
    const $F = 70;
    const $X = 88;
    const $Z = 90;
    const $LBRACKET = 91;
    const $BACKSLASH = 92;
    const $RBRACKET = 93;
    const $CARET = 94;
    const $_ = 95;
    const $a = 97;
    const $b = 98;
    const $e = 101;
    const $f = 102;
    const $n = 110;
    const $r = 114;
    const $t = 116;
    const $u = 117;
    const $v = 118;
    const $x = 120;
    const $z = 122;
    const $LBRACE = 123;
    const $BAR = 124;
    const $RBRACE = 125;
    const $NBSP = 160;
    const $BT = 96;
    function isWhitespace(code) {
        return (code >= $TAB && code <= $SPACE) || (code == $NBSP);
    }
    function isDigit(code) {
        return $0 <= code && code <= $9;
    }
    function isAsciiLetter(code) {
        return code >= $a && code <= $z || code >= $A && code <= $Z;
    }
    function isAsciiHexDigit(code) {
        return code >= $a && code <= $f || code >= $A && code <= $F || isDigit(code);
    }
    function isNewLine(code) {
        return code === $LF || code === $CR;
    }
    function isOctalDigit(code) {
        return $0 <= code && code <= $7;
    }
    function isQuote(code) {
        return code === $SQ || code === $DQ || code === $BT;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class ParseLocation {
        constructor(file, offset, line, col) {
            this.file = file;
            this.offset = offset;
            this.line = line;
            this.col = col;
        }
        toString() {
            return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;
        }
        moveBy(delta) {
            const source = this.file.content;
            const len = source.length;
            let offset = this.offset;
            let line = this.line;
            let col = this.col;
            while (offset > 0 && delta < 0) {
                offset--;
                delta++;
                const ch = source.charCodeAt(offset);
                if (ch == $LF) {
                    line--;
                    const priorLine = source.substr(0, offset - 1).lastIndexOf(String.fromCharCode($LF));
                    col = priorLine > 0 ? offset - priorLine : offset;
                }
                else {
                    col--;
                }
            }
            while (offset < len && delta > 0) {
                const ch = source.charCodeAt(offset);
                offset++;
                delta--;
                if (ch == $LF) {
                    line++;
                    col = 0;
                }
                else {
                    col++;
                }
            }
            return new ParseLocation(this.file, offset, line, col);
        }
        // Return the source around the location
        // Up to `maxChars` or `maxLines` on each side of the location
        getContext(maxChars, maxLines) {
            const content = this.file.content;
            let startOffset = this.offset;
            if (startOffset != null) {
                if (startOffset > content.length - 1) {
                    startOffset = content.length - 1;
                }
                let endOffset = startOffset;
                let ctxChars = 0;
                let ctxLines = 0;
                while (ctxChars < maxChars && startOffset > 0) {
                    startOffset--;
                    ctxChars++;
                    if (content[startOffset] == '\n') {
                        if (++ctxLines == maxLines) {
                            break;
                        }
                    }
                }
                ctxChars = 0;
                ctxLines = 0;
                while (ctxChars < maxChars && endOffset < content.length - 1) {
                    endOffset++;
                    ctxChars++;
                    if (content[endOffset] == '\n') {
                        if (++ctxLines == maxLines) {
                            break;
                        }
                    }
                }
                return {
                    before: content.substring(startOffset, this.offset),
                    after: content.substring(this.offset, endOffset + 1),
                };
            }
            return null;
        }
    }
    class ParseSourceFile {
        constructor(content, url) {
            this.content = content;
            this.url = url;
        }
    }
    class ParseSourceSpan {
        /**
         * Create an object that holds information about spans of tokens/nodes captured during
         * lexing/parsing of text.
         *
         * @param start
         * The location of the start of the span (having skipped leading trivia).
         * Skipping leading trivia makes source-spans more "user friendly", since things like HTML
         * elements will appear to begin at the start of the opening tag, rather than at the start of any
         * leading trivia, which could include newlines.
         *
         * @param end
         * The location of the end of the span.
         *
         * @param fullStart
         * The start of the token without skipping the leading trivia.
         * This is used by tooling that splits tokens further, such as extracting Angular interpolations
         * from text tokens. Such tooling creates new source-spans relative to the original token's
         * source-span. If leading trivia characters have been skipped then the new source-spans may be
         * incorrectly offset.
         *
         * @param details
         * Additional information (such as identifier names) that should be associated with the span.
         */
        constructor(start, end, fullStart = start, details = null) {
            this.start = start;
            this.end = end;
            this.fullStart = fullStart;
            this.details = details;
        }
        toString() {
            return this.start.file.content.substring(this.start.offset, this.end.offset);
        }
    }
    var ParseErrorLevel;
    (function (ParseErrorLevel) {
        ParseErrorLevel[ParseErrorLevel["WARNING"] = 0] = "WARNING";
        ParseErrorLevel[ParseErrorLevel["ERROR"] = 1] = "ERROR";
    })(ParseErrorLevel || (ParseErrorLevel = {}));
    class ParseError {
        constructor(span, msg, level = ParseErrorLevel.ERROR) {
            this.span = span;
            this.msg = msg;
            this.level = level;
        }
        contextualMessage() {
            const ctx = this.span.start.getContext(100, 3);
            return ctx ? `${this.msg} ("${ctx.before}[${ParseErrorLevel[this.level]} ->]${ctx.after}")` :
                this.msg;
        }
        toString() {
            const details = this.span.details ? `, ${this.span.details}` : '';
            return `${this.contextualMessage()}: ${this.span.start}${details}`;
        }
    }
    /**
     * Generates Source Span object for a given R3 Type for JIT mode.
     *
     * @param kind Component or Directive.
     * @param typeName name of the Component or Directive.
     * @param sourceUrl reference to Component or Directive source.
     * @returns instance of ParseSourceSpan that represent a given Component or Directive.
     */
    function r3JitTypeSourceSpan(kind, typeName, sourceUrl) {
        const sourceFileName = `in ${kind} ${typeName} in ${sourceUrl}`;
        const sourceFile = new ParseSourceFile('', sourceFileName);
        return new ParseSourceSpan(new ParseLocation(sourceFile, -1, -1, -1), new ParseLocation(sourceFile, -1, -1, -1));
    }
    let _anonymousTypeIndex = 0;
    function identifierName(compileIdentifier) {
        if (!compileIdentifier || !compileIdentifier.reference) {
            return null;
        }
        const ref = compileIdentifier.reference;
        if (ref instanceof StaticSymbol) {
            return ref.name;
        }
        if (ref['__anonymousType']) {
            return ref['__anonymousType'];
        }
        if (ref['__forward_ref__']) {
            // We do not want to try to stringify a `forwardRef()` function because that would cause the
            // inner function to be evaluated too early, defeating the whole point of the `forwardRef`.
            return '__forward_ref__';
        }
        let identifier = stringify(ref);
        if (identifier.indexOf('(') >= 0) {
            // case: anonymous functions!
            identifier = `anonymous_${_anonymousTypeIndex++}`;
            ref['__anonymousType'] = identifier;
        }
        else {
            identifier = sanitizeIdentifier(identifier);
        }
        return identifier;
    }
    function sanitizeIdentifier(name) {
        return name.replace(/\W/g, '_');
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * In TypeScript, tagged template functions expect a "template object", which is an array of
     * "cooked" strings plus a `raw` property that contains an array of "raw" strings. This is
     * typically constructed with a function called `__makeTemplateObject(cooked, raw)`, but it may not
     * be available in all environments.
     *
     * This is a JavaScript polyfill that uses __makeTemplateObject when it's available, but otherwise
     * creates an inline helper with the same functionality.
     *
     * In the inline function, if `Object.defineProperty` is available we use that to attach the `raw`
     * array.
     */
    const makeTemplateObjectPolyfill = '(this&&this.__makeTemplateObject||function(e,t){return Object.defineProperty?Object.defineProperty(e,"raw",{value:t}):e.raw=t,e})';
    class AbstractJsEmitterVisitor extends AbstractEmitterVisitor {
        constructor() {
            super(false);
        }
        visitDeclareClassStmt(stmt, ctx) {
            ctx.pushClass(stmt);
            this._visitClassConstructor(stmt, ctx);
            if (stmt.parent != null) {
                ctx.print(stmt, `${stmt.name}.prototype = Object.create(`);
                stmt.parent.visitExpression(this, ctx);
                ctx.println(stmt, `.prototype);`);
            }
            stmt.getters.forEach((getter) => this._visitClassGetter(stmt, getter, ctx));
            stmt.methods.forEach((method) => this._visitClassMethod(stmt, method, ctx));
            ctx.popClass();
            return null;
        }
        _visitClassConstructor(stmt, ctx) {
            ctx.print(stmt, `function ${stmt.name}(`);
            if (stmt.constructorMethod != null) {
                this._visitParams(stmt.constructorMethod.params, ctx);
            }
            ctx.println(stmt, `) {`);
            ctx.incIndent();
            if (stmt.constructorMethod != null) {
                if (stmt.constructorMethod.body.length > 0) {
                    ctx.println(stmt, `var self = this;`);
                    this.visitAllStatements(stmt.constructorMethod.body, ctx);
                }
            }
            ctx.decIndent();
            ctx.println(stmt, `}`);
        }
        _visitClassGetter(stmt, getter, ctx) {
            ctx.println(stmt, `Object.defineProperty(${stmt.name}.prototype, '${getter.name}', { get: function() {`);
            ctx.incIndent();
            if (getter.body.length > 0) {
                ctx.println(stmt, `var self = this;`);
                this.visitAllStatements(getter.body, ctx);
            }
            ctx.decIndent();
            ctx.println(stmt, `}});`);
        }
        _visitClassMethod(stmt, method, ctx) {
            ctx.print(stmt, `${stmt.name}.prototype.${method.name} = function(`);
            this._visitParams(method.params, ctx);
            ctx.println(stmt, `) {`);
            ctx.incIndent();
            if (method.body.length > 0) {
                ctx.println(stmt, `var self = this;`);
                this.visitAllStatements(method.body, ctx);
            }
            ctx.decIndent();
            ctx.println(stmt, `};`);
        }
        visitWrappedNodeExpr(ast, ctx) {
            throw new Error('Cannot emit a WrappedNodeExpr in Javascript.');
        }
        visitReadVarExpr(ast, ctx) {
            if (ast.builtin === BuiltinVar.This) {
                ctx.print(ast, 'self');
            }
            else if (ast.builtin === BuiltinVar.Super) {
                throw new Error(`'super' needs to be handled at a parent ast node, not at the variable level!`);
            }
            else {
                super.visitReadVarExpr(ast, ctx);
            }
            return null;
        }
        visitDeclareVarStmt(stmt, ctx) {
            ctx.print(stmt, `var ${stmt.name}`);
            if (stmt.value) {
                ctx.print(stmt, ' = ');
                stmt.value.visitExpression(this, ctx);
            }
            ctx.println(stmt, `;`);
            return null;
        }
        visitCastExpr(ast, ctx) {
            ast.value.visitExpression(this, ctx);
            return null;
        }
        visitInvokeFunctionExpr(expr, ctx) {
            const fnExpr = expr.fn;
            if (fnExpr instanceof ReadVarExpr && fnExpr.builtin === BuiltinVar.Super) {
                ctx.currentClass.parent.visitExpression(this, ctx);
                ctx.print(expr, `.call(this`);
                if (expr.args.length > 0) {
                    ctx.print(expr, `, `);
                    this.visitAllExpressions(expr.args, ctx, ',');
                }
                ctx.print(expr, `)`);
            }
            else {
                super.visitInvokeFunctionExpr(expr, ctx);
            }
            return null;
        }
        visitTaggedTemplateExpr(ast, ctx) {
            // The following convoluted piece of code is effectively the downlevelled equivalent of
            // ```
            // tag`...`
            // ```
            // which is effectively like:
            // ```
            // tag(__makeTemplateObject(cooked, raw), expression1, expression2, ...);
            // ```
            const elements = ast.template.elements;
            ast.tag.visitExpression(this, ctx);
            ctx.print(ast, `(${makeTemplateObjectPolyfill}(`);
            ctx.print(ast, `[${elements.map(part => escapeIdentifier(part.text, false)).join(', ')}], `);
            ctx.print(ast, `[${elements.map(part => escapeIdentifier(part.rawText, false)).join(', ')}])`);
            ast.template.expressions.forEach(expression => {
                ctx.print(ast, ', ');
                expression.visitExpression(this, ctx);
            });
            ctx.print(ast, ')');
            return null;
        }
        visitFunctionExpr(ast, ctx) {
            ctx.print(ast, `function${ast.name ? ' ' + ast.name : ''}(`);
            this._visitParams(ast.params, ctx);
            ctx.println(ast, `) {`);
            ctx.incIndent();
            this.visitAllStatements(ast.statements, ctx);
            ctx.decIndent();
            ctx.print(ast, `}`);
            return null;
        }
        visitDeclareFunctionStmt(stmt, ctx) {
            ctx.print(stmt, `function ${stmt.name}(`);
            this._visitParams(stmt.params, ctx);
            ctx.println(stmt, `) {`);
            ctx.incIndent();
            this.visitAllStatements(stmt.statements, ctx);
            ctx.decIndent();
            ctx.println(stmt, `}`);
            return null;
        }
        visitTryCatchStmt(stmt, ctx) {
            ctx.println(stmt, `try {`);
            ctx.incIndent();
            this.visitAllStatements(stmt.bodyStmts, ctx);
            ctx.decIndent();
            ctx.println(stmt, `} catch (${CATCH_ERROR_VAR$1.name}) {`);
            ctx.incIndent();
            const catchStmts = [CATCH_STACK_VAR$1.set(CATCH_ERROR_VAR$1.prop('stack')).toDeclStmt(null, [
                    StmtModifier.Final
                ])].concat(stmt.catchStmts);
            this.visitAllStatements(catchStmts, ctx);
            ctx.decIndent();
            ctx.println(stmt, `}`);
            return null;
        }
        visitLocalizedString(ast, ctx) {
            // The following convoluted piece of code is effectively the downlevelled equivalent of
            // ```
            // $localize `...`
            // ```
            // which is effectively like:
            // ```
            // $localize(__makeTemplateObject(cooked, raw), expression1, expression2, ...);
            // ```
            ctx.print(ast, `$localize(${makeTemplateObjectPolyfill}(`);
            const parts = [ast.serializeI18nHead()];
            for (let i = 1; i < ast.messageParts.length; i++) {
                parts.push(ast.serializeI18nTemplatePart(i));
            }
            ctx.print(ast, `[${parts.map(part => escapeIdentifier(part.cooked, false)).join(', ')}], `);
            ctx.print(ast, `[${parts.map(part => escapeIdentifier(part.raw, false)).join(', ')}])`);
            ast.expressions.forEach(expression => {
                ctx.print(ast, ', ');
                expression.visitExpression(this, ctx);
            });
            ctx.print(ast, ')');
            return null;
        }
        _visitParams(params, ctx) {
            this.visitAllObjects(param => ctx.print(null, param.name), params, ctx, ',');
        }
        getBuiltinMethodName(method) {
            let name;
            switch (method) {
                case BuiltinMethod.ConcatArray:
                    name = 'concat';
                    break;
                case BuiltinMethod.SubscribeObservable:
                    name = 'subscribe';
                    break;
                case BuiltinMethod.Bind:
                    name = 'bind';
                    break;
                default:
                    throw new Error(`Unknown builtin method: ${method}`);
            }
            return name;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * The Trusted Types policy, or null if Trusted Types are not
     * enabled/supported, or undefined if the policy has not been created yet.
     */
    let policy;
    /**
     * Returns the Trusted Types policy, or null if Trusted Types are not
     * enabled/supported. The first call to this function will create the policy.
     */
    function getPolicy() {
        if (policy === undefined) {
            policy = null;
            if (_global.trustedTypes) {
                try {
                    policy =
                        _global.trustedTypes.createPolicy('angular#unsafe-jit', {
                            createScript: (s) => s,
                        });
                }
                catch (_a) {
                    // trustedTypes.createPolicy throws if called with a name that is
                    // already registered, even in report-only mode. Until the API changes,
                    // catch the error not to break the applications functionally. In such
                    // cases, the code will fall back to using strings.
                }
            }
        }
        return policy;
    }
    /**
     * Unsafely promote a string to a TrustedScript, falling back to strings when
     * Trusted Types are not available.
     * @security In particular, it must be assured that the provided string will
     * never cause an XSS vulnerability if used in a context that will be
     * interpreted and executed as a script by a browser, e.g. when calling eval.
     */
    function trustedScriptFromString(script) {
        var _a;
        return ((_a = getPolicy()) === null || _a === void 0 ? void 0 : _a.createScript(script)) || script;
    }
    /**
     * Unsafely call the Function constructor with the given string arguments.
     * @security This is a security-sensitive function; any use of this function
     * must go through security review. In particular, it must be assured that it
     * is only called from the JIT compiler, as use in other code can lead to XSS
     * vulnerabilities.
     */
    function newTrustedFunctionForJIT(...args) {
        if (!_global.trustedTypes) {
            // In environments that don't support Trusted Types, fall back to the most
            // straightforward implementation:
            return new Function(...args);
        }
        // Chrome currently does not support passing TrustedScript to the Function
        // constructor. The following implements the workaround proposed on the page
        // below, where the Chromium bug is also referenced:
        // https://github.com/w3c/webappsec-trusted-types/wiki/Trusted-Types-for-function-constructor
        const fnArgs = args.slice(0, -1).join(',');
        const fnBody = args[args.length - 1];
        const body = `(function anonymous(${fnArgs}
) { ${fnBody}
})`;
        // Using eval directly confuses the compiler and prevents this module from
        // being stripped out of JS binaries even if not used. The global['eval']
        // indirection fixes that.
        const fn = _global['eval'](trustedScriptFromString(body));
        if (fn.bind === undefined) {
            // Workaround for a browser bug that only exists in Chrome 83, where passing
            // a TrustedScript to eval just returns the TrustedScript back without
            // evaluating it. In that case, fall back to the most straightforward
            // implementation:
            return new Function(...args);
        }
        // To completely mimic the behavior of calling "new Function", two more
        // things need to happen:
        // 1. Stringifying the resulting function should return its source code
        fn.toString = () => body;
        // 2. When calling the resulting function, `this` should refer to `global`
        return fn.bind(_global);
        // When Trusted Types support in Function constructors is widely available,
        // the implementation of this function can be simplified to:
        // return new Function(...args.map(a => trustedScriptFromString(a)));
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A helper class to manage the evaluation of JIT generated code.
     */
    class JitEvaluator {
        /**
         *
         * @param sourceUrl The URL of the generated code.
         * @param statements An array of Angular statement AST nodes to be evaluated.
         * @param reflector A helper used when converting the statements to executable code.
         * @param createSourceMaps If true then create a source-map for the generated code and include it
         * inline as a source-map comment.
         * @returns A map of all the variables in the generated code.
         */
        evaluateStatements(sourceUrl, statements, reflector, createSourceMaps) {
            const converter = new JitEmitterVisitor(reflector);
            const ctx = EmitterVisitorContext.createRoot();
            // Ensure generated code is in strict mode
            if (statements.length > 0 && !isUseStrictStatement(statements[0])) {
                statements = [
                    literal('use strict').toStmt(),
                    ...statements,
                ];
            }
            converter.visitAllStatements(statements, ctx);
            converter.createReturnStmt(ctx);
            return this.evaluateCode(sourceUrl, ctx, converter.getArgs(), createSourceMaps);
        }
        /**
         * Evaluate a piece of JIT generated code.
         * @param sourceUrl The URL of this generated code.
         * @param ctx A context object that contains an AST of the code to be evaluated.
         * @param vars A map containing the names and values of variables that the evaluated code might
         * reference.
         * @param createSourceMap If true then create a source-map for the generated code and include it
         * inline as a source-map comment.
         * @returns The result of evaluating the code.
         */
        evaluateCode(sourceUrl, ctx, vars, createSourceMap) {
            let fnBody = `"use strict";${ctx.toSource()}\n//# sourceURL=${sourceUrl}`;
            const fnArgNames = [];
            const fnArgValues = [];
            for (const argName in vars) {
                fnArgValues.push(vars[argName]);
                fnArgNames.push(argName);
            }
            if (createSourceMap) {
                // using `new Function(...)` generates a header, 1 line of no arguments, 2 lines otherwise
                // E.g. ```
                // function anonymous(a,b,c
                // /**/) { ... }```
                // We don't want to hard code this fact, so we auto detect it via an empty function first.
                const emptyFn = newTrustedFunctionForJIT(...fnArgNames.concat('return null;')).toString();
                const headerLines = emptyFn.slice(0, emptyFn.indexOf('return null;')).split('\n').length - 1;
                fnBody += `\n${ctx.toSourceMapGenerator(sourceUrl, headerLines).toJsComment()}`;
            }
            const fn = newTrustedFunctionForJIT(...fnArgNames.concat(fnBody));
            return this.executeFunction(fn, fnArgValues);
        }
        /**
         * Execute a JIT generated function by calling it.
         *
         * This method can be overridden in tests to capture the functions that are generated
         * by this `JitEvaluator` class.
         *
         * @param fn A function to execute.
         * @param args The arguments to pass to the function being executed.
         * @returns The return value of the executed function.
         */
        executeFunction(fn, args) {
            return fn(...args);
        }
    }
    /**
     * An Angular AST visitor that converts AST nodes into executable JavaScript code.
     */
    class JitEmitterVisitor extends AbstractJsEmitterVisitor {
        constructor(reflector) {
            super();
            this.reflector = reflector;
            this._evalArgNames = [];
            this._evalArgValues = [];
            this._evalExportedVars = [];
        }
        createReturnStmt(ctx) {
            const stmt = new ReturnStatement(new LiteralMapExpr(this._evalExportedVars.map(resultVar => new LiteralMapEntry(resultVar, variable(resultVar), false))));
            stmt.visitStatement(this, ctx);
        }
        getArgs() {
            const result = {};
            for (let i = 0; i < this._evalArgNames.length; i++) {
                result[this._evalArgNames[i]] = this._evalArgValues[i];
            }
            return result;
        }
        visitExternalExpr(ast, ctx) {
            this._emitReferenceToExternal(ast, this.reflector.resolveExternalReference(ast.value), ctx);
            return null;
        }
        visitWrappedNodeExpr(ast, ctx) {
            this._emitReferenceToExternal(ast, ast.node, ctx);
            return null;
        }
        visitDeclareVarStmt(stmt, ctx) {
            if (stmt.hasModifier(StmtModifier.Exported)) {
                this._evalExportedVars.push(stmt.name);
            }
            return super.visitDeclareVarStmt(stmt, ctx);
        }
        visitDeclareFunctionStmt(stmt, ctx) {
            if (stmt.hasModifier(StmtModifier.Exported)) {
                this._evalExportedVars.push(stmt.name);
            }
            return super.visitDeclareFunctionStmt(stmt, ctx);
        }
        visitDeclareClassStmt(stmt, ctx) {
            if (stmt.hasModifier(StmtModifier.Exported)) {
                this._evalExportedVars.push(stmt.name);
            }
            return super.visitDeclareClassStmt(stmt, ctx);
        }
        _emitReferenceToExternal(ast, value, ctx) {
            let id = this._evalArgValues.indexOf(value);
            if (id === -1) {
                id = this._evalArgValues.length;
                this._evalArgValues.push(value);
                const name = identifierName({ reference: value }) || 'val';
                this._evalArgNames.push(`jit_${name}_${id}`);
            }
            ctx.print(ast, this._evalArgNames[id]);
        }
    }
    function isUseStrictStatement(statement) {
        return statement.isEquivalent(literal('use strict').toStmt());
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function compileInjector(meta) {
        const definitionMap = new DefinitionMap();
        if (meta.providers !== null) {
            definitionMap.set('providers', meta.providers);
        }
        if (meta.imports.length > 0) {
            definitionMap.set('imports', literalArr(meta.imports));
        }
        const expression = importExpr(Identifiers.defineInjector).callFn([definitionMap.toLiteralMap()], undefined, true);
        const type = createInjectorType(meta);
        return { expression, type, statements: [] };
    }
    function createInjectorType(meta) {
        return new ExpressionType(importExpr(Identifiers.InjectorDeclaration, [new ExpressionType(meta.type.type)]));
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Implementation of `CompileReflector` which resolves references to @angular/core
     * symbols at runtime, according to a consumer-provided mapping.
     *
     * Only supports `resolveExternalReference`, all other methods throw.
     */
    class R3JitReflector {
        constructor(context) {
            this.context = context;
        }
        resolveExternalReference(ref) {
            // This reflector only handles @angular/core imports.
            if (ref.moduleName !== '@angular/core') {
                throw new Error(`Cannot resolve external reference to ${ref.moduleName}, only references to @angular/core are supported.`);
            }
            if (!this.context.hasOwnProperty(ref.name)) {
                throw new Error(`No value provided for @angular/core symbol '${ref.name}'.`);
            }
            return this.context[ref.name];
        }
        parameters(typeOrFunc) {
            throw new Error('Not implemented.');
        }
        annotations(typeOrFunc) {
            throw new Error('Not implemented.');
        }
        shallowAnnotations(typeOrFunc) {
            throw new Error('Not implemented.');
        }
        tryAnnotations(typeOrFunc) {
            throw new Error('Not implemented.');
        }
        propMetadata(typeOrFunc) {
            throw new Error('Not implemented.');
        }
        hasLifecycleHook(type, lcProperty) {
            throw new Error('Not implemented.');
        }
        guards(typeOrFunc) {
            throw new Error('Not implemented.');
        }
        componentModuleUrl(type, cmpMetadata) {
            throw new Error('Not implemented.');
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Construct an `R3NgModuleDef` for the given `R3NgModuleMetadata`.
     */
    function compileNgModule(meta) {
        const { internalType, bootstrap, declarations, imports, exports, schemas, containsForwardDecls, emitInline, id } = meta;
        const statements = [];
        const definitionMap = new DefinitionMap();
        definitionMap.set('type', internalType);
        if (bootstrap.length > 0) {
            definitionMap.set('bootstrap', refsToArray(bootstrap, containsForwardDecls));
        }
        // If requested to emit scope information inline, pass the `declarations`, `imports` and `exports`
        // to the `defineNgModule()` call. The JIT compilation uses this.
        if (emitInline) {
            if (declarations.length > 0) {
                definitionMap.set('declarations', refsToArray(declarations, containsForwardDecls));
            }
            if (imports.length > 0) {
                definitionMap.set('imports', refsToArray(imports, containsForwardDecls));
            }
            if (exports.length > 0) {
                definitionMap.set('exports', refsToArray(exports, containsForwardDecls));
            }
        }
        // If not emitting inline, the scope information is not passed into `defineNgModule` as it would
        // prevent tree-shaking of the declarations, imports and exports references.
        else {
            const setNgModuleScopeCall = generateSetNgModuleScopeCall(meta);
            if (setNgModuleScopeCall !== null) {
                statements.push(setNgModuleScopeCall);
            }
        }
        if (schemas !== null && schemas.length > 0) {
            definitionMap.set('schemas', literalArr(schemas.map(ref => ref.value)));
        }
        if (id !== null) {
            definitionMap.set('id', id);
        }
        const expression = importExpr(Identifiers.defineNgModule).callFn([definitionMap.toLiteralMap()], undefined, true);
        const type = createNgModuleType(meta);
        return { expression, type, statements };
    }
    /**
     * This function is used in JIT mode to generate the call to `defineNgModule()` from a call to
     * `ngDeclareNgModule()`.
     */
    function compileNgModuleDeclarationExpression(meta) {
        const definitionMap = new DefinitionMap();
        definitionMap.set('type', new WrappedNodeExpr(meta.type));
        if (meta.bootstrap !== undefined) {
            definitionMap.set('bootstrap', new WrappedNodeExpr(meta.bootstrap));
        }
        if (meta.declarations !== undefined) {
            definitionMap.set('declarations', new WrappedNodeExpr(meta.declarations));
        }
        if (meta.imports !== undefined) {
            definitionMap.set('imports', new WrappedNodeExpr(meta.imports));
        }
        if (meta.exports !== undefined) {
            definitionMap.set('exports', new WrappedNodeExpr(meta.exports));
        }
        if (meta.schemas !== undefined) {
            definitionMap.set('schemas', new WrappedNodeExpr(meta.schemas));
        }
        if (meta.id !== undefined) {
            definitionMap.set('id', new WrappedNodeExpr(meta.id));
        }
        return importExpr(Identifiers.defineNgModule).callFn([definitionMap.toLiteralMap()]);
    }
    function createNgModuleType({ type: moduleType, declarations, imports, exports }) {
        return new ExpressionType(importExpr(Identifiers.NgModuleDeclaration, [
            new ExpressionType(moduleType.type), tupleTypeOf(declarations), tupleTypeOf(imports),
            tupleTypeOf(exports)
        ]));
    }
    /**
     * Generates a function call to `setNgModuleScope` with all necessary information so that the
     * transitive module scope can be computed during runtime in JIT mode. This call is marked pure
     * such that the references to declarations, imports and exports may be elided causing these
     * symbols to become tree-shakeable.
     */
    function generateSetNgModuleScopeCall(meta) {
        const { adjacentType: moduleType, declarations, imports, exports, containsForwardDecls } = meta;
        const scopeMap = new DefinitionMap();
        if (declarations.length > 0) {
            scopeMap.set('declarations', refsToArray(declarations, containsForwardDecls));
        }
        if (imports.length > 0) {
            scopeMap.set('imports', refsToArray(imports, containsForwardDecls));
        }
        if (exports.length > 0) {
            scopeMap.set('exports', refsToArray(exports, containsForwardDecls));
        }
        if (Object.keys(scopeMap.values).length === 0) {
            return null;
        }
        // setNgModuleScope(...)
        const fnCall = new InvokeFunctionExpr(
        /* fn */ importExpr(Identifiers.setNgModuleScope), 
        /* args */ [moduleType, scopeMap.toLiteralMap()]);
        // (ngJitMode guard) && setNgModuleScope(...)
        const guardedCall = jitOnlyGuardedExpression(fnCall);
        // function() { (ngJitMode guard) && setNgModuleScope(...); }
        const iife = new FunctionExpr(
        /* params */ [], 
        /* statements */ [guardedCall.toStmt()]);
        // (function() { (ngJitMode guard) && setNgModuleScope(...); })()
        const iifeCall = new InvokeFunctionExpr(
        /* fn */ iife, 
        /* args */ []);
        return iifeCall.toStmt();
    }
    function tupleTypeOf(exp) {
        const types = exp.map(ref => typeofExpr(ref.type));
        return exp.length > 0 ? expressionType(literalArr(types)) : NONE_TYPE;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function compilePipeFromMetadata(metadata) {
        const definitionMapValues = [];
        // e.g. `name: 'myPipe'`
        definitionMapValues.push({ key: 'name', value: literal(metadata.pipeName), quoted: false });
        // e.g. `type: MyPipe`
        definitionMapValues.push({ key: 'type', value: metadata.type.value, quoted: false });
        // e.g. `pure: true`
        definitionMapValues.push({ key: 'pure', value: literal(metadata.pure), quoted: false });
        const expression = importExpr(Identifiers.definePipe).callFn([literalMap(definitionMapValues)], undefined, true);
        const type = createPipeType(metadata);
        return { expression, type, statements: [] };
    }
    function createPipeType(metadata) {
        return new ExpressionType(importExpr(Identifiers.PipeDeclaration, [
            typeWithParameters(metadata.type.type, metadata.typeArgumentCount),
            new ExpressionType(new LiteralExpr(metadata.pipeName)),
        ]));
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class ParserError {
        constructor(message, input, errLocation, ctxLocation) {
            this.input = input;
            this.errLocation = errLocation;
            this.ctxLocation = ctxLocation;
            this.message = `Parser Error: ${message} ${errLocation} [${input}] in ${ctxLocation}`;
        }
    }
    class ParseSpan {
        constructor(start, end) {
            this.start = start;
            this.end = end;
        }
        toAbsolute(absoluteOffset) {
            return new AbsoluteSourceSpan(absoluteOffset + this.start, absoluteOffset + this.end);
        }
    }
    class AST {
        constructor(span, 
        /**
         * Absolute location of the expression AST in a source code file.
         */
        sourceSpan) {
            this.span = span;
            this.sourceSpan = sourceSpan;
        }
        toString() {
            return 'AST';
        }
    }
    class ASTWithName extends AST {
        constructor(span, sourceSpan, nameSpan) {
            super(span, sourceSpan);
            this.nameSpan = nameSpan;
        }
    }
    /**
     * Represents a quoted expression of the form:
     *
     * quote = prefix `:` uninterpretedExpression
     * prefix = identifier
     * uninterpretedExpression = arbitrary string
     *
     * A quoted expression is meant to be pre-processed by an AST transformer that
     * converts it into another AST that no longer contains quoted expressions.
     * It is meant to allow third-party developers to extend Angular template
     * expression language. The `uninterpretedExpression` part of the quote is
     * therefore not interpreted by the Angular's own expression parser.
     */
    class Quote extends AST {
        constructor(span, sourceSpan, prefix, uninterpretedExpression, location) {
            super(span, sourceSpan);
            this.prefix = prefix;
            this.uninterpretedExpression = uninterpretedExpression;
            this.location = location;
        }
        visit(visitor, context = null) {
            return visitor.visitQuote(this, context);
        }
        toString() {
            return 'Quote';
        }
    }
    class EmptyExpr extends AST {
        visit(visitor, context = null) {
            // do nothing
        }
    }
    class ImplicitReceiver extends AST {
        visit(visitor, context = null) {
            return visitor.visitImplicitReceiver(this, context);
        }
    }
    /**
     * Receiver when something is accessed through `this` (e.g. `this.foo`). Note that this class
     * inherits from `ImplicitReceiver`, because accessing something through `this` is treated the
     * same as accessing it implicitly inside of an Angular template (e.g. `[attr.title]="this.title"`
     * is the same as `[attr.title]="title"`.). Inheriting allows for the `this` accesses to be treated
     * the same as implicit ones, except for a couple of exceptions like `$event` and `$any`.
     * TODO: we should find a way for this class not to extend from `ImplicitReceiver` in the future.
     */
    class ThisReceiver extends ImplicitReceiver {
        visit(visitor, context = null) {
            var _a;
            return (_a = visitor.visitThisReceiver) === null || _a === void 0 ? void 0 : _a.call(visitor, this, context);
        }
    }
    /**
     * Multiple expressions separated by a semicolon.
     */
    class Chain extends AST {
        constructor(span, sourceSpan, expressions) {
            super(span, sourceSpan);
            this.expressions = expressions;
        }
        visit(visitor, context = null) {
            return visitor.visitChain(this, context);
        }
    }
    class Conditional extends AST {
        constructor(span, sourceSpan, condition, trueExp, falseExp) {
            super(span, sourceSpan);
            this.condition = condition;
            this.trueExp = trueExp;
            this.falseExp = falseExp;
        }
        visit(visitor, context = null) {
            return visitor.visitConditional(this, context);
        }
    }
    class PropertyRead extends ASTWithName {
        constructor(span, sourceSpan, nameSpan, receiver, name) {
            super(span, sourceSpan, nameSpan);
            this.receiver = receiver;
            this.name = name;
        }
        visit(visitor, context = null) {
            return visitor.visitPropertyRead(this, context);
        }
    }
    class PropertyWrite extends ASTWithName {
        constructor(span, sourceSpan, nameSpan, receiver, name, value) {
            super(span, sourceSpan, nameSpan);
            this.receiver = receiver;
            this.name = name;
            this.value = value;
        }
        visit(visitor, context = null) {
            return visitor.visitPropertyWrite(this, context);
        }
    }
    class SafePropertyRead extends ASTWithName {
        constructor(span, sourceSpan, nameSpan, receiver, name) {
            super(span, sourceSpan, nameSpan);
            this.receiver = receiver;
            this.name = name;
        }
        visit(visitor, context = null) {
            return visitor.visitSafePropertyRead(this, context);
        }
    }
    class KeyedRead extends AST {
        constructor(span, sourceSpan, receiver, key) {
            super(span, sourceSpan);
            this.receiver = receiver;
            this.key = key;
        }
        visit(visitor, context = null) {
            return visitor.visitKeyedRead(this, context);
        }
    }
    class SafeKeyedRead extends AST {
        constructor(span, sourceSpan, receiver, key) {
            super(span, sourceSpan);
            this.receiver = receiver;
            this.key = key;
        }
        visit(visitor, context = null) {
            return visitor.visitSafeKeyedRead(this, context);
        }
    }
    class KeyedWrite extends AST {
        constructor(span, sourceSpan, receiver, key, value) {
            super(span, sourceSpan);
            this.receiver = receiver;
            this.key = key;
            this.value = value;
        }
        visit(visitor, context = null) {
            return visitor.visitKeyedWrite(this, context);
        }
    }
    class BindingPipe extends ASTWithName {
        constructor(span, sourceSpan, exp, name, args, nameSpan) {
            super(span, sourceSpan, nameSpan);
            this.exp = exp;
            this.name = name;
            this.args = args;
        }
        visit(visitor, context = null) {
            return visitor.visitPipe(this, context);
        }
    }
    class LiteralPrimitive extends AST {
        constructor(span, sourceSpan, value) {
            super(span, sourceSpan);
            this.value = value;
        }
        visit(visitor, context = null) {
            return visitor.visitLiteralPrimitive(this, context);
        }
    }
    class LiteralArray extends AST {
        constructor(span, sourceSpan, expressions) {
            super(span, sourceSpan);
            this.expressions = expressions;
        }
        visit(visitor, context = null) {
            return visitor.visitLiteralArray(this, context);
        }
    }
    class LiteralMap extends AST {
        constructor(span, sourceSpan, keys, values) {
            super(span, sourceSpan);
            this.keys = keys;
            this.values = values;
        }
        visit(visitor, context = null) {
            return visitor.visitLiteralMap(this, context);
        }
    }
    class Interpolation extends AST {
        constructor(span, sourceSpan, strings, expressions) {
            super(span, sourceSpan);
            this.strings = strings;
            this.expressions = expressions;
        }
        visit(visitor, context = null) {
            return visitor.visitInterpolation(this, context);
        }
    }
    class Binary extends AST {
        constructor(span, sourceSpan, operation, left, right) {
            super(span, sourceSpan);
            this.operation = operation;
            this.left = left;
            this.right = right;
        }
        visit(visitor, context = null) {
            return visitor.visitBinary(this, context);
        }
    }
    /**
     * For backwards compatibility reasons, `Unary` inherits from `Binary` and mimics the binary AST
     * node that was originally used. This inheritance relation can be deleted in some future major,
     * after consumers have been given a chance to fully support Unary.
     */
    class Unary extends Binary {
        /**
         * During the deprecation period this constructor is private, to avoid consumers from creating
         * a `Unary` with the fallback properties for `Binary`.
         */
        constructor(span, sourceSpan, operator, expr, binaryOp, binaryLeft, binaryRight) {
            super(span, sourceSpan, binaryOp, binaryLeft, binaryRight);
            this.operator = operator;
            this.expr = expr;
        }
        /**
         * Creates a unary minus expression "-x", represented as `Binary` using "0 - x".
         */
        static createMinus(span, sourceSpan, expr) {
            return new Unary(span, sourceSpan, '-', expr, '-', new LiteralPrimitive(span, sourceSpan, 0), expr);
        }
        /**
         * Creates a unary plus expression "+x", represented as `Binary` using "x - 0".
         */
        static createPlus(span, sourceSpan, expr) {
            return new Unary(span, sourceSpan, '+', expr, '-', expr, new LiteralPrimitive(span, sourceSpan, 0));
        }
        visit(visitor, context = null) {
            if (visitor.visitUnary !== undefined) {
                return visitor.visitUnary(this, context);
            }
            return visitor.visitBinary(this, context);
        }
    }
    class PrefixNot extends AST {
        constructor(span, sourceSpan, expression) {
            super(span, sourceSpan);
            this.expression = expression;
        }
        visit(visitor, context = null) {
            return visitor.visitPrefixNot(this, context);
        }
    }
    class NonNullAssert extends AST {
        constructor(span, sourceSpan, expression) {
            super(span, sourceSpan);
            this.expression = expression;
        }
        visit(visitor, context = null) {
            return visitor.visitNonNullAssert(this, context);
        }
    }
    class MethodCall extends ASTWithName {
        constructor(span, sourceSpan, nameSpan, receiver, name, args, argumentSpan) {
            super(span, sourceSpan, nameSpan);
            this.receiver = receiver;
            this.name = name;
            this.args = args;
            this.argumentSpan = argumentSpan;
        }
        visit(visitor, context = null) {
            return visitor.visitMethodCall(this, context);
        }
    }
    class SafeMethodCall extends ASTWithName {
        constructor(span, sourceSpan, nameSpan, receiver, name, args, argumentSpan) {
            super(span, sourceSpan, nameSpan);
            this.receiver = receiver;
            this.name = name;
            this.args = args;
            this.argumentSpan = argumentSpan;
        }
        visit(visitor, context = null) {
            return visitor.visitSafeMethodCall(this, context);
        }
    }
    class FunctionCall extends AST {
        constructor(span, sourceSpan, target, args) {
            super(span, sourceSpan);
            this.target = target;
            this.args = args;
        }
        visit(visitor, context = null) {
            return visitor.visitFunctionCall(this, context);
        }
    }
    /**
     * Records the absolute position of a text span in a source file, where `start` and `end` are the
     * starting and ending byte offsets, respectively, of the text span in a source file.
     */
    class AbsoluteSourceSpan {
        constructor(start, end) {
            this.start = start;
            this.end = end;
        }
    }
    class ASTWithSource extends AST {
        constructor(ast, source, location, absoluteOffset, errors) {
            super(new ParseSpan(0, source === null ? 0 : source.length), new AbsoluteSourceSpan(absoluteOffset, source === null ? absoluteOffset : absoluteOffset + source.length));
            this.ast = ast;
            this.source = source;
            this.location = location;
            this.errors = errors;
        }
        visit(visitor, context = null) {
            if (visitor.visitASTWithSource) {
                return visitor.visitASTWithSource(this, context);
            }
            return this.ast.visit(visitor, context);
        }
        toString() {
            return `${this.source} in ${this.location}`;
        }
    }
    class VariableBinding {
        /**
         * @param sourceSpan entire span of the binding.
         * @param key name of the LHS along with its span.
         * @param value optional value for the RHS along with its span.
         */
        constructor(sourceSpan, key, value) {
            this.sourceSpan = sourceSpan;
            this.key = key;
            this.value = value;
        }
    }
    class ExpressionBinding {
        /**
         * @param sourceSpan entire span of the binding.
         * @param key binding name, like ngForOf, ngForTrackBy, ngIf, along with its
         * span. Note that the length of the span may not be the same as
         * `key.source.length`. For example,
         * 1. key.source = ngFor, key.span is for "ngFor"
         * 2. key.source = ngForOf, key.span is for "of"
         * 3. key.source = ngForTrackBy, key.span is for "trackBy"
         * @param value optional expression for the RHS.
         */
        constructor(sourceSpan, key, value) {
            this.sourceSpan = sourceSpan;
            this.key = key;
            this.value = value;
        }
    }
    class RecursiveAstVisitor {
        visit(ast, context) {
            // The default implementation just visits every node.
            // Classes that extend RecursiveAstVisitor should override this function
            // to selectively visit the specified node.
            ast.visit(this, context);
        }
        visitUnary(ast, context) {
            this.visit(ast.expr, context);
        }
        visitBinary(ast, context) {
            this.visit(ast.left, context);
            this.visit(ast.right, context);
        }
        visitChain(ast, context) {
            this.visitAll(ast.expressions, context);
        }
        visitConditional(ast, context) {
            this.visit(ast.condition, context);
            this.visit(ast.trueExp, context);
            this.visit(ast.falseExp, context);
        }
        visitPipe(ast, context) {
            this.visit(ast.exp, context);
            this.visitAll(ast.args, context);
        }
        visitFunctionCall(ast, context) {
            if (ast.target) {
                this.visit(ast.target, context);
            }
            this.visitAll(ast.args, context);
        }
        visitImplicitReceiver(ast, context) { }
        visitThisReceiver(ast, context) { }
        visitInterpolation(ast, context) {
            this.visitAll(ast.expressions, context);
        }
        visitKeyedRead(ast, context) {
            this.visit(ast.receiver, context);
            this.visit(ast.key, context);
        }
        visitKeyedWrite(ast, context) {
            this.visit(ast.receiver, context);
            this.visit(ast.key, context);
            this.visit(ast.value, context);
        }
        visitLiteralArray(ast, context) {
            this.visitAll(ast.expressions, context);
        }
        visitLiteralMap(ast, context) {
            this.visitAll(ast.values, context);
        }
        visitLiteralPrimitive(ast, context) { }
        visitMethodCall(ast, context) {
            this.visit(ast.receiver, context);
            this.visitAll(ast.args, context);
        }
        visitPrefixNot(ast, context) {
            this.visit(ast.expression, context);
        }
        visitNonNullAssert(ast, context) {
            this.visit(ast.expression, context);
        }
        visitPropertyRead(ast, context) {
            this.visit(ast.receiver, context);
        }
        visitPropertyWrite(ast, context) {
            this.visit(ast.receiver, context);
            this.visit(ast.value, context);
        }
        visitSafePropertyRead(ast, context) {
            this.visit(ast.receiver, context);
        }
        visitSafeMethodCall(ast, context) {
            this.visit(ast.receiver, context);
            this.visitAll(ast.args, context);
        }
        visitSafeKeyedRead(ast, context) {
            this.visit(ast.receiver, context);
            this.visit(ast.key, context);
        }
        visitQuote(ast, context) { }
        // This is not part of the AstVisitor interface, just a helper method
        visitAll(asts, context) {
            for (const ast of asts) {
                this.visit(ast, context);
            }
        }
    }
    class AstTransformer {
        visitImplicitReceiver(ast, context) {
            return ast;
        }
        visitThisReceiver(ast, context) {
            return ast;
        }
        visitInterpolation(ast, context) {
            return new Interpolation(ast.span, ast.sourceSpan, ast.strings, this.visitAll(ast.expressions));
        }
        visitLiteralPrimitive(ast, context) {
            return new LiteralPrimitive(ast.span, ast.sourceSpan, ast.value);
        }
        visitPropertyRead(ast, context) {
            return new PropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name);
        }
        visitPropertyWrite(ast, context) {
            return new PropertyWrite(ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name, ast.value.visit(this));
        }
        visitSafePropertyRead(ast, context) {
            return new SafePropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name);
        }
        visitMethodCall(ast, context) {
            return new MethodCall(ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name, this.visitAll(ast.args), ast.argumentSpan);
        }
        visitSafeMethodCall(ast, context) {
            return new SafeMethodCall(ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name, this.visitAll(ast.args), ast.argumentSpan);
        }
        visitFunctionCall(ast, context) {
            return new FunctionCall(ast.span, ast.sourceSpan, ast.target.visit(this), this.visitAll(ast.args));
        }
        visitLiteralArray(ast, context) {
            return new LiteralArray(ast.span, ast.sourceSpan, this.visitAll(ast.expressions));
        }
        visitLiteralMap(ast, context) {
            return new LiteralMap(ast.span, ast.sourceSpan, ast.keys, this.visitAll(ast.values));
        }
        visitUnary(ast, context) {
            switch (ast.operator) {
                case '+':
                    return Unary.createPlus(ast.span, ast.sourceSpan, ast.expr.visit(this));
                case '-':
                    return Unary.createMinus(ast.span, ast.sourceSpan, ast.expr.visit(this));
                default:
                    throw new Error(`Unknown unary operator ${ast.operator}`);
            }
        }
        visitBinary(ast, context) {
            return new Binary(ast.span, ast.sourceSpan, ast.operation, ast.left.visit(this), ast.right.visit(this));
        }
        visitPrefixNot(ast, context) {
            return new PrefixNot(ast.span, ast.sourceSpan, ast.expression.visit(this));
        }
        visitNonNullAssert(ast, context) {
            return new NonNullAssert(ast.span, ast.sourceSpan, ast.expression.visit(this));
        }
        visitConditional(ast, context) {
            return new Conditional(ast.span, ast.sourceSpan, ast.condition.visit(this), ast.trueExp.visit(this), ast.falseExp.visit(this));
        }
        visitPipe(ast, context) {
            return new BindingPipe(ast.span, ast.sourceSpan, ast.exp.visit(this), ast.name, this.visitAll(ast.args), ast.nameSpan);
        }
        visitKeyedRead(ast, context) {
            return new KeyedRead(ast.span, ast.sourceSpan, ast.receiver.visit(this), ast.key.visit(this));
        }
        visitKeyedWrite(ast, context) {
            return new KeyedWrite(ast.span, ast.sourceSpan, ast.receiver.visit(this), ast.key.visit(this), ast.value.visit(this));
        }
        visitAll(asts) {
            const res = [];
            for (let i = 0; i < asts.length; ++i) {
                res[i] = asts[i].visit(this);
            }
            return res;
        }
        visitChain(ast, context) {
            return new Chain(ast.span, ast.sourceSpan, this.visitAll(ast.expressions));
        }
        visitQuote(ast, context) {
            return new Quote(ast.span, ast.sourceSpan, ast.prefix, ast.uninterpretedExpression, ast.location);
        }
        visitSafeKeyedRead(ast, context) {
            return new SafeKeyedRead(ast.span, ast.sourceSpan, ast.receiver.visit(this), ast.key.visit(this));
        }
    }
    // A transformer that only creates new nodes if the transformer makes a change or
    // a change is made a child node.
    class AstMemoryEfficientTransformer {
        visitImplicitReceiver(ast, context) {
            return ast;
        }
        visitThisReceiver(ast, context) {
            return ast;
        }
        visitInterpolation(ast, context) {
            const expressions = this.visitAll(ast.expressions);
            if (expressions !== ast.expressions)
                return new Interpolation(ast.span, ast.sourceSpan, ast.strings, expressions);
            return ast;
        }
        visitLiteralPrimitive(ast, context) {
            return ast;
        }
        visitPropertyRead(ast, context) {
            const receiver = ast.receiver.visit(this);
            if (receiver !== ast.receiver) {
                return new PropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name);
            }
            return ast;
        }
        visitPropertyWrite(ast, context) {
            const receiver = ast.receiver.visit(this);
            const value = ast.value.visit(this);
            if (receiver !== ast.receiver || value !== ast.value) {
                return new PropertyWrite(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name, value);
            }
            return ast;
        }
        visitSafePropertyRead(ast, context) {
            const receiver = ast.receiver.visit(this);
            if (receiver !== ast.receiver) {
                return new SafePropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name);
            }
            return ast;
        }
        visitMethodCall(ast, context) {
            const receiver = ast.receiver.visit(this);
            const args = this.visitAll(ast.args);
            if (receiver !== ast.receiver || args !== ast.args) {
                return new MethodCall(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name, args, ast.argumentSpan);
            }
            return ast;
        }
        visitSafeMethodCall(ast, context) {
            const receiver = ast.receiver.visit(this);
            const args = this.visitAll(ast.args);
            if (receiver !== ast.receiver || args !== ast.args) {
                return new SafeMethodCall(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name, args, ast.argumentSpan);
            }
            return ast;
        }
        visitFunctionCall(ast, context) {
            const target = ast.target && ast.target.visit(this);
            const args = this.visitAll(ast.args);
            if (target !== ast.target || args !== ast.args) {
                return new FunctionCall(ast.span, ast.sourceSpan, target, args);
            }
            return ast;
        }
        visitLiteralArray(ast, context) {
            const expressions = this.visitAll(ast.expressions);
            if (expressions !== ast.expressions) {
                return new LiteralArray(ast.span, ast.sourceSpan, expressions);
            }
            return ast;
        }
        visitLiteralMap(ast, context) {
            const values = this.visitAll(ast.values);
            if (values !== ast.values) {
                return new LiteralMap(ast.span, ast.sourceSpan, ast.keys, values);
            }
            return ast;
        }
        visitUnary(ast, context) {
            const expr = ast.expr.visit(this);
            if (expr !== ast.expr) {
                switch (ast.operator) {
                    case '+':
                        return Unary.createPlus(ast.span, ast.sourceSpan, expr);
                    case '-':
                        return Unary.createMinus(ast.span, ast.sourceSpan, expr);
                    default:
                        throw new Error(`Unknown unary operator ${ast.operator}`);
                }
            }
            return ast;
        }
        visitBinary(ast, context) {
            const left = ast.left.visit(this);
            const right = ast.right.visit(this);
            if (left !== ast.left || right !== ast.right) {
                return new Binary(ast.span, ast.sourceSpan, ast.operation, left, right);
            }
            return ast;
        }
        visitPrefixNot(ast, context) {
            const expression = ast.expression.visit(this);
            if (expression !== ast.expression) {
                return new PrefixNot(ast.span, ast.sourceSpan, expression);
            }
            return ast;
        }
        visitNonNullAssert(ast, context) {
            const expression = ast.expression.visit(this);
            if (expression !== ast.expression) {
                return new NonNullAssert(ast.span, ast.sourceSpan, expression);
            }
            return ast;
        }
        visitConditional(ast, context) {
            const condition = ast.condition.visit(this);
            const trueExp = ast.trueExp.visit(this);
            const falseExp = ast.falseExp.visit(this);
            if (condition !== ast.condition || trueExp !== ast.trueExp || falseExp !== ast.falseExp) {
                return new Conditional(ast.span, ast.sourceSpan, condition, trueExp, falseExp);
            }
            return ast;
        }
        visitPipe(ast, context) {
            const exp = ast.exp.visit(this);
            const args = this.visitAll(ast.args);
            if (exp !== ast.exp || args !== ast.args) {
                return new BindingPipe(ast.span, ast.sourceSpan, exp, ast.name, args, ast.nameSpan);
            }
            return ast;
        }
        visitKeyedRead(ast, context) {
            const obj = ast.receiver.visit(this);
            const key = ast.key.visit(this);
            if (obj !== ast.receiver || key !== ast.key) {
                return new KeyedRead(ast.span, ast.sourceSpan, obj, key);
            }
            return ast;
        }
        visitKeyedWrite(ast, context) {
            const obj = ast.receiver.visit(this);
            const key = ast.key.visit(this);
            const value = ast.value.visit(this);
            if (obj !== ast.receiver || key !== ast.key || value !== ast.value) {
                return new KeyedWrite(ast.span, ast.sourceSpan, obj, key, value);
            }
            return ast;
        }
        visitAll(asts) {
            const res = [];
            let modified = false;
            for (let i = 0; i < asts.length; ++i) {
                const original = asts[i];
                const value = original.visit(this);
                res[i] = value;
                modified = modified || value !== original;
            }
            return modified ? res : asts;
        }
        visitChain(ast, context) {
            const expressions = this.visitAll(ast.expressions);
            if (expressions !== ast.expressions) {
                return new Chain(ast.span, ast.sourceSpan, expressions);
            }
            return ast;
        }
        visitQuote(ast, context) {
            return ast;
        }
        visitSafeKeyedRead(ast, context) {
            const obj = ast.receiver.visit(this);
            const key = ast.key.visit(this);
            if (obj !== ast.receiver || key !== ast.key) {
                return new SafeKeyedRead(ast.span, ast.sourceSpan, obj, key);
            }
            return ast;
        }
    }
    // Bindings
    class ParsedProperty {
        constructor(name, expression, type, 
        // TODO(FW-2095): `keySpan` should really be required but allows `undefined` so VE does
        // not need to be updated. Make `keySpan` required when VE is removed.
        sourceSpan, keySpan, valueSpan) {
            this.name = name;
            this.expression = expression;
            this.type = type;
            this.sourceSpan = sourceSpan;
            this.keySpan = keySpan;
            this.valueSpan = valueSpan;
            this.isLiteral = this.type === ParsedPropertyType.LITERAL_ATTR;
            this.isAnimation = this.type === ParsedPropertyType.ANIMATION;
        }
    }
    var ParsedPropertyType;
    (function (ParsedPropertyType) {
        ParsedPropertyType[ParsedPropertyType["DEFAULT"] = 0] = "DEFAULT";
        ParsedPropertyType[ParsedPropertyType["LITERAL_ATTR"] = 1] = "LITERAL_ATTR";
        ParsedPropertyType[ParsedPropertyType["ANIMATION"] = 2] = "ANIMATION";
    })(ParsedPropertyType || (ParsedPropertyType = {}));
    class ParsedEvent {
        // Regular events have a target
        // Animation events have a phase
        constructor(name, targetOrPhase, type, handler, sourceSpan, 
        // TODO(FW-2095): keySpan should be required but was made optional to avoid changing VE
        handlerSpan, keySpan) {
            this.name = name;
            this.targetOrPhase = targetOrPhase;
            this.type = type;
            this.handler = handler;
            this.sourceSpan = sourceSpan;
            this.handlerSpan = handlerSpan;
            this.keySpan = keySpan;
        }
    }
    /**
     * ParsedVariable represents a variable declaration in a microsyntax expression.
     */
    class ParsedVariable {
        constructor(name, value, sourceSpan, keySpan, valueSpan) {
            this.name = name;
            this.value = value;
            this.sourceSpan = sourceSpan;
            this.keySpan = keySpan;
            this.valueSpan = valueSpan;
        }
    }
    class BoundElementProperty {
        constructor(name, type, securityContext, value, unit, sourceSpan, keySpan, valueSpan) {
            this.name = name;
            this.type = type;
            this.securityContext = securityContext;
            this.value = value;
            this.unit = unit;
            this.sourceSpan = sourceSpan;
            this.keySpan = keySpan;
            this.valueSpan = valueSpan;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const CORE$1 = '@angular/core';
    class Identifiers$1 {
    }
    Identifiers$1.ANALYZE_FOR_ENTRY_COMPONENTS = {
        name: 'ANALYZE_FOR_ENTRY_COMPONENTS',
        moduleName: CORE$1,
    };
    Identifiers$1.ElementRef = { name: 'ElementRef', moduleName: CORE$1 };
    Identifiers$1.NgModuleRef = { name: 'NgModuleRef', moduleName: CORE$1 };
    Identifiers$1.ViewContainerRef = { name: 'ViewContainerRef', moduleName: CORE$1 };
    Identifiers$1.ChangeDetectorRef = {
        name: 'ChangeDetectorRef',
        moduleName: CORE$1,
    };
    Identifiers$1.QueryList = { name: 'QueryList', moduleName: CORE$1 };
    Identifiers$1.TemplateRef = { name: 'TemplateRef', moduleName: CORE$1 };
    Identifiers$1.Renderer2 = { name: 'Renderer2', moduleName: CORE$1 };
    Identifiers$1.CodegenComponentFactoryResolver = {
        name: 'CodegenComponentFactoryResolver',
        moduleName: CORE$1,
    };
    Identifiers$1.ComponentFactoryResolver = {
        name: 'ComponentFactoryResolver',
        moduleName: CORE$1,
    };
    Identifiers$1.ComponentFactory = { name: 'ComponentFactory', moduleName: CORE$1 };
    Identifiers$1.ComponentRef = { name: 'ComponentRef', moduleName: CORE$1 };
    Identifiers$1.NgModuleFactory = { name: 'NgModuleFactory', moduleName: CORE$1 };
    Identifiers$1.createModuleFactory = {
        name: 'cmf',
        moduleName: CORE$1,
    };
    Identifiers$1.moduleDef = {
        name: 'mod',
        moduleName: CORE$1,
    };
    Identifiers$1.moduleProviderDef = {
        name: 'mpd',
        moduleName: CORE$1,
    };
    Identifiers$1.RegisterModuleFactoryFn = {
        name: 'registerModuleFactory',
        moduleName: CORE$1,
    };
    Identifiers$1.inject = { name: 'inject', moduleName: CORE$1 };
    Identifiers$1.directiveInject = { name: 'directiveInject', moduleName: CORE$1 };
    Identifiers$1.INJECTOR = { name: 'INJECTOR', moduleName: CORE$1 };
    Identifiers$1.Injector = { name: 'Injector', moduleName: CORE$1 };
    Identifiers$1.ViewEncapsulation = {
        name: 'ViewEncapsulation',
        moduleName: CORE$1,
    };
    Identifiers$1.ChangeDetectionStrategy = {
        name: 'ChangeDetectionStrategy',
        moduleName: CORE$1,
    };
    Identifiers$1.SecurityContext = {
        name: 'SecurityContext',
        moduleName: CORE$1,
    };
    Identifiers$1.LOCALE_ID = { name: 'LOCALE_ID', moduleName: CORE$1 };
    Identifiers$1.TRANSLATIONS_FORMAT = {
        name: 'TRANSLATIONS_FORMAT',
        moduleName: CORE$1,
    };
    Identifiers$1.inlineInterpolate = {
        name: 'inlineInterpolate',
        moduleName: CORE$1,
    };
    Identifiers$1.interpolate = { name: 'interpolate', moduleName: CORE$1 };
    Identifiers$1.EMPTY_ARRAY = { name: 'EMPTY_ARRAY', moduleName: CORE$1 };
    Identifiers$1.EMPTY_MAP = { name: 'EMPTY_MAP', moduleName: CORE$1 };
    Identifiers$1.Renderer = { name: 'Renderer', moduleName: CORE$1 };
    Identifiers$1.viewDef = { name: 'vid', moduleName: CORE$1 };
    Identifiers$1.elementDef = { name: 'eld', moduleName: CORE$1 };
    Identifiers$1.anchorDef = { name: 'and', moduleName: CORE$1 };
    Identifiers$1.textDef = { name: 'ted', moduleName: CORE$1 };
    Identifiers$1.directiveDef = { name: 'did', moduleName: CORE$1 };
    Identifiers$1.providerDef = { name: 'prd', moduleName: CORE$1 };
    Identifiers$1.queryDef = { name: 'qud', moduleName: CORE$1 };
    Identifiers$1.pureArrayDef = { name: 'pad', moduleName: CORE$1 };
    Identifiers$1.pureObjectDef = { name: 'pod', moduleName: CORE$1 };
    Identifiers$1.purePipeDef = { name: 'ppd', moduleName: CORE$1 };
    Identifiers$1.pipeDef = { name: 'pid', moduleName: CORE$1 };
    Identifiers$1.nodeValue = { name: 'nov', moduleName: CORE$1 };
    Identifiers$1.ngContentDef = { name: 'ncd', moduleName: CORE$1 };
    Identifiers$1.unwrapValue = { name: 'unv', moduleName: CORE$1 };
    Identifiers$1.createRendererType2 = { name: 'crt', moduleName: CORE$1 };
    // type only
    Identifiers$1.RendererType2 = {
        name: 'RendererType2',
        moduleName: CORE$1,
    };
    // type only
    Identifiers$1.ViewDefinition = {
        name: 'ViewDefinition',
        moduleName: CORE$1,
    };
    Identifiers$1.createComponentFactory = { name: 'ccf', moduleName: CORE$1 };

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class EventHandlerVars {
    }
    EventHandlerVars.event = variable('$event');
    class ConvertActionBindingResult {
        constructor(
        /**
         * Render2 compatible statements,
         */
        stmts, 
        /**
         * Variable name used with render2 compatible statements.
         */
        allowDefault) {
            this.stmts = stmts;
            this.allowDefault = allowDefault;
            /**
             * This is bit of a hack. It converts statements which render2 expects to statements which are
             * expected by render3.
             *
             * Example: `<div click="doSomething($event)">` will generate:
             *
             * Render3:
             * ```
             * const pd_b:any = ((<any>ctx.doSomething($event)) !== false);
             * return pd_b;
             * ```
             *
             * but render2 expects:
             * ```
             * return ctx.doSomething($event);
             * ```
             */
            // TODO(misko): remove this hack once we no longer support ViewEngine.
            this.render3Stmts = stmts.map((statement) => {
                if (statement instanceof DeclareVarStmt && statement.name == allowDefault.name &&
                    statement.value instanceof BinaryOperatorExpr) {
                    const lhs = statement.value.lhs;
                    return new ReturnStatement(lhs.value);
                }
                return statement;
            });
        }
    }
    /**
     * Converts the given expression AST into an executable output AST, assuming the expression is
     * used in an action binding (e.g. an event handler).
     */
    function convertActionBinding(localResolver, implicitReceiver, action, bindingId, interpolationFunction, baseSourceSpan, implicitReceiverAccesses, globals) {
        if (!localResolver) {
            localResolver = new DefaultLocalResolver(globals);
        }
        const actionWithoutBuiltins = convertPropertyBindingBuiltins({
            createLiteralArrayConverter: (argCount) => {
                // Note: no caching for literal arrays in actions.
                return (args) => literalArr(args);
            },
            createLiteralMapConverter: (keys) => {
                // Note: no caching for literal maps in actions.
                return (values) => {
                    const entries = keys.map((k, i) => ({
                        key: k.key,
                        value: values[i],
                        quoted: k.quoted,
                    }));
                    return literalMap(entries);
                };
            },
            createPipeConverter: (name) => {
                throw new Error(`Illegal State: Actions are not allowed to contain pipes. Pipe: ${name}`);
            }
        }, action);
        const visitor = new _AstToIrVisitor(localResolver, implicitReceiver, bindingId, interpolationFunction, baseSourceSpan, implicitReceiverAccesses);
        const actionStmts = [];
        flattenStatements(actionWithoutBuiltins.visit(visitor, _Mode.Statement), actionStmts);
        prependTemporaryDecls(visitor.temporaryCount, bindingId, actionStmts);
        if (visitor.usesImplicitReceiver) {
            localResolver.notifyImplicitReceiverUse();
        }
        const lastIndex = actionStmts.length - 1;
        let preventDefaultVar = null;
        if (lastIndex >= 0) {
            const lastStatement = actionStmts[lastIndex];
            const returnExpr = convertStmtIntoExpression(lastStatement);
            if (returnExpr) {
                // Note: We need to cast the result of the method call to dynamic,
                // as it might be a void method!
                preventDefaultVar = createPreventDefaultVar(bindingId);
                actionStmts[lastIndex] =
                    preventDefaultVar.set(returnExpr.cast(DYNAMIC_TYPE).notIdentical(literal(false)))
                        .toDeclStmt(null, [StmtModifier.Final]);
            }
        }
        return new ConvertActionBindingResult(actionStmts, preventDefaultVar);
    }
    function convertPropertyBindingBuiltins(converterFactory, ast) {
        return convertBuiltins(converterFactory, ast);
    }
    class ConvertPropertyBindingResult {
        constructor(stmts, currValExpr) {
            this.stmts = stmts;
            this.currValExpr = currValExpr;
        }
    }
    var BindingForm;
    (function (BindingForm) {
        // The general form of binding expression, supports all expressions.
        BindingForm[BindingForm["General"] = 0] = "General";
        // Try to generate a simple binding (no temporaries or statements)
        // otherwise generate a general binding
        BindingForm[BindingForm["TrySimple"] = 1] = "TrySimple";
        // Inlines assignment of temporaries into the generated expression. The result may still
        // have statements attached for declarations of temporary variables.
        // This is the only relevant form for Ivy, the other forms are only used in ViewEngine.
        BindingForm[BindingForm["Expression"] = 2] = "Expression";
    })(BindingForm || (BindingForm = {}));
    /**
     * Converts the given expression AST into an executable output AST, assuming the expression
     * is used in property binding. The expression has to be preprocessed via
     * `convertPropertyBindingBuiltins`.
     */
    function convertPropertyBinding(localResolver, implicitReceiver, expressionWithoutBuiltins, bindingId, form, interpolationFunction) {
        if (!localResolver) {
            localResolver = new DefaultLocalResolver();
        }
        const visitor = new _AstToIrVisitor(localResolver, implicitReceiver, bindingId, interpolationFunction);
        const outputExpr = expressionWithoutBuiltins.visit(visitor, _Mode.Expression);
        const stmts = getStatementsFromVisitor(visitor, bindingId);
        if (visitor.usesImplicitReceiver) {
            localResolver.notifyImplicitReceiverUse();
        }
        if (visitor.temporaryCount === 0 && form == BindingForm.TrySimple) {
            return new ConvertPropertyBindingResult([], outputExpr);
        }
        else if (form === BindingForm.Expression) {
            return new ConvertPropertyBindingResult(stmts, outputExpr);
        }
        const currValExpr = createCurrValueExpr(bindingId);
        stmts.push(currValExpr.set(outputExpr).toDeclStmt(DYNAMIC_TYPE, [StmtModifier.Final]));
        return new ConvertPropertyBindingResult(stmts, currValExpr);
    }
    /**
     * Given some expression, such as a binding or interpolation expression, and a context expression to
     * look values up on, visit each facet of the given expression resolving values from the context
     * expression such that a list of arguments can be derived from the found values that can be used as
     * arguments to an external update instruction.
     *
     * @param localResolver The resolver to use to look up expressions by name appropriately
     * @param contextVariableExpression The expression representing the context variable used to create
     * the final argument expressions
     * @param expressionWithArgumentsToExtract The expression to visit to figure out what values need to
     * be resolved and what arguments list to build.
     * @param bindingId A name prefix used to create temporary variable names if they're needed for the
     * arguments generated
     * @returns An array of expressions that can be passed as arguments to instruction expressions like
     * `o.importExpr(R3.propertyInterpolate).callFn(result)`
     */
    function convertUpdateArguments(localResolver, contextVariableExpression, expressionWithArgumentsToExtract, bindingId) {
        const visitor = new _AstToIrVisitor(localResolver, contextVariableExpression, bindingId, undefined);
        const outputExpr = expressionWithArgumentsToExtract.visit(visitor, _Mode.Expression);
        if (visitor.usesImplicitReceiver) {
            localResolver.notifyImplicitReceiverUse();
        }
        const stmts = getStatementsFromVisitor(visitor, bindingId);
        // Removing the first argument, because it was a length for ViewEngine, not Ivy.
        let args = outputExpr.args.slice(1);
        if (expressionWithArgumentsToExtract instanceof Interpolation) {
            // If we're dealing with an interpolation of 1 value with an empty prefix and suffix, reduce the
            // args returned to just the value, because we're going to pass it to a special instruction.
            const strings = expressionWithArgumentsToExtract.strings;
            if (args.length === 3 && strings[0] === '' && strings[1] === '') {
                // Single argument interpolate instructions.
                args = [args[1]];
            }
            else if (args.length >= 19) {
                // 19 or more arguments must be passed to the `interpolateV`-style instructions, which accept
                // an array of arguments
                args = [literalArr(args)];
            }
        }
        return { stmts, args };
    }
    function getStatementsFromVisitor(visitor, bindingId) {
        const stmts = [];
        for (let i = 0; i < visitor.temporaryCount; i++) {
            stmts.push(temporaryDeclaration(bindingId, i));
        }
        return stmts;
    }
    function convertBuiltins(converterFactory, ast) {
        const visitor = new _BuiltinAstConverter(converterFactory);
        return ast.visit(visitor);
    }
    function temporaryName(bindingId, temporaryNumber) {
        return `tmp_${bindingId}_${temporaryNumber}`;
    }
    function temporaryDeclaration(bindingId, temporaryNumber) {
        return new DeclareVarStmt(temporaryName(bindingId, temporaryNumber));
    }
    function prependTemporaryDecls(temporaryCount, bindingId, statements) {
        for (let i = temporaryCount - 1; i >= 0; i--) {
            statements.unshift(temporaryDeclaration(bindingId, i));
        }
    }
    var _Mode;
    (function (_Mode) {
        _Mode[_Mode["Statement"] = 0] = "Statement";
        _Mode[_Mode["Expression"] = 1] = "Expression";
    })(_Mode || (_Mode = {}));
    function ensureStatementMode(mode, ast) {
        if (mode !== _Mode.Statement) {
            throw new Error(`Expected a statement, but saw ${ast}`);
        }
    }
    function ensureExpressionMode(mode, ast) {
        if (mode !== _Mode.Expression) {
            throw new Error(`Expected an expression, but saw ${ast}`);
        }
    }
    function convertToStatementIfNeeded(mode, expr) {
        if (mode === _Mode.Statement) {
            return expr.toStmt();
        }
        else {
            return expr;
        }
    }
    class _BuiltinAstConverter extends AstTransformer {
        constructor(_converterFactory) {
            super();
            this._converterFactory = _converterFactory;
        }
        visitPipe(ast, context) {
            const args = [ast.exp, ...ast.args].map(ast => ast.visit(this, context));
            return new BuiltinFunctionCall(ast.span, ast.sourceSpan, args, this._converterFactory.createPipeConverter(ast.name, args.length));
        }
        visitLiteralArray(ast, context) {
            const args = ast.expressions.map(ast => ast.visit(this, context));
            return new BuiltinFunctionCall(ast.span, ast.sourceSpan, args, this._converterFactory.createLiteralArrayConverter(ast.expressions.length));
        }
        visitLiteralMap(ast, context) {
            const args = ast.values.map(ast => ast.visit(this, context));
            return new BuiltinFunctionCall(ast.span, ast.sourceSpan, args, this._converterFactory.createLiteralMapConverter(ast.keys));
        }
    }
    class _AstToIrVisitor {
        constructor(_localResolver, _implicitReceiver, bindingId, interpolationFunction, baseSourceSpan, implicitReceiverAccesses) {
            this._localResolver = _localResolver;
            this._implicitReceiver = _implicitReceiver;
            this.bindingId = bindingId;
            this.interpolationFunction = interpolationFunction;
            this.baseSourceSpan = baseSourceSpan;
            this.implicitReceiverAccesses = implicitReceiverAccesses;
            this._nodeMap = new Map();
            this._resultMap = new Map();
            this._currentTemporary = 0;
            this.temporaryCount = 0;
            this.usesImplicitReceiver = false;
        }
        visitUnary(ast, mode) {
            let op;
            switch (ast.operator) {
                case '+':
                    op = UnaryOperator.Plus;
                    break;
                case '-':
                    op = UnaryOperator.Minus;
                    break;
                default:
                    throw new Error(`Unsupported operator ${ast.operator}`);
            }
            return convertToStatementIfNeeded(mode, new UnaryOperatorExpr(op, this._visit(ast.expr, _Mode.Expression), undefined, this.convertSourceSpan(ast.span)));
        }
        visitBinary(ast, mode) {
            let op;
            switch (ast.operation) {
                case '+':
                    op = BinaryOperator.Plus;
                    break;
                case '-':
                    op = BinaryOperator.Minus;
                    break;
                case '*':
                    op = BinaryOperator.Multiply;
                    break;
                case '/':
                    op = BinaryOperator.Divide;
                    break;
                case '%':
                    op = BinaryOperator.Modulo;
                    break;
                case '&&':
                    op = BinaryOperator.And;
                    break;
                case '||':
                    op = BinaryOperator.Or;
                    break;
                case '==':
                    op = BinaryOperator.Equals;
                    break;
                case '!=':
                    op = BinaryOperator.NotEquals;
                    break;
                case '===':
                    op = BinaryOperator.Identical;
                    break;
                case '!==':
                    op = BinaryOperator.NotIdentical;
                    break;
                case '<':
                    op = BinaryOperator.Lower;
                    break;
                case '>':
                    op = BinaryOperator.Bigger;
                    break;
                case '<=':
                    op = BinaryOperator.LowerEquals;
                    break;
                case '>=':
                    op = BinaryOperator.BiggerEquals;
                    break;
                case '??':
                    return this.convertNullishCoalesce(ast, mode);
                default:
                    throw new Error(`Unsupported operation ${ast.operation}`);
            }
            return convertToStatementIfNeeded(mode, new BinaryOperatorExpr(op, this._visit(ast.left, _Mode.Expression), this._visit(ast.right, _Mode.Expression), undefined, this.convertSourceSpan(ast.span)));
        }
        visitChain(ast, mode) {
            ensureStatementMode(mode, ast);
            return this.visitAll(ast.expressions, mode);
        }
        visitConditional(ast, mode) {
            const value = this._visit(ast.condition, _Mode.Expression);
            return convertToStatementIfNeeded(mode, value.conditional(this._visit(ast.trueExp, _Mode.Expression), this._visit(ast.falseExp, _Mode.Expression), this.convertSourceSpan(ast.span)));
        }
        visitPipe(ast, mode) {
            throw new Error(`Illegal state: Pipes should have been converted into functions. Pipe: ${ast.name}`);
        }
        visitFunctionCall(ast, mode) {
            const convertedArgs = this.visitAll(ast.args, _Mode.Expression);
            let fnResult;
            if (ast instanceof BuiltinFunctionCall) {
                fnResult = ast.converter(convertedArgs);
            }
            else {
                fnResult = this._visit(ast.target, _Mode.Expression)
                    .callFn(convertedArgs, this.convertSourceSpan(ast.span));
            }
            return convertToStatementIfNeeded(mode, fnResult);
        }
        visitImplicitReceiver(ast, mode) {
            ensureExpressionMode(mode, ast);
            this.usesImplicitReceiver = true;
            return this._implicitReceiver;
        }
        visitThisReceiver(ast, mode) {
            return this.visitImplicitReceiver(ast, mode);
        }
        visitInterpolation(ast, mode) {
            ensureExpressionMode(mode, ast);
            const args = [literal(ast.expressions.length)];
            for (let i = 0; i < ast.strings.length - 1; i++) {
                args.push(literal(ast.strings[i]));
                args.push(this._visit(ast.expressions[i], _Mode.Expression));
            }
            args.push(literal(ast.strings[ast.strings.length - 1]));
            if (this.interpolationFunction) {
                return this.interpolationFunction(args);
            }
            return ast.expressions.length <= 9 ?
                importExpr(Identifiers$1.inlineInterpolate).callFn(args) :
                importExpr(Identifiers$1.interpolate).callFn([
                    args[0], literalArr(args.slice(1), undefined, this.convertSourceSpan(ast.span))
                ]);
        }
        visitKeyedRead(ast, mode) {
            const leftMostSafe = this.leftMostSafeNode(ast);
            if (leftMostSafe) {
                return this.convertSafeAccess(ast, leftMostSafe, mode);
            }
            else {
                return convertToStatementIfNeeded(mode, this._visit(ast.receiver, _Mode.Expression).key(this._visit(ast.key, _Mode.Expression)));
            }
        }
        visitKeyedWrite(ast, mode) {
            const obj = this._visit(ast.receiver, _Mode.Expression);
            const key = this._visit(ast.key, _Mode.Expression);
            const value = this._visit(ast.value, _Mode.Expression);
            if (obj === this._implicitReceiver) {
                this._localResolver.maybeRestoreView();
            }
            return convertToStatementIfNeeded(mode, obj.key(key).set(value));
        }
        visitLiteralArray(ast, mode) {
            throw new Error(`Illegal State: literal arrays should have been converted into functions`);
        }
        visitLiteralMap(ast, mode) {
            throw new Error(`Illegal State: literal maps should have been converted into functions`);
        }
        visitLiteralPrimitive(ast, mode) {
            // For literal values of null, undefined, true, or false allow type interference
            // to infer the type.
            const type = ast.value === null || ast.value === undefined || ast.value === true || ast.value === true ?
                INFERRED_TYPE :
                undefined;
            return convertToStatementIfNeeded(mode, literal(ast.value, type, this.convertSourceSpan(ast.span)));
        }
        _getLocal(name, receiver) {
            var _a;
            if (((_a = this._localResolver.globals) === null || _a === void 0 ? void 0 : _a.has(name)) && receiver instanceof ThisReceiver) {
                return null;
            }
            return this._localResolver.getLocal(name);
        }
        visitMethodCall(ast, mode) {
            if (ast.receiver instanceof ImplicitReceiver &&
                !(ast.receiver instanceof ThisReceiver) && ast.name === '$any') {
                const args = this.visitAll(ast.args, _Mode.Expression);
                if (args.length != 1) {
                    throw new Error(`Invalid call to $any, expected 1 argument but received ${args.length || 'none'}`);
                }
                return args[0].cast(DYNAMIC_TYPE, this.convertSourceSpan(ast.span));
            }
            const leftMostSafe = this.leftMostSafeNode(ast);
            if (leftMostSafe) {
                return this.convertSafeAccess(ast, leftMostSafe, mode);
            }
            else {
                const args = this.visitAll(ast.args, _Mode.Expression);
                const prevUsesImplicitReceiver = this.usesImplicitReceiver;
                let result = null;
                const receiver = this._visit(ast.receiver, _Mode.Expression);
                if (receiver === this._implicitReceiver) {
                    const varExpr = this._getLocal(ast.name, ast.receiver);
                    if (varExpr) {
                        // Restore the previous "usesImplicitReceiver" state since the implicit
                        // receiver has been replaced with a resolved local expression.
                        this.usesImplicitReceiver = prevUsesImplicitReceiver;
                        result = varExpr.callFn(args);
                        this.addImplicitReceiverAccess(ast.name);
                    }
                }
                if (result == null) {
                    result = receiver.callMethod(ast.name, args, this.convertSourceSpan(ast.span));
                }
                return convertToStatementIfNeeded(mode, result);
            }
        }
        visitPrefixNot(ast, mode) {
            return convertToStatementIfNeeded(mode, not(this._visit(ast.expression, _Mode.Expression)));
        }
        visitNonNullAssert(ast, mode) {
            return convertToStatementIfNeeded(mode, assertNotNull(this._visit(ast.expression, _Mode.Expression)));
        }
        visitPropertyRead(ast, mode) {
            const leftMostSafe = this.leftMostSafeNode(ast);
            if (leftMostSafe) {
                return this.convertSafeAccess(ast, leftMostSafe, mode);
            }
            else {
                let result = null;
                const prevUsesImplicitReceiver = this.usesImplicitReceiver;
                const receiver = this._visit(ast.receiver, _Mode.Expression);
                if (receiver === this._implicitReceiver) {
                    result = this._getLocal(ast.name, ast.receiver);
                    if (result) {
                        // Restore the previous "usesImplicitReceiver" state since the implicit
                        // receiver has been replaced with a resolved local expression.
                        this.usesImplicitReceiver = prevUsesImplicitReceiver;
                        this.addImplicitReceiverAccess(ast.name);
                    }
                }
                if (result == null) {
                    result = receiver.prop(ast.name);
                }
                return convertToStatementIfNeeded(mode, result);
            }
        }
        visitPropertyWrite(ast, mode) {
            const receiver = this._visit(ast.receiver, _Mode.Expression);
            const prevUsesImplicitReceiver = this.usesImplicitReceiver;
            let varExpr = null;
            if (receiver === this._implicitReceiver) {
                const localExpr = this._getLocal(ast.name, ast.receiver);
                if (localExpr) {
                    if (localExpr instanceof ReadPropExpr) {
                        // If the local variable is a property read expression, it's a reference
                        // to a 'context.property' value and will be used as the target of the
                        // write expression.
                        varExpr = localExpr;
                        // Restore the previous "usesImplicitReceiver" state since the implicit
                        // receiver has been replaced with a resolved local expression.
                        this.usesImplicitReceiver = prevUsesImplicitReceiver;
                        this.addImplicitReceiverAccess(ast.name);
                    }
                    else {
                        // Otherwise it's an error.
                        const receiver = ast.name;
                        const value = (ast.value instanceof PropertyRead) ? ast.value.name : undefined;
                        throw new Error(`Cannot assign value "${value}" to template variable "${receiver}". Template variables are read-only.`);
                    }
                }
            }
            // If no local expression could be produced, use the original receiver's
            // property as the target.
            if (varExpr === null) {
                varExpr = receiver.prop(ast.name);
            }
            return convertToStatementIfNeeded(mode, varExpr.set(this._visit(ast.value, _Mode.Expression)));
        }
        visitSafePropertyRead(ast, mode) {
            return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);
        }
        visitSafeMethodCall(ast, mode) {
            return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);
        }
        visitSafeKeyedRead(ast, mode) {
            return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);
        }
        visitAll(asts, mode) {
            return asts.map(ast => this._visit(ast, mode));
        }
        visitQuote(ast, mode) {
            throw new Error(`Quotes are not supported for evaluation!
        Statement: ${ast.uninterpretedExpression} located at ${ast.location}`);
        }
        _visit(ast, mode) {
            const result = this._resultMap.get(ast);
            if (result)
                return result;
            return (this._nodeMap.get(ast) || ast).visit(this, mode);
        }
        convertSafeAccess(ast, leftMostSafe, mode) {
            // If the expression contains a safe access node on the left it needs to be converted to
            // an expression that guards the access to the member by checking the receiver for blank. As
            // execution proceeds from left to right, the left most part of the expression must be guarded
            // first but, because member access is left associative, the right side of the expression is at
            // the top of the AST. The desired result requires lifting a copy of the left part of the
            // expression up to test it for blank before generating the unguarded version.
            // Consider, for example the following expression: a?.b.c?.d.e
            // This results in the ast:
            //         .
            //        / \
            //       ?.   e
            //      /  \
            //     .    d
            //    / \
            //   ?.  c
            //  /  \
            // a    b
            // The following tree should be generated:
            //
            //        /---- ? ----\
            //       /      |      \
            //     a   /--- ? ---\  null
            //        /     |     \
            //       .      .     null
            //      / \    / \
            //     .  c   .   e
            //    / \    / \
            //   a   b  .   d
            //         / \
            //        .   c
            //       / \
            //      a   b
            //
            // Notice that the first guard condition is the left hand of the left most safe access node
            // which comes in as leftMostSafe to this routine.
            let guardedExpression = this._visit(leftMostSafe.receiver, _Mode.Expression);
            let temporary = undefined;
            if (this.needsTemporaryInSafeAccess(leftMostSafe.receiver)) {
                // If the expression has method calls or pipes then we need to save the result into a
                // temporary variable to avoid calling stateful or impure code more than once.
                temporary = this.allocateTemporary();
                // Preserve the result in the temporary variable
                guardedExpression = temporary.set(guardedExpression);
                // Ensure all further references to the guarded expression refer to the temporary instead.
                this._resultMap.set(leftMostSafe.receiver, temporary);
            }
            const condition = guardedExpression.isBlank();
            // Convert the ast to an unguarded access to the receiver's member. The map will substitute
            // leftMostNode with its unguarded version in the call to `this.visit()`.
            if (leftMostSafe instanceof SafeMethodCall) {
                this._nodeMap.set(leftMostSafe, new MethodCall(leftMostSafe.span, leftMostSafe.sourceSpan, leftMostSafe.nameSpan, leftMostSafe.receiver, leftMostSafe.name, leftMostSafe.args, leftMostSafe.argumentSpan));
            }
            else if (leftMostSafe instanceof SafeKeyedRead) {
                this._nodeMap.set(leftMostSafe, new KeyedRead(leftMostSafe.span, leftMostSafe.sourceSpan, leftMostSafe.receiver, leftMostSafe.key));
            }
            else {
                this._nodeMap.set(leftMostSafe, new PropertyRead(leftMostSafe.span, leftMostSafe.sourceSpan, leftMostSafe.nameSpan, leftMostSafe.receiver, leftMostSafe.name));
            }
            // Recursively convert the node now without the guarded member access.
            const access = this._visit(ast, _Mode.Expression);
            // Remove the mapping. This is not strictly required as the converter only traverses each node
            // once but is safer if the conversion is changed to traverse the nodes more than once.
            this._nodeMap.delete(leftMostSafe);
            // If we allocated a temporary, release it.
            if (temporary) {
                this.releaseTemporary(temporary);
            }
            // Produce the conditional
            return convertToStatementIfNeeded(mode, condition.conditional(NULL_EXPR, access));
        }
        convertNullishCoalesce(ast, mode) {
            const left = this._visit(ast.left, _Mode.Expression);
            const right = this._visit(ast.right, _Mode.Expression);
            const temporary = this.allocateTemporary();
            this.releaseTemporary(temporary);
            // Generate the following expression. It is identical to how TS
            // transpiles binary expressions with a nullish coalescing operator.
            // let temp;
            // (temp = a) !== null && temp !== undefined ? temp : b;
            return convertToStatementIfNeeded(mode, temporary.set(left)
                .notIdentical(NULL_EXPR)
                .and(temporary.notIdentical(literal(undefined)))
                .conditional(temporary, right));
        }
        // Given an expression of the form a?.b.c?.d.e then the left most safe node is
        // the (a?.b). The . and ?. are left associative thus can be rewritten as:
        // ((((a?.c).b).c)?.d).e. This returns the most deeply nested safe read or
        // safe method call as this needs to be transformed initially to:
        //   a == null ? null : a.c.b.c?.d.e
        // then to:
        //   a == null ? null : a.b.c == null ? null : a.b.c.d.e
        leftMostSafeNode(ast) {
            const visit = (visitor, ast) => {
                return (this._nodeMap.get(ast) || ast).visit(visitor);
            };
            return ast.visit({
                visitUnary(ast) {
                    return null;
                },
                visitBinary(ast) {
                    return null;
                },
                visitChain(ast) {
                    return null;
                },
                visitConditional(ast) {
                    return null;
                },
                visitFunctionCall(ast) {
                    return null;
                },
                visitImplicitReceiver(ast) {
                    return null;
                },
                visitThisReceiver(ast) {
                    return null;
                },
                visitInterpolation(ast) {
                    return null;
                },
                visitKeyedRead(ast) {
                    return visit(this, ast.receiver);
                },
                visitKeyedWrite(ast) {
                    return null;
                },
                visitLiteralArray(ast) {
                    return null;
                },
                visitLiteralMap(ast) {
                    return null;
                },
                visitLiteralPrimitive(ast) {
                    return null;
                },
                visitMethodCall(ast) {
                    return visit(this, ast.receiver);
                },
                visitPipe(ast) {
                    return null;
                },
                visitPrefixNot(ast) {
                    return null;
                },
                visitNonNullAssert(ast) {
                    return null;
                },
                visitPropertyRead(ast) {
                    return visit(this, ast.receiver);
                },
                visitPropertyWrite(ast) {
                    return null;
                },
                visitQuote(ast) {
                    return null;
                },
                visitSafeMethodCall(ast) {
                    return visit(this, ast.receiver) || ast;
                },
                visitSafePropertyRead(ast) {
                    return visit(this, ast.receiver) || ast;
                },
                visitSafeKeyedRead(ast) {
                    return visit(this, ast.receiver) || ast;
                }
            });
        }
        // Returns true of the AST includes a method or a pipe indicating that, if the
        // expression is used as the target of a safe property or method access then
        // the expression should be stored into a temporary variable.
        needsTemporaryInSafeAccess(ast) {
            const visit = (visitor, ast) => {
                return ast && (this._nodeMap.get(ast) || ast).visit(visitor);
            };
            const visitSome = (visitor, ast) => {
                return ast.some(ast => visit(visitor, ast));
            };
            return ast.visit({
                visitUnary(ast) {
                    return visit(this, ast.expr);
                },
                visitBinary(ast) {
                    return visit(this, ast.left) || visit(this, ast.right);
                },
                visitChain(ast) {
                    return false;
                },
                visitConditional(ast) {
                    return visit(this, ast.condition) || visit(this, ast.trueExp) || visit(this, ast.falseExp);
                },
                visitFunctionCall(ast) {
                    return true;
                },
                visitImplicitReceiver(ast) {
                    return false;
                },
                visitThisReceiver(ast) {
                    return false;
                },
                visitInterpolation(ast) {
                    return visitSome(this, ast.expressions);
                },
                visitKeyedRead(ast) {
                    return false;
                },
                visitKeyedWrite(ast) {
                    return false;
                },
                visitLiteralArray(ast) {
                    return true;
                },
                visitLiteralMap(ast) {
                    return true;
                },
                visitLiteralPrimitive(ast) {
                    return false;
                },
                visitMethodCall(ast) {
                    return true;
                },
                visitPipe(ast) {
                    return true;
                },
                visitPrefixNot(ast) {
                    return visit(this, ast.expression);
                },
                visitNonNullAssert(ast) {
                    return visit(this, ast.expression);
                },
                visitPropertyRead(ast) {
                    return false;
                },
                visitPropertyWrite(ast) {
                    return false;
                },
                visitQuote(ast) {
                    return false;
                },
                visitSafeMethodCall(ast) {
                    return true;
                },
                visitSafePropertyRead(ast) {
                    return false;
                },
                visitSafeKeyedRead(ast) {
                    return false;
                }
            });
        }
        allocateTemporary() {
            const tempNumber = this._currentTemporary++;
            this.temporaryCount = Math.max(this._currentTemporary, this.temporaryCount);
            return new ReadVarExpr(temporaryName(this.bindingId, tempNumber));
        }
        releaseTemporary(temporary) {
            this._currentTemporary--;
            if (temporary.name != temporaryName(this.bindingId, this._currentTemporary)) {
                throw new Error(`Temporary ${temporary.name} released out of order`);
            }
        }
        /**
         * Creates an absolute `ParseSourceSpan` from the relative `ParseSpan`.
         *
         * `ParseSpan` objects are relative to the start of the expression.
         * This method converts these to full `ParseSourceSpan` objects that
         * show where the span is within the overall source file.
         *
         * @param span the relative span to convert.
         * @returns a `ParseSourceSpan` for the given span or null if no
         * `baseSourceSpan` was provided to this class.
         */
        convertSourceSpan(span) {
            if (this.baseSourceSpan) {
                const start = this.baseSourceSpan.start.moveBy(span.start);
                const end = this.baseSourceSpan.start.moveBy(span.end);
                const fullStart = this.baseSourceSpan.fullStart.moveBy(span.start);
                return new ParseSourceSpan(start, end, fullStart);
            }
            else {
                return null;
            }
        }
        /** Adds the name of an AST to the list of implicit receiver accesses. */
        addImplicitReceiverAccess(name) {
            if (this.implicitReceiverAccesses) {
                this.implicitReceiverAccesses.add(name);
            }
        }
    }
    function flattenStatements(arg, output) {
        if (Array.isArray(arg)) {
            arg.forEach((entry) => flattenStatements(entry, output));
        }
        else {
            output.push(arg);
        }
    }
    class DefaultLocalResolver {
        constructor(globals) {
            this.globals = globals;
        }
        notifyImplicitReceiverUse() { }
        maybeRestoreView() { }
        getLocal(name) {
            if (name === EventHandlerVars.event.name) {
                return EventHandlerVars.event;
            }
            return null;
        }
    }
    function createCurrValueExpr(bindingId) {
        return variable(`currVal_${bindingId}`); // fix syntax highlighting: `
    }
    function createPreventDefaultVar(bindingId) {
        return variable(`pd_${bindingId}`);
    }
    function convertStmtIntoExpression(stmt) {
        if (stmt instanceof ExpressionStatement) {
            return stmt.expr;
        }
        else if (stmt instanceof ReturnStatement) {
            return stmt.value;
        }
        return null;
    }
    class BuiltinFunctionCall extends FunctionCall {
        constructor(span, sourceSpan, args, converter) {
            super(span, sourceSpan, null, args);
            this.converter = converter;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * This file is a port of shadowCSS from webcomponents.js to TypeScript.
     *
     * Please make sure to keep to edits in sync with the source file.
     *
     * Source:
     * https://github.com/webcomponents/webcomponentsjs/blob/4efecd7e0e/src/ShadowCSS/ShadowCSS.js
     *
     * The original file level comment is reproduced below
     */
    /*
      This is a limited shim for ShadowDOM css styling.
      https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html#styles

      The intention here is to support only the styling features which can be
      relatively simply implemented. The goal is to allow users to avoid the
      most obvious pitfalls and do so without compromising performance significantly.
      For ShadowDOM styling that's not covered here, a set of best practices
      can be provided that should allow users to accomplish more complex styling.

      The following is a list of specific ShadowDOM styling features and a brief
      discussion of the approach used to shim.

      Shimmed features:

      * :host, :host-context: ShadowDOM allows styling of the shadowRoot's host
      element using the :host rule. To shim this feature, the :host styles are
      reformatted and prefixed with a given scope name and promoted to a
      document level stylesheet.
      For example, given a scope name of .foo, a rule like this:

        :host {
            background: red;
          }
        }

      becomes:

        .foo {
          background: red;
        }

      * encapsulation: Styles defined within ShadowDOM, apply only to
      dom inside the ShadowDOM. Polymer uses one of two techniques to implement
      this feature.

      By default, rules are prefixed with the host element tag name
      as a descendant selector. This ensures styling does not leak out of the 'top'
      of the element's ShadowDOM. For example,

      div {
          font-weight: bold;
        }

      becomes:

      x-foo div {
          font-weight: bold;
        }

      becomes:


      Alternatively, if WebComponents.ShadowCSS.strictStyling is set to true then
      selectors are scoped by adding an attribute selector suffix to each
      simple selector that contains the host element tag name. Each element
      in the element's ShadowDOM template is also given the scope attribute.
      Thus, these rules match only elements that have the scope attribute.
      For example, given a scope name of x-foo, a rule like this:

        div {
          font-weight: bold;
        }

      becomes:

        div[x-foo] {
          font-weight: bold;
        }

      Note that elements that are dynamically added to a scope must have the scope
      selector added to them manually.

      * upper/lower bound encapsulation: Styles which are defined outside a
      shadowRoot should not cross the ShadowDOM boundary and should not apply
      inside a shadowRoot.

      This styling behavior is not emulated. Some possible ways to do this that
      were rejected due to complexity and/or performance concerns include: (1) reset
      every possible property for every possible selector for a given scope name;
      (2) re-implement css in javascript.

      As an alternative, users should make sure to use selectors
      specific to the scope in which they are working.

      * ::distributed: This behavior is not emulated. It's often not necessary
      to style the contents of a specific insertion point and instead, descendants
      of the host element can be styled selectively. Users can also create an
      extra node around an insertion point and style that node's contents
      via descendent selectors. For example, with a shadowRoot like this:

        <style>
          ::content(div) {
            background: red;
          }
        </style>
        <content></content>

      could become:

        <style>
          / *@polyfill .content-container div * /
          ::content(div) {
            background: red;
          }
        </style>
        <div class="content-container">
          <content></content>
        </div>

      Note the use of @polyfill in the comment above a ShadowDOM specific style
      declaration. This is a directive to the styling shim to use the selector
      in comments in lieu of the next selector when running under polyfill.
    */
    class ShadowCss {
        constructor() {
            this.strictStyling = true;
        }
        /*
         * Shim some cssText with the given selector. Returns cssText that can
         * be included in the document via WebComponents.ShadowCSS.addCssToDocument(css).
         *
         * When strictStyling is true:
         * - selector is the attribute added to all elements inside the host,
         * - hostSelector is the attribute added to the host itself.
         */
        shimCssText(cssText, selector, hostSelector = '') {
            const commentsWithHash = extractCommentsWithHash(cssText);
            cssText = stripComments(cssText);
            cssText = this._insertDirectives(cssText);
            const scopedCssText = this._scopeCssText(cssText, selector, hostSelector);
            return [scopedCssText, ...commentsWithHash].join('\n');
        }
        _insertDirectives(cssText) {
            cssText = this._insertPolyfillDirectivesInCssText(cssText);
            return this._insertPolyfillRulesInCssText(cssText);
        }
        /*
         * Process styles to convert native ShadowDOM rules that will trip
         * up the css parser; we rely on decorating the stylesheet with inert rules.
         *
         * For example, we convert this rule:
         *
         * polyfill-next-selector { content: ':host menu-item'; }
         * ::content menu-item {
         *
         * to this:
         *
         * scopeName menu-item {
         *
         **/
        _insertPolyfillDirectivesInCssText(cssText) {
            // Difference with webcomponents.js: does not handle comments
            return cssText.replace(_cssContentNextSelectorRe, function (...m) {
                return m[2] + '{';
            });
        }
        /*
         * Process styles to add rules which will only apply under the polyfill
         *
         * For example, we convert this rule:
         *
         * polyfill-rule {
         *   content: ':host menu-item';
         * ...
         * }
         *
         * to this:
         *
         * scopeName menu-item {...}
         *
         **/
        _insertPolyfillRulesInCssText(cssText) {
            // Difference with webcomponents.js: does not handle comments
            return cssText.replace(_cssContentRuleRe, (...m) => {
                const rule = m[0].replace(m[1], '').replace(m[2], '');
                return m[4] + rule;
            });
        }
        /* Ensure styles are scoped. Pseudo-scoping takes a rule like:
         *
         *  .foo {... }
         *
         *  and converts this to
         *
         *  scopeName .foo { ... }
         */
        _scopeCssText(cssText, scopeSelector, hostSelector) {
            const unscopedRules = this._extractUnscopedRulesFromCssText(cssText);
            // replace :host and :host-context -shadowcsshost and -shadowcsshost respectively
            cssText = this._insertPolyfillHostInCssText(cssText);
            cssText = this._convertColonHost(cssText);
            cssText = this._convertColonHostContext(cssText);
            cssText = this._convertShadowDOMSelectors(cssText);
            if (scopeSelector) {
                cssText = this._scopeSelectors(cssText, scopeSelector, hostSelector);
            }
            cssText = cssText + '\n' + unscopedRules;
            return cssText.trim();
        }
        /*
         * Process styles to add rules which will only apply under the polyfill
         * and do not process via CSSOM. (CSSOM is destructive to rules on rare
         * occasions, e.g. -webkit-calc on Safari.)
         * For example, we convert this rule:
         *
         * @polyfill-unscoped-rule {
         *   content: 'menu-item';
         * ... }
         *
         * to this:
         *
         * menu-item {...}
         *
         **/
        _extractUnscopedRulesFromCssText(cssText) {
            // Difference with webcomponents.js: does not handle comments
            let r = '';
            let m;
            _cssContentUnscopedRuleRe.lastIndex = 0;
            while ((m = _cssContentUnscopedRuleRe.exec(cssText)) !== null) {
                const rule = m[0].replace(m[2], '').replace(m[1], m[4]);
                r += rule + '\n\n';
            }
            return r;
        }
        /*
         * convert a rule like :host(.foo) > .bar { }
         *
         * to
         *
         * .foo<scopeName> > .bar
         */
        _convertColonHost(cssText) {
            return cssText.replace(_cssColonHostRe, (_, hostSelectors, otherSelectors) => {
                if (hostSelectors) {
                    const convertedSelectors = [];
                    const hostSelectorArray = hostSelectors.split(',').map(p => p.trim());
                    for (const hostSelector of hostSelectorArray) {
                        if (!hostSelector)
                            break;
                        const convertedSelector = _polyfillHostNoCombinator + hostSelector.replace(_polyfillHost, '') + otherSelectors;
                        convertedSelectors.push(convertedSelector);
                    }
                    return convertedSelectors.join(',');
                }
                else {
                    return _polyfillHostNoCombinator + otherSelectors;
                }
            });
        }
        /*
         * convert a rule like :host-context(.foo) > .bar { }
         *
         * to
         *
         * .foo<scopeName> > .bar, .foo <scopeName> > .bar { }
         *
         * and
         *
         * :host-context(.foo:host) .bar { ... }
         *
         * to
         *
         * .foo<scopeName> .bar { ... }
         */
        _convertColonHostContext(cssText) {
            return cssText.replace(_cssColonHostContextReGlobal, selectorText => {
                // We have captured a selector that contains a `:host-context` rule.
                var _a;
                // For backward compatibility `:host-context` may contain a comma separated list of selectors.
                // Each context selector group will contain a list of host-context selectors that must match
                // an ancestor of the host.
                // (Normally `contextSelectorGroups` will only contain a single array of context selectors.)
                const contextSelectorGroups = [[]];
                // There may be more than `:host-context` in this selector so `selectorText` could look like:
                // `:host-context(.one):host-context(.two)`.
                // Execute `_cssColonHostContextRe` over and over until we have extracted all the
                // `:host-context` selectors from this selector.
                let match;
                while (match = _cssColonHostContextRe.exec(selectorText)) {
                    // `match` = [':host-context(<selectors>)<rest>', <selectors>, <rest>]
                    // The `<selectors>` could actually be a comma separated list: `:host-context(.one, .two)`.
                    const newContextSelectors = ((_a = match[1]) !== null && _a !== void 0 ? _a : '').trim().split(',').map(m => m.trim()).filter(m => m !== '');
                    // We must duplicate the current selector group for each of these new selectors.
                    // For example if the current groups are:
                    // ```
                    // [
                    //   ['a', 'b', 'c'],
                    //   ['x', 'y', 'z'],
                    // ]
                    // ```
                    // And we have a new set of comma separated selectors: `:host-context(m,n)` then the new
                    // groups are:
                    // ```
                    // [
                    //   ['a', 'b', 'c', 'm'],
                    //   ['x', 'y', 'z', 'm'],
                    //   ['a', 'b', 'c', 'n'],
                    //   ['x', 'y', 'z', 'n'],
                    // ]
                    // ```
                    const contextSelectorGroupsLength = contextSelectorGroups.length;
                    repeatGroups(contextSelectorGroups, newContextSelectors.length);
                    for (let i = 0; i < newContextSelectors.length; i++) {
                        for (let j = 0; j < contextSelectorGroupsLength; j++) {
                            contextSelectorGroups[j + (i * contextSelectorGroupsLength)].push(newContextSelectors[i]);
                        }
                    }
                    // Update the `selectorText` and see repeat to see if there are more `:host-context`s.
                    selectorText = match[2];
                }
                // The context selectors now must be combined with each other to capture all the possible
                // selectors that `:host-context` can match. See `combineHostContextSelectors()` for more
                // info about how this is done.
                return contextSelectorGroups
                    .map(contextSelectors => combineHostContextSelectors(contextSelectors, selectorText))
                    .join(', ');
            });
        }
        /*
         * Convert combinators like ::shadow and pseudo-elements like ::content
         * by replacing with space.
         */
        _convertShadowDOMSelectors(cssText) {
            return _shadowDOMSelectorsRe.reduce((result, pattern) => result.replace(pattern, ' '), cssText);
        }
        // change a selector like 'div' to 'name div'
        _scopeSelectors(cssText, scopeSelector, hostSelector) {
            return processRules(cssText, (rule) => {
                let selector = rule.selector;
                let content = rule.content;
                if (rule.selector[0] !== '@') {
                    selector =
                        this._scopeSelector(rule.selector, scopeSelector, hostSelector, this.strictStyling);
                }
                else if (rule.selector.startsWith('@media') || rule.selector.startsWith('@supports') ||
                    rule.selector.startsWith('@document')) {
                    content = this._scopeSelectors(rule.content, scopeSelector, hostSelector);
                }
                else if (rule.selector.startsWith('@font-face') || rule.selector.startsWith('@page')) {
                    content = this._stripScopingSelectors(rule.content);
                }
                return new CssRule(selector, content);
            });
        }
        /**
         * Handle a css text that is within a rule that should not contain scope selectors by simply
         * removing them! An example of such a rule is `@font-face`.
         *
         * `@font-face` rules cannot contain nested selectors. Nor can they be nested under a selector.
         * Normally this would be a syntax error by the author of the styles. But in some rare cases, such
         * as importing styles from a library, and applying `:host ::ng-deep` to the imported styles, we
         * can end up with broken css if the imported styles happen to contain @font-face rules.
         *
         * For example:
         *
         * ```
         * :host ::ng-deep {
         *   import 'some/lib/containing/font-face';
         * }
         *
         * Similar logic applies to `@page` rules which can contain a particular set of properties,
         * as well as some specific at-rules. Since they can't be encapsulated, we have to strip
         * any scoping selectors from them. For more information: https://www.w3.org/TR/css-page-3
         * ```
         */
        _stripScopingSelectors(cssText) {
            return processRules(cssText, rule => {
                const selector = rule.selector.replace(_shadowDeepSelectors, ' ')
                    .replace(_polyfillHostNoCombinatorRe, ' ');
                return new CssRule(selector, rule.content);
            });
        }
        _scopeSelector(selector, scopeSelector, hostSelector, strict) {
            return selector.split(',')
                .map(part => part.trim().split(_shadowDeepSelectors))
                .map((deepParts) => {
                const [shallowPart, ...otherParts] = deepParts;
                const applyScope = (shallowPart) => {
                    if (this._selectorNeedsScoping(shallowPart, scopeSelector)) {
                        return strict ?
                            this._applyStrictSelectorScope(shallowPart, scopeSelector, hostSelector) :
                            this._applySelectorScope(shallowPart, scopeSelector, hostSelector);
                    }
                    else {
                        return shallowPart;
                    }
                };
                return [applyScope(shallowPart), ...otherParts].join(' ');
            })
                .join(', ');
        }
        _selectorNeedsScoping(selector, scopeSelector) {
            const re = this._makeScopeMatcher(scopeSelector);
            return !re.test(selector);
        }
        _makeScopeMatcher(scopeSelector) {
            const lre = /\[/g;
            const rre = /\]/g;
            scopeSelector = scopeSelector.replace(lre, '\\[').replace(rre, '\\]');
            return new RegExp('^(' + scopeSelector + ')' + _selectorReSuffix, 'm');
        }
        _applySelectorScope(selector, scopeSelector, hostSelector) {
            // Difference from webcomponents.js: scopeSelector could not be an array
            return this._applySimpleSelectorScope(selector, scopeSelector, hostSelector);
        }
        // scope via name and [is=name]
        _applySimpleSelectorScope(selector, scopeSelector, hostSelector) {
            // In Android browser, the lastIndex is not reset when the regex is used in String.replace()
            _polyfillHostRe.lastIndex = 0;
            if (_polyfillHostRe.test(selector)) {
                const replaceBy = this.strictStyling ? `[${hostSelector}]` : scopeSelector;
                return selector
                    .replace(_polyfillHostNoCombinatorRe, (hnc, selector) => {
                    return selector.replace(/([^:]*)(:*)(.*)/, (_, before, colon, after) => {
                        return before + replaceBy + colon + after;
                    });
                })
                    .replace(_polyfillHostRe, replaceBy + ' ');
            }
            return scopeSelector + ' ' + selector;
        }
        // return a selector with [name] suffix on each simple selector
        // e.g. .foo.bar > .zot becomes .foo[name].bar[name] > .zot[name]  /** @internal */
        _applyStrictSelectorScope(selector, scopeSelector, hostSelector) {
            const isRe = /\[is=([^\]]*)\]/g;
            scopeSelector = scopeSelector.replace(isRe, (_, ...parts) => parts[0]);
            const attrName = '[' + scopeSelector + ']';
            const _scopeSelectorPart = (p) => {
                let scopedP = p.trim();
                if (!scopedP) {
                    return '';
                }
                if (p.indexOf(_polyfillHostNoCombinator) > -1) {
                    scopedP = this._applySimpleSelectorScope(p, scopeSelector, hostSelector);
                }
                else {
                    // remove :host since it should be unnecessary
                    const t = p.replace(_polyfillHostRe, '');
                    if (t.length > 0) {
                        const matches = t.match(/([^:]*)(:*)(.*)/);
                        if (matches) {
                            scopedP = matches[1] + attrName + matches[2] + matches[3];
                        }
                    }
                }
                return scopedP;
            };
            const safeContent = new SafeSelector(selector);
            selector = safeContent.content();
            let scopedSelector = '';
            let startIndex = 0;
            let res;
            const sep = /( |>|\+|~(?!=))\s*/g;
            // If a selector appears before :host it should not be shimmed as it
            // matches on ancestor elements and not on elements in the host's shadow
            // `:host-context(div)` is transformed to
            // `-shadowcsshost-no-combinatordiv, div -shadowcsshost-no-combinator`
            // the `div` is not part of the component in the 2nd selectors and should not be scoped.
            // Historically `component-tag:host` was matching the component so we also want to preserve
            // this behavior to avoid breaking legacy apps (it should not match).
            // The behavior should be:
            // - `tag:host` -> `tag[h]` (this is to avoid breaking legacy apps, should not match anything)
            // - `tag :host` -> `tag [h]` (`tag` is not scoped because it's considered part of a
            //   `:host-context(tag)`)
            const hasHost = selector.indexOf(_polyfillHostNoCombinator) > -1;
            // Only scope parts after the first `-shadowcsshost-no-combinator` when it is present
            let shouldScope = !hasHost;
            while ((res = sep.exec(selector)) !== null) {
                const separator = res[1];
                const part = selector.slice(startIndex, res.index).trim();
                shouldScope = shouldScope || part.indexOf(_polyfillHostNoCombinator) > -1;
                const scopedPart = shouldScope ? _scopeSelectorPart(part) : part;
                scopedSelector += `${scopedPart} ${separator} `;
                startIndex = sep.lastIndex;
            }
            const part = selector.substring(startIndex);
            shouldScope = shouldScope || part.indexOf(_polyfillHostNoCombinator) > -1;
            scopedSelector += shouldScope ? _scopeSelectorPart(part) : part;
            // replace the placeholders with their original values
            return safeContent.restore(scopedSelector);
        }
        _insertPolyfillHostInCssText(selector) {
            return selector.replace(_colonHostContextRe, _polyfillHostContext)
                .replace(_colonHostRe, _polyfillHost);
        }
    }
    class SafeSelector {
        constructor(selector) {
            this.placeholders = [];
            this.index = 0;
            // Replaces attribute selectors with placeholders.
            // The WS in [attr="va lue"] would otherwise be interpreted as a selector separator.
            selector = this._escapeRegexMatches(selector, /(\[[^\]]*\])/g);
            // CSS allows for certain special characters to be used in selectors if they're escaped.
            // E.g. `.foo:blue` won't match a class called `foo:blue`, because the colon denotes a
            // pseudo-class, but writing `.foo\:blue` will match, because the colon was escaped.
            // Replace all escape sequences (`\` followed by a character) with a placeholder so
            // that our handling of pseudo-selectors doesn't mess with them.
            selector = this._escapeRegexMatches(selector, /(\\.)/g);
            // Replaces the expression in `:nth-child(2n + 1)` with a placeholder.
            // WS and "+" would otherwise be interpreted as selector separators.
            this._content = selector.replace(/(:nth-[-\w]+)(\([^)]+\))/g, (_, pseudo, exp) => {
                const replaceBy = `__ph-${this.index}__`;
                this.placeholders.push(exp);
                this.index++;
                return pseudo + replaceBy;
            });
        }
        restore(content) {
            return content.replace(/__ph-(\d+)__/g, (_ph, index) => this.placeholders[+index]);
        }
        content() {
            return this._content;
        }
        /**
         * Replaces all of the substrings that match a regex within a
         * special string (e.g. `__ph-0__`, `__ph-1__`, etc).
         */
        _escapeRegexMatches(content, pattern) {
            return content.replace(pattern, (_, keep) => {
                const replaceBy = `__ph-${this.index}__`;
                this.placeholders.push(keep);
                this.index++;
                return replaceBy;
            });
        }
    }
    const _cssContentNextSelectorRe = /polyfill-next-selector[^}]*content:[\s]*?(['"])(.*?)\1[;\s]*}([^{]*?){/gim;
    const _cssContentRuleRe = /(polyfill-rule)[^}]*(content:[\s]*(['"])(.*?)\3)[;\s]*[^}]*}/gim;
    const _cssContentUnscopedRuleRe = /(polyfill-unscoped-rule)[^}]*(content:[\s]*(['"])(.*?)\3)[;\s]*[^}]*}/gim;
    const _polyfillHost = '-shadowcsshost';
    // note: :host-context pre-processed to -shadowcsshostcontext.
    const _polyfillHostContext = '-shadowcsscontext';
    const _parenSuffix = '(?:\\((' +
        '(?:\\([^)(]*\\)|[^)(]*)+?' +
        ')\\))?([^,{]*)';
    const _cssColonHostRe = new RegExp(_polyfillHost + _parenSuffix, 'gim');
    const _cssColonHostContextReGlobal = new RegExp(_polyfillHostContext + _parenSuffix, 'gim');
    const _cssColonHostContextRe = new RegExp(_polyfillHostContext + _parenSuffix, 'im');
    const _polyfillHostNoCombinator = _polyfillHost + '-no-combinator';
    const _polyfillHostNoCombinatorRe = /-shadowcsshost-no-combinator([^\s]*)/;
    const _shadowDOMSelectorsRe = [
        /::shadow/g,
        /::content/g,
        // Deprecated selectors
        /\/shadow-deep\//g,
        /\/shadow\//g,
    ];
    // The deep combinator is deprecated in the CSS spec
    // Support for `>>>`, `deep`, `::ng-deep` is then also deprecated and will be removed in the future.
    // see https://github.com/angular/angular/pull/17677
    const _shadowDeepSelectors = /(?:>>>)|(?:\/deep\/)|(?:::ng-deep)/g;
    const _selectorReSuffix = '([>\\s~+[.,{:][\\s\\S]*)?$';
    const _polyfillHostRe = /-shadowcsshost/gim;
    const _colonHostRe = /:host/gim;
    const _colonHostContextRe = /:host-context/gim;
    const _commentRe = /\/\*[\s\S]*?\*\//g;
    function stripComments(input) {
        return input.replace(_commentRe, '');
    }
    const _commentWithHashRe = /\/\*\s*#\s*source(Mapping)?URL=[\s\S]+?\*\//g;
    function extractCommentsWithHash(input) {
        return input.match(_commentWithHashRe) || [];
    }
    const BLOCK_PLACEHOLDER = '%BLOCK%';
    const QUOTE_PLACEHOLDER = '%QUOTED%';
    const _ruleRe = /(\s*)([^;\{\}]+?)(\s*)((?:{%BLOCK%}?\s*;?)|(?:\s*;))/g;
    const _quotedRe = /%QUOTED%/g;
    const CONTENT_PAIRS = new Map([['{', '}']]);
    const QUOTE_PAIRS = new Map([[`"`, `"`], [`'`, `'`]]);
    class CssRule {
        constructor(selector, content) {
            this.selector = selector;
            this.content = content;
        }
    }
    function processRules(input, ruleCallback) {
        const inputWithEscapedQuotes = escapeBlocks(input, QUOTE_PAIRS, QUOTE_PLACEHOLDER);
        const inputWithEscapedBlocks = escapeBlocks(inputWithEscapedQuotes.escapedString, CONTENT_PAIRS, BLOCK_PLACEHOLDER);
        let nextBlockIndex = 0;
        let nextQuoteIndex = 0;
        return inputWithEscapedBlocks.escapedString
            .replace(_ruleRe, (...m) => {
            const selector = m[2];
            let content = '';
            let suffix = m[4];
            let contentPrefix = '';
            if (suffix && suffix.startsWith('{' + BLOCK_PLACEHOLDER)) {
                content = inputWithEscapedBlocks.blocks[nextBlockIndex++];
                suffix = suffix.substring(BLOCK_PLACEHOLDER.length + 1);
                contentPrefix = '{';
            }
            const rule = ruleCallback(new CssRule(selector, content));
            return `${m[1]}${rule.selector}${m[3]}${contentPrefix}${rule.content}${suffix}`;
        })
            .replace(_quotedRe, () => inputWithEscapedQuotes.blocks[nextQuoteIndex++]);
    }
    class StringWithEscapedBlocks {
        constructor(escapedString, blocks) {
            this.escapedString = escapedString;
            this.blocks = blocks;
        }
    }
    function escapeBlocks(input, charPairs, placeholder) {
        const resultParts = [];
        const escapedBlocks = [];
        let openCharCount = 0;
        let nonBlockStartIndex = 0;
        let blockStartIndex = -1;
        let openChar;
        let closeChar;
        for (let i = 0; i < input.length; i++) {
            const char = input[i];
            if (char === '\\') {
                i++;
            }
            else if (char === closeChar) {
                openCharCount--;
                if (openCharCount === 0) {
                    escapedBlocks.push(input.substring(blockStartIndex, i));
                    resultParts.push(placeholder);
                    nonBlockStartIndex = i;
                    blockStartIndex = -1;
                    openChar = closeChar = undefined;
                }
            }
            else if (char === openChar) {
                openCharCount++;
            }
            else if (openCharCount === 0 && charPairs.has(char)) {
                openChar = char;
                closeChar = charPairs.get(char);
                openCharCount = 1;
                blockStartIndex = i + 1;
                resultParts.push(input.substring(nonBlockStartIndex, blockStartIndex));
            }
        }
        if (blockStartIndex !== -1) {
            escapedBlocks.push(input.substring(blockStartIndex));
            resultParts.push(placeholder);
        }
        else {
            resultParts.push(input.substring(nonBlockStartIndex));
        }
        return new StringWithEscapedBlocks(resultParts.join(''), escapedBlocks);
    }
    /**
     * Combine the `contextSelectors` with the `hostMarker` and the `otherSelectors`
     * to create a selector that matches the same as `:host-context()`.
     *
     * Given a single context selector `A` we need to output selectors that match on the host and as an
     * ancestor of the host:
     *
     * ```
     * A <hostMarker>, A<hostMarker> {}
     * ```
     *
     * When there is more than one context selector we also have to create combinations of those
     * selectors with each other. For example if there are `A` and `B` selectors the output is:
     *
     * ```
     * AB<hostMarker>, AB <hostMarker>, A B<hostMarker>,
     * B A<hostMarker>, A B <hostMarker>, B A <hostMarker> {}
     * ```
     *
     * And so on...
     *
     * @param hostMarker the string that selects the host element.
     * @param contextSelectors an array of context selectors that will be combined.
     * @param otherSelectors the rest of the selectors that are not context selectors.
     */
    function combineHostContextSelectors(contextSelectors, otherSelectors) {
        const hostMarker = _polyfillHostNoCombinator;
        _polyfillHostRe.lastIndex = 0; // reset the regex to ensure we get an accurate test
        const otherSelectorsHasHost = _polyfillHostRe.test(otherSelectors);
        // If there are no context selectors then just output a host marker
        if (contextSelectors.length === 0) {
            return hostMarker + otherSelectors;
        }
        const combined = [contextSelectors.pop() || ''];
        while (contextSelectors.length > 0) {
            const length = combined.length;
            const contextSelector = contextSelectors.pop();
            for (let i = 0; i < length; i++) {
                const previousSelectors = combined[i];
                // Add the new selector as a descendant of the previous selectors
                combined[length * 2 + i] = previousSelectors + ' ' + contextSelector;
                // Add the new selector as an ancestor of the previous selectors
                combined[length + i] = contextSelector + ' ' + previousSelectors;
                // Add the new selector to act on the same element as the previous selectors
                combined[i] = contextSelector + previousSelectors;
            }
        }
        // Finally connect the selector to the `hostMarker`s: either acting directly on the host
        // (A<hostMarker>) or as an ancestor (A <hostMarker>).
        return combined
            .map(s => otherSelectorsHasHost ?
            `${s}${otherSelectors}` :
            `${s}${hostMarker}${otherSelectors}, ${s} ${hostMarker}${otherSelectors}`)
            .join(',');
    }
    /**
     * Mutate the given `groups` array so that there are `multiples` clones of the original array
     * stored.
     *
     * For example `repeatGroups([a, b], 3)` will result in `[a, b, a, b, a, b]` - but importantly the
     * newly added groups will be clones of the original.
     *
     * @param groups An array of groups of strings that will be repeated. This array is mutated
     *     in-place.
     * @param multiples The number of times the current groups should appear.
     */
    function repeatGroups(groups, multiples) {
        const length = groups.length;
        for (let i = 1; i < multiples; i++) {
            for (let j = 0; j < length; j++) {
                groups[j + (i * length)] = groups[j].slice(0);
            }
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var CompileSummaryKind;
    (function (CompileSummaryKind) {
        CompileSummaryKind[CompileSummaryKind["Pipe"] = 0] = "Pipe";
        CompileSummaryKind[CompileSummaryKind["Directive"] = 1] = "Directive";
        CompileSummaryKind[CompileSummaryKind["NgModule"] = 2] = "NgModule";
        CompileSummaryKind[CompileSummaryKind["Injectable"] = 3] = "Injectable";
    })(CompileSummaryKind || (CompileSummaryKind = {}));
    function flatten(list) {
        return list.reduce((flat, item) => {
            const flatItem = Array.isArray(item) ? flatten(item) : item;
            return flat.concat(flatItem);
        }, []);
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const COMPONENT_VARIABLE = '%COMP%';
    const HOST_ATTR = `_nghost-${COMPONENT_VARIABLE}`;
    const CONTENT_ATTR = `_ngcontent-${COMPONENT_VARIABLE}`;

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class NodeWithI18n {
        constructor(sourceSpan, i18n) {
            this.sourceSpan = sourceSpan;
            this.i18n = i18n;
        }
    }
    class Text$2 extends NodeWithI18n {
        constructor(value, sourceSpan, tokens, i18n) {
            super(sourceSpan, i18n);
            this.value = value;
            this.tokens = tokens;
        }
        visit(visitor, context) {
            return visitor.visitText(this, context);
        }
    }
    class Expansion extends NodeWithI18n {
        constructor(switchValue, type, cases, sourceSpan, switchValueSourceSpan, i18n) {
            super(sourceSpan, i18n);
            this.switchValue = switchValue;
            this.type = type;
            this.cases = cases;
            this.switchValueSourceSpan = switchValueSourceSpan;
        }
        visit(visitor, context) {
            return visitor.visitExpansion(this, context);
        }
    }
    class ExpansionCase {
        constructor(value, expression, sourceSpan, valueSourceSpan, expSourceSpan) {
            this.value = value;
            this.expression = expression;
            this.sourceSpan = sourceSpan;
            this.valueSourceSpan = valueSourceSpan;
            this.expSourceSpan = expSourceSpan;
        }
        visit(visitor, context) {
            return visitor.visitExpansionCase(this, context);
        }
    }
    class Attribute extends NodeWithI18n {
        constructor(name, value, sourceSpan, keySpan, valueSpan, valueTokens, i18n) {
            super(sourceSpan, i18n);
            this.name = name;
            this.value = value;
            this.keySpan = keySpan;
            this.valueSpan = valueSpan;
            this.valueTokens = valueTokens;
        }
        visit(visitor, context) {
            return visitor.visitAttribute(this, context);
        }
    }
    class Element$1 extends NodeWithI18n {
        constructor(name, attrs, children, sourceSpan, startSourceSpan, endSourceSpan = null, i18n) {
            super(sourceSpan, i18n);
            this.name = name;
            this.attrs = attrs;
            this.children = children;
            this.startSourceSpan = startSourceSpan;
            this.endSourceSpan = endSourceSpan;
        }
        visit(visitor, context) {
            return visitor.visitElement(this, context);
        }
    }
    class Comment$1 {
        constructor(value, sourceSpan) {
            this.value = value;
            this.sourceSpan = sourceSpan;
        }
        visit(visitor, context) {
            return visitor.visitComment(this, context);
        }
    }
    function visitAll$1(visitor, nodes, context = null) {
        const result = [];
        const visit = visitor.visit ?
            (ast) => visitor.visit(ast, context) || ast.visit(visitor, context) :
            (ast) => ast.visit(visitor, context);
        nodes.forEach(ast => {
            const astResult = visit(ast);
            if (astResult) {
                result.push(astResult);
            }
        });
        return result;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    // Mapping between all HTML entity names and their unicode representation.
    // Generated from https://html.spec.whatwg.org/multipage/entities.json by stripping
    // the `&` and `;` from the keys and removing the duplicates.
    // see https://www.w3.org/TR/html51/syntax.html#named-character-references
    const NAMED_ENTITIES = {
        'AElig': '\u00C6',
        'AMP': '\u0026',
        'amp': '\u0026',
        'Aacute': '\u00C1',
        'Abreve': '\u0102',
        'Acirc': '\u00C2',
        'Acy': '\u0410',
        'Afr': '\uD835\uDD04',
        'Agrave': '\u00C0',
        'Alpha': '\u0391',
        'Amacr': '\u0100',
        'And': '\u2A53',
        'Aogon': '\u0104',
        'Aopf': '\uD835\uDD38',
        'ApplyFunction': '\u2061',
        'af': '\u2061',
        'Aring': '\u00C5',
        'angst': '\u00C5',
        'Ascr': '\uD835\uDC9C',
        'Assign': '\u2254',
        'colone': '\u2254',
        'coloneq': '\u2254',
        'Atilde': '\u00C3',
        'Auml': '\u00C4',
        'Backslash': '\u2216',
        'setminus': '\u2216',
        'setmn': '\u2216',
        'smallsetminus': '\u2216',
        'ssetmn': '\u2216',
        'Barv': '\u2AE7',
        'Barwed': '\u2306',
        'doublebarwedge': '\u2306',
        'Bcy': '\u0411',
        'Because': '\u2235',
        'becaus': '\u2235',
        'because': '\u2235',
        'Bernoullis': '\u212C',
        'Bscr': '\u212C',
        'bernou': '\u212C',
        'Beta': '\u0392',
        'Bfr': '\uD835\uDD05',
        'Bopf': '\uD835\uDD39',
        'Breve': '\u02D8',
        'breve': '\u02D8',
        'Bumpeq': '\u224E',
        'HumpDownHump': '\u224E',
        'bump': '\u224E',
        'CHcy': '\u0427',
        'COPY': '\u00A9',
        'copy': '\u00A9',
        'Cacute': '\u0106',
        'Cap': '\u22D2',
        'CapitalDifferentialD': '\u2145',
        'DD': '\u2145',
        'Cayleys': '\u212D',
        'Cfr': '\u212D',
        'Ccaron': '\u010C',
        'Ccedil': '\u00C7',
        'Ccirc': '\u0108',
        'Cconint': '\u2230',
        'Cdot': '\u010A',
        'Cedilla': '\u00B8',
        'cedil': '\u00B8',
        'CenterDot': '\u00B7',
        'centerdot': '\u00B7',
        'middot': '\u00B7',
        'Chi': '\u03A7',
        'CircleDot': '\u2299',
        'odot': '\u2299',
        'CircleMinus': '\u2296',
        'ominus': '\u2296',
        'CirclePlus': '\u2295',
        'oplus': '\u2295',
        'CircleTimes': '\u2297',
        'otimes': '\u2297',
        'ClockwiseContourIntegral': '\u2232',
        'cwconint': '\u2232',
        'CloseCurlyDoubleQuote': '\u201D',
        'rdquo': '\u201D',
        'rdquor': '\u201D',
        'CloseCurlyQuote': '\u2019',
        'rsquo': '\u2019',
        'rsquor': '\u2019',
        'Colon': '\u2237',
        'Proportion': '\u2237',
        'Colone': '\u2A74',
        'Congruent': '\u2261',
        'equiv': '\u2261',
        'Conint': '\u222F',
        'DoubleContourIntegral': '\u222F',
        'ContourIntegral': '\u222E',
        'conint': '\u222E',
        'oint': '\u222E',
        'Copf': '\u2102',
        'complexes': '\u2102',
        'Coproduct': '\u2210',
        'coprod': '\u2210',
        'CounterClockwiseContourIntegral': '\u2233',
        'awconint': '\u2233',
        'Cross': '\u2A2F',
        'Cscr': '\uD835\uDC9E',
        'Cup': '\u22D3',
        'CupCap': '\u224D',
        'asympeq': '\u224D',
        'DDotrahd': '\u2911',
        'DJcy': '\u0402',
        'DScy': '\u0405',
        'DZcy': '\u040F',
        'Dagger': '\u2021',
        'ddagger': '\u2021',
        'Darr': '\u21A1',
        'Dashv': '\u2AE4',
        'DoubleLeftTee': '\u2AE4',
        'Dcaron': '\u010E',
        'Dcy': '\u0414',
        'Del': '\u2207',
        'nabla': '\u2207',
        'Delta': '\u0394',
        'Dfr': '\uD835\uDD07',
        'DiacriticalAcute': '\u00B4',
        'acute': '\u00B4',
        'DiacriticalDot': '\u02D9',
        'dot': '\u02D9',
        'DiacriticalDoubleAcute': '\u02DD',
        'dblac': '\u02DD',
        'DiacriticalGrave': '\u0060',
        'grave': '\u0060',
        'DiacriticalTilde': '\u02DC',
        'tilde': '\u02DC',
        'Diamond': '\u22C4',
        'diam': '\u22C4',
        'diamond': '\u22C4',
        'DifferentialD': '\u2146',
        'dd': '\u2146',
        'Dopf': '\uD835\uDD3B',
        'Dot': '\u00A8',
        'DoubleDot': '\u00A8',
        'die': '\u00A8',
        'uml': '\u00A8',
        'DotDot': '\u20DC',
        'DotEqual': '\u2250',
        'doteq': '\u2250',
        'esdot': '\u2250',
        'DoubleDownArrow': '\u21D3',
        'Downarrow': '\u21D3',
        'dArr': '\u21D3',
        'DoubleLeftArrow': '\u21D0',
        'Leftarrow': '\u21D0',
        'lArr': '\u21D0',
        'DoubleLeftRightArrow': '\u21D4',
        'Leftrightarrow': '\u21D4',
        'hArr': '\u21D4',
        'iff': '\u21D4',
        'DoubleLongLeftArrow': '\u27F8',
        'Longleftarrow': '\u27F8',
        'xlArr': '\u27F8',
        'DoubleLongLeftRightArrow': '\u27FA',
        'Longleftrightarrow': '\u27FA',
        'xhArr': '\u27FA',
        'DoubleLongRightArrow': '\u27F9',
        'Longrightarrow': '\u27F9',
        'xrArr': '\u27F9',
        'DoubleRightArrow': '\u21D2',
        'Implies': '\u21D2',
        'Rightarrow': '\u21D2',
        'rArr': '\u21D2',
        'DoubleRightTee': '\u22A8',
        'vDash': '\u22A8',
        'DoubleUpArrow': '\u21D1',
        'Uparrow': '\u21D1',
        'uArr': '\u21D1',
        'DoubleUpDownArrow': '\u21D5',
        'Updownarrow': '\u21D5',
        'vArr': '\u21D5',
        'DoubleVerticalBar': '\u2225',
        'par': '\u2225',
        'parallel': '\u2225',
        'shortparallel': '\u2225',
        'spar': '\u2225',
        'DownArrow': '\u2193',
        'ShortDownArrow': '\u2193',
        'darr': '\u2193',
        'downarrow': '\u2193',
        'DownArrowBar': '\u2913',
        'DownArrowUpArrow': '\u21F5',
        'duarr': '\u21F5',
        'DownBreve': '\u0311',
        'DownLeftRightVector': '\u2950',
        'DownLeftTeeVector': '\u295E',
        'DownLeftVector': '\u21BD',
        'leftharpoondown': '\u21BD',
        'lhard': '\u21BD',
        'DownLeftVectorBar': '\u2956',
        'DownRightTeeVector': '\u295F',
        'DownRightVector': '\u21C1',
        'rhard': '\u21C1',
        'rightharpoondown': '\u21C1',
        'DownRightVectorBar': '\u2957',
        'DownTee': '\u22A4',
        'top': '\u22A4',
        'DownTeeArrow': '\u21A7',
        'mapstodown': '\u21A7',
        'Dscr': '\uD835\uDC9F',
        'Dstrok': '\u0110',
        'ENG': '\u014A',
        'ETH': '\u00D0',
        'Eacute': '\u00C9',
        'Ecaron': '\u011A',
        'Ecirc': '\u00CA',
        'Ecy': '\u042D',
        'Edot': '\u0116',
        'Efr': '\uD835\uDD08',
        'Egrave': '\u00C8',
        'Element': '\u2208',
        'in': '\u2208',
        'isin': '\u2208',
        'isinv': '\u2208',
        'Emacr': '\u0112',
        'EmptySmallSquare': '\u25FB',
        'EmptyVerySmallSquare': '\u25AB',
        'Eogon': '\u0118',
        'Eopf': '\uD835\uDD3C',
        'Epsilon': '\u0395',
        'Equal': '\u2A75',
        'EqualTilde': '\u2242',
        'eqsim': '\u2242',
        'esim': '\u2242',
        'Equilibrium': '\u21CC',
        'rightleftharpoons': '\u21CC',
        'rlhar': '\u21CC',
        'Escr': '\u2130',
        'expectation': '\u2130',
        'Esim': '\u2A73',
        'Eta': '\u0397',
        'Euml': '\u00CB',
        'Exists': '\u2203',
        'exist': '\u2203',
        'ExponentialE': '\u2147',
        'ee': '\u2147',
        'exponentiale': '\u2147',
        'Fcy': '\u0424',
        'Ffr': '\uD835\uDD09',
        'FilledSmallSquare': '\u25FC',
        'FilledVerySmallSquare': '\u25AA',
        'blacksquare': '\u25AA',
        'squarf': '\u25AA',
        'squf': '\u25AA',
        'Fopf': '\uD835\uDD3D',
        'ForAll': '\u2200',
        'forall': '\u2200',
        'Fouriertrf': '\u2131',
        'Fscr': '\u2131',
        'GJcy': '\u0403',
        'GT': '\u003E',
        'gt': '\u003E',
        'Gamma': '\u0393',
        'Gammad': '\u03DC',
        'Gbreve': '\u011E',
        'Gcedil': '\u0122',
        'Gcirc': '\u011C',
        'Gcy': '\u0413',
        'Gdot': '\u0120',
        'Gfr': '\uD835\uDD0A',
        'Gg': '\u22D9',
        'ggg': '\u22D9',
        'Gopf': '\uD835\uDD3E',
        'GreaterEqual': '\u2265',
        'ge': '\u2265',
        'geq': '\u2265',
        'GreaterEqualLess': '\u22DB',
        'gel': '\u22DB',
        'gtreqless': '\u22DB',
        'GreaterFullEqual': '\u2267',
        'gE': '\u2267',
        'geqq': '\u2267',
        'GreaterGreater': '\u2AA2',
        'GreaterLess': '\u2277',
        'gl': '\u2277',
        'gtrless': '\u2277',
        'GreaterSlantEqual': '\u2A7E',
        'geqslant': '\u2A7E',
        'ges': '\u2A7E',
        'GreaterTilde': '\u2273',
        'gsim': '\u2273',
        'gtrsim': '\u2273',
        'Gscr': '\uD835\uDCA2',
        'Gt': '\u226B',
        'NestedGreaterGreater': '\u226B',
        'gg': '\u226B',
        'HARDcy': '\u042A',
        'Hacek': '\u02C7',
        'caron': '\u02C7',
        'Hat': '\u005E',
        'Hcirc': '\u0124',
        'Hfr': '\u210C',
        'Poincareplane': '\u210C',
        'HilbertSpace': '\u210B',
        'Hscr': '\u210B',
        'hamilt': '\u210B',
        'Hopf': '\u210D',
        'quaternions': '\u210D',
        'HorizontalLine': '\u2500',
        'boxh': '\u2500',
        'Hstrok': '\u0126',
        'HumpEqual': '\u224F',
        'bumpe': '\u224F',
        'bumpeq': '\u224F',
        'IEcy': '\u0415',
        'IJlig': '\u0132',
        'IOcy': '\u0401',
        'Iacute': '\u00CD',
        'Icirc': '\u00CE',
        'Icy': '\u0418',
        'Idot': '\u0130',
        'Ifr': '\u2111',
        'Im': '\u2111',
        'image': '\u2111',
        'imagpart': '\u2111',
        'Igrave': '\u00CC',
        'Imacr': '\u012A',
        'ImaginaryI': '\u2148',
        'ii': '\u2148',
        'Int': '\u222C',
        'Integral': '\u222B',
        'int': '\u222B',
        'Intersection': '\u22C2',
        'bigcap': '\u22C2',
        'xcap': '\u22C2',
        'InvisibleComma': '\u2063',
        'ic': '\u2063',
        'InvisibleTimes': '\u2062',
        'it': '\u2062',
        'Iogon': '\u012E',
        'Iopf': '\uD835\uDD40',
        'Iota': '\u0399',
        'Iscr': '\u2110',
        'imagline': '\u2110',
        'Itilde': '\u0128',
        'Iukcy': '\u0406',
        'Iuml': '\u00CF',
        'Jcirc': '\u0134',
        'Jcy': '\u0419',
        'Jfr': '\uD835\uDD0D',
        'Jopf': '\uD835\uDD41',
        'Jscr': '\uD835\uDCA5',
        'Jsercy': '\u0408',
        'Jukcy': '\u0404',
        'KHcy': '\u0425',
        'KJcy': '\u040C',
        'Kappa': '\u039A',
        'Kcedil': '\u0136',
        'Kcy': '\u041A',
        'Kfr': '\uD835\uDD0E',
        'Kopf': '\uD835\uDD42',
        'Kscr': '\uD835\uDCA6',
        'LJcy': '\u0409',
        'LT': '\u003C',
        'lt': '\u003C',
        'Lacute': '\u0139',
        'Lambda': '\u039B',
        'Lang': '\u27EA',
        'Laplacetrf': '\u2112',
        'Lscr': '\u2112',
        'lagran': '\u2112',
        'Larr': '\u219E',
        'twoheadleftarrow': '\u219E',
        'Lcaron': '\u013D',
        'Lcedil': '\u013B',
        'Lcy': '\u041B',
        'LeftAngleBracket': '\u27E8',
        'lang': '\u27E8',
        'langle': '\u27E8',
        'LeftArrow': '\u2190',
        'ShortLeftArrow': '\u2190',
        'larr': '\u2190',
        'leftarrow': '\u2190',
        'slarr': '\u2190',
        'LeftArrowBar': '\u21E4',
        'larrb': '\u21E4',
        'LeftArrowRightArrow': '\u21C6',
        'leftrightarrows': '\u21C6',
        'lrarr': '\u21C6',
        'LeftCeiling': '\u2308',
        'lceil': '\u2308',
        'LeftDoubleBracket': '\u27E6',
        'lobrk': '\u27E6',
        'LeftDownTeeVector': '\u2961',
        'LeftDownVector': '\u21C3',
        'dharl': '\u21C3',
        'downharpoonleft': '\u21C3',
        'LeftDownVectorBar': '\u2959',
        'LeftFloor': '\u230A',
        'lfloor': '\u230A',
        'LeftRightArrow': '\u2194',
        'harr': '\u2194',
        'leftrightarrow': '\u2194',
        'LeftRightVector': '\u294E',
        'LeftTee': '\u22A3',
        'dashv': '\u22A3',
        'LeftTeeArrow': '\u21A4',
        'mapstoleft': '\u21A4',
        'LeftTeeVector': '\u295A',
        'LeftTriangle': '\u22B2',
        'vartriangleleft': '\u22B2',
        'vltri': '\u22B2',
        'LeftTriangleBar': '\u29CF',
        'LeftTriangleEqual': '\u22B4',
        'ltrie': '\u22B4',
        'trianglelefteq': '\u22B4',
        'LeftUpDownVector': '\u2951',
        'LeftUpTeeVector': '\u2960',
        'LeftUpVector': '\u21BF',
        'uharl': '\u21BF',
        'upharpoonleft': '\u21BF',
        'LeftUpVectorBar': '\u2958',
        'LeftVector': '\u21BC',
        'leftharpoonup': '\u21BC',
        'lharu': '\u21BC',
        'LeftVectorBar': '\u2952',
        'LessEqualGreater': '\u22DA',
        'leg': '\u22DA',
        'lesseqgtr': '\u22DA',
        'LessFullEqual': '\u2266',
        'lE': '\u2266',
        'leqq': '\u2266',
        'LessGreater': '\u2276',
        'lessgtr': '\u2276',
        'lg': '\u2276',
        'LessLess': '\u2AA1',
        'LessSlantEqual': '\u2A7D',
        'leqslant': '\u2A7D',
        'les': '\u2A7D',
        'LessTilde': '\u2272',
        'lesssim': '\u2272',
        'lsim': '\u2272',
        'Lfr': '\uD835\uDD0F',
        'Ll': '\u22D8',
        'Lleftarrow': '\u21DA',
        'lAarr': '\u21DA',
        'Lmidot': '\u013F',
        'LongLeftArrow': '\u27F5',
        'longleftarrow': '\u27F5',
        'xlarr': '\u27F5',
        'LongLeftRightArrow': '\u27F7',
        'longleftrightarrow': '\u27F7',
        'xharr': '\u27F7',
        'LongRightArrow': '\u27F6',
        'longrightarrow': '\u27F6',
        'xrarr': '\u27F6',
        'Lopf': '\uD835\uDD43',
        'LowerLeftArrow': '\u2199',
        'swarr': '\u2199',
        'swarrow': '\u2199',
        'LowerRightArrow': '\u2198',
        'searr': '\u2198',
        'searrow': '\u2198',
        'Lsh': '\u21B0',
        'lsh': '\u21B0',
        'Lstrok': '\u0141',
        'Lt': '\u226A',
        'NestedLessLess': '\u226A',
        'll': '\u226A',
        'Map': '\u2905',
        'Mcy': '\u041C',
        'MediumSpace': '\u205F',
        'Mellintrf': '\u2133',
        'Mscr': '\u2133',
        'phmmat': '\u2133',
        'Mfr': '\uD835\uDD10',
        'MinusPlus': '\u2213',
        'mnplus': '\u2213',
        'mp': '\u2213',
        'Mopf': '\uD835\uDD44',
        'Mu': '\u039C',
        'NJcy': '\u040A',
        'Nacute': '\u0143',
        'Ncaron': '\u0147',
        'Ncedil': '\u0145',
        'Ncy': '\u041D',
        'NegativeMediumSpace': '\u200B',
        'NegativeThickSpace': '\u200B',
        'NegativeThinSpace': '\u200B',
        'NegativeVeryThinSpace': '\u200B',
        'ZeroWidthSpace': '\u200B',
        'NewLine': '\u000A',
        'Nfr': '\uD835\uDD11',
        'NoBreak': '\u2060',
        'NonBreakingSpace': '\u00A0',
        'nbsp': '\u00A0',
        'Nopf': '\u2115',
        'naturals': '\u2115',
        'Not': '\u2AEC',
        'NotCongruent': '\u2262',
        'nequiv': '\u2262',
        'NotCupCap': '\u226D',
        'NotDoubleVerticalBar': '\u2226',
        'npar': '\u2226',
        'nparallel': '\u2226',
        'nshortparallel': '\u2226',
        'nspar': '\u2226',
        'NotElement': '\u2209',
        'notin': '\u2209',
        'notinva': '\u2209',
        'NotEqual': '\u2260',
        'ne': '\u2260',
        'NotEqualTilde': '\u2242\u0338',
        'nesim': '\u2242\u0338',
        'NotExists': '\u2204',
        'nexist': '\u2204',
        'nexists': '\u2204',
        'NotGreater': '\u226F',
        'ngt': '\u226F',
        'ngtr': '\u226F',
        'NotGreaterEqual': '\u2271',
        'nge': '\u2271',
        'ngeq': '\u2271',
        'NotGreaterFullEqual': '\u2267\u0338',
        'ngE': '\u2267\u0338',
        'ngeqq': '\u2267\u0338',
        'NotGreaterGreater': '\u226B\u0338',
        'nGtv': '\u226B\u0338',
        'NotGreaterLess': '\u2279',
        'ntgl': '\u2279',
        'NotGreaterSlantEqual': '\u2A7E\u0338',
        'ngeqslant': '\u2A7E\u0338',
        'nges': '\u2A7E\u0338',
        'NotGreaterTilde': '\u2275',
        'ngsim': '\u2275',
        'NotHumpDownHump': '\u224E\u0338',
        'nbump': '\u224E\u0338',
        'NotHumpEqual': '\u224F\u0338',
        'nbumpe': '\u224F\u0338',
        'NotLeftTriangle': '\u22EA',
        'nltri': '\u22EA',
        'ntriangleleft': '\u22EA',
        'NotLeftTriangleBar': '\u29CF\u0338',
        'NotLeftTriangleEqual': '\u22EC',
        'nltrie': '\u22EC',
        'ntrianglelefteq': '\u22EC',
        'NotLess': '\u226E',
        'nless': '\u226E',
        'nlt': '\u226E',
        'NotLessEqual': '\u2270',
        'nle': '\u2270',
        'nleq': '\u2270',
        'NotLessGreater': '\u2278',
        'ntlg': '\u2278',
        'NotLessLess': '\u226A\u0338',
        'nLtv': '\u226A\u0338',
        'NotLessSlantEqual': '\u2A7D\u0338',
        'nleqslant': '\u2A7D\u0338',
        'nles': '\u2A7D\u0338',
        'NotLessTilde': '\u2274',
        'nlsim': '\u2274',
        'NotNestedGreaterGreater': '\u2AA2\u0338',
        'NotNestedLessLess': '\u2AA1\u0338',
        'NotPrecedes': '\u2280',
        'npr': '\u2280',
        'nprec': '\u2280',
        'NotPrecedesEqual': '\u2AAF\u0338',
        'npre': '\u2AAF\u0338',
        'npreceq': '\u2AAF\u0338',
        'NotPrecedesSlantEqual': '\u22E0',
        'nprcue': '\u22E0',
        'NotReverseElement': '\u220C',
        'notni': '\u220C',
        'notniva': '\u220C',
        'NotRightTriangle': '\u22EB',
        'nrtri': '\u22EB',
        'ntriangleright': '\u22EB',
        'NotRightTriangleBar': '\u29D0\u0338',
        'NotRightTriangleEqual': '\u22ED',
        'nrtrie': '\u22ED',
        'ntrianglerighteq': '\u22ED',
        'NotSquareSubset': '\u228F\u0338',
        'NotSquareSubsetEqual': '\u22E2',
        'nsqsube': '\u22E2',
        'NotSquareSuperset': '\u2290\u0338',
        'NotSquareSupersetEqual': '\u22E3',
        'nsqsupe': '\u22E3',
        'NotSubset': '\u2282\u20D2',
        'nsubset': '\u2282\u20D2',
        'vnsub': '\u2282\u20D2',
        'NotSubsetEqual': '\u2288',
        'nsube': '\u2288',
        'nsubseteq': '\u2288',
        'NotSucceeds': '\u2281',
        'nsc': '\u2281',
        'nsucc': '\u2281',
        'NotSucceedsEqual': '\u2AB0\u0338',
        'nsce': '\u2AB0\u0338',
        'nsucceq': '\u2AB0\u0338',
        'NotSucceedsSlantEqual': '\u22E1',
        'nsccue': '\u22E1',
        'NotSucceedsTilde': '\u227F\u0338',
        'NotSuperset': '\u2283\u20D2',
        'nsupset': '\u2283\u20D2',
        'vnsup': '\u2283\u20D2',
        'NotSupersetEqual': '\u2289',
        'nsupe': '\u2289',
        'nsupseteq': '\u2289',
        'NotTilde': '\u2241',
        'nsim': '\u2241',
        'NotTildeEqual': '\u2244',
        'nsime': '\u2244',
        'nsimeq': '\u2244',
        'NotTildeFullEqual': '\u2247',
        'ncong': '\u2247',
        'NotTildeTilde': '\u2249',
        'nap': '\u2249',
        'napprox': '\u2249',
        'NotVerticalBar': '\u2224',
        'nmid': '\u2224',
        'nshortmid': '\u2224',
        'nsmid': '\u2224',
        'Nscr': '\uD835\uDCA9',
        'Ntilde': '\u00D1',
        'Nu': '\u039D',
        'OElig': '\u0152',
        'Oacute': '\u00D3',
        'Ocirc': '\u00D4',
        'Ocy': '\u041E',
        'Odblac': '\u0150',
        'Ofr': '\uD835\uDD12',
        'Ograve': '\u00D2',
        'Omacr': '\u014C',
        'Omega': '\u03A9',
        'ohm': '\u03A9',
        'Omicron': '\u039F',
        'Oopf': '\uD835\uDD46',
        'OpenCurlyDoubleQuote': '\u201C',
        'ldquo': '\u201C',
        'OpenCurlyQuote': '\u2018',
        'lsquo': '\u2018',
        'Or': '\u2A54',
        'Oscr': '\uD835\uDCAA',
        'Oslash': '\u00D8',
        'Otilde': '\u00D5',
        'Otimes': '\u2A37',
        'Ouml': '\u00D6',
        'OverBar': '\u203E',
        'oline': '\u203E',
        'OverBrace': '\u23DE',
        'OverBracket': '\u23B4',
        'tbrk': '\u23B4',
        'OverParenthesis': '\u23DC',
        'PartialD': '\u2202',
        'part': '\u2202',
        'Pcy': '\u041F',
        'Pfr': '\uD835\uDD13',
        'Phi': '\u03A6',
        'Pi': '\u03A0',
        'PlusMinus': '\u00B1',
        'plusmn': '\u00B1',
        'pm': '\u00B1',
        'Popf': '\u2119',
        'primes': '\u2119',
        'Pr': '\u2ABB',
        'Precedes': '\u227A',
        'pr': '\u227A',
        'prec': '\u227A',
        'PrecedesEqual': '\u2AAF',
        'pre': '\u2AAF',
        'preceq': '\u2AAF',
        'PrecedesSlantEqual': '\u227C',
        'prcue': '\u227C',
        'preccurlyeq': '\u227C',
        'PrecedesTilde': '\u227E',
        'precsim': '\u227E',
        'prsim': '\u227E',
        'Prime': '\u2033',
        'Product': '\u220F',
        'prod': '\u220F',
        'Proportional': '\u221D',
        'prop': '\u221D',
        'propto': '\u221D',
        'varpropto': '\u221D',
        'vprop': '\u221D',
        'Pscr': '\uD835\uDCAB',
        'Psi': '\u03A8',
        'QUOT': '\u0022',
        'quot': '\u0022',
        'Qfr': '\uD835\uDD14',
        'Qopf': '\u211A',
        'rationals': '\u211A',
        'Qscr': '\uD835\uDCAC',
        'RBarr': '\u2910',
        'drbkarow': '\u2910',
        'REG': '\u00AE',
        'circledR': '\u00AE',
        'reg': '\u00AE',
        'Racute': '\u0154',
        'Rang': '\u27EB',
        'Rarr': '\u21A0',
        'twoheadrightarrow': '\u21A0',
        'Rarrtl': '\u2916',
        'Rcaron': '\u0158',
        'Rcedil': '\u0156',
        'Rcy': '\u0420',
        'Re': '\u211C',
        'Rfr': '\u211C',
        'real': '\u211C',
        'realpart': '\u211C',
        'ReverseElement': '\u220B',
        'SuchThat': '\u220B',
        'ni': '\u220B',
        'niv': '\u220B',
        'ReverseEquilibrium': '\u21CB',
        'leftrightharpoons': '\u21CB',
        'lrhar': '\u21CB',
        'ReverseUpEquilibrium': '\u296F',
        'duhar': '\u296F',
        'Rho': '\u03A1',
        'RightAngleBracket': '\u27E9',
        'rang': '\u27E9',
        'rangle': '\u27E9',
        'RightArrow': '\u2192',
        'ShortRightArrow': '\u2192',
        'rarr': '\u2192',
        'rightarrow': '\u2192',
        'srarr': '\u2192',
        'RightArrowBar': '\u21E5',
        'rarrb': '\u21E5',
        'RightArrowLeftArrow': '\u21C4',
        'rightleftarrows': '\u21C4',
        'rlarr': '\u21C4',
        'RightCeiling': '\u2309',
        'rceil': '\u2309',
        'RightDoubleBracket': '\u27E7',
        'robrk': '\u27E7',
        'RightDownTeeVector': '\u295D',
        'RightDownVector': '\u21C2',
        'dharr': '\u21C2',
        'downharpoonright': '\u21C2',
        'RightDownVectorBar': '\u2955',
        'RightFloor': '\u230B',
        'rfloor': '\u230B',
        'RightTee': '\u22A2',
        'vdash': '\u22A2',
        'RightTeeArrow': '\u21A6',
        'map': '\u21A6',
        'mapsto': '\u21A6',
        'RightTeeVector': '\u295B',
        'RightTriangle': '\u22B3',
        'vartriangleright': '\u22B3',
        'vrtri': '\u22B3',
        'RightTriangleBar': '\u29D0',
        'RightTriangleEqual': '\u22B5',
        'rtrie': '\u22B5',
        'trianglerighteq': '\u22B5',
        'RightUpDownVector': '\u294F',
        'RightUpTeeVector': '\u295C',
        'RightUpVector': '\u21BE',
        'uharr': '\u21BE',
        'upharpoonright': '\u21BE',
        'RightUpVectorBar': '\u2954',
        'RightVector': '\u21C0',
        'rharu': '\u21C0',
        'rightharpoonup': '\u21C0',
        'RightVectorBar': '\u2953',
        'Ropf': '\u211D',
        'reals': '\u211D',
        'RoundImplies': '\u2970',
        'Rrightarrow': '\u21DB',
        'rAarr': '\u21DB',
        'Rscr': '\u211B',
        'realine': '\u211B',
        'Rsh': '\u21B1',
        'rsh': '\u21B1',
        'RuleDelayed': '\u29F4',
        'SHCHcy': '\u0429',
        'SHcy': '\u0428',
        'SOFTcy': '\u042C',
        'Sacute': '\u015A',
        'Sc': '\u2ABC',
        'Scaron': '\u0160',
        'Scedil': '\u015E',
        'Scirc': '\u015C',
        'Scy': '\u0421',
        'Sfr': '\uD835\uDD16',
        'ShortUpArrow': '\u2191',
        'UpArrow': '\u2191',
        'uarr': '\u2191',
        'uparrow': '\u2191',
        'Sigma': '\u03A3',
        'SmallCircle': '\u2218',
        'compfn': '\u2218',
        'Sopf': '\uD835\uDD4A',
        'Sqrt': '\u221A',
        'radic': '\u221A',
        'Square': '\u25A1',
        'squ': '\u25A1',
        'square': '\u25A1',
        'SquareIntersection': '\u2293',
        'sqcap': '\u2293',
        'SquareSubset': '\u228F',
        'sqsub': '\u228F',
        'sqsubset': '\u228F',
        'SquareSubsetEqual': '\u2291',
        'sqsube': '\u2291',
        'sqsubseteq': '\u2291',
        'SquareSuperset': '\u2290',
        'sqsup': '\u2290',
        'sqsupset': '\u2290',
        'SquareSupersetEqual': '\u2292',
        'sqsupe': '\u2292',
        'sqsupseteq': '\u2292',
        'SquareUnion': '\u2294',
        'sqcup': '\u2294',
        'Sscr': '\uD835\uDCAE',
        'Star': '\u22C6',
        'sstarf': '\u22C6',
        'Sub': '\u22D0',
        'Subset': '\u22D0',
        'SubsetEqual': '\u2286',
        'sube': '\u2286',
        'subseteq': '\u2286',
        'Succeeds': '\u227B',
        'sc': '\u227B',
        'succ': '\u227B',
        'SucceedsEqual': '\u2AB0',
        'sce': '\u2AB0',
        'succeq': '\u2AB0',
        'SucceedsSlantEqual': '\u227D',
        'sccue': '\u227D',
        'succcurlyeq': '\u227D',
        'SucceedsTilde': '\u227F',
        'scsim': '\u227F',
        'succsim': '\u227F',
        'Sum': '\u2211',
        'sum': '\u2211',
        'Sup': '\u22D1',
        'Supset': '\u22D1',
        'Superset': '\u2283',
        'sup': '\u2283',
        'supset': '\u2283',
        'SupersetEqual': '\u2287',
        'supe': '\u2287',
        'supseteq': '\u2287',
        'THORN': '\u00DE',
        'TRADE': '\u2122',
        'trade': '\u2122',
        'TSHcy': '\u040B',
        'TScy': '\u0426',
        'Tab': '\u0009',
        'Tau': '\u03A4',
        'Tcaron': '\u0164',
        'Tcedil': '\u0162',
        'Tcy': '\u0422',
        'Tfr': '\uD835\uDD17',
        'Therefore': '\u2234',
        'there4': '\u2234',
        'therefore': '\u2234',
        'Theta': '\u0398',
        'ThickSpace': '\u205F\u200A',
        'ThinSpace': '\u2009',
        'thinsp': '\u2009',
        'Tilde': '\u223C',
        'sim': '\u223C',
        'thicksim': '\u223C',
        'thksim': '\u223C',
        'TildeEqual': '\u2243',
        'sime': '\u2243',
        'simeq': '\u2243',
        'TildeFullEqual': '\u2245',
        'cong': '\u2245',
        'TildeTilde': '\u2248',
        'ap': '\u2248',
        'approx': '\u2248',
        'asymp': '\u2248',
        'thickapprox': '\u2248',
        'thkap': '\u2248',
        'Topf': '\uD835\uDD4B',
        'TripleDot': '\u20DB',
        'tdot': '\u20DB',
        'Tscr': '\uD835\uDCAF',
        'Tstrok': '\u0166',
        'Uacute': '\u00DA',
        'Uarr': '\u219F',
        'Uarrocir': '\u2949',
        'Ubrcy': '\u040E',
        'Ubreve': '\u016C',
        'Ucirc': '\u00DB',
        'Ucy': '\u0423',
        'Udblac': '\u0170',
        'Ufr': '\uD835\uDD18',
        'Ugrave': '\u00D9',
        'Umacr': '\u016A',
        'UnderBar': '\u005F',
        'lowbar': '\u005F',
        'UnderBrace': '\u23DF',
        'UnderBracket': '\u23B5',
        'bbrk': '\u23B5',
        'UnderParenthesis': '\u23DD',
        'Union': '\u22C3',
        'bigcup': '\u22C3',
        'xcup': '\u22C3',
        'UnionPlus': '\u228E',
        'uplus': '\u228E',
        'Uogon': '\u0172',
        'Uopf': '\uD835\uDD4C',
        'UpArrowBar': '\u2912',
        'UpArrowDownArrow': '\u21C5',
        'udarr': '\u21C5',
        'UpDownArrow': '\u2195',
        'updownarrow': '\u2195',
        'varr': '\u2195',
        'UpEquilibrium': '\u296E',
        'udhar': '\u296E',
        'UpTee': '\u22A5',
        'bot': '\u22A5',
        'bottom': '\u22A5',
        'perp': '\u22A5',
        'UpTeeArrow': '\u21A5',
        'mapstoup': '\u21A5',
        'UpperLeftArrow': '\u2196',
        'nwarr': '\u2196',
        'nwarrow': '\u2196',
        'UpperRightArrow': '\u2197',
        'nearr': '\u2197',
        'nearrow': '\u2197',
        'Upsi': '\u03D2',
        'upsih': '\u03D2',
        'Upsilon': '\u03A5',
        'Uring': '\u016E',
        'Uscr': '\uD835\uDCB0',
        'Utilde': '\u0168',
        'Uuml': '\u00DC',
        'VDash': '\u22AB',
        'Vbar': '\u2AEB',
        'Vcy': '\u0412',
        'Vdash': '\u22A9',
        'Vdashl': '\u2AE6',
        'Vee': '\u22C1',
        'bigvee': '\u22C1',
        'xvee': '\u22C1',
        'Verbar': '\u2016',
        'Vert': '\u2016',
        'VerticalBar': '\u2223',
        'mid': '\u2223',
        'shortmid': '\u2223',
        'smid': '\u2223',
        'VerticalLine': '\u007C',
        'verbar': '\u007C',
        'vert': '\u007C',
        'VerticalSeparator': '\u2758',
        'VerticalTilde': '\u2240',
        'wr': '\u2240',
        'wreath': '\u2240',
        'VeryThinSpace': '\u200A',
        'hairsp': '\u200A',
        'Vfr': '\uD835\uDD19',
        'Vopf': '\uD835\uDD4D',
        'Vscr': '\uD835\uDCB1',
        'Vvdash': '\u22AA',
        'Wcirc': '\u0174',
        'Wedge': '\u22C0',
        'bigwedge': '\u22C0',
        'xwedge': '\u22C0',
        'Wfr': '\uD835\uDD1A',
        'Wopf': '\uD835\uDD4E',
        'Wscr': '\uD835\uDCB2',
        'Xfr': '\uD835\uDD1B',
        'Xi': '\u039E',
        'Xopf': '\uD835\uDD4F',
        'Xscr': '\uD835\uDCB3',
        'YAcy': '\u042F',
        'YIcy': '\u0407',
        'YUcy': '\u042E',
        'Yacute': '\u00DD',
        'Ycirc': '\u0176',
        'Ycy': '\u042B',
        'Yfr': '\uD835\uDD1C',
        'Yopf': '\uD835\uDD50',
        'Yscr': '\uD835\uDCB4',
        'Yuml': '\u0178',
        'ZHcy': '\u0416',
        'Zacute': '\u0179',
        'Zcaron': '\u017D',
        'Zcy': '\u0417',
        'Zdot': '\u017B',
        'Zeta': '\u0396',
        'Zfr': '\u2128',
        'zeetrf': '\u2128',
        'Zopf': '\u2124',
        'integers': '\u2124',
        'Zscr': '\uD835\uDCB5',
        'aacute': '\u00E1',
        'abreve': '\u0103',
        'ac': '\u223E',
        'mstpos': '\u223E',
        'acE': '\u223E\u0333',
        'acd': '\u223F',
        'acirc': '\u00E2',
        'acy': '\u0430',
        'aelig': '\u00E6',
        'afr': '\uD835\uDD1E',
        'agrave': '\u00E0',
        'alefsym': '\u2135',
        'aleph': '\u2135',
        'alpha': '\u03B1',
        'amacr': '\u0101',
        'amalg': '\u2A3F',
        'and': '\u2227',
        'wedge': '\u2227',
        'andand': '\u2A55',
        'andd': '\u2A5C',
        'andslope': '\u2A58',
        'andv': '\u2A5A',
        'ang': '\u2220',
        'angle': '\u2220',
        'ange': '\u29A4',
        'angmsd': '\u2221',
        'measuredangle': '\u2221',
        'angmsdaa': '\u29A8',
        'angmsdab': '\u29A9',
        'angmsdac': '\u29AA',
        'angmsdad': '\u29AB',
        'angmsdae': '\u29AC',
        'angmsdaf': '\u29AD',
        'angmsdag': '\u29AE',
        'angmsdah': '\u29AF',
        'angrt': '\u221F',
        'angrtvb': '\u22BE',
        'angrtvbd': '\u299D',
        'angsph': '\u2222',
        'angzarr': '\u237C',
        'aogon': '\u0105',
        'aopf': '\uD835\uDD52',
        'apE': '\u2A70',
        'apacir': '\u2A6F',
        'ape': '\u224A',
        'approxeq': '\u224A',
        'apid': '\u224B',
        'apos': '\u0027',
        'aring': '\u00E5',
        'ascr': '\uD835\uDCB6',
        'ast': '\u002A',
        'midast': '\u002A',
        'atilde': '\u00E3',
        'auml': '\u00E4',
        'awint': '\u2A11',
        'bNot': '\u2AED',
        'backcong': '\u224C',
        'bcong': '\u224C',
        'backepsilon': '\u03F6',
        'bepsi': '\u03F6',
        'backprime': '\u2035',
        'bprime': '\u2035',
        'backsim': '\u223D',
        'bsim': '\u223D',
        'backsimeq': '\u22CD',
        'bsime': '\u22CD',
        'barvee': '\u22BD',
        'barwed': '\u2305',
        'barwedge': '\u2305',
        'bbrktbrk': '\u23B6',
        'bcy': '\u0431',
        'bdquo': '\u201E',
        'ldquor': '\u201E',
        'bemptyv': '\u29B0',
        'beta': '\u03B2',
        'beth': '\u2136',
        'between': '\u226C',
        'twixt': '\u226C',
        'bfr': '\uD835\uDD1F',
        'bigcirc': '\u25EF',
        'xcirc': '\u25EF',
        'bigodot': '\u2A00',
        'xodot': '\u2A00',
        'bigoplus': '\u2A01',
        'xoplus': '\u2A01',
        'bigotimes': '\u2A02',
        'xotime': '\u2A02',
        'bigsqcup': '\u2A06',
        'xsqcup': '\u2A06',
        'bigstar': '\u2605',
        'starf': '\u2605',
        'bigtriangledown': '\u25BD',
        'xdtri': '\u25BD',
        'bigtriangleup': '\u25B3',
        'xutri': '\u25B3',
        'biguplus': '\u2A04',
        'xuplus': '\u2A04',
        'bkarow': '\u290D',
        'rbarr': '\u290D',
        'blacklozenge': '\u29EB',
        'lozf': '\u29EB',
        'blacktriangle': '\u25B4',
        'utrif': '\u25B4',
        'blacktriangledown': '\u25BE',
        'dtrif': '\u25BE',
        'blacktriangleleft': '\u25C2',
        'ltrif': '\u25C2',
        'blacktriangleright': '\u25B8',
        'rtrif': '\u25B8',
        'blank': '\u2423',
        'blk12': '\u2592',
        'blk14': '\u2591',
        'blk34': '\u2593',
        'block': '\u2588',
        'bne': '\u003D\u20E5',
        'bnequiv': '\u2261\u20E5',
        'bnot': '\u2310',
        'bopf': '\uD835\uDD53',
        'bowtie': '\u22C8',
        'boxDL': '\u2557',
        'boxDR': '\u2554',
        'boxDl': '\u2556',
        'boxDr': '\u2553',
        'boxH': '\u2550',
        'boxHD': '\u2566',
        'boxHU': '\u2569',
        'boxHd': '\u2564',
        'boxHu': '\u2567',
        'boxUL': '\u255D',
        'boxUR': '\u255A',
        'boxUl': '\u255C',
        'boxUr': '\u2559',
        'boxV': '\u2551',
        'boxVH': '\u256C',
        'boxVL': '\u2563',
        'boxVR': '\u2560',
        'boxVh': '\u256B',
        'boxVl': '\u2562',
        'boxVr': '\u255F',
        'boxbox': '\u29C9',
        'boxdL': '\u2555',
        'boxdR': '\u2552',
        'boxdl': '\u2510',
        'boxdr': '\u250C',
        'boxhD': '\u2565',
        'boxhU': '\u2568',
        'boxhd': '\u252C',
        'boxhu': '\u2534',
        'boxminus': '\u229F',
        'minusb': '\u229F',
        'boxplus': '\u229E',
        'plusb': '\u229E',
        'boxtimes': '\u22A0',
        'timesb': '\u22A0',
        'boxuL': '\u255B',
        'boxuR': '\u2558',
        'boxul': '\u2518',
        'boxur': '\u2514',
        'boxv': '\u2502',
        'boxvH': '\u256A',
        'boxvL': '\u2561',
        'boxvR': '\u255E',
        'boxvh': '\u253C',
        'boxvl': '\u2524',
        'boxvr': '\u251C',
        'brvbar': '\u00A6',
        'bscr': '\uD835\uDCB7',
        'bsemi': '\u204F',
        'bsol': '\u005C',
        'bsolb': '\u29C5',
        'bsolhsub': '\u27C8',
        'bull': '\u2022',
        'bullet': '\u2022',
        'bumpE': '\u2AAE',
        'cacute': '\u0107',
        'cap': '\u2229',
        'capand': '\u2A44',
        'capbrcup': '\u2A49',
        'capcap': '\u2A4B',
        'capcup': '\u2A47',
        'capdot': '\u2A40',
        'caps': '\u2229\uFE00',
        'caret': '\u2041',
        'ccaps': '\u2A4D',
        'ccaron': '\u010D',
        'ccedil': '\u00E7',
        'ccirc': '\u0109',
        'ccups': '\u2A4C',
        'ccupssm': '\u2A50',
        'cdot': '\u010B',
        'cemptyv': '\u29B2',
        'cent': '\u00A2',
        'cfr': '\uD835\uDD20',
        'chcy': '\u0447',
        'check': '\u2713',
        'checkmark': '\u2713',
        'chi': '\u03C7',
        'cir': '\u25CB',
        'cirE': '\u29C3',
        'circ': '\u02C6',
        'circeq': '\u2257',
        'cire': '\u2257',
        'circlearrowleft': '\u21BA',
        'olarr': '\u21BA',
        'circlearrowright': '\u21BB',
        'orarr': '\u21BB',
        'circledS': '\u24C8',
        'oS': '\u24C8',
        'circledast': '\u229B',
        'oast': '\u229B',
        'circledcirc': '\u229A',
        'ocir': '\u229A',
        'circleddash': '\u229D',
        'odash': '\u229D',
        'cirfnint': '\u2A10',
        'cirmid': '\u2AEF',
        'cirscir': '\u29C2',
        'clubs': '\u2663',
        'clubsuit': '\u2663',
        'colon': '\u003A',
        'comma': '\u002C',
        'commat': '\u0040',
        'comp': '\u2201',
        'complement': '\u2201',
        'congdot': '\u2A6D',
        'copf': '\uD835\uDD54',
        'copysr': '\u2117',
        'crarr': '\u21B5',
        'cross': '\u2717',
        'cscr': '\uD835\uDCB8',
        'csub': '\u2ACF',
        'csube': '\u2AD1',
        'csup': '\u2AD0',
        'csupe': '\u2AD2',
        'ctdot': '\u22EF',
        'cudarrl': '\u2938',
        'cudarrr': '\u2935',
        'cuepr': '\u22DE',
        'curlyeqprec': '\u22DE',
        'cuesc': '\u22DF',
        'curlyeqsucc': '\u22DF',
        'cularr': '\u21B6',
        'curvearrowleft': '\u21B6',
        'cularrp': '\u293D',
        'cup': '\u222A',
        'cupbrcap': '\u2A48',
        'cupcap': '\u2A46',
        'cupcup': '\u2A4A',
        'cupdot': '\u228D',
        'cupor': '\u2A45',
        'cups': '\u222A\uFE00',
        'curarr': '\u21B7',
        'curvearrowright': '\u21B7',
        'curarrm': '\u293C',
        'curlyvee': '\u22CE',
        'cuvee': '\u22CE',
        'curlywedge': '\u22CF',
        'cuwed': '\u22CF',
        'curren': '\u00A4',
        'cwint': '\u2231',
        'cylcty': '\u232D',
        'dHar': '\u2965',
        'dagger': '\u2020',
        'daleth': '\u2138',
        'dash': '\u2010',
        'hyphen': '\u2010',
        'dbkarow': '\u290F',
        'rBarr': '\u290F',
        'dcaron': '\u010F',
        'dcy': '\u0434',
        'ddarr': '\u21CA',
        'downdownarrows': '\u21CA',
        'ddotseq': '\u2A77',
        'eDDot': '\u2A77',
        'deg': '\u00B0',
        'delta': '\u03B4',
        'demptyv': '\u29B1',
        'dfisht': '\u297F',
        'dfr': '\uD835\uDD21',
        'diamondsuit': '\u2666',
        'diams': '\u2666',
        'digamma': '\u03DD',
        'gammad': '\u03DD',
        'disin': '\u22F2',
        'div': '\u00F7',
        'divide': '\u00F7',
        'divideontimes': '\u22C7',
        'divonx': '\u22C7',
        'djcy': '\u0452',
        'dlcorn': '\u231E',
        'llcorner': '\u231E',
        'dlcrop': '\u230D',
        'dollar': '\u0024',
        'dopf': '\uD835\uDD55',
        'doteqdot': '\u2251',
        'eDot': '\u2251',
        'dotminus': '\u2238',
        'minusd': '\u2238',
        'dotplus': '\u2214',
        'plusdo': '\u2214',
        'dotsquare': '\u22A1',
        'sdotb': '\u22A1',
        'drcorn': '\u231F',
        'lrcorner': '\u231F',
        'drcrop': '\u230C',
        'dscr': '\uD835\uDCB9',
        'dscy': '\u0455',
        'dsol': '\u29F6',
        'dstrok': '\u0111',
        'dtdot': '\u22F1',
        'dtri': '\u25BF',
        'triangledown': '\u25BF',
        'dwangle': '\u29A6',
        'dzcy': '\u045F',
        'dzigrarr': '\u27FF',
        'eacute': '\u00E9',
        'easter': '\u2A6E',
        'ecaron': '\u011B',
        'ecir': '\u2256',
        'eqcirc': '\u2256',
        'ecirc': '\u00EA',
        'ecolon': '\u2255',
        'eqcolon': '\u2255',
        'ecy': '\u044D',
        'edot': '\u0117',
        'efDot': '\u2252',
        'fallingdotseq': '\u2252',
        'efr': '\uD835\uDD22',
        'eg': '\u2A9A',
        'egrave': '\u00E8',
        'egs': '\u2A96',
        'eqslantgtr': '\u2A96',
        'egsdot': '\u2A98',
        'el': '\u2A99',
        'elinters': '\u23E7',
        'ell': '\u2113',
        'els': '\u2A95',
        'eqslantless': '\u2A95',
        'elsdot': '\u2A97',
        'emacr': '\u0113',
        'empty': '\u2205',
        'emptyset': '\u2205',
        'emptyv': '\u2205',
        'varnothing': '\u2205',
        'emsp13': '\u2004',
        'emsp14': '\u2005',
        'emsp': '\u2003',
        'eng': '\u014B',
        'ensp': '\u2002',
        'eogon': '\u0119',
        'eopf': '\uD835\uDD56',
        'epar': '\u22D5',
        'eparsl': '\u29E3',
        'eplus': '\u2A71',
        'epsi': '\u03B5',
        'epsilon': '\u03B5',
        'epsiv': '\u03F5',
        'straightepsilon': '\u03F5',
        'varepsilon': '\u03F5',
        'equals': '\u003D',
        'equest': '\u225F',
        'questeq': '\u225F',
        'equivDD': '\u2A78',
        'eqvparsl': '\u29E5',
        'erDot': '\u2253',
        'risingdotseq': '\u2253',
        'erarr': '\u2971',
        'escr': '\u212F',
        'eta': '\u03B7',
        'eth': '\u00F0',
        'euml': '\u00EB',
        'euro': '\u20AC',
        'excl': '\u0021',
        'fcy': '\u0444',
        'female': '\u2640',
        'ffilig': '\uFB03',
        'fflig': '\uFB00',
        'ffllig': '\uFB04',
        'ffr': '\uD835\uDD23',
        'filig': '\uFB01',
        'fjlig': '\u0066\u006A',
        'flat': '\u266D',
        'fllig': '\uFB02',
        'fltns': '\u25B1',
        'fnof': '\u0192',
        'fopf': '\uD835\uDD57',
        'fork': '\u22D4',
        'pitchfork': '\u22D4',
        'forkv': '\u2AD9',
        'fpartint': '\u2A0D',
        'frac12': '\u00BD',
        'half': '\u00BD',
        'frac13': '\u2153',
        'frac14': '\u00BC',
        'frac15': '\u2155',
        'frac16': '\u2159',
        'frac18': '\u215B',
        'frac23': '\u2154',
        'frac25': '\u2156',
        'frac34': '\u00BE',
        'frac35': '\u2157',
        'frac38': '\u215C',
        'frac45': '\u2158',
        'frac56': '\u215A',
        'frac58': '\u215D',
        'frac78': '\u215E',
        'frasl': '\u2044',
        'frown': '\u2322',
        'sfrown': '\u2322',
        'fscr': '\uD835\uDCBB',
        'gEl': '\u2A8C',
        'gtreqqless': '\u2A8C',
        'gacute': '\u01F5',
        'gamma': '\u03B3',
        'gap': '\u2A86',
        'gtrapprox': '\u2A86',
        'gbreve': '\u011F',
        'gcirc': '\u011D',
        'gcy': '\u0433',
        'gdot': '\u0121',
        'gescc': '\u2AA9',
        'gesdot': '\u2A80',
        'gesdoto': '\u2A82',
        'gesdotol': '\u2A84',
        'gesl': '\u22DB\uFE00',
        'gesles': '\u2A94',
        'gfr': '\uD835\uDD24',
        'gimel': '\u2137',
        'gjcy': '\u0453',
        'glE': '\u2A92',
        'gla': '\u2AA5',
        'glj': '\u2AA4',
        'gnE': '\u2269',
        'gneqq': '\u2269',
        'gnap': '\u2A8A',
        'gnapprox': '\u2A8A',
        'gne': '\u2A88',
        'gneq': '\u2A88',
        'gnsim': '\u22E7',
        'gopf': '\uD835\uDD58',
        'gscr': '\u210A',
        'gsime': '\u2A8E',
        'gsiml': '\u2A90',
        'gtcc': '\u2AA7',
        'gtcir': '\u2A7A',
        'gtdot': '\u22D7',
        'gtrdot': '\u22D7',
        'gtlPar': '\u2995',
        'gtquest': '\u2A7C',
        'gtrarr': '\u2978',
        'gvertneqq': '\u2269\uFE00',
        'gvnE': '\u2269\uFE00',
        'hardcy': '\u044A',
        'harrcir': '\u2948',
        'harrw': '\u21AD',
        'leftrightsquigarrow': '\u21AD',
        'hbar': '\u210F',
        'hslash': '\u210F',
        'planck': '\u210F',
        'plankv': '\u210F',
        'hcirc': '\u0125',
        'hearts': '\u2665',
        'heartsuit': '\u2665',
        'hellip': '\u2026',
        'mldr': '\u2026',
        'hercon': '\u22B9',
        'hfr': '\uD835\uDD25',
        'hksearow': '\u2925',
        'searhk': '\u2925',
        'hkswarow': '\u2926',
        'swarhk': '\u2926',
        'hoarr': '\u21FF',
        'homtht': '\u223B',
        'hookleftarrow': '\u21A9',
        'larrhk': '\u21A9',
        'hookrightarrow': '\u21AA',
        'rarrhk': '\u21AA',
        'hopf': '\uD835\uDD59',
        'horbar': '\u2015',
        'hscr': '\uD835\uDCBD',
        'hstrok': '\u0127',
        'hybull': '\u2043',
        'iacute': '\u00ED',
        'icirc': '\u00EE',
        'icy': '\u0438',
        'iecy': '\u0435',
        'iexcl': '\u00A1',
        'ifr': '\uD835\uDD26',
        'igrave': '\u00EC',
        'iiiint': '\u2A0C',
        'qint': '\u2A0C',
        'iiint': '\u222D',
        'tint': '\u222D',
        'iinfin': '\u29DC',
        'iiota': '\u2129',
        'ijlig': '\u0133',
        'imacr': '\u012B',
        'imath': '\u0131',
        'inodot': '\u0131',
        'imof': '\u22B7',
        'imped': '\u01B5',
        'incare': '\u2105',
        'infin': '\u221E',
        'infintie': '\u29DD',
        'intcal': '\u22BA',
        'intercal': '\u22BA',
        'intlarhk': '\u2A17',
        'intprod': '\u2A3C',
        'iprod': '\u2A3C',
        'iocy': '\u0451',
        'iogon': '\u012F',
        'iopf': '\uD835\uDD5A',
        'iota': '\u03B9',
        'iquest': '\u00BF',
        'iscr': '\uD835\uDCBE',
        'isinE': '\u22F9',
        'isindot': '\u22F5',
        'isins': '\u22F4',
        'isinsv': '\u22F3',
        'itilde': '\u0129',
        'iukcy': '\u0456',
        'iuml': '\u00EF',
        'jcirc': '\u0135',
        'jcy': '\u0439',
        'jfr': '\uD835\uDD27',
        'jmath': '\u0237',
        'jopf': '\uD835\uDD5B',
        'jscr': '\uD835\uDCBF',
        'jsercy': '\u0458',
        'jukcy': '\u0454',
        'kappa': '\u03BA',
        'kappav': '\u03F0',
        'varkappa': '\u03F0',
        'kcedil': '\u0137',
        'kcy': '\u043A',
        'kfr': '\uD835\uDD28',
        'kgreen': '\u0138',
        'khcy': '\u0445',
        'kjcy': '\u045C',
        'kopf': '\uD835\uDD5C',
        'kscr': '\uD835\uDCC0',
        'lAtail': '\u291B',
        'lBarr': '\u290E',
        'lEg': '\u2A8B',
        'lesseqqgtr': '\u2A8B',
        'lHar': '\u2962',
        'lacute': '\u013A',
        'laemptyv': '\u29B4',
        'lambda': '\u03BB',
        'langd': '\u2991',
        'lap': '\u2A85',
        'lessapprox': '\u2A85',
        'laquo': '\u00AB',
        'larrbfs': '\u291F',
        'larrfs': '\u291D',
        'larrlp': '\u21AB',
        'looparrowleft': '\u21AB',
        'larrpl': '\u2939',
        'larrsim': '\u2973',
        'larrtl': '\u21A2',
        'leftarrowtail': '\u21A2',
        'lat': '\u2AAB',
        'latail': '\u2919',
        'late': '\u2AAD',
        'lates': '\u2AAD\uFE00',
        'lbarr': '\u290C',
        'lbbrk': '\u2772',
        'lbrace': '\u007B',
        'lcub': '\u007B',
        'lbrack': '\u005B',
        'lsqb': '\u005B',
        'lbrke': '\u298B',
        'lbrksld': '\u298F',
        'lbrkslu': '\u298D',
        'lcaron': '\u013E',
        'lcedil': '\u013C',
        'lcy': '\u043B',
        'ldca': '\u2936',
        'ldrdhar': '\u2967',
        'ldrushar': '\u294B',
        'ldsh': '\u21B2',
        'le': '\u2264',
        'leq': '\u2264',
        'leftleftarrows': '\u21C7',
        'llarr': '\u21C7',
        'leftthreetimes': '\u22CB',
        'lthree': '\u22CB',
        'lescc': '\u2AA8',
        'lesdot': '\u2A7F',
        'lesdoto': '\u2A81',
        'lesdotor': '\u2A83',
        'lesg': '\u22DA\uFE00',
        'lesges': '\u2A93',
        'lessdot': '\u22D6',
        'ltdot': '\u22D6',
        'lfisht': '\u297C',
        'lfr': '\uD835\uDD29',
        'lgE': '\u2A91',
        'lharul': '\u296A',
        'lhblk': '\u2584',
        'ljcy': '\u0459',
        'llhard': '\u296B',
        'lltri': '\u25FA',
        'lmidot': '\u0140',
        'lmoust': '\u23B0',
        'lmoustache': '\u23B0',
        'lnE': '\u2268',
        'lneqq': '\u2268',
        'lnap': '\u2A89',
        'lnapprox': '\u2A89',
        'lne': '\u2A87',
        'lneq': '\u2A87',
        'lnsim': '\u22E6',
        'loang': '\u27EC',
        'loarr': '\u21FD',
        'longmapsto': '\u27FC',
        'xmap': '\u27FC',
        'looparrowright': '\u21AC',
        'rarrlp': '\u21AC',
        'lopar': '\u2985',
        'lopf': '\uD835\uDD5D',
        'loplus': '\u2A2D',
        'lotimes': '\u2A34',
        'lowast': '\u2217',
        'loz': '\u25CA',
        'lozenge': '\u25CA',
        'lpar': '\u0028',
        'lparlt': '\u2993',
        'lrhard': '\u296D',
        'lrm': '\u200E',
        'lrtri': '\u22BF',
        'lsaquo': '\u2039',
        'lscr': '\uD835\uDCC1',
        'lsime': '\u2A8D',
        'lsimg': '\u2A8F',
        'lsquor': '\u201A',
        'sbquo': '\u201A',
        'lstrok': '\u0142',
        'ltcc': '\u2AA6',
        'ltcir': '\u2A79',
        'ltimes': '\u22C9',
        'ltlarr': '\u2976',
        'ltquest': '\u2A7B',
        'ltrPar': '\u2996',
        'ltri': '\u25C3',
        'triangleleft': '\u25C3',
        'lurdshar': '\u294A',
        'luruhar': '\u2966',
        'lvertneqq': '\u2268\uFE00',
        'lvnE': '\u2268\uFE00',
        'mDDot': '\u223A',
        'macr': '\u00AF',
        'strns': '\u00AF',
        'male': '\u2642',
        'malt': '\u2720',
        'maltese': '\u2720',
        'marker': '\u25AE',
        'mcomma': '\u2A29',
        'mcy': '\u043C',
        'mdash': '\u2014',
        'mfr': '\uD835\uDD2A',
        'mho': '\u2127',
        'micro': '\u00B5',
        'midcir': '\u2AF0',
        'minus': '\u2212',
        'minusdu': '\u2A2A',
        'mlcp': '\u2ADB',
        'models': '\u22A7',
        'mopf': '\uD835\uDD5E',
        'mscr': '\uD835\uDCC2',
        'mu': '\u03BC',
        'multimap': '\u22B8',
        'mumap': '\u22B8',
        'nGg': '\u22D9\u0338',
        'nGt': '\u226B\u20D2',
        'nLeftarrow': '\u21CD',
        'nlArr': '\u21CD',
        'nLeftrightarrow': '\u21CE',
        'nhArr': '\u21CE',
        'nLl': '\u22D8\u0338',
        'nLt': '\u226A\u20D2',
        'nRightarrow': '\u21CF',
        'nrArr': '\u21CF',
        'nVDash': '\u22AF',
        'nVdash': '\u22AE',
        'nacute': '\u0144',
        'nang': '\u2220\u20D2',
        'napE': '\u2A70\u0338',
        'napid': '\u224B\u0338',
        'napos': '\u0149',
        'natur': '\u266E',
        'natural': '\u266E',
        'ncap': '\u2A43',
        'ncaron': '\u0148',
        'ncedil': '\u0146',
        'ncongdot': '\u2A6D\u0338',
        'ncup': '\u2A42',
        'ncy': '\u043D',
        'ndash': '\u2013',
        'neArr': '\u21D7',
        'nearhk': '\u2924',
        'nedot': '\u2250\u0338',
        'nesear': '\u2928',
        'toea': '\u2928',
        'nfr': '\uD835\uDD2B',
        'nharr': '\u21AE',
        'nleftrightarrow': '\u21AE',
        'nhpar': '\u2AF2',
        'nis': '\u22FC',
        'nisd': '\u22FA',
        'njcy': '\u045A',
        'nlE': '\u2266\u0338',
        'nleqq': '\u2266\u0338',
        'nlarr': '\u219A',
        'nleftarrow': '\u219A',
        'nldr': '\u2025',
        'nopf': '\uD835\uDD5F',
        'not': '\u00AC',
        'notinE': '\u22F9\u0338',
        'notindot': '\u22F5\u0338',
        'notinvb': '\u22F7',
        'notinvc': '\u22F6',
        'notnivb': '\u22FE',
        'notnivc': '\u22FD',
        'nparsl': '\u2AFD\u20E5',
        'npart': '\u2202\u0338',
        'npolint': '\u2A14',
        'nrarr': '\u219B',
        'nrightarrow': '\u219B',
        'nrarrc': '\u2933\u0338',
        'nrarrw': '\u219D\u0338',
        'nscr': '\uD835\uDCC3',
        'nsub': '\u2284',
        'nsubE': '\u2AC5\u0338',
        'nsubseteqq': '\u2AC5\u0338',
        'nsup': '\u2285',
        'nsupE': '\u2AC6\u0338',
        'nsupseteqq': '\u2AC6\u0338',
        'ntilde': '\u00F1',
        'nu': '\u03BD',
        'num': '\u0023',
        'numero': '\u2116',
        'numsp': '\u2007',
        'nvDash': '\u22AD',
        'nvHarr': '\u2904',
        'nvap': '\u224D\u20D2',
        'nvdash': '\u22AC',
        'nvge': '\u2265\u20D2',
        'nvgt': '\u003E\u20D2',
        'nvinfin': '\u29DE',
        'nvlArr': '\u2902',
        'nvle': '\u2264\u20D2',
        'nvlt': '\u003C\u20D2',
        'nvltrie': '\u22B4\u20D2',
        'nvrArr': '\u2903',
        'nvrtrie': '\u22B5\u20D2',
        'nvsim': '\u223C\u20D2',
        'nwArr': '\u21D6',
        'nwarhk': '\u2923',
        'nwnear': '\u2927',
        'oacute': '\u00F3',
        'ocirc': '\u00F4',
        'ocy': '\u043E',
        'odblac': '\u0151',
        'odiv': '\u2A38',
        'odsold': '\u29BC',
        'oelig': '\u0153',
        'ofcir': '\u29BF',
        'ofr': '\uD835\uDD2C',
        'ogon': '\u02DB',
        'ograve': '\u00F2',
        'ogt': '\u29C1',
        'ohbar': '\u29B5',
        'olcir': '\u29BE',
        'olcross': '\u29BB',
        'olt': '\u29C0',
        'omacr': '\u014D',
        'omega': '\u03C9',
        'omicron': '\u03BF',
        'omid': '\u29B6',
        'oopf': '\uD835\uDD60',
        'opar': '\u29B7',
        'operp': '\u29B9',
        'or': '\u2228',
        'vee': '\u2228',
        'ord': '\u2A5D',
        'order': '\u2134',
        'orderof': '\u2134',
        'oscr': '\u2134',
        'ordf': '\u00AA',
        'ordm': '\u00BA',
        'origof': '\u22B6',
        'oror': '\u2A56',
        'orslope': '\u2A57',
        'orv': '\u2A5B',
        'oslash': '\u00F8',
        'osol': '\u2298',
        'otilde': '\u00F5',
        'otimesas': '\u2A36',
        'ouml': '\u00F6',
        'ovbar': '\u233D',
        'para': '\u00B6',
        'parsim': '\u2AF3',
        'parsl': '\u2AFD',
        'pcy': '\u043F',
        'percnt': '\u0025',
        'period': '\u002E',
        'permil': '\u2030',
        'pertenk': '\u2031',
        'pfr': '\uD835\uDD2D',
        'phi': '\u03C6',
        'phiv': '\u03D5',
        'straightphi': '\u03D5',
        'varphi': '\u03D5',
        'phone': '\u260E',
        'pi': '\u03C0',
        'piv': '\u03D6',
        'varpi': '\u03D6',
        'planckh': '\u210E',
        'plus': '\u002B',
        'plusacir': '\u2A23',
        'pluscir': '\u2A22',
        'plusdu': '\u2A25',
        'pluse': '\u2A72',
        'plussim': '\u2A26',
        'plustwo': '\u2A27',
        'pointint': '\u2A15',
        'popf': '\uD835\uDD61',
        'pound': '\u00A3',
        'prE': '\u2AB3',
        'prap': '\u2AB7',
        'precapprox': '\u2AB7',
        'precnapprox': '\u2AB9',
        'prnap': '\u2AB9',
        'precneqq': '\u2AB5',
        'prnE': '\u2AB5',
        'precnsim': '\u22E8',
        'prnsim': '\u22E8',
        'prime': '\u2032',
        'profalar': '\u232E',
        'profline': '\u2312',
        'profsurf': '\u2313',
        'prurel': '\u22B0',
        'pscr': '\uD835\uDCC5',
        'psi': '\u03C8',
        'puncsp': '\u2008',
        'qfr': '\uD835\uDD2E',
        'qopf': '\uD835\uDD62',
        'qprime': '\u2057',
        'qscr': '\uD835\uDCC6',
        'quatint': '\u2A16',
        'quest': '\u003F',
        'rAtail': '\u291C',
        'rHar': '\u2964',
        'race': '\u223D\u0331',
        'racute': '\u0155',
        'raemptyv': '\u29B3',
        'rangd': '\u2992',
        'range': '\u29A5',
        'raquo': '\u00BB',
        'rarrap': '\u2975',
        'rarrbfs': '\u2920',
        'rarrc': '\u2933',
        'rarrfs': '\u291E',
        'rarrpl': '\u2945',
        'rarrsim': '\u2974',
        'rarrtl': '\u21A3',
        'rightarrowtail': '\u21A3',
        'rarrw': '\u219D',
        'rightsquigarrow': '\u219D',
        'ratail': '\u291A',
        'ratio': '\u2236',
        'rbbrk': '\u2773',
        'rbrace': '\u007D',
        'rcub': '\u007D',
        'rbrack': '\u005D',
        'rsqb': '\u005D',
        'rbrke': '\u298C',
        'rbrksld': '\u298E',
        'rbrkslu': '\u2990',
        'rcaron': '\u0159',
        'rcedil': '\u0157',
        'rcy': '\u0440',
        'rdca': '\u2937',
        'rdldhar': '\u2969',
        'rdsh': '\u21B3',
        'rect': '\u25AD',
        'rfisht': '\u297D',
        'rfr': '\uD835\uDD2F',
        'rharul': '\u296C',
        'rho': '\u03C1',
        'rhov': '\u03F1',
        'varrho': '\u03F1',
        'rightrightarrows': '\u21C9',
        'rrarr': '\u21C9',
        'rightthreetimes': '\u22CC',
        'rthree': '\u22CC',
        'ring': '\u02DA',
        'rlm': '\u200F',
        'rmoust': '\u23B1',
        'rmoustache': '\u23B1',
        'rnmid': '\u2AEE',
        'roang': '\u27ED',
        'roarr': '\u21FE',
        'ropar': '\u2986',
        'ropf': '\uD835\uDD63',
        'roplus': '\u2A2E',
        'rotimes': '\u2A35',
        'rpar': '\u0029',
        'rpargt': '\u2994',
        'rppolint': '\u2A12',
        'rsaquo': '\u203A',
        'rscr': '\uD835\uDCC7',
        'rtimes': '\u22CA',
        'rtri': '\u25B9',
        'triangleright': '\u25B9',
        'rtriltri': '\u29CE',
        'ruluhar': '\u2968',
        'rx': '\u211E',
        'sacute': '\u015B',
        'scE': '\u2AB4',
        'scap': '\u2AB8',
        'succapprox': '\u2AB8',
        'scaron': '\u0161',
        'scedil': '\u015F',
        'scirc': '\u015D',
        'scnE': '\u2AB6',
        'succneqq': '\u2AB6',
        'scnap': '\u2ABA',
        'succnapprox': '\u2ABA',
        'scnsim': '\u22E9',
        'succnsim': '\u22E9',
        'scpolint': '\u2A13',
        'scy': '\u0441',
        'sdot': '\u22C5',
        'sdote': '\u2A66',
        'seArr': '\u21D8',
        'sect': '\u00A7',
        'semi': '\u003B',
        'seswar': '\u2929',
        'tosa': '\u2929',
        'sext': '\u2736',
        'sfr': '\uD835\uDD30',
        'sharp': '\u266F',
        'shchcy': '\u0449',
        'shcy': '\u0448',
        'shy': '\u00AD',
        'sigma': '\u03C3',
        'sigmaf': '\u03C2',
        'sigmav': '\u03C2',
        'varsigma': '\u03C2',
        'simdot': '\u2A6A',
        'simg': '\u2A9E',
        'simgE': '\u2AA0',
        'siml': '\u2A9D',
        'simlE': '\u2A9F',
        'simne': '\u2246',
        'simplus': '\u2A24',
        'simrarr': '\u2972',
        'smashp': '\u2A33',
        'smeparsl': '\u29E4',
        'smile': '\u2323',
        'ssmile': '\u2323',
        'smt': '\u2AAA',
        'smte': '\u2AAC',
        'smtes': '\u2AAC\uFE00',
        'softcy': '\u044C',
        'sol': '\u002F',
        'solb': '\u29C4',
        'solbar': '\u233F',
        'sopf': '\uD835\uDD64',
        'spades': '\u2660',
        'spadesuit': '\u2660',
        'sqcaps': '\u2293\uFE00',
        'sqcups': '\u2294\uFE00',
        'sscr': '\uD835\uDCC8',
        'star': '\u2606',
        'sub': '\u2282',
        'subset': '\u2282',
        'subE': '\u2AC5',
        'subseteqq': '\u2AC5',
        'subdot': '\u2ABD',
        'subedot': '\u2AC3',
        'submult': '\u2AC1',
        'subnE': '\u2ACB',
        'subsetneqq': '\u2ACB',
        'subne': '\u228A',
        'subsetneq': '\u228A',
        'subplus': '\u2ABF',
        'subrarr': '\u2979',
        'subsim': '\u2AC7',
        'subsub': '\u2AD5',
        'subsup': '\u2AD3',
        'sung': '\u266A',
        'sup1': '\u00B9',
        'sup2': '\u00B2',
        'sup3': '\u00B3',
        'supE': '\u2AC6',
        'supseteqq': '\u2AC6',
        'supdot': '\u2ABE',
        'supdsub': '\u2AD8',
        'supedot': '\u2AC4',
        'suphsol': '\u27C9',
        'suphsub': '\u2AD7',
        'suplarr': '\u297B',
        'supmult': '\u2AC2',
        'supnE': '\u2ACC',
        'supsetneqq': '\u2ACC',
        'supne': '\u228B',
        'supsetneq': '\u228B',
        'supplus': '\u2AC0',
        'supsim': '\u2AC8',
        'supsub': '\u2AD4',
        'supsup': '\u2AD6',
        'swArr': '\u21D9',
        'swnwar': '\u292A',
        'szlig': '\u00DF',
        'target': '\u2316',
        'tau': '\u03C4',
        'tcaron': '\u0165',
        'tcedil': '\u0163',
        'tcy': '\u0442',
        'telrec': '\u2315',
        'tfr': '\uD835\uDD31',
        'theta': '\u03B8',
        'thetasym': '\u03D1',
        'thetav': '\u03D1',
        'vartheta': '\u03D1',
        'thorn': '\u00FE',
        'times': '\u00D7',
        'timesbar': '\u2A31',
        'timesd': '\u2A30',
        'topbot': '\u2336',
        'topcir': '\u2AF1',
        'topf': '\uD835\uDD65',
        'topfork': '\u2ADA',
        'tprime': '\u2034',
        'triangle': '\u25B5',
        'utri': '\u25B5',
        'triangleq': '\u225C',
        'trie': '\u225C',
        'tridot': '\u25EC',
        'triminus': '\u2A3A',
        'triplus': '\u2A39',
        'trisb': '\u29CD',
        'tritime': '\u2A3B',
        'trpezium': '\u23E2',
        'tscr': '\uD835\uDCC9',
        'tscy': '\u0446',
        'tshcy': '\u045B',
        'tstrok': '\u0167',
        'uHar': '\u2963',
        'uacute': '\u00FA',
        'ubrcy': '\u045E',
        'ubreve': '\u016D',
        'ucirc': '\u00FB',
        'ucy': '\u0443',
        'udblac': '\u0171',
        'ufisht': '\u297E',
        'ufr': '\uD835\uDD32',
        'ugrave': '\u00F9',
        'uhblk': '\u2580',
        'ulcorn': '\u231C',
        'ulcorner': '\u231C',
        'ulcrop': '\u230F',
        'ultri': '\u25F8',
        'umacr': '\u016B',
        'uogon': '\u0173',
        'uopf': '\uD835\uDD66',
        'upsi': '\u03C5',
        'upsilon': '\u03C5',
        'upuparrows': '\u21C8',
        'uuarr': '\u21C8',
        'urcorn': '\u231D',
        'urcorner': '\u231D',
        'urcrop': '\u230E',
        'uring': '\u016F',
        'urtri': '\u25F9',
        'uscr': '\uD835\uDCCA',
        'utdot': '\u22F0',
        'utilde': '\u0169',
        'uuml': '\u00FC',
        'uwangle': '\u29A7',
        'vBar': '\u2AE8',
        'vBarv': '\u2AE9',
        'vangrt': '\u299C',
        'varsubsetneq': '\u228A\uFE00',
        'vsubne': '\u228A\uFE00',
        'varsubsetneqq': '\u2ACB\uFE00',
        'vsubnE': '\u2ACB\uFE00',
        'varsupsetneq': '\u228B\uFE00',
        'vsupne': '\u228B\uFE00',
        'varsupsetneqq': '\u2ACC\uFE00',
        'vsupnE': '\u2ACC\uFE00',
        'vcy': '\u0432',
        'veebar': '\u22BB',
        'veeeq': '\u225A',
        'vellip': '\u22EE',
        'vfr': '\uD835\uDD33',
        'vopf': '\uD835\uDD67',
        'vscr': '\uD835\uDCCB',
        'vzigzag': '\u299A',
        'wcirc': '\u0175',
        'wedbar': '\u2A5F',
        'wedgeq': '\u2259',
        'weierp': '\u2118',
        'wp': '\u2118',
        'wfr': '\uD835\uDD34',
        'wopf': '\uD835\uDD68',
        'wscr': '\uD835\uDCCC',
        'xfr': '\uD835\uDD35',
        'xi': '\u03BE',
        'xnis': '\u22FB',
        'xopf': '\uD835\uDD69',
        'xscr': '\uD835\uDCCD',
        'yacute': '\u00FD',
        'yacy': '\u044F',
        'ycirc': '\u0177',
        'ycy': '\u044B',
        'yen': '\u00A5',
        'yfr': '\uD835\uDD36',
        'yicy': '\u0457',
        'yopf': '\uD835\uDD6A',
        'yscr': '\uD835\uDCCE',
        'yucy': '\u044E',
        'yuml': '\u00FF',
        'zacute': '\u017A',
        'zcaron': '\u017E',
        'zcy': '\u0437',
        'zdot': '\u017C',
        'zeta': '\u03B6',
        'zfr': '\uD835\uDD37',
        'zhcy': '\u0436',
        'zigrarr': '\u21DD',
        'zopf': '\uD835\uDD6B',
        'zscr': '\uD835\uDCCF',
        'zwj': '\u200D',
        'zwnj': '\u200C'
    };
    // The &ngsp; pseudo-entity is denoting a space. see:
    // https://github.com/dart-lang/angular/blob/0bb611387d29d65b5af7f9d2515ab571fd3fbee4/_tests/test/compiler/preserve_whitespace_test.dart
    const NGSP_UNICODE = '\uE500';
    NAMED_ENTITIES['ngsp'] = NGSP_UNICODE;

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class TokenError extends ParseError {
        constructor(errorMsg, tokenType, span) {
            super(span, errorMsg);
            this.tokenType = tokenType;
        }
    }
    class TokenizeResult {
        constructor(tokens, errors, nonNormalizedIcuExpressions) {
            this.tokens = tokens;
            this.errors = errors;
            this.nonNormalizedIcuExpressions = nonNormalizedIcuExpressions;
        }
    }
    function tokenize(source, url, getTagDefinition, options = {}) {
        const tokenizer = new _Tokenizer(new ParseSourceFile(source, url), getTagDefinition, options);
        tokenizer.tokenize();
        return new TokenizeResult(mergeTextTokens(tokenizer.tokens), tokenizer.errors, tokenizer.nonNormalizedIcuExpressions);
    }
    const _CR_OR_CRLF_REGEXP = /\r\n?/g;
    function _unexpectedCharacterErrorMsg(charCode) {
        const char = charCode === $EOF ? 'EOF' : String.fromCharCode(charCode);
        return `Unexpected character "${char}"`;
    }
    function _unknownEntityErrorMsg(entitySrc) {
        return `Unknown entity "${entitySrc}" - use the "&#<decimal>;" or  "&#x<hex>;" syntax`;
    }
    function _unparsableEntityErrorMsg(type, entityStr) {
        return `Unable to parse entity "${entityStr}" - ${type} character reference entities must end with ";"`;
    }
    var CharacterReferenceType;
    (function (CharacterReferenceType) {
        CharacterReferenceType["HEX"] = "hexadecimal";
        CharacterReferenceType["DEC"] = "decimal";
    })(CharacterReferenceType || (CharacterReferenceType = {}));
    class _ControlFlowError {
        constructor(error) {
            this.error = error;
        }
    }
    // See https://www.w3.org/TR/html51/syntax.html#writing-html-documents
    class _Tokenizer {
        /**
         * @param _file The html source file being tokenized.
         * @param _getTagDefinition A function that will retrieve a tag definition for a given tag name.
         * @param options Configuration of the tokenization.
         */
        constructor(_file, _getTagDefinition, options) {
            this._getTagDefinition = _getTagDefinition;
            this._currentTokenStart = null;
            this._currentTokenType = null;
            this._expansionCaseStack = [];
            this._inInterpolation = false;
            this.tokens = [];
            this.errors = [];
            this.nonNormalizedIcuExpressions = [];
            this._tokenizeIcu = options.tokenizeExpansionForms || false;
            this._interpolationConfig = options.interpolationConfig || DEFAULT_INTERPOLATION_CONFIG;
            this._leadingTriviaCodePoints =
                options.leadingTriviaChars && options.leadingTriviaChars.map(c => c.codePointAt(0) || 0);
            const range = options.range || { endPos: _file.content.length, startPos: 0, startLine: 0, startCol: 0 };
            this._cursor = options.escapedString ? new EscapedCharacterCursor(_file, range) :
                new PlainCharacterCursor(_file, range);
            this._preserveLineEndings = options.preserveLineEndings || false;
            this._escapedString = options.escapedString || false;
            this._i18nNormalizeLineEndingsInICUs = options.i18nNormalizeLineEndingsInICUs || false;
            try {
                this._cursor.init();
            }
            catch (e) {
                this.handleError(e);
            }
        }
        _processCarriageReturns(content) {
            if (this._preserveLineEndings) {
                return content;
            }
            // https://www.w3.org/TR/html51/syntax.html#preprocessing-the-input-stream
            // In order to keep the original position in the source, we can not
            // pre-process it.
            // Instead CRs are processed right before instantiating the tokens.
            return content.replace(_CR_OR_CRLF_REGEXP, '\n');
        }
        tokenize() {
            while (this._cursor.peek() !== $EOF) {
                const start = this._cursor.clone();
                try {
                    if (this._attemptCharCode($LT)) {
                        if (this._attemptCharCode($BANG)) {
                            if (this._attemptCharCode($LBRACKET)) {
                                this._consumeCdata(start);
                            }
                            else if (this._attemptCharCode($MINUS)) {
                                this._consumeComment(start);
                            }
                            else {
                                this._consumeDocType(start);
                            }
                        }
                        else if (this._attemptCharCode($SLASH)) {
                            this._consumeTagClose(start);
                        }
                        else {
                            this._consumeTagOpen(start);
                        }
                    }
                    else if (!(this._tokenizeIcu && this._tokenizeExpansionForm())) {
                        // In (possibly interpolated) text the end of the text is given by `isTextEnd()`, while
                        // the premature end of an interpolation is given by the start of a new HTML element.
                        this._consumeWithInterpolation(5 /* TEXT */, 8 /* INTERPOLATION */, () => this._isTextEnd(), () => this._isTagStart());
                    }
                }
                catch (e) {
                    this.handleError(e);
                }
            }
            this._beginToken(24 /* EOF */);
            this._endToken([]);
        }
        /**
         * @returns whether an ICU token has been created
         * @internal
         */
        _tokenizeExpansionForm() {
            if (this.isExpansionFormStart()) {
                this._consumeExpansionFormStart();
                return true;
            }
            if (isExpansionCaseStart(this._cursor.peek()) && this._isInExpansionForm()) {
                this._consumeExpansionCaseStart();
                return true;
            }
            if (this._cursor.peek() === $RBRACE) {
                if (this._isInExpansionCase()) {
                    this._consumeExpansionCaseEnd();
                    return true;
                }
                if (this._isInExpansionForm()) {
                    this._consumeExpansionFormEnd();
                    return true;
                }
            }
            return false;
        }
        _beginToken(type, start = this._cursor.clone()) {
            this._currentTokenStart = start;
            this._currentTokenType = type;
        }
        _endToken(parts, end) {
            if (this._currentTokenStart === null) {
                throw new TokenError('Programming error - attempted to end a token when there was no start to the token', this._currentTokenType, this._cursor.getSpan(end));
            }
            if (this._currentTokenType === null) {
                throw new TokenError('Programming error - attempted to end a token which has no token type', null, this._cursor.getSpan(this._currentTokenStart));
            }
            const token = {
                type: this._currentTokenType,
                parts,
                sourceSpan: (end !== null && end !== void 0 ? end : this._cursor).getSpan(this._currentTokenStart, this._leadingTriviaCodePoints),
            };
            this.tokens.push(token);
            this._currentTokenStart = null;
            this._currentTokenType = null;
            return token;
        }
        _createError(msg, span) {
            if (this._isInExpansionForm()) {
                msg += ` (Do you have an unescaped "{" in your template? Use "{{ '{' }}") to escape it.)`;
            }
            const error = new TokenError(msg, this._currentTokenType, span);
            this._currentTokenStart = null;
            this._currentTokenType = null;
            return new _ControlFlowError(error);
        }
        handleError(e) {
            if (e instanceof CursorError) {
                e = this._createError(e.msg, this._cursor.getSpan(e.cursor));
            }
            if (e instanceof _ControlFlowError) {
                this.errors.push(e.error);
            }
            else {
                throw e;
            }
        }
        _attemptCharCode(charCode) {
            if (this._cursor.peek() === charCode) {
                this._cursor.advance();
                return true;
            }
            return false;
        }
        _attemptCharCodeCaseInsensitive(charCode) {
            if (compareCharCodeCaseInsensitive(this._cursor.peek(), charCode)) {
                this._cursor.advance();
                return true;
            }
            return false;
        }
        _requireCharCode(charCode) {
            const location = this._cursor.clone();
            if (!this._attemptCharCode(charCode)) {
                throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(location));
            }
        }
        _attemptStr(chars) {
            const len = chars.length;
            if (this._cursor.charsLeft() < len) {
                return false;
            }
            const initialPosition = this._cursor.clone();
            for (let i = 0; i < len; i++) {
                if (!this._attemptCharCode(chars.charCodeAt(i))) {
                    // If attempting to parse the string fails, we want to reset the parser
                    // to where it was before the attempt
                    this._cursor = initialPosition;
                    return false;
                }
            }
            return true;
        }
        _attemptStrCaseInsensitive(chars) {
            for (let i = 0; i < chars.length; i++) {
                if (!this._attemptCharCodeCaseInsensitive(chars.charCodeAt(i))) {
                    return false;
                }
            }
            return true;
        }
        _requireStr(chars) {
            const location = this._cursor.clone();
            if (!this._attemptStr(chars)) {
                throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(location));
            }
        }
        _attemptCharCodeUntilFn(predicate) {
            while (!predicate(this._cursor.peek())) {
                this._cursor.advance();
            }
        }
        _requireCharCodeUntilFn(predicate, len) {
            const start = this._cursor.clone();
            this._attemptCharCodeUntilFn(predicate);
            if (this._cursor.diff(start) < len) {
                throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(start));
            }
        }
        _attemptUntilChar(char) {
            while (this._cursor.peek() !== char) {
                this._cursor.advance();
            }
        }
        _readChar() {
            // Don't rely upon reading directly from `_input` as the actual char value
            // may have been generated from an escape sequence.
            const char = String.fromCodePoint(this._cursor.peek());
            this._cursor.advance();
            return char;
        }
        _consumeEntity(textTokenType) {
            this._beginToken(9 /* ENCODED_ENTITY */);
            const start = this._cursor.clone();
            this._cursor.advance();
            if (this._attemptCharCode($HASH)) {
                const isHex = this._attemptCharCode($x) || this._attemptCharCode($X);
                const codeStart = this._cursor.clone();
                this._attemptCharCodeUntilFn(isDigitEntityEnd);
                if (this._cursor.peek() != $SEMICOLON) {
                    // Advance cursor to include the peeked character in the string provided to the error
                    // message.
                    this._cursor.advance();
                    const entityType = isHex ? CharacterReferenceType.HEX : CharacterReferenceType.DEC;
                    throw this._createError(_unparsableEntityErrorMsg(entityType, this._cursor.getChars(start)), this._cursor.getSpan());
                }
                const strNum = this._cursor.getChars(codeStart);
                this._cursor.advance();
                try {
                    const charCode = parseInt(strNum, isHex ? 16 : 10);
                    this._endToken([String.fromCharCode(charCode), this._cursor.getChars(start)]);
                }
                catch (_a) {
                    throw this._createError(_unknownEntityErrorMsg(this._cursor.getChars(start)), this._cursor.getSpan());
                }
            }
            else {
                const nameStart = this._cursor.clone();
                this._attemptCharCodeUntilFn(isNamedEntityEnd);
                if (this._cursor.peek() != $SEMICOLON) {
                    // No semicolon was found so abort the encoded entity token that was in progress, and treat
                    // this as a text token
                    this._beginToken(textTokenType, start);
                    this._cursor = nameStart;
                    this._endToken(['&']);
                }
                else {
                    const name = this._cursor.getChars(nameStart);
                    this._cursor.advance();
                    const char = NAMED_ENTITIES[name];
                    if (!char) {
                        throw this._createError(_unknownEntityErrorMsg(name), this._cursor.getSpan(start));
                    }
                    this._endToken([char, `&${name};`]);
                }
            }
        }
        _consumeRawText(consumeEntities, endMarkerPredicate) {
            this._beginToken(consumeEntities ? 6 /* ESCAPABLE_RAW_TEXT */ : 7 /* RAW_TEXT */);
            const parts = [];
            while (true) {
                const tagCloseStart = this._cursor.clone();
                const foundEndMarker = endMarkerPredicate();
                this._cursor = tagCloseStart;
                if (foundEndMarker) {
                    break;
                }
                if (consumeEntities && this._cursor.peek() === $AMPERSAND) {
                    this._endToken([this._processCarriageReturns(parts.join(''))]);
                    parts.length = 0;
                    this._consumeEntity(6 /* ESCAPABLE_RAW_TEXT */);
                    this._beginToken(6 /* ESCAPABLE_RAW_TEXT */);
                }
                else {
                    parts.push(this._readChar());
                }
            }
            this._endToken([this._processCarriageReturns(parts.join(''))]);
        }
        _consumeComment(start) {
            this._beginToken(10 /* COMMENT_START */, start);
            this._requireCharCode($MINUS);
            this._endToken([]);
            this._consumeRawText(false, () => this._attemptStr('-->'));
            this._beginToken(11 /* COMMENT_END */);
            this._requireStr('-->');
            this._endToken([]);
        }
        _consumeCdata(start) {
            this._beginToken(12 /* CDATA_START */, start);
            this._requireStr('CDATA[');
            this._endToken([]);
            this._consumeRawText(false, () => this._attemptStr(']]>'));
            this._beginToken(13 /* CDATA_END */);
            this._requireStr(']]>');
            this._endToken([]);
        }
        _consumeDocType(start) {
            this._beginToken(18 /* DOC_TYPE */, start);
            const contentStart = this._cursor.clone();
            this._attemptUntilChar($GT);
            const content = this._cursor.getChars(contentStart);
            this._cursor.advance();
            this._endToken([content]);
        }
        _consumePrefixAndName() {
            const nameOrPrefixStart = this._cursor.clone();
            let prefix = '';
            while (this._cursor.peek() !== $COLON && !isPrefixEnd(this._cursor.peek())) {
                this._cursor.advance();
            }
            let nameStart;
            if (this._cursor.peek() === $COLON) {
                prefix = this._cursor.getChars(nameOrPrefixStart);
                this._cursor.advance();
                nameStart = this._cursor.clone();
            }
            else {
                nameStart = nameOrPrefixStart;
            }
            this._requireCharCodeUntilFn(isNameEnd, prefix === '' ? 0 : 1);
            const name = this._cursor.getChars(nameStart);
            return [prefix, name];
        }
        _consumeTagOpen(start) {
            let tagName;
            let prefix;
            let openTagToken;
            try {
                if (!isAsciiLetter(this._cursor.peek())) {
                    throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(start));
                }
                openTagToken = this._consumeTagOpenStart(start);
                prefix = openTagToken.parts[0];
                tagName = openTagToken.parts[1];
                this._attemptCharCodeUntilFn(isNotWhitespace);
                while (this._cursor.peek() !== $SLASH && this._cursor.peek() !== $GT &&
                    this._cursor.peek() !== $LT && this._cursor.peek() !== $EOF) {
                    this._consumeAttributeName();
                    this._attemptCharCodeUntilFn(isNotWhitespace);
                    if (this._attemptCharCode($EQ)) {
                        this._attemptCharCodeUntilFn(isNotWhitespace);
                        this._consumeAttributeValue();
                    }
                    this._attemptCharCodeUntilFn(isNotWhitespace);
                }
                this._consumeTagOpenEnd();
            }
            catch (e) {
                if (e instanceof _ControlFlowError) {
                    if (openTagToken) {
                        // We errored before we could close the opening tag, so it is incomplete.
                        openTagToken.type = 4 /* INCOMPLETE_TAG_OPEN */;
                    }
                    else {
                        // When the start tag is invalid, assume we want a "<" as text.
                        // Back to back text tokens are merged at the end.
                        this._beginToken(5 /* TEXT */, start);
                        this._endToken(['<']);
                    }
                    return;
                }
                throw e;
            }
            const contentTokenType = this._getTagDefinition(tagName).getContentType(prefix);
            if (contentTokenType === TagContentType.RAW_TEXT) {
                this._consumeRawTextWithTagClose(prefix, tagName, false);
            }
            else if (contentTokenType === TagContentType.ESCAPABLE_RAW_TEXT) {
                this._consumeRawTextWithTagClose(prefix, tagName, true);
            }
        }
        _consumeRawTextWithTagClose(prefix, tagName, consumeEntities) {
            this._consumeRawText(consumeEntities, () => {
                if (!this._attemptCharCode($LT))
                    return false;
                if (!this._attemptCharCode($SLASH))
                    return false;
                this._attemptCharCodeUntilFn(isNotWhitespace);
                if (!this._attemptStrCaseInsensitive(tagName))
                    return false;
                this._attemptCharCodeUntilFn(isNotWhitespace);
                return this._attemptCharCode($GT);
            });
            this._beginToken(3 /* TAG_CLOSE */);
            this._requireCharCodeUntilFn(code => code === $GT, 3);
            this._cursor.advance(); // Consume the `>`
            this._endToken([prefix, tagName]);
        }
        _consumeTagOpenStart(start) {
            this._beginToken(0 /* TAG_OPEN_START */, start);
            const parts = this._consumePrefixAndName();
            return this._endToken(parts);
        }
        _consumeAttributeName() {
            const attrNameStart = this._cursor.peek();
            if (attrNameStart === $SQ || attrNameStart === $DQ) {
                throw this._createError(_unexpectedCharacterErrorMsg(attrNameStart), this._cursor.getSpan());
            }
            this._beginToken(14 /* ATTR_NAME */);
            const prefixAndName = this._consumePrefixAndName();
            this._endToken(prefixAndName);
        }
        _consumeAttributeValue() {
            if (this._cursor.peek() === $SQ || this._cursor.peek() === $DQ) {
                const quoteChar = this._cursor.peek();
                this._consumeQuote(quoteChar);
                // In an attribute then end of the attribute value and the premature end to an interpolation
                // are both triggered by the `quoteChar`.
                const endPredicate = () => this._cursor.peek() === quoteChar;
                this._consumeWithInterpolation(16 /* ATTR_VALUE_TEXT */, 17 /* ATTR_VALUE_INTERPOLATION */, endPredicate, endPredicate);
                this._consumeQuote(quoteChar);
            }
            else {
                const endPredicate = () => isNameEnd(this._cursor.peek());
                this._consumeWithInterpolation(16 /* ATTR_VALUE_TEXT */, 17 /* ATTR_VALUE_INTERPOLATION */, endPredicate, endPredicate);
            }
        }
        _consumeQuote(quoteChar) {
            this._beginToken(15 /* ATTR_QUOTE */);
            this._requireCharCode(quoteChar);
            this._endToken([String.fromCodePoint(quoteChar)]);
        }
        _consumeTagOpenEnd() {
            const tokenType = this._attemptCharCode($SLASH) ? 2 /* TAG_OPEN_END_VOID */ : 1 /* TAG_OPEN_END */;
            this._beginToken(tokenType);
            this._requireCharCode($GT);
            this._endToken([]);
        }
        _consumeTagClose(start) {
            this._beginToken(3 /* TAG_CLOSE */, start);
            this._attemptCharCodeUntilFn(isNotWhitespace);
            const prefixAndName = this._consumePrefixAndName();
            this._attemptCharCodeUntilFn(isNotWhitespace);
            this._requireCharCode($GT);
            this._endToken(prefixAndName);
        }
        _consumeExpansionFormStart() {
            this._beginToken(19 /* EXPANSION_FORM_START */);
            this._requireCharCode($LBRACE);
            this._endToken([]);
            this._expansionCaseStack.push(19 /* EXPANSION_FORM_START */);
            this._beginToken(7 /* RAW_TEXT */);
            const condition = this._readUntil($COMMA);
            const normalizedCondition = this._processCarriageReturns(condition);
            if (this._i18nNormalizeLineEndingsInICUs) {
                // We explicitly want to normalize line endings for this text.
                this._endToken([normalizedCondition]);
            }
            else {
                // We are not normalizing line endings.
                const conditionToken = this._endToken([condition]);
                if (normalizedCondition !== condition) {
                    this.nonNormalizedIcuExpressions.push(conditionToken);
                }
            }
            this._requireCharCode($COMMA);
            this._attemptCharCodeUntilFn(isNotWhitespace);
            this._beginToken(7 /* RAW_TEXT */);
            const type = this._readUntil($COMMA);
            this._endToken([type]);
            this._requireCharCode($COMMA);
            this._attemptCharCodeUntilFn(isNotWhitespace);
        }
        _consumeExpansionCaseStart() {
            this._beginToken(20 /* EXPANSION_CASE_VALUE */);
            const value = this._readUntil($LBRACE).trim();
            this._endToken([value]);
            this._attemptCharCodeUntilFn(isNotWhitespace);
            this._beginToken(21 /* EXPANSION_CASE_EXP_START */);
            this._requireCharCode($LBRACE);
            this._endToken([]);
            this._attemptCharCodeUntilFn(isNotWhitespace);
            this._expansionCaseStack.push(21 /* EXPANSION_CASE_EXP_START */);
        }
        _consumeExpansionCaseEnd() {
            this._beginToken(22 /* EXPANSION_CASE_EXP_END */);
            this._requireCharCode($RBRACE);
            this._endToken([]);
            this._attemptCharCodeUntilFn(isNotWhitespace);
            this._expansionCaseStack.pop();
        }
        _consumeExpansionFormEnd() {
            this._beginToken(23 /* EXPANSION_FORM_END */);
            this._requireCharCode($RBRACE);
            this._endToken([]);
            this._expansionCaseStack.pop();
        }
        /**
         * Consume a string that may contain interpolation expressions.
         *
         * The first token consumed will be of `tokenType` and then there will be alternating
         * `interpolationTokenType` and `tokenType` tokens until the `endPredicate()` returns true.
         *
         * If an interpolation token ends prematurely it will have no end marker in its `parts` array.
         *
         * @param textTokenType the kind of tokens to interleave around interpolation tokens.
         * @param interpolationTokenType the kind of tokens that contain interpolation.
         * @param endPredicate a function that should return true when we should stop consuming.
         * @param endInterpolation a function that should return true if there is a premature end to an
         *     interpolation expression - i.e. before we get to the normal interpolation closing marker.
         */
        _consumeWithInterpolation(textTokenType, interpolationTokenType, endPredicate, endInterpolation) {
            this._beginToken(textTokenType);
            const parts = [];
            while (!endPredicate()) {
                const current = this._cursor.clone();
                if (this._interpolationConfig && this._attemptStr(this._interpolationConfig.start)) {
                    this._endToken([this._processCarriageReturns(parts.join(''))], current);
                    parts.length = 0;
                    this._consumeInterpolation(interpolationTokenType, current, endInterpolation);
                    this._beginToken(textTokenType);
                }
                else if (this._cursor.peek() === $AMPERSAND) {
                    this._endToken([this._processCarriageReturns(parts.join(''))]);
                    parts.length = 0;
                    this._consumeEntity(textTokenType);
                    this._beginToken(textTokenType);
                }
                else {
                    parts.push(this._readChar());
                }
            }
            // It is possible that an interpolation was started but not ended inside this text token.
            // Make sure that we reset the state of the lexer correctly.
            this._inInterpolation = false;
            this._endToken([this._processCarriageReturns(parts.join(''))]);
        }
        /**
         * Consume a block of text that has been interpreted as an Angular interpolation.
         *
         * @param interpolationTokenType the type of the interpolation token to generate.
         * @param interpolationStart a cursor that points to the start of this interpolation.
         * @param prematureEndPredicate a function that should return true if the next characters indicate
         *     an end to the interpolation before its normal closing marker.
         */
        _consumeInterpolation(interpolationTokenType, interpolationStart, prematureEndPredicate) {
            const parts = [];
            this._beginToken(interpolationTokenType, interpolationStart);
            parts.push(this._interpolationConfig.start);
            // Find the end of the interpolation, ignoring content inside quotes.
            const expressionStart = this._cursor.clone();
            let inQuote = null;
            let inComment = false;
            while (this._cursor.peek() !== $EOF &&
                (prematureEndPredicate === null || !prematureEndPredicate())) {
                const current = this._cursor.clone();
                if (this._isTagStart()) {
                    // We are starting what looks like an HTML element in the middle of this interpolation.
                    // Reset the cursor to before the `<` character and end the interpolation token.
                    // (This is actually wrong but here for backward compatibility).
                    this._cursor = current;
                    parts.push(this._getProcessedChars(expressionStart, current));
                    this._endToken(parts);
                    return;
                }
                if (inQuote === null) {
                    if (this._attemptStr(this._interpolationConfig.end)) {
                        // We are not in a string, and we hit the end interpolation marker
                        parts.push(this._getProcessedChars(expressionStart, current));
                        parts.push(this._interpolationConfig.end);
                        this._endToken(parts);
                        return;
                    }
                    else if (this._attemptStr('//')) {
                        // Once we are in a comment we ignore any quotes
                        inComment = true;
                    }
                }
                const char = this._cursor.peek();
                this._cursor.advance();
                if (char === $BACKSLASH) {
                    // Skip the next character because it was escaped.
                    this._cursor.advance();
                }
                else if (char === inQuote) {
                    // Exiting the current quoted string
                    inQuote = null;
                }
                else if (!inComment && inQuote === null && isQuote(char)) {
                    // Entering a new quoted string
                    inQuote = char;
                }
            }
            // We hit EOF without finding a closing interpolation marker
            parts.push(this._getProcessedChars(expressionStart, this._cursor));
            this._endToken(parts);
        }
        _getProcessedChars(start, end) {
            return this._processCarriageReturns(end.getChars(start));
        }
        _isTextEnd() {
            if (this._isTagStart() || this._cursor.peek() === $EOF) {
                return true;
            }
            if (this._tokenizeIcu && !this._inInterpolation) {
                if (this.isExpansionFormStart()) {
                    // start of an expansion form
                    return true;
                }
                if (this._cursor.peek() === $RBRACE && this._isInExpansionCase()) {
                    // end of and expansion case
                    return true;
                }
            }
            return false;
        }
        /**
         * Returns true if the current cursor is pointing to the start of a tag
         * (opening/closing/comments/cdata/etc).
         */
        _isTagStart() {
            if (this._cursor.peek() === $LT) {
                // We assume that `<` followed by whitespace is not the start of an HTML element.
                const tmp = this._cursor.clone();
                tmp.advance();
                // If the next character is alphabetic, ! nor / then it is a tag start
                const code = tmp.peek();
                if (($a <= code && code <= $z) || ($A <= code && code <= $Z) ||
                    code === $SLASH || code === $BANG) {
                    return true;
                }
            }
            return false;
        }
        _readUntil(char) {
            const start = this._cursor.clone();
            this._attemptUntilChar(char);
            return this._cursor.getChars(start);
        }
        _isInExpansionCase() {
            return this._expansionCaseStack.length > 0 &&
                this._expansionCaseStack[this._expansionCaseStack.length - 1] ===
                    21 /* EXPANSION_CASE_EXP_START */;
        }
        _isInExpansionForm() {
            return this._expansionCaseStack.length > 0 &&
                this._expansionCaseStack[this._expansionCaseStack.length - 1] ===
                    19 /* EXPANSION_FORM_START */;
        }
        isExpansionFormStart() {
            if (this._cursor.peek() !== $LBRACE) {
                return false;
            }
            if (this._interpolationConfig) {
                const start = this._cursor.clone();
                const isInterpolation = this._attemptStr(this._interpolationConfig.start);
                this._cursor = start;
                return !isInterpolation;
            }
            return true;
        }
    }
    function isNotWhitespace(code) {
        return !isWhitespace(code) || code === $EOF;
    }
    function isNameEnd(code) {
        return isWhitespace(code) || code === $GT || code === $LT ||
            code === $SLASH || code === $SQ || code === $DQ || code === $EQ ||
            code === $EOF;
    }
    function isPrefixEnd(code) {
        return (code < $a || $z < code) && (code < $A || $Z < code) &&
            (code < $0 || code > $9);
    }
    function isDigitEntityEnd(code) {
        return code === $SEMICOLON || code === $EOF || !isAsciiHexDigit(code);
    }
    function isNamedEntityEnd(code) {
        return code === $SEMICOLON || code === $EOF || !isAsciiLetter(code);
    }
    function isExpansionCaseStart(peek) {
        return peek !== $RBRACE;
    }
    function compareCharCodeCaseInsensitive(code1, code2) {
        return toUpperCaseCharCode(code1) === toUpperCaseCharCode(code2);
    }
    function toUpperCaseCharCode(code) {
        return code >= $a && code <= $z ? code - $a + $A : code;
    }
    function mergeTextTokens(srcTokens) {
        const dstTokens = [];
        let lastDstToken = undefined;
        for (let i = 0; i < srcTokens.length; i++) {
            const token = srcTokens[i];
            if ((lastDstToken && lastDstToken.type === 5 /* TEXT */ && token.type === 5 /* TEXT */) ||
                (lastDstToken && lastDstToken.type === 16 /* ATTR_VALUE_TEXT */ &&
                    token.type === 16 /* ATTR_VALUE_TEXT */)) {
                lastDstToken.parts[0] += token.parts[0];
                lastDstToken.sourceSpan.end = token.sourceSpan.end;
            }
            else {
                lastDstToken = token;
                dstTokens.push(lastDstToken);
            }
        }
        return dstTokens;
    }
    class PlainCharacterCursor {
        constructor(fileOrCursor, range) {
            if (fileOrCursor instanceof PlainCharacterCursor) {
                this.file = fileOrCursor.file;
                this.input = fileOrCursor.input;
                this.end = fileOrCursor.end;
                const state = fileOrCursor.state;
                // Note: avoid using `{...fileOrCursor.state}` here as that has a severe performance penalty.
                // In ES5 bundles the object spread operator is translated into the `__assign` helper, which
                // is not optimized by VMs as efficiently as a raw object literal. Since this constructor is
                // called in tight loops, this difference matters.
                this.state = {
                    peek: state.peek,
                    offset: state.offset,
                    line: state.line,
                    column: state.column,
                };
            }
            else {
                if (!range) {
                    throw new Error('Programming error: the range argument must be provided with a file argument.');
                }
                this.file = fileOrCursor;
                this.input = fileOrCursor.content;
                this.end = range.endPos;
                this.state = {
                    peek: -1,
                    offset: range.startPos,
                    line: range.startLine,
                    column: range.startCol,
                };
            }
        }
        clone() {
            return new PlainCharacterCursor(this);
        }
        peek() {
            return this.state.peek;
        }
        charsLeft() {
            return this.end - this.state.offset;
        }
        diff(other) {
            return this.state.offset - other.state.offset;
        }
        advance() {
            this.advanceState(this.state);
        }
        init() {
            this.updatePeek(this.state);
        }
        getSpan(start, leadingTriviaCodePoints) {
            start = start || this;
            let fullStart = start;
            if (leadingTriviaCodePoints) {
                while (this.diff(start) > 0 && leadingTriviaCodePoints.indexOf(start.peek()) !== -1) {
                    if (fullStart === start) {
                        start = start.clone();
                    }
                    start.advance();
                }
            }
            const startLocation = this.locationFromCursor(start);
            const endLocation = this.locationFromCursor(this);
            const fullStartLocation = fullStart !== start ? this.locationFromCursor(fullStart) : startLocation;
            return new ParseSourceSpan(startLocation, endLocation, fullStartLocation);
        }
        getChars(start) {
            return this.input.substring(start.state.offset, this.state.offset);
        }
        charAt(pos) {
            return this.input.charCodeAt(pos);
        }
        advanceState(state) {
            if (state.offset >= this.end) {
                this.state = state;
                throw new CursorError('Unexpected character "EOF"', this);
            }
            const currentChar = this.charAt(state.offset);
            if (currentChar === $LF) {
                state.line++;
                state.column = 0;
            }
            else if (!isNewLine(currentChar)) {
                state.column++;
            }
            state.offset++;
            this.updatePeek(state);
        }
        updatePeek(state) {
            state.peek = state.offset >= this.end ? $EOF : this.charAt(state.offset);
        }
        locationFromCursor(cursor) {
            return new ParseLocation(cursor.file, cursor.state.offset, cursor.state.line, cursor.state.column);
        }
    }
    class EscapedCharacterCursor extends PlainCharacterCursor {
        constructor(fileOrCursor, range) {
            if (fileOrCursor instanceof EscapedCharacterCursor) {
                super(fileOrCursor);
                this.internalState = Object.assign({}, fileOrCursor.internalState);
            }
            else {
                super(fileOrCursor, range);
                this.internalState = this.state;
            }
        }
        advance() {
            this.state = this.internalState;
            super.advance();
            this.processEscapeSequence();
        }
        init() {
            super.init();
            this.processEscapeSequence();
        }
        clone() {
            return new EscapedCharacterCursor(this);
        }
        getChars(start) {
            const cursor = start.clone();
            let chars = '';
            while (cursor.internalState.offset < this.internalState.offset) {
                chars += String.fromCodePoint(cursor.peek());
                cursor.advance();
            }
            return chars;
        }
        /**
         * Process the escape sequence that starts at the current position in the text.
         *
         * This method is called to ensure that `peek` has the unescaped value of escape sequences.
         */
        processEscapeSequence() {
            const peek = () => this.internalState.peek;
            if (peek() === $BACKSLASH) {
                // We have hit an escape sequence so we need the internal state to become independent
                // of the external state.
                this.internalState = Object.assign({}, this.state);
                // Move past the backslash
                this.advanceState(this.internalState);
                // First check for standard control char sequences
                if (peek() === $n) {
                    this.state.peek = $LF;
                }
                else if (peek() === $r) {
                    this.state.peek = $CR;
                }
                else if (peek() === $v) {
                    this.state.peek = $VTAB;
                }
                else if (peek() === $t) {
                    this.state.peek = $TAB;
                }
                else if (peek() === $b) {
                    this.state.peek = $BSPACE;
                }
                else if (peek() === $f) {
                    this.state.peek = $FF;
                }
                // Now consider more complex sequences
                else if (peek() === $u) {
                    // Unicode code-point sequence
                    this.advanceState(this.internalState); // advance past the `u` char
                    if (peek() === $LBRACE) {
                        // Variable length Unicode, e.g. `\x{123}`
                        this.advanceState(this.internalState); // advance past the `{` char
                        // Advance past the variable number of hex digits until we hit a `}` char
                        const digitStart = this.clone();
                        let length = 0;
                        while (peek() !== $RBRACE) {
                            this.advanceState(this.internalState);
                            length++;
                        }
                        this.state.peek = this.decodeHexDigits(digitStart, length);
                    }
                    else {
                        // Fixed length Unicode, e.g. `\u1234`
                        const digitStart = this.clone();
                        this.advanceState(this.internalState);
                        this.advanceState(this.internalState);
                        this.advanceState(this.internalState);
                        this.state.peek = this.decodeHexDigits(digitStart, 4);
                    }
                }
                else if (peek() === $x) {
                    // Hex char code, e.g. `\x2F`
                    this.advanceState(this.internalState); // advance past the `x` char
                    const digitStart = this.clone();
                    this.advanceState(this.internalState);
                    this.state.peek = this.decodeHexDigits(digitStart, 2);
                }
                else if (isOctalDigit(peek())) {
                    // Octal char code, e.g. `\012`,
                    let octal = '';
                    let length = 0;
                    let previous = this.clone();
                    while (isOctalDigit(peek()) && length < 3) {
                        previous = this.clone();
                        octal += String.fromCodePoint(peek());
                        this.advanceState(this.internalState);
                        length++;
                    }
                    this.state.peek = parseInt(octal, 8);
                    // Backup one char
                    this.internalState = previous.internalState;
                }
                else if (isNewLine(this.internalState.peek)) {
                    // Line continuation `\` followed by a new line
                    this.advanceState(this.internalState); // advance over the newline
                    this.state = this.internalState;
                }
                else {
                    // If none of the `if` blocks were executed then we just have an escaped normal character.
                    // In that case we just, effectively, skip the backslash from the character.
                    this.state.peek = this.internalState.peek;
                }
            }
        }
        decodeHexDigits(start, length) {
            const hex = this.input.substr(start.internalState.offset, length);
            const charCode = parseInt(hex, 16);
            if (!isNaN(charCode)) {
                return charCode;
            }
            else {
                start.state = start.internalState;
                throw new CursorError('Invalid hexadecimal escape sequence', start);
            }
        }
    }
    class CursorError {
        constructor(msg, cursor) {
            this.msg = msg;
            this.cursor = cursor;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class TreeError extends ParseError {
        constructor(elementName, span, msg) {
            super(span, msg);
            this.elementName = elementName;
        }
        static create(elementName, span, msg) {
            return new TreeError(elementName, span, msg);
        }
    }
    class ParseTreeResult {
        constructor(rootNodes, errors) {
            this.rootNodes = rootNodes;
            this.errors = errors;
        }
    }
    class Parser {
        constructor(getTagDefinition) {
            this.getTagDefinition = getTagDefinition;
        }
        parse(source, url, options) {
            const tokenizeResult = tokenize(source, url, this.getTagDefinition, options);
            const parser = new _TreeBuilder(tokenizeResult.tokens, this.getTagDefinition);
            parser.build();
            return new ParseTreeResult(parser.rootNodes, tokenizeResult.errors.concat(parser.errors));
        }
    }
    class _TreeBuilder {
        constructor(tokens, getTagDefinition) {
            this.tokens = tokens;
            this.getTagDefinition = getTagDefinition;
            this._index = -1;
            this._elementStack = [];
            this.rootNodes = [];
            this.errors = [];
            this._advance();
        }
        build() {
            while (this._peek.type !== 24 /* EOF */) {
                if (this._peek.type === 0 /* TAG_OPEN_START */ ||
                    this._peek.type === 4 /* INCOMPLETE_TAG_OPEN */) {
                    this._consumeStartTag(this._advance());
                }
                else if (this._peek.type === 3 /* TAG_CLOSE */) {
                    this._consumeEndTag(this._advance());
                }
                else if (this._peek.type === 12 /* CDATA_START */) {
                    this._closeVoidElement();
                    this._consumeCdata(this._advance());
                }
                else if (this._peek.type === 10 /* COMMENT_START */) {
                    this._closeVoidElement();
                    this._consumeComment(this._advance());
                }
                else if (this._peek.type === 5 /* TEXT */ || this._peek.type === 7 /* RAW_TEXT */ ||
                    this._peek.type === 6 /* ESCAPABLE_RAW_TEXT */) {
                    this._closeVoidElement();
                    this._consumeText(this._advance());
                }
                else if (this._peek.type === 19 /* EXPANSION_FORM_START */) {
                    this._consumeExpansion(this._advance());
                }
                else {
                    // Skip all other tokens...
                    this._advance();
                }
            }
        }
        _advance() {
            const prev = this._peek;
            if (this._index < this.tokens.length - 1) {
                // Note: there is always an EOF token at the end
                this._index++;
            }
            this._peek = this.tokens[this._index];
            return prev;
        }
        _advanceIf(type) {
            if (this._peek.type === type) {
                return this._advance();
            }
            return null;
        }
        _consumeCdata(_startToken) {
            this._consumeText(this._advance());
            this._advanceIf(13 /* CDATA_END */);
        }
        _consumeComment(token) {
            const text = this._advanceIf(7 /* RAW_TEXT */);
            this._advanceIf(11 /* COMMENT_END */);
            const value = text != null ? text.parts[0].trim() : null;
            this._addToParent(new Comment$1(value, token.sourceSpan));
        }
        _consumeExpansion(token) {
            const switchValue = this._advance();
            const type = this._advance();
            const cases = [];
            // read =
            while (this._peek.type === 20 /* EXPANSION_CASE_VALUE */) {
                const expCase = this._parseExpansionCase();
                if (!expCase)
                    return; // error
                cases.push(expCase);
            }
            // read the final }
            if (this._peek.type !== 23 /* EXPANSION_FORM_END */) {
                this.errors.push(TreeError.create(null, this._peek.sourceSpan, `Invalid ICU message. Missing '}'.`));
                return;
            }
            const sourceSpan = new ParseSourceSpan(token.sourceSpan.start, this._peek.sourceSpan.end, token.sourceSpan.fullStart);
            this._addToParent(new Expansion(switchValue.parts[0], type.parts[0], cases, sourceSpan, switchValue.sourceSpan));
            this._advance();
        }
        _parseExpansionCase() {
            const value = this._advance();
            // read {
            if (this._peek.type !== 21 /* EXPANSION_CASE_EXP_START */) {
                this.errors.push(TreeError.create(null, this._peek.sourceSpan, `Invalid ICU message. Missing '{'.`));
                return null;
            }
            // read until }
            const start = this._advance();
            const exp = this._collectExpansionExpTokens(start);
            if (!exp)
                return null;
            const end = this._advance();
            exp.push({ type: 24 /* EOF */, parts: [], sourceSpan: end.sourceSpan });
            // parse everything in between { and }
            const expansionCaseParser = new _TreeBuilder(exp, this.getTagDefinition);
            expansionCaseParser.build();
            if (expansionCaseParser.errors.length > 0) {
                this.errors = this.errors.concat(expansionCaseParser.errors);
                return null;
            }
            const sourceSpan = new ParseSourceSpan(value.sourceSpan.start, end.sourceSpan.end, value.sourceSpan.fullStart);
            const expSourceSpan = new ParseSourceSpan(start.sourceSpan.start, end.sourceSpan.end, start.sourceSpan.fullStart);
            return new ExpansionCase(value.parts[0], expansionCaseParser.rootNodes, sourceSpan, value.sourceSpan, expSourceSpan);
        }
        _collectExpansionExpTokens(start) {
            const exp = [];
            const expansionFormStack = [21 /* EXPANSION_CASE_EXP_START */];
            while (true) {
                if (this._peek.type === 19 /* EXPANSION_FORM_START */ ||
                    this._peek.type === 21 /* EXPANSION_CASE_EXP_START */) {
                    expansionFormStack.push(this._peek.type);
                }
                if (this._peek.type === 22 /* EXPANSION_CASE_EXP_END */) {
                    if (lastOnStack(expansionFormStack, 21 /* EXPANSION_CASE_EXP_START */)) {
                        expansionFormStack.pop();
                        if (expansionFormStack.length === 0)
                            return exp;
                    }
                    else {
                        this.errors.push(TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`));
                        return null;
                    }
                }
                if (this._peek.type === 23 /* EXPANSION_FORM_END */) {
                    if (lastOnStack(expansionFormStack, 19 /* EXPANSION_FORM_START */)) {
                        expansionFormStack.pop();
                    }
                    else {
                        this.errors.push(TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`));
                        return null;
                    }
                }
                if (this._peek.type === 24 /* EOF */) {
                    this.errors.push(TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`));
                    return null;
                }
                exp.push(this._advance());
            }
        }
        _consumeText(token) {
            const tokens = [token];
            const startSpan = token.sourceSpan;
            let text = token.parts[0];
            if (text.length > 0 && text[0] === '\n') {
                const parent = this._getParentElement();
                if (parent != null && parent.children.length === 0 &&
                    this.getTagDefinition(parent.name).ignoreFirstLf) {
                    text = text.substring(1);
                    tokens[0] = { type: token.type, sourceSpan: token.sourceSpan, parts: [text] };
                }
            }
            while (this._peek.type === 8 /* INTERPOLATION */ || this._peek.type === 5 /* TEXT */ ||
                this._peek.type === 9 /* ENCODED_ENTITY */) {
                token = this._advance();
                tokens.push(token);
                if (token.type === 8 /* INTERPOLATION */) {
                    // For backward compatibility we decode HTML entities that appear in interpolation
                    // expressions. This is arguably a bug, but it could be a considerable breaking change to
                    // fix it. It should be addressed in a larger project to refactor the entire parser/lexer
                    // chain after View Engine has been removed.
                    text += token.parts.join('').replace(/&([^;]+);/g, decodeEntity);
                }
                else if (token.type === 9 /* ENCODED_ENTITY */) {
                    text += token.parts[0];
                }
                else {
                    text += token.parts.join('');
                }
            }
            if (text.length > 0) {
                const endSpan = token.sourceSpan;
                this._addToParent(new Text$2(text, new ParseSourceSpan(startSpan.start, endSpan.end, startSpan.fullStart, startSpan.details), tokens));
            }
        }
        _closeVoidElement() {
            const el = this._getParentElement();
            if (el && this.getTagDefinition(el.name).isVoid) {
                this._elementStack.pop();
            }
        }
        _consumeStartTag(startTagToken) {
            const [prefix, name] = startTagToken.parts;
            const attrs = [];
            while (this._peek.type === 14 /* ATTR_NAME */) {
                attrs.push(this._consumeAttr(this._advance()));
            }
            const fullName = this._getElementFullName(prefix, name, this._getParentElement());
            let selfClosing = false;
            // Note: There could have been a tokenizer error
            // so that we don't get a token for the end tag...
            if (this._peek.type === 2 /* TAG_OPEN_END_VOID */) {
                this._advance();
                selfClosing = true;
                const tagDef = this.getTagDefinition(fullName);
                if (!(tagDef.canSelfClose || getNsPrefix(fullName) !== null || tagDef.isVoid)) {
                    this.errors.push(TreeError.create(fullName, startTagToken.sourceSpan, `Only void and foreign elements can be self closed "${startTagToken.parts[1]}"`));
                }
            }
            else if (this._peek.type === 1 /* TAG_OPEN_END */) {
                this._advance();
                selfClosing = false;
            }
            const end = this._peek.sourceSpan.fullStart;
            const span = new ParseSourceSpan(startTagToken.sourceSpan.start, end, startTagToken.sourceSpan.fullStart);
            // Create a separate `startSpan` because `span` will be modified when there is an `end` span.
            const startSpan = new ParseSourceSpan(startTagToken.sourceSpan.start, end, startTagToken.sourceSpan.fullStart);
            const el = new Element$1(fullName, attrs, [], span, startSpan, undefined);
            this._pushElement(el);
            if (selfClosing) {
                // Elements that are self-closed have their `endSourceSpan` set to the full span, as the
                // element start tag also represents the end tag.
                this._popElement(fullName, span);
            }
            else if (startTagToken.type === 4 /* INCOMPLETE_TAG_OPEN */) {
                // We already know the opening tag is not complete, so it is unlikely it has a corresponding
                // close tag. Let's optimistically parse it as a full element and emit an error.
                this._popElement(fullName, null);
                this.errors.push(TreeError.create(fullName, span, `Opening tag "${fullName}" not terminated.`));
            }
        }
        _pushElement(el) {
            const parentEl = this._getParentElement();
            if (parentEl && this.getTagDefinition(parentEl.name).isClosedByChild(el.name)) {
                this._elementStack.pop();
            }
            this._addToParent(el);
            this._elementStack.push(el);
        }
        _consumeEndTag(endTagToken) {
            const fullName = this._getElementFullName(endTagToken.parts[0], endTagToken.parts[1], this._getParentElement());
            if (this.getTagDefinition(fullName).isVoid) {
                this.errors.push(TreeError.create(fullName, endTagToken.sourceSpan, `Void elements do not have end tags "${endTagToken.parts[1]}"`));
            }
            else if (!this._popElement(fullName, endTagToken.sourceSpan)) {
                const errMsg = `Unexpected closing tag "${fullName}". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags`;
                this.errors.push(TreeError.create(fullName, endTagToken.sourceSpan, errMsg));
            }
        }
        /**
         * Closes the nearest element with the tag name `fullName` in the parse tree.
         * `endSourceSpan` is the span of the closing tag, or null if the element does
         * not have a closing tag (for example, this happens when an incomplete
         * opening tag is recovered).
         */
        _popElement(fullName, endSourceSpan) {
            let unexpectedCloseTagDetected = false;
            for (let stackIndex = this._elementStack.length - 1; stackIndex >= 0; stackIndex--) {
                const el = this._elementStack[stackIndex];
                if (el.name === fullName) {
                    // Record the parse span with the element that is being closed. Any elements that are
                    // removed from the element stack at this point are closed implicitly, so they won't get
                    // an end source span (as there is no explicit closing element).
                    el.endSourceSpan = endSourceSpan;
                    el.sourceSpan.end = endSourceSpan !== null ? endSourceSpan.end : el.sourceSpan.end;
                    this._elementStack.splice(stackIndex, this._elementStack.length - stackIndex);
                    return !unexpectedCloseTagDetected;
                }
                if (!this.getTagDefinition(el.name).closedByParent) {
                    // Note that we encountered an unexpected close tag but continue processing the element
                    // stack so we can assign an `endSourceSpan` if there is a corresponding start tag for this
                    // end tag in the stack.
                    unexpectedCloseTagDetected = true;
                }
            }
            return false;
        }
        _consumeAttr(attrName) {
            const fullName = mergeNsAndName(attrName.parts[0], attrName.parts[1]);
            let attrEnd = attrName.sourceSpan.end;
            // Consume any quote
            if (this._peek.type === 15 /* ATTR_QUOTE */) {
                this._advance();
            }
            // Consume the attribute value
            let value = '';
            const valueTokens = [];
            let valueStartSpan = undefined;
            let valueEnd = undefined;
            // NOTE: We need to use a new variable `nextTokenType` here to hide the actual type of
            // `_peek.type` from TS. Otherwise TS will narrow the type of `_peek.type` preventing it from
            // being able to consider `ATTR_VALUE_INTERPOLATION` as an option. This is because TS is not
            // able to see that `_advance()` will actually mutate `_peek`.
            const nextTokenType = this._peek.type;
            if (nextTokenType === 16 /* ATTR_VALUE_TEXT */) {
                valueStartSpan = this._peek.sourceSpan;
                valueEnd = this._peek.sourceSpan.end;
                while (this._peek.type === 16 /* ATTR_VALUE_TEXT */ ||
                    this._peek.type === 17 /* ATTR_VALUE_INTERPOLATION */ ||
                    this._peek.type === 9 /* ENCODED_ENTITY */) {
                    const valueToken = this._advance();
                    valueTokens.push(valueToken);
                    if (valueToken.type === 17 /* ATTR_VALUE_INTERPOLATION */) {
                        // For backward compatibility we decode HTML entities that appear in interpolation
                        // expressions. This is arguably a bug, but it could be a considerable breaking change to
                        // fix it. It should be addressed in a larger project to refactor the entire parser/lexer
                        // chain after View Engine has been removed.
                        value += valueToken.parts.join('').replace(/&([^;]+);/g, decodeEntity);
                    }
                    else if (valueToken.type === 9 /* ENCODED_ENTITY */) {
                        value += valueToken.parts[0];
                    }
                    else {
                        value += valueToken.parts.join('');
                    }
                    valueEnd = attrEnd = valueToken.sourceSpan.end;
                }
            }
            // Consume any quote
            if (this._peek.type === 15 /* ATTR_QUOTE */) {
                const quoteToken = this._advance();
                attrEnd = quoteToken.sourceSpan.end;
            }
            const valueSpan = valueStartSpan && valueEnd &&
                new ParseSourceSpan(valueStartSpan.start, valueEnd, valueStartSpan.fullStart);
            return new Attribute(fullName, value, new ParseSourceSpan(attrName.sourceSpan.start, attrEnd, attrName.sourceSpan.fullStart), attrName.sourceSpan, valueSpan, valueTokens.length > 0 ? valueTokens : undefined, undefined);
        }
        _getParentElement() {
            return this._elementStack.length > 0 ? this._elementStack[this._elementStack.length - 1] : null;
        }
        _addToParent(node) {
            const parent = this._getParentElement();
            if (parent != null) {
                parent.children.push(node);
            }
            else {
                this.rootNodes.push(node);
            }
        }
        _getElementFullName(prefix, localName, parentElement) {
            if (prefix === '') {
                prefix = this.getTagDefinition(localName).implicitNamespacePrefix || '';
                if (prefix === '' && parentElement != null) {
                    const parentTagName = splitNsName(parentElement.name)[1];
                    const parentTagDefinition = this.getTagDefinition(parentTagName);
                    if (!parentTagDefinition.preventNamespaceInheritance) {
                        prefix = getNsPrefix(parentElement.name);
                    }
                }
            }
            return mergeNsAndName(prefix, localName);
        }
    }
    function lastOnStack(stack, element) {
        return stack.length > 0 && stack[stack.length - 1] === element;
    }
    /**
     * Decode the `entity` string, which we believe is the contents of an HTML entity.
     *
     * If the string is not actually a valid/known entity then just return the original `match` string.
     */
    function decodeEntity(match, entity) {
        if (NAMED_ENTITIES[entity] !== undefined) {
            return NAMED_ENTITIES[entity] || match;
        }
        if (/^#x[a-f0-9]+$/i.test(entity)) {
            return String.fromCodePoint(parseInt(entity.slice(2), 16));
        }
        if (/^#\d+$/.test(entity)) {
            return String.fromCodePoint(parseInt(entity.slice(1), 10));
        }
        return match;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class HtmlParser extends Parser {
        constructor() {
            super(getHtmlTagDefinition);
        }
        parse(source, url, options) {
            return super.parse(source, url, options);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const PRESERVE_WS_ATTR_NAME = 'ngPreserveWhitespaces';
    const SKIP_WS_TRIM_TAGS = new Set(['pre', 'template', 'textarea', 'script', 'style']);
    // Equivalent to \s with \u00a0 (non-breaking space) excluded.
    // Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp
    const WS_CHARS = ' \f\n\r\t\v\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff';
    const NO_WS_REGEXP = new RegExp(`[^${WS_CHARS}]`);
    const WS_REPLACE_REGEXP = new RegExp(`[${WS_CHARS}]{2,}`, 'g');
    function hasPreserveWhitespacesAttr(attrs) {
        return attrs.some((attr) => attr.name === PRESERVE_WS_ATTR_NAME);
    }
    /**
     * Angular Dart introduced &ngsp; as a placeholder for non-removable space, see:
     * https://github.com/dart-lang/angular/blob/0bb611387d29d65b5af7f9d2515ab571fd3fbee4/_tests/test/compiler/preserve_whitespace_test.dart#L25-L32
     * In Angular Dart &ngsp; is converted to the 0xE500 PUA (Private Use Areas) unicode character
     * and later on replaced by a space. We are re-implementing the same idea here.
     */
    function replaceNgsp(value) {
        // lexer is replacing the &ngsp; pseudo-entity with NGSP_UNICODE
        return value.replace(new RegExp(NGSP_UNICODE, 'g'), ' ');
    }
    /**
     * This visitor can walk HTML parse tree and remove / trim text nodes using the following rules:
     * - consider spaces, tabs and new lines as whitespace characters;
     * - drop text nodes consisting of whitespace characters only;
     * - for all other text nodes replace consecutive whitespace characters with one space;
     * - convert &ngsp; pseudo-entity to a single space;
     *
     * Removal and trimming of whitespaces have positive performance impact (less code to generate
     * while compiling templates, faster view creation). At the same time it can be "destructive"
     * in some cases (whitespaces can influence layout). Because of the potential of breaking layout
     * this visitor is not activated by default in Angular 5 and people need to explicitly opt-in for
     * whitespace removal. The default option for whitespace removal will be revisited in Angular 6
     * and might be changed to "on" by default.
     */
    class WhitespaceVisitor {
        visitElement(element, context) {
            if (SKIP_WS_TRIM_TAGS.has(element.name) || hasPreserveWhitespacesAttr(element.attrs)) {
                // don't descent into elements where we need to preserve whitespaces
                // but still visit all attributes to eliminate one used as a market to preserve WS
                return new Element$1(element.name, visitAll$1(this, element.attrs), element.children, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);
            }
            return new Element$1(element.name, element.attrs, visitAllWithSiblings(this, element.children), element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);
        }
        visitAttribute(attribute, context) {
            return attribute.name !== PRESERVE_WS_ATTR_NAME ? attribute : null;
        }
        visitText(text, context) {
            const isNotBlank = text.value.match(NO_WS_REGEXP);
            const hasExpansionSibling = context &&
                (context.prev instanceof Expansion || context.next instanceof Expansion);
            if (isNotBlank || hasExpansionSibling) {
                // Process the whitespace in the tokens of this Text node
                const tokens = text.tokens.map(token => token.type === 5 /* TEXT */ ? createWhitespaceProcessedTextToken(token) : token);
                // Process the whitespace of the value of this Text node
                const value = processWhitespace(text.value);
                return new Text$2(value, text.sourceSpan, tokens, text.i18n);
            }
            return null;
        }
        visitComment(comment, context) {
            return comment;
        }
        visitExpansion(expansion, context) {
            return expansion;
        }
        visitExpansionCase(expansionCase, context) {
            return expansionCase;
        }
    }
    function createWhitespaceProcessedTextToken({ type, parts, sourceSpan }) {
        return { type, parts: [processWhitespace(parts[0])], sourceSpan };
    }
    function processWhitespace(text) {
        return replaceNgsp(text).replace(WS_REPLACE_REGEXP, ' ');
    }
    function visitAllWithSiblings(visitor, nodes) {
        const result = [];
        nodes.forEach((ast, i) => {
            const context = { prev: nodes[i - 1], next: nodes[i + 1] };
            const astResult = ast.visit(visitor, context);
            if (astResult) {
                result.push(astResult);
            }
        });
        return result;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var ProviderAstType;
    (function (ProviderAstType) {
        ProviderAstType[ProviderAstType["PublicService"] = 0] = "PublicService";
        ProviderAstType[ProviderAstType["PrivateService"] = 1] = "PrivateService";
        ProviderAstType[ProviderAstType["Component"] = 2] = "Component";
        ProviderAstType[ProviderAstType["Directive"] = 3] = "Directive";
        ProviderAstType[ProviderAstType["Builtin"] = 4] = "Builtin";
    })(ProviderAstType || (ProviderAstType = {}));

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function isStyleUrlResolvable(url) {
        if (url == null || url.length === 0 || url[0] == '/')
            return false;
        const schemeMatch = url.match(URL_WITH_SCHEMA_REGEXP);
        return schemeMatch === null || schemeMatch[1] == 'package' || schemeMatch[1] == 'asset';
    }
    const URL_WITH_SCHEMA_REGEXP = /^([^:/?#]+):/;

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const PROPERTY_PARTS_SEPARATOR = '.';
    const ATTRIBUTE_PREFIX = 'attr';
    const CLASS_PREFIX = 'class';
    const STYLE_PREFIX = 'style';
    const TEMPLATE_ATTR_PREFIX = '*';
    const ANIMATE_PROP_PREFIX = 'animate-';
    /**
     * Parses bindings in templates and in the directive host area.
     */
    class BindingParser {
        constructor(_exprParser, _interpolationConfig, _schemaRegistry, pipes, errors) {
            this._exprParser = _exprParser;
            this._interpolationConfig = _interpolationConfig;
            this._schemaRegistry = _schemaRegistry;
            this.errors = errors;
            this.pipesByName = null;
            this._usedPipes = new Map();
            // When the `pipes` parameter is `null`, do not check for used pipes
            // This is used in IVY when we might not know the available pipes at compile time
            if (pipes) {
                const pipesByName = new Map();
                pipes.forEach(pipe => pipesByName.set(pipe.name, pipe));
                this.pipesByName = pipesByName;
            }
        }
        get interpolationConfig() {
            return this._interpolationConfig;
        }
        getUsedPipes() {
            return Array.from(this._usedPipes.values());
        }
        createBoundHostProperties(dirMeta, sourceSpan) {
            if (dirMeta.hostProperties) {
                const boundProps = [];
                Object.keys(dirMeta.hostProperties).forEach(propName => {
                    const expression = dirMeta.hostProperties[propName];
                    if (typeof expression === 'string') {
                        this.parsePropertyBinding(propName, expression, true, sourceSpan, sourceSpan.start.offset, undefined, [], 
                        // Use the `sourceSpan` for  `keySpan`. This isn't really accurate, but neither is the
                        // sourceSpan, as it represents the sourceSpan of the host itself rather than the
                        // source of the host binding (which doesn't exist in the template). Regardless,
                        // neither of these values are used in Ivy but are only here to satisfy the function
                        // signature. This should likely be refactored in the future so that `sourceSpan`
                        // isn't being used inaccurately.
                        boundProps, sourceSpan);
                    }
                    else {
                        this._reportError(`Value of the host property binding "${propName}" needs to be a string representing an expression but got "${expression}" (${typeof expression})`, sourceSpan);
                    }
                });
                return boundProps;
            }
            return null;
        }
        createDirectiveHostPropertyAsts(dirMeta, elementSelector, sourceSpan) {
            const boundProps = this.createBoundHostProperties(dirMeta, sourceSpan);
            return boundProps &&
                boundProps.map((prop) => this.createBoundElementProperty(elementSelector, prop));
        }
        createDirectiveHostEventAsts(dirMeta, sourceSpan) {
            if (dirMeta.hostListeners) {
                const targetEvents = [];
                Object.keys(dirMeta.hostListeners).forEach(propName => {
                    const expression = dirMeta.hostListeners[propName];
                    if (typeof expression === 'string') {
                        // Use the `sourceSpan` for  `keySpan` and `handlerSpan`. This isn't really accurate, but
                        // neither is the `sourceSpan`, as it represents the `sourceSpan` of the host itself
                        // rather than the source of the host binding (which doesn't exist in the template).
                        // Regardless, neither of these values are used in Ivy but are only here to satisfy the
                        // function signature. This should likely be refactored in the future so that `sourceSpan`
                        // isn't being used inaccurately.
                        this.parseEvent(propName, expression, sourceSpan, sourceSpan, [], targetEvents, sourceSpan);
                    }
                    else {
                        this._reportError(`Value of the host listener "${propName}" needs to be a string representing an expression but got "${expression}" (${typeof expression})`, sourceSpan);
                    }
                });
                return targetEvents;
            }
            return null;
        }
        parseInterpolation(value, sourceSpan) {
            const sourceInfo = sourceSpan.start.toString();
            const absoluteOffset = sourceSpan.fullStart.offset;
            try {
                const ast = this._exprParser.parseInterpolation(value, sourceInfo, absoluteOffset, this._interpolationConfig);
                if (ast)
                    this._reportExpressionParserErrors(ast.errors, sourceSpan);
                this._checkPipes(ast, sourceSpan);
                return ast;
            }
            catch (e) {
                this._reportError(`${e}`, sourceSpan);
                return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);
            }
        }
        /**
         * Similar to `parseInterpolation`, but treats the provided string as a single expression
         * element that would normally appear within the interpolation prefix and suffix (`{{` and `}}`).
         * This is used for parsing the switch expression in ICUs.
         */
        parseInterpolationExpression(expression, sourceSpan) {
            const sourceInfo = sourceSpan.start.toString();
            const absoluteOffset = sourceSpan.start.offset;
            try {
                const ast = this._exprParser.parseInterpolationExpression(expression, sourceInfo, absoluteOffset);
                if (ast)
                    this._reportExpressionParserErrors(ast.errors, sourceSpan);
                this._checkPipes(ast, sourceSpan);
                return ast;
            }
            catch (e) {
                this._reportError(`${e}`, sourceSpan);
                return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);
            }
        }
        /**
         * Parses the bindings in a microsyntax expression, and converts them to
         * `ParsedProperty` or `ParsedVariable`.
         *
         * @param tplKey template binding name
         * @param tplValue template binding value
         * @param sourceSpan span of template binding relative to entire the template
         * @param absoluteValueOffset start of the tplValue relative to the entire template
         * @param targetMatchableAttrs potential attributes to match in the template
         * @param targetProps target property bindings in the template
         * @param targetVars target variables in the template
         */
        parseInlineTemplateBinding(tplKey, tplValue, sourceSpan, absoluteValueOffset, targetMatchableAttrs, targetProps, targetVars, isIvyAst) {
            const absoluteKeyOffset = sourceSpan.start.offset + TEMPLATE_ATTR_PREFIX.length;
            const bindings = this._parseTemplateBindings(tplKey, tplValue, sourceSpan, absoluteKeyOffset, absoluteValueOffset);
            for (const binding of bindings) {
                // sourceSpan is for the entire HTML attribute. bindingSpan is for a particular
                // binding within the microsyntax expression so it's more narrow than sourceSpan.
                const bindingSpan = moveParseSourceSpan(sourceSpan, binding.sourceSpan);
                const key = binding.key.source;
                const keySpan = moveParseSourceSpan(sourceSpan, binding.key.span);
                if (binding instanceof VariableBinding) {
                    const value = binding.value ? binding.value.source : '$implicit';
                    const valueSpan = binding.value ? moveParseSourceSpan(sourceSpan, binding.value.span) : undefined;
                    targetVars.push(new ParsedVariable(key, value, bindingSpan, keySpan, valueSpan));
                }
                else if (binding.value) {
                    const srcSpan = isIvyAst ? bindingSpan : sourceSpan;
                    const valueSpan = moveParseSourceSpan(sourceSpan, binding.value.ast.sourceSpan);
                    this._parsePropertyAst(key, binding.value, srcSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps);
                }
                else {
                    targetMatchableAttrs.push([key, '' /* value */]);
                    // Since this is a literal attribute with no RHS, source span should be
                    // just the key span.
                    this.parseLiteralAttr(key, null /* value */, keySpan, absoluteValueOffset, undefined /* valueSpan */, targetMatchableAttrs, targetProps, keySpan);
                }
            }
        }
        /**
         * Parses the bindings in a microsyntax expression, e.g.
         * ```
         *    <tag *tplKey="let value1 = prop; let value2 = localVar">
         * ```
         *
         * @param tplKey template binding name
         * @param tplValue template binding value
         * @param sourceSpan span of template binding relative to entire the template
         * @param absoluteKeyOffset start of the `tplKey`
         * @param absoluteValueOffset start of the `tplValue`
         */
        _parseTemplateBindings(tplKey, tplValue, sourceSpan, absoluteKeyOffset, absoluteValueOffset) {
            const sourceInfo = sourceSpan.start.toString();
            try {
                const bindingsResult = this._exprParser.parseTemplateBindings(tplKey, tplValue, sourceInfo, absoluteKeyOffset, absoluteValueOffset);
                this._reportExpressionParserErrors(bindingsResult.errors, sourceSpan);
                bindingsResult.templateBindings.forEach((binding) => {
                    if (binding.value instanceof ASTWithSource) {
                        this._checkPipes(binding.value, sourceSpan);
                    }
                });
                bindingsResult.warnings.forEach((warning) => {
                    this._reportError(warning, sourceSpan, ParseErrorLevel.WARNING);
                });
                return bindingsResult.templateBindings;
            }
            catch (e) {
                this._reportError(`${e}`, sourceSpan);
                return [];
            }
        }
        parseLiteralAttr(name, value, sourceSpan, absoluteOffset, valueSpan, targetMatchableAttrs, 
        // TODO(atscott): keySpan is only optional here so VE template parser implementation does not
        // have to change This should be required when VE is removed.
        targetProps, keySpan) {
            if (isAnimationLabel(name)) {
                name = name.substring(1);
                if (keySpan !== undefined) {
                    keySpan = moveParseSourceSpan(keySpan, new AbsoluteSourceSpan(keySpan.start.offset + 1, keySpan.end.offset));
                }
                if (value) {
                    this._reportError(`Assigning animation triggers via @prop="exp" attributes with an expression is invalid.` +
                        ` Use property bindings (e.g. [@prop]="exp") or use an attribute without a value (e.g. @prop) instead.`, sourceSpan, ParseErrorLevel.ERROR);
                }
                this._parseAnimation(name, value, sourceSpan, absoluteOffset, keySpan, valueSpan, targetMatchableAttrs, targetProps);
            }
            else {
                targetProps.push(new ParsedProperty(name, this._exprParser.wrapLiteralPrimitive(value, '', absoluteOffset), ParsedPropertyType.LITERAL_ATTR, sourceSpan, keySpan, valueSpan));
            }
        }
        parsePropertyBinding(name, expression, isHost, sourceSpan, absoluteOffset, valueSpan, 
        // TODO(atscott): keySpan is only optional here so VE template parser implementation does not
        // have to change This should be required when VE is removed.
        targetMatchableAttrs, targetProps, keySpan) {
            if (name.length === 0) {
                this._reportError(`Property name is missing in binding`, sourceSpan);
            }
            let isAnimationProp = false;
            if (name.startsWith(ANIMATE_PROP_PREFIX)) {
                isAnimationProp = true;
                name = name.substring(ANIMATE_PROP_PREFIX.length);
                if (keySpan !== undefined) {
                    keySpan = moveParseSourceSpan(keySpan, new AbsoluteSourceSpan(keySpan.start.offset + ANIMATE_PROP_PREFIX.length, keySpan.end.offset));
                }
            }
            else if (isAnimationLabel(name)) {
                isAnimationProp = true;
                name = name.substring(1);
                if (keySpan !== undefined) {
                    keySpan = moveParseSourceSpan(keySpan, new AbsoluteSourceSpan(keySpan.start.offset + 1, keySpan.end.offset));
                }
            }
            if (isAnimationProp) {
                this._parseAnimation(name, expression, sourceSpan, absoluteOffset, keySpan, valueSpan, targetMatchableAttrs, targetProps);
            }
            else {
                this._parsePropertyAst(name, this._parseBinding(expression, isHost, valueSpan || sourceSpan, absoluteOffset), sourceSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps);
            }
        }
        parsePropertyInterpolation(name, value, sourceSpan, valueSpan, targetMatchableAttrs, 
        // TODO(atscott): keySpan is only optional here so VE template parser implementation does not
        // have to change This should be required when VE is removed.
        targetProps, keySpan) {
            const expr = this.parseInterpolation(value, valueSpan || sourceSpan);
            if (expr) {
                this._parsePropertyAst(name, expr, sourceSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps);
                return true;
            }
            return false;
        }
        _parsePropertyAst(name, ast, sourceSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps) {
            targetMatchableAttrs.push([name, ast.source]);
            targetProps.push(new ParsedProperty(name, ast, ParsedPropertyType.DEFAULT, sourceSpan, keySpan, valueSpan));
        }
        _parseAnimation(name, expression, sourceSpan, absoluteOffset, keySpan, valueSpan, targetMatchableAttrs, targetProps) {
            if (name.length === 0) {
                this._reportError('Animation trigger is missing', sourceSpan);
            }
            // This will occur when a @trigger is not paired with an expression.
            // For animations it is valid to not have an expression since */void
            // states will be applied by angular when the element is attached/detached
            const ast = this._parseBinding(expression || 'undefined', false, valueSpan || sourceSpan, absoluteOffset);
            targetMatchableAttrs.push([name, ast.source]);
            targetProps.push(new ParsedProperty(name, ast, ParsedPropertyType.ANIMATION, sourceSpan, keySpan, valueSpan));
        }
        _parseBinding(value, isHostBinding, sourceSpan, absoluteOffset) {
            const sourceInfo = (sourceSpan && sourceSpan.start || '(unknown)').toString();
            try {
                const ast = isHostBinding ?
                    this._exprParser.parseSimpleBinding(value, sourceInfo, absoluteOffset, this._interpolationConfig) :
                    this._exprParser.parseBinding(value, sourceInfo, absoluteOffset, this._interpolationConfig);
                if (ast)
                    this._reportExpressionParserErrors(ast.errors, sourceSpan);
                this._checkPipes(ast, sourceSpan);
                return ast;
            }
            catch (e) {
                this._reportError(`${e}`, sourceSpan);
                return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);
            }
        }
        createBoundElementProperty(elementSelector, boundProp, skipValidation = false, mapPropertyName = true) {
            if (boundProp.isAnimation) {
                return new BoundElementProperty(boundProp.name, 4 /* Animation */, SecurityContext.NONE, boundProp.expression, null, boundProp.sourceSpan, boundProp.keySpan, boundProp.valueSpan);
            }
            let unit = null;
            let bindingType = undefined;
            let boundPropertyName = null;
            const parts = boundProp.name.split(PROPERTY_PARTS_SEPARATOR);
            let securityContexts = undefined;
            // Check for special cases (prefix style, attr, class)
            if (parts.length > 1) {
                if (parts[0] == ATTRIBUTE_PREFIX) {
                    boundPropertyName = parts.slice(1).join(PROPERTY_PARTS_SEPARATOR);
                    if (!skipValidation) {
                        this._validatePropertyOrAttributeName(boundPropertyName, boundProp.sourceSpan, true);
                    }
                    securityContexts = calcPossibleSecurityContexts(this._schemaRegistry, elementSelector, boundPropertyName, true);
                    const nsSeparatorIdx = boundPropertyName.indexOf(':');
                    if (nsSeparatorIdx > -1) {
                        const ns = boundPropertyName.substring(0, nsSeparatorIdx);
                        const name = boundPropertyName.substring(nsSeparatorIdx + 1);
                        boundPropertyName = mergeNsAndName(ns, name);
                    }
                    bindingType = 1 /* Attribute */;
                }
                else if (parts[0] == CLASS_PREFIX) {
                    boundPropertyName = parts[1];
                    bindingType = 2 /* Class */;
                    securityContexts = [SecurityContext.NONE];
                }
                else if (parts[0] == STYLE_PREFIX) {
                    unit = parts.length > 2 ? parts[2] : null;
                    boundPropertyName = parts[1];
                    bindingType = 3 /* Style */;
                    securityContexts = [SecurityContext.STYLE];
                }
            }
            // If not a special case, use the full property name
            if (boundPropertyName === null) {
                const mappedPropName = this._schemaRegistry.getMappedPropName(boundProp.name);
                boundPropertyName = mapPropertyName ? mappedPropName : boundProp.name;
                securityContexts = calcPossibleSecurityContexts(this._schemaRegistry, elementSelector, mappedPropName, false);
                bindingType = 0 /* Property */;
                if (!skipValidation) {
                    this._validatePropertyOrAttributeName(mappedPropName, boundProp.sourceSpan, false);
                }
            }
            return new BoundElementProperty(boundPropertyName, bindingType, securityContexts[0], boundProp.expression, unit, boundProp.sourceSpan, boundProp.keySpan, boundProp.valueSpan);
        }
        // TODO: keySpan should be required but was made optional to avoid changing VE parser.
        parseEvent(name, expression, sourceSpan, handlerSpan, targetMatchableAttrs, targetEvents, keySpan) {
            if (name.length === 0) {
                this._reportError(`Event name is missing in binding`, sourceSpan);
            }
            if (isAnimationLabel(name)) {
                name = name.substr(1);
                if (keySpan !== undefined) {
                    keySpan = moveParseSourceSpan(keySpan, new AbsoluteSourceSpan(keySpan.start.offset + 1, keySpan.end.offset));
                }
                this._parseAnimationEvent(name, expression, sourceSpan, handlerSpan, targetEvents, keySpan);
            }
            else {
                this._parseRegularEvent(name, expression, sourceSpan, handlerSpan, targetMatchableAttrs, targetEvents, keySpan);
            }
        }
        calcPossibleSecurityContexts(selector, propName, isAttribute) {
            const prop = this._schemaRegistry.getMappedPropName(propName);
            return calcPossibleSecurityContexts(this._schemaRegistry, selector, prop, isAttribute);
        }
        _parseAnimationEvent(name, expression, sourceSpan, handlerSpan, targetEvents, keySpan) {
            const matches = splitAtPeriod(name, [name, '']);
            const eventName = matches[0];
            const phase = matches[1].toLowerCase();
            const ast = this._parseAction(expression, handlerSpan);
            targetEvents.push(new ParsedEvent(eventName, phase, 1 /* Animation */, ast, sourceSpan, handlerSpan, keySpan));
            if (eventName.length === 0) {
                this._reportError(`Animation event name is missing in binding`, sourceSpan);
            }
            if (phase) {
                if (phase !== 'start' && phase !== 'done') {
                    this._reportError(`The provided animation output phase value "${phase}" for "@${eventName}" is not supported (use start or done)`, sourceSpan);
                }
            }
            else {
                this._reportError(`The animation trigger output event (@${eventName}) is missing its phase value name (start or done are currently supported)`, sourceSpan);
            }
        }
        _parseRegularEvent(name, expression, sourceSpan, handlerSpan, targetMatchableAttrs, targetEvents, keySpan) {
            // long format: 'target: eventName'
            const [target, eventName] = splitAtColon(name, [null, name]);
            const ast = this._parseAction(expression, handlerSpan);
            targetMatchableAttrs.push([name, ast.source]);
            targetEvents.push(new ParsedEvent(eventName, target, 0 /* Regular */, ast, sourceSpan, handlerSpan, keySpan));
            // Don't detect directives for event names for now,
            // so don't add the event name to the matchableAttrs
        }
        _parseAction(value, sourceSpan) {
            const sourceInfo = (sourceSpan && sourceSpan.start || '(unknown').toString();
            const absoluteOffset = (sourceSpan && sourceSpan.start) ? sourceSpan.start.offset : 0;
            try {
                const ast = this._exprParser.parseAction(value, sourceInfo, absoluteOffset, this._interpolationConfig);
                if (ast) {
                    this._reportExpressionParserErrors(ast.errors, sourceSpan);
                }
                if (!ast || ast.ast instanceof EmptyExpr) {
                    this._reportError(`Empty expressions are not allowed`, sourceSpan);
                    return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);
                }
                this._checkPipes(ast, sourceSpan);
                return ast;
            }
            catch (e) {
                this._reportError(`${e}`, sourceSpan);
                return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);
            }
        }
        _reportError(message, sourceSpan, level = ParseErrorLevel.ERROR) {
            this.errors.push(new ParseError(sourceSpan, message, level));
        }
        _reportExpressionParserErrors(errors, sourceSpan) {
            for (const error of errors) {
                this._reportError(error.message, sourceSpan);
            }
        }
        // Make sure all the used pipes are known in `this.pipesByName`
        _checkPipes(ast, sourceSpan) {
            if (ast && this.pipesByName) {
                const collector = new PipeCollector();
                ast.visit(collector);
                collector.pipes.forEach((ast, pipeName) => {
                    const pipeMeta = this.pipesByName.get(pipeName);
                    if (!pipeMeta) {
                        this._reportError(`The pipe '${pipeName}' could not be found`, new ParseSourceSpan(sourceSpan.start.moveBy(ast.span.start), sourceSpan.start.moveBy(ast.span.end)));
                    }
                    else {
                        this._usedPipes.set(pipeName, pipeMeta);
                    }
                });
            }
        }
        /**
         * @param propName the name of the property / attribute
         * @param sourceSpan
         * @param isAttr true when binding to an attribute
         */
        _validatePropertyOrAttributeName(propName, sourceSpan, isAttr) {
            const report = isAttr ? this._schemaRegistry.validateAttribute(propName) :
                this._schemaRegistry.validateProperty(propName);
            if (report.error) {
                this._reportError(report.msg, sourceSpan, ParseErrorLevel.ERROR);
            }
        }
    }
    class PipeCollector extends RecursiveAstVisitor {
        constructor() {
            super(...arguments);
            this.pipes = new Map();
        }
        visitPipe(ast, context) {
            this.pipes.set(ast.name, ast);
            ast.exp.visit(this);
            this.visitAll(ast.args, context);
            return null;
        }
    }
    function isAnimationLabel(name) {
        return name[0] == '@';
    }
    function calcPossibleSecurityContexts(registry, selector, propName, isAttribute) {
        const ctxs = [];
        CssSelector.parse(selector).forEach((selector) => {
            const elementNames = selector.element ? [selector.element] : registry.allKnownElementNames();
            const notElementNames = new Set(selector.notSelectors.filter(selector => selector.isElementSelector())
                .map((selector) => selector.element));
            const possibleElementNames = elementNames.filter(elementName => !notElementNames.has(elementName));
            ctxs.push(...possibleElementNames.map(elementName => registry.securityContext(elementName, propName, isAttribute)));
        });
        return ctxs.length === 0 ? [SecurityContext.NONE] : Array.from(new Set(ctxs)).sort();
    }
    /**
     * Compute a new ParseSourceSpan based off an original `sourceSpan` by using
     * absolute offsets from the specified `absoluteSpan`.
     *
     * @param sourceSpan original source span
     * @param absoluteSpan absolute source span to move to
     */
    function moveParseSourceSpan(sourceSpan, absoluteSpan) {
        // The difference of two absolute offsets provide the relative offset
        const startDiff = absoluteSpan.start - sourceSpan.start.offset;
        const endDiff = absoluteSpan.end - sourceSpan.end.offset;
        return new ParseSourceSpan(sourceSpan.start.moveBy(startDiff), sourceSpan.end.moveBy(endDiff), sourceSpan.fullStart.moveBy(startDiff), sourceSpan.details);
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const NG_CONTENT_SELECT_ATTR = 'select';
    const LINK_ELEMENT = 'link';
    const LINK_STYLE_REL_ATTR = 'rel';
    const LINK_STYLE_HREF_ATTR = 'href';
    const LINK_STYLE_REL_VALUE = 'stylesheet';
    const STYLE_ELEMENT = 'style';
    const SCRIPT_ELEMENT = 'script';
    const NG_NON_BINDABLE_ATTR = 'ngNonBindable';
    const NG_PROJECT_AS = 'ngProjectAs';
    function preparseElement(ast) {
        let selectAttr = null;
        let hrefAttr = null;
        let relAttr = null;
        let nonBindable = false;
        let projectAs = '';
        ast.attrs.forEach(attr => {
            const lcAttrName = attr.name.toLowerCase();
            if (lcAttrName == NG_CONTENT_SELECT_ATTR) {
                selectAttr = attr.value;
            }
            else if (lcAttrName == LINK_STYLE_HREF_ATTR) {
                hrefAttr = attr.value;
            }
            else if (lcAttrName == LINK_STYLE_REL_ATTR) {
                relAttr = attr.value;
            }
            else if (attr.name == NG_NON_BINDABLE_ATTR) {
                nonBindable = true;
            }
            else if (attr.name == NG_PROJECT_AS) {
                if (attr.value.length > 0) {
                    projectAs = attr.value;
                }
            }
        });
        selectAttr = normalizeNgContentSelect(selectAttr);
        const nodeName = ast.name.toLowerCase();
        let type = PreparsedElementType.OTHER;
        if (isNgContent(nodeName)) {
            type = PreparsedElementType.NG_CONTENT;
        }
        else if (nodeName == STYLE_ELEMENT) {
            type = PreparsedElementType.STYLE;
        }
        else if (nodeName == SCRIPT_ELEMENT) {
            type = PreparsedElementType.SCRIPT;
        }
        else if (nodeName == LINK_ELEMENT && relAttr == LINK_STYLE_REL_VALUE) {
            type = PreparsedElementType.STYLESHEET;
        }
        return new PreparsedElement(type, selectAttr, hrefAttr, nonBindable, projectAs);
    }
    var PreparsedElementType;
    (function (PreparsedElementType) {
        PreparsedElementType[PreparsedElementType["NG_CONTENT"] = 0] = "NG_CONTENT";
        PreparsedElementType[PreparsedElementType["STYLE"] = 1] = "STYLE";
        PreparsedElementType[PreparsedElementType["STYLESHEET"] = 2] = "STYLESHEET";
        PreparsedElementType[PreparsedElementType["SCRIPT"] = 3] = "SCRIPT";
        PreparsedElementType[PreparsedElementType["OTHER"] = 4] = "OTHER";
    })(PreparsedElementType || (PreparsedElementType = {}));
    class PreparsedElement {
        constructor(type, selectAttr, hrefAttr, nonBindable, projectAs) {
            this.type = type;
            this.selectAttr = selectAttr;
            this.hrefAttr = hrefAttr;
            this.nonBindable = nonBindable;
            this.projectAs = projectAs;
        }
    }
    function normalizeNgContentSelect(selectAttr) {
        if (selectAttr === null || selectAttr.length === 0) {
            return '*';
        }
        return selectAttr;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function isEmptyExpression(ast) {
        if (ast instanceof ASTWithSource) {
            ast = ast.ast;
        }
        return ast instanceof EmptyExpr;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Parses string representation of a style and converts it into object literal.
     *
     * @param value string representation of style as used in the `style` attribute in HTML.
     *   Example: `color: red; height: auto`.
     * @returns An array of style property name and value pairs, e.g. `['color', 'red', 'height',
     * 'auto']`
     */
    function parse(value) {
        // we use a string array here instead of a string map
        // because a string-map is not guaranteed to retain the
        // order of the entries whereas a string array can be
        // constructed in a [key, value, key, value] format.
        const styles = [];
        let i = 0;
        let parenDepth = 0;
        let quote = 0 /* QuoteNone */;
        let valueStart = 0;
        let propStart = 0;
        let currentProp = null;
        let valueHasQuotes = false;
        while (i < value.length) {
            const token = value.charCodeAt(i++);
            switch (token) {
                case 40 /* OpenParen */:
                    parenDepth++;
                    break;
                case 41 /* CloseParen */:
                    parenDepth--;
                    break;
                case 39 /* QuoteSingle */:
                    // valueStart needs to be there since prop values don't
                    // have quotes in CSS
                    valueHasQuotes = valueHasQuotes || valueStart > 0;
                    if (quote === 0 /* QuoteNone */) {
                        quote = 39 /* QuoteSingle */;
                    }
                    else if (quote === 39 /* QuoteSingle */ && value.charCodeAt(i - 1) !== 92 /* BackSlash */) {
                        quote = 0 /* QuoteNone */;
                    }
                    break;
                case 34 /* QuoteDouble */:
                    // same logic as above
                    valueHasQuotes = valueHasQuotes || valueStart > 0;
                    if (quote === 0 /* QuoteNone */) {
                        quote = 34 /* QuoteDouble */;
                    }
                    else if (quote === 34 /* QuoteDouble */ && value.charCodeAt(i - 1) !== 92 /* BackSlash */) {
                        quote = 0 /* QuoteNone */;
                    }
                    break;
                case 58 /* Colon */:
                    if (!currentProp && parenDepth === 0 && quote === 0 /* QuoteNone */) {
                        currentProp = hyphenate(value.substring(propStart, i - 1).trim());
                        valueStart = i;
                    }
                    break;
                case 59 /* Semicolon */:
                    if (currentProp && valueStart > 0 && parenDepth === 0 && quote === 0 /* QuoteNone */) {
                        const styleVal = value.substring(valueStart, i - 1).trim();
                        styles.push(currentProp, valueHasQuotes ? stripUnnecessaryQuotes(styleVal) : styleVal);
                        propStart = i;
                        valueStart = 0;
                        currentProp = null;
                        valueHasQuotes = false;
                    }
                    break;
            }
        }
        if (currentProp && valueStart) {
            const styleVal = value.substr(valueStart).trim();
            styles.push(currentProp, valueHasQuotes ? stripUnnecessaryQuotes(styleVal) : styleVal);
        }
        return styles;
    }
    function stripUnnecessaryQuotes(value) {
        const qS = value.charCodeAt(0);
        const qE = value.charCodeAt(value.length - 1);
        if (qS == qE && (qS == 39 /* QuoteSingle */ || qS == 34 /* QuoteDouble */)) {
            const tempValue = value.substring(1, value.length - 1);
            // special case to avoid using a multi-quoted string that was just chomped
            // (e.g. `font-family: "Verdana", "sans-serif"`)
            if (tempValue.indexOf('\'') == -1 && tempValue.indexOf('"') == -1) {
                value = tempValue;
            }
        }
        return value;
    }
    function hyphenate(value) {
        return value
            .replace(/[a-z][A-Z]/g, v => {
            return v.charAt(0) + '-' + v.charAt(1);
        })
            .toLowerCase();
    }

    const IMPORTANT_FLAG = '!important';
    /**
     * Minimum amount of binding slots required in the runtime for style/class bindings.
     *
     * Styling in Angular uses up two slots in the runtime LView/TData data structures to
     * record binding data, property information and metadata.
     *
     * When a binding is registered it will place the following information in the `LView`:
     *
     * slot 1) binding value
     * slot 2) cached value (all other values collected before it in string form)
     *
     * When a binding is registered it will place the following information in the `TData`:
     *
     * slot 1) prop name
     * slot 2) binding index that points to the previous style/class binding (and some extra config
     * values)
     *
     * Let's imagine we have a binding that looks like so:
     *
     * ```
     * <div [style.width]="x" [style.height]="y">
     * ```
     *
     * Our `LView` and `TData` data-structures look like so:
     *
     * ```typescript
     * LView = [
     *   // ...
     *   x, // value of x
     *   "width: x",
     *
     *   y, // value of y
     *   "width: x; height: y",
     *   // ...
     * ];
     *
     * TData = [
     *   // ...
     *   "width", // binding slot 20
     *   0,
     *
     *   "height",
     *   20,
     *   // ...
     * ];
     * ```
     *
     * */
    const MIN_STYLING_BINDING_SLOTS_REQUIRED = 2;
    /**
     * Produces creation/update instructions for all styling bindings (class and style)
     *
     * It also produces the creation instruction to register all initial styling values
     * (which are all the static class="..." and style="..." attribute values that exist
     * on an element within a template).
     *
     * The builder class below handles producing instructions for the following cases:
     *
     * - Static style/class attributes (style="..." and class="...")
     * - Dynamic style/class map bindings ([style]="map" and [class]="map|string")
     * - Dynamic style/class property bindings ([style.prop]="exp" and [class.name]="exp")
     *
     * Due to the complex relationship of all of these cases, the instructions generated
     * for these attributes/properties/bindings must be done so in the correct order. The
     * order which these must be generated is as follows:
     *
     * if (createMode) {
     *   styling(...)
     * }
     * if (updateMode) {
     *   styleMap(...)
     *   classMap(...)
     *   styleProp(...)
     *   classProp(...)
     * }
     *
     * The creation/update methods within the builder class produce these instructions.
     */
    class StylingBuilder {
        constructor(_directiveExpr) {
            this._directiveExpr = _directiveExpr;
            /** Whether or not there are any static styling values present */
            this._hasInitialValues = false;
            /**
             *  Whether or not there are any styling bindings present
             *  (i.e. `[style]`, `[class]`, `[style.prop]` or `[class.name]`)
             */
            this.hasBindings = false;
            this.hasBindingsWithPipes = false;
            /** the input for [class] (if it exists) */
            this._classMapInput = null;
            /** the input for [style] (if it exists) */
            this._styleMapInput = null;
            /** an array of each [style.prop] input */
            this._singleStyleInputs = null;
            /** an array of each [class.name] input */
            this._singleClassInputs = null;
            this._lastStylingInput = null;
            this._firstStylingInput = null;
            // maps are used instead of hash maps because a Map will
            // retain the ordering of the keys
            /**
             * Represents the location of each style binding in the template
             * (e.g. `<div [style.width]="w" [style.height]="h">` implies
             * that `width=0` and `height=1`)
             */
            this._stylesIndex = new Map();
            /**
             * Represents the location of each class binding in the template
             * (e.g. `<div [class.big]="b" [class.hidden]="h">` implies
             * that `big=0` and `hidden=1`)
             */
            this._classesIndex = new Map();
            this._initialStyleValues = [];
            this._initialClassValues = [];
        }
        /**
         * Registers a given input to the styling builder to be later used when producing AOT code.
         *
         * The code below will only accept the input if it is somehow tied to styling (whether it be
         * style/class bindings or static style/class attributes).
         */
        registerBoundInput(input) {
            // [attr.style] or [attr.class] are skipped in the code below,
            // they should not be treated as styling-based bindings since
            // they are intended to be written directly to the attr and
            // will therefore skip all style/class resolution that is present
            // with style="", [style]="" and [style.prop]="", class="",
            // [class.prop]="". [class]="" assignments
            let binding = null;
            let name = input.name;
            switch (input.type) {
                case 0 /* Property */:
                    binding = this.registerInputBasedOnName(name, input.value, input.sourceSpan);
                    break;
                case 3 /* Style */:
                    binding = this.registerStyleInput(name, false, input.value, input.sourceSpan, input.unit);
                    break;
                case 2 /* Class */:
                    binding = this.registerClassInput(name, false, input.value, input.sourceSpan);
                    break;
            }
            return binding ? true : false;
        }
        registerInputBasedOnName(name, expression, sourceSpan) {
            let binding = null;
            const prefix = name.substring(0, 6);
            const isStyle = name === 'style' || prefix === 'style.' || prefix === 'style!';
            const isClass = !isStyle && (name === 'class' || prefix === 'class.' || prefix === 'class!');
            if (isStyle || isClass) {
                const isMapBased = name.charAt(5) !== '.'; // style.prop or class.prop makes this a no
                const property = name.substr(isMapBased ? 5 : 6); // the dot explains why there's a +1
                if (isStyle) {
                    binding = this.registerStyleInput(property, isMapBased, expression, sourceSpan);
                }
                else {
                    binding = this.registerClassInput(property, isMapBased, expression, sourceSpan);
                }
            }
            return binding;
        }
        registerStyleInput(name, isMapBased, value, sourceSpan, suffix) {
            if (isEmptyExpression(value)) {
                return null;
            }
            // CSS custom properties are case-sensitive so we shouldn't normalize them.
            // See: https://www.w3.org/TR/css-variables-1/#defining-variables
            if (!isCssCustomProperty(name)) {
                name = hyphenate(name);
            }
            const { property, hasOverrideFlag, suffix: bindingSuffix } = parseProperty(name);
            suffix = typeof suffix === 'string' && suffix.length !== 0 ? suffix : bindingSuffix;
            const entry = { name: property, suffix: suffix, value, sourceSpan, hasOverrideFlag };
            if (isMapBased) {
                this._styleMapInput = entry;
            }
            else {
                (this._singleStyleInputs = this._singleStyleInputs || []).push(entry);
                registerIntoMap(this._stylesIndex, property);
            }
            this._lastStylingInput = entry;
            this._firstStylingInput = this._firstStylingInput || entry;
            this._checkForPipes(value);
            this.hasBindings = true;
            return entry;
        }
        registerClassInput(name, isMapBased, value, sourceSpan) {
            if (isEmptyExpression(value)) {
                return null;
            }
            const { property, hasOverrideFlag } = parseProperty(name);
            const entry = { name: property, value, sourceSpan, hasOverrideFlag, suffix: null };
            if (isMapBased) {
                this._classMapInput = entry;
            }
            else {
                (this._singleClassInputs = this._singleClassInputs || []).push(entry);
                registerIntoMap(this._classesIndex, property);
            }
            this._lastStylingInput = entry;
            this._firstStylingInput = this._firstStylingInput || entry;
            this._checkForPipes(value);
            this.hasBindings = true;
            return entry;
        }
        _checkForPipes(value) {
            if ((value instanceof ASTWithSource) && (value.ast instanceof BindingPipe)) {
                this.hasBindingsWithPipes = true;
            }
        }
        /**
         * Registers the element's static style string value to the builder.
         *
         * @param value the style string (e.g. `width:100px; height:200px;`)
         */
        registerStyleAttr(value) {
            this._initialStyleValues = parse(value);
            this._hasInitialValues = true;
        }
        /**
         * Registers the element's static class string value to the builder.
         *
         * @param value the className string (e.g. `disabled gold zoom`)
         */
        registerClassAttr(value) {
            this._initialClassValues = value.trim().split(/\s+/g);
            this._hasInitialValues = true;
        }
        /**
         * Appends all styling-related expressions to the provided attrs array.
         *
         * @param attrs an existing array where each of the styling expressions
         * will be inserted into.
         */
        populateInitialStylingAttrs(attrs) {
            // [CLASS_MARKER, 'foo', 'bar', 'baz' ...]
            if (this._initialClassValues.length) {
                attrs.push(literal(1 /* Classes */));
                for (let i = 0; i < this._initialClassValues.length; i++) {
                    attrs.push(literal(this._initialClassValues[i]));
                }
            }
            // [STYLE_MARKER, 'width', '200px', 'height', '100px', ...]
            if (this._initialStyleValues.length) {
                attrs.push(literal(2 /* Styles */));
                for (let i = 0; i < this._initialStyleValues.length; i += 2) {
                    attrs.push(literal(this._initialStyleValues[i]), literal(this._initialStyleValues[i + 1]));
                }
            }
        }
        /**
         * Builds an instruction with all the expressions and parameters for `elementHostAttrs`.
         *
         * The instruction generation code below is used for producing the AOT statement code which is
         * responsible for registering initial styles (within a directive hostBindings' creation block),
         * as well as any of the provided attribute values, to the directive host element.
         */
        assignHostAttrs(attrs, definitionMap) {
            if (this._directiveExpr && (attrs.length || this._hasInitialValues)) {
                this.populateInitialStylingAttrs(attrs);
                definitionMap.set('hostAttrs', literalArr(attrs));
            }
        }
        /**
         * Builds an instruction with all the expressions and parameters for `classMap`.
         *
         * The instruction data will contain all expressions for `classMap` to function
         * which includes the `[class]` expression params.
         */
        buildClassMapInstruction(valueConverter) {
            if (this._classMapInput) {
                return this._buildMapBasedInstruction(valueConverter, true, this._classMapInput);
            }
            return null;
        }
        /**
         * Builds an instruction with all the expressions and parameters for `styleMap`.
         *
         * The instruction data will contain all expressions for `styleMap` to function
         * which includes the `[style]` expression params.
         */
        buildStyleMapInstruction(valueConverter) {
            if (this._styleMapInput) {
                return this._buildMapBasedInstruction(valueConverter, false, this._styleMapInput);
            }
            return null;
        }
        _buildMapBasedInstruction(valueConverter, isClassBased, stylingInput) {
            // each styling binding value is stored in the LView
            // map-based bindings allocate two slots: one for the
            // previous binding value and another for the previous
            // className or style attribute value.
            let totalBindingSlotsRequired = MIN_STYLING_BINDING_SLOTS_REQUIRED;
            // these values must be outside of the update block so that they can
            // be evaluated (the AST visit call) during creation time so that any
            // pipes can be picked up in time before the template is built
            const mapValue = stylingInput.value.visit(valueConverter);
            let reference;
            if (mapValue instanceof Interpolation) {
                totalBindingSlotsRequired += mapValue.expressions.length;
                reference = isClassBased ? getClassMapInterpolationExpression(mapValue) :
                    getStyleMapInterpolationExpression(mapValue);
            }
            else {
                reference = isClassBased ? Identifiers.classMap : Identifiers.styleMap;
            }
            return {
                reference,
                calls: [{
                        supportsInterpolation: true,
                        sourceSpan: stylingInput.sourceSpan,
                        allocateBindingSlots: totalBindingSlotsRequired,
                        params: (convertFn) => {
                            const convertResult = convertFn(mapValue);
                            const params = Array.isArray(convertResult) ? convertResult : [convertResult];
                            return params;
                        }
                    }]
            };
        }
        _buildSingleInputs(reference, inputs, valueConverter, getInterpolationExpressionFn, isClassBased) {
            const instructions = [];
            inputs.forEach(input => {
                const previousInstruction = instructions[instructions.length - 1];
                const value = input.value.visit(valueConverter);
                let referenceForCall = reference;
                // each styling binding value is stored in the LView
                // but there are two values stored for each binding:
                //   1) the value itself
                //   2) an intermediate value (concatenation of style up to this point).
                //      We need to store the intermediate value so that we don't allocate
                //      the strings on each CD.
                let totalBindingSlotsRequired = MIN_STYLING_BINDING_SLOTS_REQUIRED;
                if (value instanceof Interpolation) {
                    totalBindingSlotsRequired += value.expressions.length;
                    if (getInterpolationExpressionFn) {
                        referenceForCall = getInterpolationExpressionFn(value);
                    }
                }
                const call = {
                    sourceSpan: input.sourceSpan,
                    allocateBindingSlots: totalBindingSlotsRequired,
                    supportsInterpolation: !!getInterpolationExpressionFn,
                    params: (convertFn) => {
                        // params => stylingProp(propName, value, suffix)
                        const params = [];
                        params.push(literal(input.name));
                        const convertResult = convertFn(value);
                        if (Array.isArray(convertResult)) {
                            params.push(...convertResult);
                        }
                        else {
                            params.push(convertResult);
                        }
                        // [style.prop] bindings may use suffix values (e.g. px, em, etc...), therefore,
                        // if that is detected then we need to pass that in as an optional param.
                        if (!isClassBased && input.suffix !== null) {
                            params.push(literal(input.suffix));
                        }
                        return params;
                    }
                };
                // If we ended up generating a call to the same instruction as the previous styling property
                // we can chain the calls together safely to save some bytes, otherwise we have to generate
                // a separate instruction call. This is primarily a concern with interpolation instructions
                // where we may start off with one `reference`, but end up using another based on the
                // number of interpolations.
                if (previousInstruction && previousInstruction.reference === referenceForCall) {
                    previousInstruction.calls.push(call);
                }
                else {
                    instructions.push({ reference: referenceForCall, calls: [call] });
                }
            });
            return instructions;
        }
        _buildClassInputs(valueConverter) {
            if (this._singleClassInputs) {
                return this._buildSingleInputs(Identifiers.classProp, this._singleClassInputs, valueConverter, null, true);
            }
            return [];
        }
        _buildStyleInputs(valueConverter) {
            if (this._singleStyleInputs) {
                return this._buildSingleInputs(Identifiers.styleProp, this._singleStyleInputs, valueConverter, getStylePropInterpolationExpression, false);
            }
            return [];
        }
        /**
         * Constructs all instructions which contain the expressions that will be placed
         * into the update block of a template function or a directive hostBindings function.
         */
        buildUpdateLevelInstructions(valueConverter) {
            const instructions = [];
            if (this.hasBindings) {
                const styleMapInstruction = this.buildStyleMapInstruction(valueConverter);
                if (styleMapInstruction) {
                    instructions.push(styleMapInstruction);
                }
                const classMapInstruction = this.buildClassMapInstruction(valueConverter);
                if (classMapInstruction) {
                    instructions.push(classMapInstruction);
                }
                instructions.push(...this._buildStyleInputs(valueConverter));
                instructions.push(...this._buildClassInputs(valueConverter));
            }
            return instructions;
        }
    }
    function registerIntoMap(map, key) {
        if (!map.has(key)) {
            map.set(key, map.size);
        }
    }
    function parseProperty(name) {
        let hasOverrideFlag = false;
        const overrideIndex = name.indexOf(IMPORTANT_FLAG);
        if (overrideIndex !== -1) {
            name = overrideIndex > 0 ? name.substring(0, overrideIndex) : '';
            hasOverrideFlag = true;
        }
        let suffix = null;
        let property = name;
        const unitIndex = name.lastIndexOf('.');
        if (unitIndex > 0) {
            suffix = name.substr(unitIndex + 1);
            property = name.substring(0, unitIndex);
        }
        return { property, suffix, hasOverrideFlag };
    }
    /**
     * Gets the instruction to generate for an interpolated class map.
     * @param interpolation An Interpolation AST
     */
    function getClassMapInterpolationExpression(interpolation) {
        switch (getInterpolationArgsLength(interpolation)) {
            case 1:
                return Identifiers.classMap;
            case 3:
                return Identifiers.classMapInterpolate1;
            case 5:
                return Identifiers.classMapInterpolate2;
            case 7:
                return Identifiers.classMapInterpolate3;
            case 9:
                return Identifiers.classMapInterpolate4;
            case 11:
                return Identifiers.classMapInterpolate5;
            case 13:
                return Identifiers.classMapInterpolate6;
            case 15:
                return Identifiers.classMapInterpolate7;
            case 17:
                return Identifiers.classMapInterpolate8;
            default:
                return Identifiers.classMapInterpolateV;
        }
    }
    /**
     * Gets the instruction to generate for an interpolated style map.
     * @param interpolation An Interpolation AST
     */
    function getStyleMapInterpolationExpression(interpolation) {
        switch (getInterpolationArgsLength(interpolation)) {
            case 1:
                return Identifiers.styleMap;
            case 3:
                return Identifiers.styleMapInterpolate1;
            case 5:
                return Identifiers.styleMapInterpolate2;
            case 7:
                return Identifiers.styleMapInterpolate3;
            case 9:
                return Identifiers.styleMapInterpolate4;
            case 11:
                return Identifiers.styleMapInterpolate5;
            case 13:
                return Identifiers.styleMapInterpolate6;
            case 15:
                return Identifiers.styleMapInterpolate7;
            case 17:
                return Identifiers.styleMapInterpolate8;
            default:
                return Identifiers.styleMapInterpolateV;
        }
    }
    /**
     * Gets the instruction to generate for an interpolated style prop.
     * @param interpolation An Interpolation AST
     */
    function getStylePropInterpolationExpression(interpolation) {
        switch (getInterpolationArgsLength(interpolation)) {
            case 1:
                return Identifiers.styleProp;
            case 3:
                return Identifiers.stylePropInterpolate1;
            case 5:
                return Identifiers.stylePropInterpolate2;
            case 7:
                return Identifiers.stylePropInterpolate3;
            case 9:
                return Identifiers.stylePropInterpolate4;
            case 11:
                return Identifiers.stylePropInterpolate5;
            case 13:
                return Identifiers.stylePropInterpolate6;
            case 15:
                return Identifiers.stylePropInterpolate7;
            case 17:
                return Identifiers.stylePropInterpolate8;
            default:
                return Identifiers.stylePropInterpolateV;
        }
    }
    /**
     * Checks whether property name is a custom CSS property.
     * See: https://www.w3.org/TR/css-variables-1
     */
    function isCssCustomProperty(name) {
        return name.startsWith('--');
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var TokenType;
    (function (TokenType) {
        TokenType[TokenType["Character"] = 0] = "Character";
        TokenType[TokenType["Identifier"] = 1] = "Identifier";
        TokenType[TokenType["PrivateIdentifier"] = 2] = "PrivateIdentifier";
        TokenType[TokenType["Keyword"] = 3] = "Keyword";
        TokenType[TokenType["String"] = 4] = "String";
        TokenType[TokenType["Operator"] = 5] = "Operator";
        TokenType[TokenType["Number"] = 6] = "Number";
        TokenType[TokenType["Error"] = 7] = "Error";
    })(TokenType || (TokenType = {}));
    const KEYWORDS = ['var', 'let', 'as', 'null', 'undefined', 'true', 'false', 'if', 'else', 'this'];
    class Lexer {
        tokenize(text) {
            const scanner = new _Scanner(text);
            const tokens = [];
            let token = scanner.scanToken();
            while (token != null) {
                tokens.push(token);
                token = scanner.scanToken();
            }
            return tokens;
        }
    }
    class Token {
        constructor(index, end, type, numValue, strValue) {
            this.index = index;
            this.end = end;
            this.type = type;
            this.numValue = numValue;
            this.strValue = strValue;
        }
        isCharacter(code) {
            return this.type == TokenType.Character && this.numValue == code;
        }
        isNumber() {
            return this.type == TokenType.Number;
        }
        isString() {
            return this.type == TokenType.String;
        }
        isOperator(operator) {
            return this.type == TokenType.Operator && this.strValue == operator;
        }
        isIdentifier() {
            return this.type == TokenType.Identifier;
        }
        isPrivateIdentifier() {
            return this.type == TokenType.PrivateIdentifier;
        }
        isKeyword() {
            return this.type == TokenType.Keyword;
        }
        isKeywordLet() {
            return this.type == TokenType.Keyword && this.strValue == 'let';
        }
        isKeywordAs() {
            return this.type == TokenType.Keyword && this.strValue == 'as';
        }
        isKeywordNull() {
            return this.type == TokenType.Keyword && this.strValue == 'null';
        }
        isKeywordUndefined() {
            return this.type == TokenType.Keyword && this.strValue == 'undefined';
        }
        isKeywordTrue() {
            return this.type == TokenType.Keyword && this.strValue == 'true';
        }
        isKeywordFalse() {
            return this.type == TokenType.Keyword && this.strValue == 'false';
        }
        isKeywordThis() {
            return this.type == TokenType.Keyword && this.strValue == 'this';
        }
        isError() {
            return this.type == TokenType.Error;
        }
        toNumber() {
            return this.type == TokenType.Number ? this.numValue : -1;
        }
        toString() {
            switch (this.type) {
                case TokenType.Character:
                case TokenType.Identifier:
                case TokenType.Keyword:
                case TokenType.Operator:
                case TokenType.PrivateIdentifier:
                case TokenType.String:
                case TokenType.Error:
                    return this.strValue;
                case TokenType.Number:
                    return this.numValue.toString();
                default:
                    return null;
            }
        }
    }
    function newCharacterToken(index, end, code) {
        return new Token(index, end, TokenType.Character, code, String.fromCharCode(code));
    }
    function newIdentifierToken(index, end, text) {
        return new Token(index, end, TokenType.Identifier, 0, text);
    }
    function newPrivateIdentifierToken(index, end, text) {
        return new Token(index, end, TokenType.PrivateIdentifier, 0, text);
    }
    function newKeywordToken(index, end, text) {
        return new Token(index, end, TokenType.Keyword, 0, text);
    }
    function newOperatorToken(index, end, text) {
        return new Token(index, end, TokenType.Operator, 0, text);
    }
    function newStringToken(index, end, text) {
        return new Token(index, end, TokenType.String, 0, text);
    }
    function newNumberToken(index, end, n) {
        return new Token(index, end, TokenType.Number, n, '');
    }
    function newErrorToken(index, end, message) {
        return new Token(index, end, TokenType.Error, 0, message);
    }
    const EOF = new Token(-1, -1, TokenType.Character, 0, '');
    class _Scanner {
        constructor(input) {
            this.input = input;
            this.peek = 0;
            this.index = -1;
            this.length = input.length;
            this.advance();
        }
        advance() {
            this.peek = ++this.index >= this.length ? $EOF : this.input.charCodeAt(this.index);
        }
        scanToken() {
            const input = this.input, length = this.length;
            let peek = this.peek, index = this.index;
            // Skip whitespace.
            while (peek <= $SPACE) {
                if (++index >= length) {
                    peek = $EOF;
                    break;
                }
                else {
                    peek = input.charCodeAt(index);
                }
            }
            this.peek = peek;
            this.index = index;
            if (index >= length) {
                return null;
            }
            // Handle identifiers and numbers.
            if (isIdentifierStart(peek))
                return this.scanIdentifier();
            if (isDigit(peek))
                return this.scanNumber(index);
            const start = index;
            switch (peek) {
                case $PERIOD:
                    this.advance();
                    return isDigit(this.peek) ? this.scanNumber(start) :
                        newCharacterToken(start, this.index, $PERIOD);
                case $LPAREN:
                case $RPAREN:
                case $LBRACE:
                case $RBRACE:
                case $LBRACKET:
                case $RBRACKET:
                case $COMMA:
                case $COLON:
                case $SEMICOLON:
                    return this.scanCharacter(start, peek);
                case $SQ:
                case $DQ:
                    return this.scanString();
                case $HASH:
                    return this.scanPrivateIdentifier();
                case $PLUS:
                case $MINUS:
                case $STAR:
                case $SLASH:
                case $PERCENT:
                case $CARET:
                    return this.scanOperator(start, String.fromCharCode(peek));
                case $QUESTION:
                    return this.scanQuestion(start);
                case $LT:
                case $GT:
                    return this.scanComplexOperator(start, String.fromCharCode(peek), $EQ, '=');
                case $BANG:
                case $EQ:
                    return this.scanComplexOperator(start, String.fromCharCode(peek), $EQ, '=', $EQ, '=');
                case $AMPERSAND:
                    return this.scanComplexOperator(start, '&', $AMPERSAND, '&');
                case $BAR:
                    return this.scanComplexOperator(start, '|', $BAR, '|');
                case $NBSP:
                    while (isWhitespace(this.peek))
                        this.advance();
                    return this.scanToken();
            }
            this.advance();
            return this.error(`Unexpected character [${String.fromCharCode(peek)}]`, 0);
        }
        scanCharacter(start, code) {
            this.advance();
            return newCharacterToken(start, this.index, code);
        }
        scanOperator(start, str) {
            this.advance();
            return newOperatorToken(start, this.index, str);
        }
        /**
         * Tokenize a 2/3 char long operator
         *
         * @param start start index in the expression
         * @param one first symbol (always part of the operator)
         * @param twoCode code point for the second symbol
         * @param two second symbol (part of the operator when the second code point matches)
         * @param threeCode code point for the third symbol
         * @param three third symbol (part of the operator when provided and matches source expression)
         */
        scanComplexOperator(start, one, twoCode, two, threeCode, three) {
            this.advance();
            let str = one;
            if (this.peek == twoCode) {
                this.advance();
                str += two;
            }
            if (threeCode != null && this.peek == threeCode) {
                this.advance();
                str += three;
            }
            return newOperatorToken(start, this.index, str);
        }
        scanIdentifier() {
            const start = this.index;
            this.advance();
            while (isIdentifierPart(this.peek))
                this.advance();
            const str = this.input.substring(start, this.index);
            return KEYWORDS.indexOf(str) > -1 ? newKeywordToken(start, this.index, str) :
                newIdentifierToken(start, this.index, str);
        }
        /** Scans an ECMAScript private identifier. */
        scanPrivateIdentifier() {
            const start = this.index;
            this.advance();
            if (!isIdentifierStart(this.peek)) {
                return this.error('Invalid character [#]', -1);
            }
            while (isIdentifierPart(this.peek))
                this.advance();
            const identifierName = this.input.substring(start, this.index);
            return newPrivateIdentifierToken(start, this.index, identifierName);
        }
        scanNumber(start) {
            let simple = (this.index === start);
            let hasSeparators = false;
            this.advance(); // Skip initial digit.
            while (true) {
                if (isDigit(this.peek)) ;
                else if (this.peek === $_) {
                    // Separators are only valid when they're surrounded by digits. E.g. `1_0_1` is
                    // valid while `_101` and `101_` are not. The separator can't be next to the decimal
                    // point or another separator either. Note that it's unlikely that we'll hit a case where
                    // the underscore is at the start, because that's a valid identifier and it will be picked
                    // up earlier in the parsing. We validate for it anyway just in case.
                    if (!isDigit(this.input.charCodeAt(this.index - 1)) ||
                        !isDigit(this.input.charCodeAt(this.index + 1))) {
                        return this.error('Invalid numeric separator', 0);
                    }
                    hasSeparators = true;
                }
                else if (this.peek === $PERIOD) {
                    simple = false;
                }
                else if (isExponentStart(this.peek)) {
                    this.advance();
                    if (isExponentSign(this.peek))
                        this.advance();
                    if (!isDigit(this.peek))
                        return this.error('Invalid exponent', -1);
                    simple = false;
                }
                else {
                    break;
                }
                this.advance();
            }
            let str = this.input.substring(start, this.index);
            if (hasSeparators) {
                str = str.replace(/_/g, '');
            }
            const value = simple ? parseIntAutoRadix(str) : parseFloat(str);
            return newNumberToken(start, this.index, value);
        }
        scanString() {
            const start = this.index;
            const quote = this.peek;
            this.advance(); // Skip initial quote.
            let buffer = '';
            let marker = this.index;
            const input = this.input;
            while (this.peek != quote) {
                if (this.peek == $BACKSLASH) {
                    buffer += input.substring(marker, this.index);
                    this.advance();
                    let unescapedCode;
                    // Workaround for TS2.1-introduced type strictness
                    this.peek = this.peek;
                    if (this.peek == $u) {
                        // 4 character hex code for unicode character.
                        const hex = input.substring(this.index + 1, this.index + 5);
                        if (/^[0-9a-f]+$/i.test(hex)) {
                            unescapedCode = parseInt(hex, 16);
                        }
                        else {
                            return this.error(`Invalid unicode escape [\\u${hex}]`, 0);
                        }
                        for (let i = 0; i < 5; i++) {
                            this.advance();
                        }
                    }
                    else {
                        unescapedCode = unescape(this.peek);
                        this.advance();
                    }
                    buffer += String.fromCharCode(unescapedCode);
                    marker = this.index;
                }
                else if (this.peek == $EOF) {
                    return this.error('Unterminated quote', 0);
                }
                else {
                    this.advance();
                }
            }
            const last = input.substring(marker, this.index);
            this.advance(); // Skip terminating quote.
            return newStringToken(start, this.index, buffer + last);
        }
        scanQuestion(start) {
            this.advance();
            let str = '?';
            // Either `a ?? b` or 'a?.b'.
            if (this.peek === $QUESTION || this.peek === $PERIOD) {
                str += this.peek === $PERIOD ? '.' : '?';
                this.advance();
            }
            return newOperatorToken(start, this.index, str);
        }
        error(message, offset) {
            const position = this.index + offset;
            return newErrorToken(position, this.index, `Lexer Error: ${message} at column ${position} in expression [${this.input}]`);
        }
    }
    function isIdentifierStart(code) {
        return ($a <= code && code <= $z) || ($A <= code && code <= $Z) ||
            (code == $_) || (code == $$);
    }
    function isIdentifier(input) {
        if (input.length == 0)
            return false;
        const scanner = new _Scanner(input);
        if (!isIdentifierStart(scanner.peek))
            return false;
        scanner.advance();
        while (scanner.peek !== $EOF) {
            if (!isIdentifierPart(scanner.peek))
                return false;
            scanner.advance();
        }
        return true;
    }
    function isIdentifierPart(code) {
        return isAsciiLetter(code) || isDigit(code) || (code == $_) ||
            (code == $$);
    }
    function isExponentStart(code) {
        return code == $e || code == $E;
    }
    function isExponentSign(code) {
        return code == $MINUS || code == $PLUS;
    }
    function unescape(code) {
        switch (code) {
            case $n:
                return $LF;
            case $f:
                return $FF;
            case $r:
                return $CR;
            case $t:
                return $TAB;
            case $v:
                return $VTAB;
            default:
                return code;
        }
    }
    function parseIntAutoRadix(text) {
        const result = parseInt(text);
        if (isNaN(result)) {
            throw new Error('Invalid integer literal when parsing ' + text);
        }
        return result;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class SplitInterpolation {
        constructor(strings, expressions, offsets) {
            this.strings = strings;
            this.expressions = expressions;
            this.offsets = offsets;
        }
    }
    class TemplateBindingParseResult {
        constructor(templateBindings, warnings, errors) {
            this.templateBindings = templateBindings;
            this.warnings = warnings;
            this.errors = errors;
        }
    }
    class Parser$1 {
        constructor(_lexer) {
            this._lexer = _lexer;
            this.errors = [];
            this.simpleExpressionChecker = SimpleExpressionChecker;
        }
        parseAction(input, location, absoluteOffset, interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {
            this._checkNoInterpolation(input, location, interpolationConfig);
            const sourceToLex = this._stripComments(input);
            const tokens = this._lexer.tokenize(this._stripComments(input));
            const ast = new _ParseAST(input, location, absoluteOffset, tokens, sourceToLex.length, true, this.errors, input.length - sourceToLex.length)
                .parseChain();
            return new ASTWithSource(ast, input, location, absoluteOffset, this.errors);
        }
        parseBinding(input, location, absoluteOffset, interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {
            const ast = this._parseBindingAst(input, location, absoluteOffset, interpolationConfig);
            return new ASTWithSource(ast, input, location, absoluteOffset, this.errors);
        }
        checkSimpleExpression(ast) {
            const checker = new this.simpleExpressionChecker();
            ast.visit(checker);
            return checker.errors;
        }
        parseSimpleBinding(input, location, absoluteOffset, interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {
            const ast = this._parseBindingAst(input, location, absoluteOffset, interpolationConfig);
            const errors = this.checkSimpleExpression(ast);
            if (errors.length > 0) {
                this._reportError(`Host binding expression cannot contain ${errors.join(' ')}`, input, location);
            }
            return new ASTWithSource(ast, input, location, absoluteOffset, this.errors);
        }
        _reportError(message, input, errLocation, ctxLocation) {
            this.errors.push(new ParserError(message, input, errLocation, ctxLocation));
        }
        _parseBindingAst(input, location, absoluteOffset, interpolationConfig) {
            // Quotes expressions use 3rd-party expression language. We don't want to use
            // our lexer or parser for that, so we check for that ahead of time.
            const quote = this._parseQuote(input, location, absoluteOffset);
            if (quote != null) {
                return quote;
            }
            this._checkNoInterpolation(input, location, interpolationConfig);
            const sourceToLex = this._stripComments(input);
            const tokens = this._lexer.tokenize(sourceToLex);
            return new _ParseAST(input, location, absoluteOffset, tokens, sourceToLex.length, false, this.errors, input.length - sourceToLex.length)
                .parseChain();
        }
        _parseQuote(input, location, absoluteOffset) {
            if (input == null)
                return null;
            const prefixSeparatorIndex = input.indexOf(':');
            if (prefixSeparatorIndex == -1)
                return null;
            const prefix = input.substring(0, prefixSeparatorIndex).trim();
            if (!isIdentifier(prefix))
                return null;
            const uninterpretedExpression = input.substring(prefixSeparatorIndex + 1);
            const span = new ParseSpan(0, input.length);
            return new Quote(span, span.toAbsolute(absoluteOffset), prefix, uninterpretedExpression, location);
        }
        /**
         * Parse microsyntax template expression and return a list of bindings or
         * parsing errors in case the given expression is invalid.
         *
         * For example,
         * ```
         *   <div *ngFor="let item of items">
         *         ^      ^ absoluteValueOffset for `templateValue`
         *         absoluteKeyOffset for `templateKey`
         * ```
         * contains three bindings:
         * 1. ngFor -> null
         * 2. item -> NgForOfContext.$implicit
         * 3. ngForOf -> items
         *
         * This is apparent from the de-sugared template:
         * ```
         *   <ng-template ngFor let-item [ngForOf]="items">
         * ```
         *
         * @param templateKey name of directive, without the * prefix. For example: ngIf, ngFor
         * @param templateValue RHS of the microsyntax attribute
         * @param templateUrl template filename if it's external, component filename if it's inline
         * @param absoluteKeyOffset start of the `templateKey`
         * @param absoluteValueOffset start of the `templateValue`
         */
        parseTemplateBindings(templateKey, templateValue, templateUrl, absoluteKeyOffset, absoluteValueOffset) {
            const tokens = this._lexer.tokenize(templateValue);
            const parser = new _ParseAST(templateValue, templateUrl, absoluteValueOffset, tokens, templateValue.length, false /* parseAction */, this.errors, 0 /* relative offset */);
            return parser.parseTemplateBindings({
                source: templateKey,
                span: new AbsoluteSourceSpan(absoluteKeyOffset, absoluteKeyOffset + templateKey.length),
            });
        }
        parseInterpolation(input, location, absoluteOffset, interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {
            const { strings, expressions, offsets } = this.splitInterpolation(input, location, interpolationConfig);
            if (expressions.length === 0)
                return null;
            const expressionNodes = [];
            for (let i = 0; i < expressions.length; ++i) {
                const expressionText = expressions[i].text;
                const sourceToLex = this._stripComments(expressionText);
                const tokens = this._lexer.tokenize(sourceToLex);
                const ast = new _ParseAST(input, location, absoluteOffset, tokens, sourceToLex.length, false, this.errors, offsets[i] + (expressionText.length - sourceToLex.length))
                    .parseChain();
                expressionNodes.push(ast);
            }
            return this.createInterpolationAst(strings.map(s => s.text), expressionNodes, input, location, absoluteOffset);
        }
        /**
         * Similar to `parseInterpolation`, but treats the provided string as a single expression
         * element that would normally appear within the interpolation prefix and suffix (`{{` and `}}`).
         * This is used for parsing the switch expression in ICUs.
         */
        parseInterpolationExpression(expression, location, absoluteOffset) {
            const sourceToLex = this._stripComments(expression);
            const tokens = this._lexer.tokenize(sourceToLex);
            const ast = new _ParseAST(expression, location, absoluteOffset, tokens, sourceToLex.length, 
            /* parseAction */ false, this.errors, 0)
                .parseChain();
            const strings = ['', '']; // The prefix and suffix strings are both empty
            return this.createInterpolationAst(strings, [ast], expression, location, absoluteOffset);
        }
        createInterpolationAst(strings, expressions, input, location, absoluteOffset) {
            const span = new ParseSpan(0, input.length);
            const interpolation = new Interpolation(span, span.toAbsolute(absoluteOffset), strings, expressions);
            return new ASTWithSource(interpolation, input, location, absoluteOffset, this.errors);
        }
        /**
         * Splits a string of text into "raw" text segments and expressions present in interpolations in
         * the string.
         * Returns `null` if there are no interpolations, otherwise a
         * `SplitInterpolation` with splits that look like
         *   <raw text> <expression> <raw text> ... <raw text> <expression> <raw text>
         */
        splitInterpolation(input, location, interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {
            const strings = [];
            const expressions = [];
            const offsets = [];
            let i = 0;
            let atInterpolation = false;
            let extendLastString = false;
            let { start: interpStart, end: interpEnd } = interpolationConfig;
            while (i < input.length) {
                if (!atInterpolation) {
                    // parse until starting {{
                    const start = i;
                    i = input.indexOf(interpStart, i);
                    if (i === -1) {
                        i = input.length;
                    }
                    const text = input.substring(start, i);
                    strings.push({ text, start, end: i });
                    atInterpolation = true;
                }
                else {
                    // parse from starting {{ to ending }} while ignoring content inside quotes.
                    const fullStart = i;
                    const exprStart = fullStart + interpStart.length;
                    const exprEnd = this._getInterpolationEndIndex(input, interpEnd, exprStart);
                    if (exprEnd === -1) {
                        // Could not find the end of the interpolation; do not parse an expression.
                        // Instead we should extend the content on the last raw string.
                        atInterpolation = false;
                        extendLastString = true;
                        break;
                    }
                    const fullEnd = exprEnd + interpEnd.length;
                    const text = input.substring(exprStart, exprEnd);
                    if (text.trim().length === 0) {
                        this._reportError('Blank expressions are not allowed in interpolated strings', input, `at column ${i} in`, location);
                    }
                    expressions.push({ text, start: fullStart, end: fullEnd });
                    offsets.push(exprStart);
                    i = fullEnd;
                    atInterpolation = false;
                }
            }
            if (!atInterpolation) {
                // If we are now at a text section, add the remaining content as a raw string.
                if (extendLastString) {
                    const piece = strings[strings.length - 1];
                    piece.text += input.substring(i);
                    piece.end = input.length;
                }
                else {
                    strings.push({ text: input.substring(i), start: i, end: input.length });
                }
            }
            return new SplitInterpolation(strings, expressions, offsets);
        }
        wrapLiteralPrimitive(input, location, absoluteOffset) {
            const span = new ParseSpan(0, input == null ? 0 : input.length);
            return new ASTWithSource(new LiteralPrimitive(span, span.toAbsolute(absoluteOffset), input), input, location, absoluteOffset, this.errors);
        }
        _stripComments(input) {
            const i = this._commentStart(input);
            return i != null ? input.substring(0, i).trim() : input;
        }
        _commentStart(input) {
            let outerQuote = null;
            for (let i = 0; i < input.length - 1; i++) {
                const char = input.charCodeAt(i);
                const nextChar = input.charCodeAt(i + 1);
                if (char === $SLASH && nextChar == $SLASH && outerQuote == null)
                    return i;
                if (outerQuote === char) {
                    outerQuote = null;
                }
                else if (outerQuote == null && isQuote(char)) {
                    outerQuote = char;
                }
            }
            return null;
        }
        _checkNoInterpolation(input, location, { start, end }) {
            let startIndex = -1;
            let endIndex = -1;
            for (const charIndex of this._forEachUnquotedChar(input, 0)) {
                if (startIndex === -1) {
                    if (input.startsWith(start)) {
                        startIndex = charIndex;
                    }
                }
                else {
                    endIndex = this._getInterpolationEndIndex(input, end, charIndex);
                    if (endIndex > -1) {
                        break;
                    }
                }
            }
            if (startIndex > -1 && endIndex > -1) {
                this._reportError(`Got interpolation (${start}${end}) where expression was expected`, input, `at column ${startIndex} in`, location);
            }
        }
        /**
         * Finds the index of the end of an interpolation expression
         * while ignoring comments and quoted content.
         */
        _getInterpolationEndIndex(input, expressionEnd, start) {
            for (const charIndex of this._forEachUnquotedChar(input, start)) {
                if (input.startsWith(expressionEnd, charIndex)) {
                    return charIndex;
                }
                // Nothing else in the expression matters after we've
                // hit a comment so look directly for the end token.
                if (input.startsWith('//', charIndex)) {
                    return input.indexOf(expressionEnd, charIndex);
                }
            }
            return -1;
        }
        /**
         * Generator used to iterate over the character indexes of a string that are outside of quotes.
         * @param input String to loop through.
         * @param start Index within the string at which to start.
         */
        *_forEachUnquotedChar(input, start) {
            let currentQuote = null;
            let escapeCount = 0;
            for (let i = start; i < input.length; i++) {
                const char = input[i];
                // Skip the characters inside quotes. Note that we only care about the outer-most
                // quotes matching up and we need to account for escape characters.
                if (isQuote(input.charCodeAt(i)) && (currentQuote === null || currentQuote === char) &&
                    escapeCount % 2 === 0) {
                    currentQuote = currentQuote === null ? char : null;
                }
                else if (currentQuote === null) {
                    yield i;
                }
                escapeCount = char === '\\' ? escapeCount + 1 : 0;
            }
        }
    }
    class IvyParser extends Parser$1 {
        constructor() {
            super(...arguments);
            this.simpleExpressionChecker = IvySimpleExpressionChecker;
        }
    }
    /** Describes a stateful context an expression parser is in. */
    var ParseContextFlags;
    (function (ParseContextFlags) {
        ParseContextFlags[ParseContextFlags["None"] = 0] = "None";
        /**
         * A Writable context is one in which a value may be written to an lvalue.
         * For example, after we see a property access, we may expect a write to the
         * property via the "=" operator.
         *   prop
         *        ^ possible "=" after
         */
        ParseContextFlags[ParseContextFlags["Writable"] = 1] = "Writable";
    })(ParseContextFlags || (ParseContextFlags = {}));
    class _ParseAST {
        constructor(input, location, absoluteOffset, tokens, inputLength, parseAction, errors, offset) {
            this.input = input;
            this.location = location;
            this.absoluteOffset = absoluteOffset;
            this.tokens = tokens;
            this.inputLength = inputLength;
            this.parseAction = parseAction;
            this.errors = errors;
            this.offset = offset;
            this.rparensExpected = 0;
            this.rbracketsExpected = 0;
            this.rbracesExpected = 0;
            this.context = ParseContextFlags.None;
            // Cache of expression start and input indeces to the absolute source span they map to, used to
            // prevent creating superfluous source spans in `sourceSpan`.
            // A serial of the expression start and input index is used for mapping because both are stateful
            // and may change for subsequent expressions visited by the parser.
            this.sourceSpanCache = new Map();
            this.index = 0;
        }
        peek(offset) {
            const i = this.index + offset;
            return i < this.tokens.length ? this.tokens[i] : EOF;
        }
        get next() {
            return this.peek(0);
        }
        /** Whether all the parser input has been processed. */
        get atEOF() {
            return this.index >= this.tokens.length;
        }
        /**
         * Index of the next token to be processed, or the end of the last token if all have been
         * processed.
         */
        get inputIndex() {
            return this.atEOF ? this.currentEndIndex : this.next.index + this.offset;
        }
        /**
         * End index of the last processed token, or the start of the first token if none have been
         * processed.
         */
        get currentEndIndex() {
            if (this.index > 0) {
                const curToken = this.peek(-1);
                return curToken.end + this.offset;
            }
            // No tokens have been processed yet; return the next token's start or the length of the input
            // if there is no token.
            if (this.tokens.length === 0) {
                return this.inputLength + this.offset;
            }
            return this.next.index + this.offset;
        }
        /**
         * Returns the absolute offset of the start of the current token.
         */
        get currentAbsoluteOffset() {
            return this.absoluteOffset + this.inputIndex;
        }
        /**
         * Retrieve a `ParseSpan` from `start` to the current position (or to `artificialEndIndex` if
         * provided).
         *
         * @param start Position from which the `ParseSpan` will start.
         * @param artificialEndIndex Optional ending index to be used if provided (and if greater than the
         *     natural ending index)
         */
        span(start, artificialEndIndex) {
            let endIndex = this.currentEndIndex;
            if (artificialEndIndex !== undefined && artificialEndIndex > this.currentEndIndex) {
                endIndex = artificialEndIndex;
            }
            // In some unusual parsing scenarios (like when certain tokens are missing and an `EmptyExpr` is
            // being created), the current token may already be advanced beyond the `currentEndIndex`. This
            // appears to be a deep-seated parser bug.
            //
            // As a workaround for now, swap the start and end indices to ensure a valid `ParseSpan`.
            // TODO(alxhub): fix the bug upstream in the parser state, and remove this workaround.
            if (start > endIndex) {
                const tmp = endIndex;
                endIndex = start;
                start = tmp;
            }
            return new ParseSpan(start, endIndex);
        }
        sourceSpan(start, artificialEndIndex) {
            const serial = `${start}@${this.inputIndex}:${artificialEndIndex}`;
            if (!this.sourceSpanCache.has(serial)) {
                this.sourceSpanCache.set(serial, this.span(start, artificialEndIndex).toAbsolute(this.absoluteOffset));
            }
            return this.sourceSpanCache.get(serial);
        }
        advance() {
            this.index++;
        }
        /**
         * Executes a callback in the provided context.
         */
        withContext(context, cb) {
            this.context |= context;
            const ret = cb();
            this.context ^= context;
            return ret;
        }
        consumeOptionalCharacter(code) {
            if (this.next.isCharacter(code)) {
                this.advance();
                return true;
            }
            else {
                return false;
            }
        }
        peekKeywordLet() {
            return this.next.isKeywordLet();
        }
        peekKeywordAs() {
            return this.next.isKeywordAs();
        }
        /**
         * Consumes an expected character, otherwise emits an error about the missing expected character
         * and skips over the token stream until reaching a recoverable point.
         *
         * See `this.error` and `this.skip` for more details.
         */
        expectCharacter(code) {
            if (this.consumeOptionalCharacter(code))
                return;
            this.error(`Missing expected ${String.fromCharCode(code)}`);
        }
        consumeOptionalOperator(op) {
            if (this.next.isOperator(op)) {
                this.advance();
                return true;
            }
            else {
                return false;
            }
        }
        expectOperator(operator) {
            if (this.consumeOptionalOperator(operator))
                return;
            this.error(`Missing expected operator ${operator}`);
        }
        prettyPrintToken(tok) {
            return tok === EOF ? 'end of input' : `token ${tok}`;
        }
        expectIdentifierOrKeyword() {
            const n = this.next;
            if (!n.isIdentifier() && !n.isKeyword()) {
                if (n.isPrivateIdentifier()) {
                    this._reportErrorForPrivateIdentifier(n, 'expected identifier or keyword');
                }
                else {
                    this.error(`Unexpected ${this.prettyPrintToken(n)}, expected identifier or keyword`);
                }
                return null;
            }
            this.advance();
            return n.toString();
        }
        expectIdentifierOrKeywordOrString() {
            const n = this.next;
            if (!n.isIdentifier() && !n.isKeyword() && !n.isString()) {
                if (n.isPrivateIdentifier()) {
                    this._reportErrorForPrivateIdentifier(n, 'expected identifier, keyword or string');
                }
                else {
                    this.error(`Unexpected ${this.prettyPrintToken(n)}, expected identifier, keyword, or string`);
                }
                return '';
            }
            this.advance();
            return n.toString();
        }
        parseChain() {
            const exprs = [];
            const start = this.inputIndex;
            while (this.index < this.tokens.length) {
                const expr = this.parsePipe();
                exprs.push(expr);
                if (this.consumeOptionalCharacter($SEMICOLON)) {
                    if (!this.parseAction) {
                        this.error('Binding expression cannot contain chained expression');
                    }
                    while (this.consumeOptionalCharacter($SEMICOLON)) {
                    } // read all semicolons
                }
                else if (this.index < this.tokens.length) {
                    this.error(`Unexpected token '${this.next}'`);
                }
            }
            if (exprs.length == 0) {
                // We have no expressions so create an empty expression that spans the entire input length
                const artificialStart = this.offset;
                const artificialEnd = this.offset + this.inputLength;
                return new EmptyExpr(this.span(artificialStart, artificialEnd), this.sourceSpan(artificialStart, artificialEnd));
            }
            if (exprs.length == 1)
                return exprs[0];
            return new Chain(this.span(start), this.sourceSpan(start), exprs);
        }
        parsePipe() {
            const start = this.inputIndex;
            let result = this.parseExpression();
            if (this.consumeOptionalOperator('|')) {
                if (this.parseAction) {
                    this.error('Cannot have a pipe in an action expression');
                }
                do {
                    const nameStart = this.inputIndex;
                    let nameId = this.expectIdentifierOrKeyword();
                    let nameSpan;
                    let fullSpanEnd = undefined;
                    if (nameId !== null) {
                        nameSpan = this.sourceSpan(nameStart);
                    }
                    else {
                        // No valid identifier was found, so we'll assume an empty pipe name ('').
                        nameId = '';
                        // However, there may have been whitespace present between the pipe character and the next
                        // token in the sequence (or the end of input). We want to track this whitespace so that
                        // the `BindingPipe` we produce covers not just the pipe character, but any trailing
                        // whitespace beyond it. Another way of thinking about this is that the zero-length name
                        // is assumed to be at the end of any whitespace beyond the pipe character.
                        //
                        // Therefore, we push the end of the `ParseSpan` for this pipe all the way up to the
                        // beginning of the next token, or until the end of input if the next token is EOF.
                        fullSpanEnd = this.next.index !== -1 ? this.next.index : this.inputLength + this.offset;
                        // The `nameSpan` for an empty pipe name is zero-length at the end of any whitespace
                        // beyond the pipe character.
                        nameSpan = new ParseSpan(fullSpanEnd, fullSpanEnd).toAbsolute(this.absoluteOffset);
                    }
                    const args = [];
                    while (this.consumeOptionalCharacter($COLON)) {
                        args.push(this.parseExpression());
                        // If there are additional expressions beyond the name, then the artificial end for the
                        // name is no longer relevant.
                    }
                    result = new BindingPipe(this.span(start), this.sourceSpan(start, fullSpanEnd), result, nameId, args, nameSpan);
                } while (this.consumeOptionalOperator('|'));
            }
            return result;
        }
        parseExpression() {
            return this.parseConditional();
        }
        parseConditional() {
            const start = this.inputIndex;
            const result = this.parseLogicalOr();
            if (this.consumeOptionalOperator('?')) {
                const yes = this.parsePipe();
                let no;
                if (!this.consumeOptionalCharacter($COLON)) {
                    const end = this.inputIndex;
                    const expression = this.input.substring(start, end);
                    this.error(`Conditional expression ${expression} requires all 3 expressions`);
                    no = new EmptyExpr(this.span(start), this.sourceSpan(start));
                }
                else {
                    no = this.parsePipe();
                }
                return new Conditional(this.span(start), this.sourceSpan(start), result, yes, no);
            }
            else {
                return result;
            }
        }
        parseLogicalOr() {
            // '||'
            const start = this.inputIndex;
            let result = this.parseLogicalAnd();
            while (this.consumeOptionalOperator('||')) {
                const right = this.parseLogicalAnd();
                result = new Binary(this.span(start), this.sourceSpan(start), '||', result, right);
            }
            return result;
        }
        parseLogicalAnd() {
            // '&&'
            const start = this.inputIndex;
            let result = this.parseNullishCoalescing();
            while (this.consumeOptionalOperator('&&')) {
                const right = this.parseNullishCoalescing();
                result = new Binary(this.span(start), this.sourceSpan(start), '&&', result, right);
            }
            return result;
        }
        parseNullishCoalescing() {
            // '??'
            const start = this.inputIndex;
            let result = this.parseEquality();
            while (this.consumeOptionalOperator('??')) {
                const right = this.parseEquality();
                result = new Binary(this.span(start), this.sourceSpan(start), '??', result, right);
            }
            return result;
        }
        parseEquality() {
            // '==','!=','===','!=='
            const start = this.inputIndex;
            let result = this.parseRelational();
            while (this.next.type == TokenType.Operator) {
                const operator = this.next.strValue;
                switch (operator) {
                    case '==':
                    case '===':
                    case '!=':
                    case '!==':
                        this.advance();
                        const right = this.parseRelational();
                        result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);
                        continue;
                }
                break;
            }
            return result;
        }
        parseRelational() {
            // '<', '>', '<=', '>='
            const start = this.inputIndex;
            let result = this.parseAdditive();
            while (this.next.type == TokenType.Operator) {
                const operator = this.next.strValue;
                switch (operator) {
                    case '<':
                    case '>':
                    case '<=':
                    case '>=':
                        this.advance();
                        const right = this.parseAdditive();
                        result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);
                        continue;
                }
                break;
            }
            return result;
        }
        parseAdditive() {
            // '+', '-'
            const start = this.inputIndex;
            let result = this.parseMultiplicative();
            while (this.next.type == TokenType.Operator) {
                const operator = this.next.strValue;
                switch (operator) {
                    case '+':
                    case '-':
                        this.advance();
                        let right = this.parseMultiplicative();
                        result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);
                        continue;
                }
                break;
            }
            return result;
        }
        parseMultiplicative() {
            // '*', '%', '/'
            const start = this.inputIndex;
            let result = this.parsePrefix();
            while (this.next.type == TokenType.Operator) {
                const operator = this.next.strValue;
                switch (operator) {
                    case '*':
                    case '%':
                    case '/':
                        this.advance();
                        let right = this.parsePrefix();
                        result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);
                        continue;
                }
                break;
            }
            return result;
        }
        parsePrefix() {
            if (this.next.type == TokenType.Operator) {
                const start = this.inputIndex;
                const operator = this.next.strValue;
                let result;
                switch (operator) {
                    case '+':
                        this.advance();
                        result = this.parsePrefix();
                        return Unary.createPlus(this.span(start), this.sourceSpan(start), result);
                    case '-':
                        this.advance();
                        result = this.parsePrefix();
                        return Unary.createMinus(this.span(start), this.sourceSpan(start), result);
                    case '!':
                        this.advance();
                        result = this.parsePrefix();
                        return new PrefixNot(this.span(start), this.sourceSpan(start), result);
                }
            }
            return this.parseCallChain();
        }
        parseCallChain() {
            const start = this.inputIndex;
            let result = this.parsePrimary();
            while (true) {
                if (this.consumeOptionalCharacter($PERIOD)) {
                    result = this.parseAccessMemberOrMethodCall(result, start, false);
                }
                else if (this.consumeOptionalOperator('?.')) {
                    result = this.consumeOptionalCharacter($LBRACKET) ?
                        this.parseKeyedReadOrWrite(result, start, true) :
                        this.parseAccessMemberOrMethodCall(result, start, true);
                }
                else if (this.consumeOptionalCharacter($LBRACKET)) {
                    result = this.parseKeyedReadOrWrite(result, start, false);
                }
                else if (this.consumeOptionalCharacter($LPAREN)) {
                    this.rparensExpected++;
                    const args = this.parseCallArguments();
                    this.rparensExpected--;
                    this.expectCharacter($RPAREN);
                    result = new FunctionCall(this.span(start), this.sourceSpan(start), result, args);
                }
                else if (this.consumeOptionalOperator('!')) {
                    result = new NonNullAssert(this.span(start), this.sourceSpan(start), result);
                }
                else {
                    return result;
                }
            }
        }
        parsePrimary() {
            const start = this.inputIndex;
            if (this.consumeOptionalCharacter($LPAREN)) {
                this.rparensExpected++;
                const result = this.parsePipe();
                this.rparensExpected--;
                this.expectCharacter($RPAREN);
                return result;
            }
            else if (this.next.isKeywordNull()) {
                this.advance();
                return new LiteralPrimitive(this.span(start), this.sourceSpan(start), null);
            }
            else if (this.next.isKeywordUndefined()) {
                this.advance();
                return new LiteralPrimitive(this.span(start), this.sourceSpan(start), void 0);
            }
            else if (this.next.isKeywordTrue()) {
                this.advance();
                return new LiteralPrimitive(this.span(start), this.sourceSpan(start), true);
            }
            else if (this.next.isKeywordFalse()) {
                this.advance();
                return new LiteralPrimitive(this.span(start), this.sourceSpan(start), false);
            }
            else if (this.next.isKeywordThis()) {
                this.advance();
                return new ThisReceiver(this.span(start), this.sourceSpan(start));
            }
            else if (this.consumeOptionalCharacter($LBRACKET)) {
                this.rbracketsExpected++;
                const elements = this.parseExpressionList($RBRACKET);
                this.rbracketsExpected--;
                this.expectCharacter($RBRACKET);
                return new LiteralArray(this.span(start), this.sourceSpan(start), elements);
            }
            else if (this.next.isCharacter($LBRACE)) {
                return this.parseLiteralMap();
            }
            else if (this.next.isIdentifier()) {
                return this.parseAccessMemberOrMethodCall(new ImplicitReceiver(this.span(start), this.sourceSpan(start)), start, false);
            }
            else if (this.next.isNumber()) {
                const value = this.next.toNumber();
                this.advance();
                return new LiteralPrimitive(this.span(start), this.sourceSpan(start), value);
            }
            else if (this.next.isString()) {
                const literalValue = this.next.toString();
                this.advance();
                return new LiteralPrimitive(this.span(start), this.sourceSpan(start), literalValue);
            }
            else if (this.next.isPrivateIdentifier()) {
                this._reportErrorForPrivateIdentifier(this.next, null);
                return new EmptyExpr(this.span(start), this.sourceSpan(start));
            }
            else if (this.index >= this.tokens.length) {
                this.error(`Unexpected end of expression: ${this.input}`);
                return new EmptyExpr(this.span(start), this.sourceSpan(start));
            }
            else {
                this.error(`Unexpected token ${this.next}`);
                return new EmptyExpr(this.span(start), this.sourceSpan(start));
            }
        }
        parseExpressionList(terminator) {
            const result = [];
            do {
                if (!this.next.isCharacter(terminator)) {
                    result.push(this.parsePipe());
                }
                else {
                    break;
                }
            } while (this.consumeOptionalCharacter($COMMA));
            return result;
        }
        parseLiteralMap() {
            const keys = [];
            const values = [];
            const start = this.inputIndex;
            this.expectCharacter($LBRACE);
            if (!this.consumeOptionalCharacter($RBRACE)) {
                this.rbracesExpected++;
                do {
                    const keyStart = this.inputIndex;
                    const quoted = this.next.isString();
                    const key = this.expectIdentifierOrKeywordOrString();
                    keys.push({ key, quoted });
                    // Properties with quoted keys can't use the shorthand syntax.
                    if (quoted) {
                        this.expectCharacter($COLON);
                        values.push(this.parsePipe());
                    }
                    else if (this.consumeOptionalCharacter($COLON)) {
                        values.push(this.parsePipe());
                    }
                    else {
                        const span = this.span(keyStart);
                        const sourceSpan = this.sourceSpan(keyStart);
                        values.push(new PropertyRead(span, sourceSpan, sourceSpan, new ImplicitReceiver(span, sourceSpan), key));
                    }
                } while (this.consumeOptionalCharacter($COMMA));
                this.rbracesExpected--;
                this.expectCharacter($RBRACE);
            }
            return new LiteralMap(this.span(start), this.sourceSpan(start), keys, values);
        }
        parseAccessMemberOrMethodCall(receiver, start, isSafe) {
            const nameStart = this.inputIndex;
            const id = this.withContext(ParseContextFlags.Writable, () => {
                var _a;
                const id = (_a = this.expectIdentifierOrKeyword()) !== null && _a !== void 0 ? _a : '';
                if (id.length === 0) {
                    this.error(`Expected identifier for property access`, receiver.span.end);
                }
                return id;
            });
            const nameSpan = this.sourceSpan(nameStart);
            if (this.consumeOptionalCharacter($LPAREN)) {
                const argumentStart = this.inputIndex;
                this.rparensExpected++;
                const args = this.parseCallArguments();
                const argumentSpan = this.span(argumentStart, this.inputIndex).toAbsolute(this.absoluteOffset);
                this.expectCharacter($RPAREN);
                this.rparensExpected--;
                const span = this.span(start);
                const sourceSpan = this.sourceSpan(start);
                return isSafe ?
                    new SafeMethodCall(span, sourceSpan, nameSpan, receiver, id, args, argumentSpan) :
                    new MethodCall(span, sourceSpan, nameSpan, receiver, id, args, argumentSpan);
            }
            else {
                if (isSafe) {
                    if (this.consumeOptionalOperator('=')) {
                        this.error('The \'?.\' operator cannot be used in the assignment');
                        return new EmptyExpr(this.span(start), this.sourceSpan(start));
                    }
                    else {
                        return new SafePropertyRead(this.span(start), this.sourceSpan(start), nameSpan, receiver, id);
                    }
                }
                else {
                    if (this.consumeOptionalOperator('=')) {
                        if (!this.parseAction) {
                            this.error('Bindings cannot contain assignments');
                            return new EmptyExpr(this.span(start), this.sourceSpan(start));
                        }
                        const value = this.parseConditional();
                        return new PropertyWrite(this.span(start), this.sourceSpan(start), nameSpan, receiver, id, value);
                    }
                    else {
                        return new PropertyRead(this.span(start), this.sourceSpan(start), nameSpan, receiver, id);
                    }
                }
            }
        }
        parseCallArguments() {
            if (this.next.isCharacter($RPAREN))
                return [];
            const positionals = [];
            do {
                positionals.push(this.parsePipe());
            } while (this.consumeOptionalCharacter($COMMA));
            return positionals;
        }
        /**
         * Parses an identifier, a keyword, a string with an optional `-` in between,
         * and returns the string along with its absolute source span.
         */
        expectTemplateBindingKey() {
            let result = '';
            let operatorFound = false;
            const start = this.currentAbsoluteOffset;
            do {
                result += this.expectIdentifierOrKeywordOrString();
                operatorFound = this.consumeOptionalOperator('-');
                if (operatorFound) {
                    result += '-';
                }
            } while (operatorFound);
            return {
                source: result,
                span: new AbsoluteSourceSpan(start, start + result.length),
            };
        }
        /**
         * Parse microsyntax template expression and return a list of bindings or
         * parsing errors in case the given expression is invalid.
         *
         * For example,
         * ```
         *   <div *ngFor="let item of items; index as i; trackBy: func">
         * ```
         * contains five bindings:
         * 1. ngFor -> null
         * 2. item -> NgForOfContext.$implicit
         * 3. ngForOf -> items
         * 4. i -> NgForOfContext.index
         * 5. ngForTrackBy -> func
         *
         * For a full description of the microsyntax grammar, see
         * https://gist.github.com/mhevery/d3530294cff2e4a1b3fe15ff75d08855
         *
         * @param templateKey name of the microsyntax directive, like ngIf, ngFor,
         * without the *, along with its absolute span.
         */
        parseTemplateBindings(templateKey) {
            const bindings = [];
            // The first binding is for the template key itself
            // In *ngFor="let item of items", key = "ngFor", value = null
            // In *ngIf="cond | pipe", key = "ngIf", value = "cond | pipe"
            bindings.push(...this.parseDirectiveKeywordBindings(templateKey));
            while (this.index < this.tokens.length) {
                // If it starts with 'let', then this must be variable declaration
                const letBinding = this.parseLetBinding();
                if (letBinding) {
                    bindings.push(letBinding);
                }
                else {
                    // Two possible cases here, either `value "as" key` or
                    // "directive-keyword expression". We don't know which case, but both
                    // "value" and "directive-keyword" are template binding key, so consume
                    // the key first.
                    const key = this.expectTemplateBindingKey();
                    // Peek at the next token, if it is "as" then this must be variable
                    // declaration.
                    const binding = this.parseAsBinding(key);
                    if (binding) {
                        bindings.push(binding);
                    }
                    else {
                        // Otherwise the key must be a directive keyword, like "of". Transform
                        // the key to actual key. Eg. of -> ngForOf, trackBy -> ngForTrackBy
                        key.source =
                            templateKey.source + key.source.charAt(0).toUpperCase() + key.source.substring(1);
                        bindings.push(...this.parseDirectiveKeywordBindings(key));
                    }
                }
                this.consumeStatementTerminator();
            }
            return new TemplateBindingParseResult(bindings, [] /* warnings */, this.errors);
        }
        parseKeyedReadOrWrite(receiver, start, isSafe) {
            return this.withContext(ParseContextFlags.Writable, () => {
                this.rbracketsExpected++;
                const key = this.parsePipe();
                if (key instanceof EmptyExpr) {
                    this.error(`Key access cannot be empty`);
                }
                this.rbracketsExpected--;
                this.expectCharacter($RBRACKET);
                if (this.consumeOptionalOperator('=')) {
                    if (isSafe) {
                        this.error('The \'?.\' operator cannot be used in the assignment');
                    }
                    else {
                        const value = this.parseConditional();
                        return new KeyedWrite(this.span(start), this.sourceSpan(start), receiver, key, value);
                    }
                }
                else {
                    return isSafe ? new SafeKeyedRead(this.span(start), this.sourceSpan(start), receiver, key) :
                        new KeyedRead(this.span(start), this.sourceSpan(start), receiver, key);
                }
                return new EmptyExpr(this.span(start), this.sourceSpan(start));
            });
        }
        /**
         * Parse a directive keyword, followed by a mandatory expression.
         * For example, "of items", "trackBy: func".
         * The bindings are: ngForOf -> items, ngForTrackBy -> func
         * There could be an optional "as" binding that follows the expression.
         * For example,
         * ```
         *   *ngFor="let item of items | slice:0:1 as collection".
         *                    ^^ ^^^^^^^^^^^^^^^^^ ^^^^^^^^^^^^^
         *               keyword    bound target   optional 'as' binding
         * ```
         *
         * @param key binding key, for example, ngFor, ngIf, ngForOf, along with its
         * absolute span.
         */
        parseDirectiveKeywordBindings(key) {
            const bindings = [];
            this.consumeOptionalCharacter($COLON); // trackBy: trackByFunction
            const value = this.getDirectiveBoundTarget();
            let spanEnd = this.currentAbsoluteOffset;
            // The binding could optionally be followed by "as". For example,
            // *ngIf="cond | pipe as x". In this case, the key in the "as" binding
            // is "x" and the value is the template key itself ("ngIf"). Note that the
            // 'key' in the current context now becomes the "value" in the next binding.
            const asBinding = this.parseAsBinding(key);
            if (!asBinding) {
                this.consumeStatementTerminator();
                spanEnd = this.currentAbsoluteOffset;
            }
            const sourceSpan = new AbsoluteSourceSpan(key.span.start, spanEnd);
            bindings.push(new ExpressionBinding(sourceSpan, key, value));
            if (asBinding) {
                bindings.push(asBinding);
            }
            return bindings;
        }
        /**
         * Return the expression AST for the bound target of a directive keyword
         * binding. For example,
         * ```
         *   *ngIf="condition | pipe"
         *          ^^^^^^^^^^^^^^^^ bound target for "ngIf"
         *   *ngFor="let item of items"
         *                       ^^^^^ bound target for "ngForOf"
         * ```
         */
        getDirectiveBoundTarget() {
            if (this.next === EOF || this.peekKeywordAs() || this.peekKeywordLet()) {
                return null;
            }
            const ast = this.parsePipe(); // example: "condition | async"
            const { start, end } = ast.span;
            const value = this.input.substring(start, end);
            return new ASTWithSource(ast, value, this.location, this.absoluteOffset + start, this.errors);
        }
        /**
         * Return the binding for a variable declared using `as`. Note that the order
         * of the key-value pair in this declaration is reversed. For example,
         * ```
         *   *ngFor="let item of items; index as i"
         *                              ^^^^^    ^
         *                              value    key
         * ```
         *
         * @param value name of the value in the declaration, "ngIf" in the example
         * above, along with its absolute span.
         */
        parseAsBinding(value) {
            if (!this.peekKeywordAs()) {
                return null;
            }
            this.advance(); // consume the 'as' keyword
            const key = this.expectTemplateBindingKey();
            this.consumeStatementTerminator();
            const sourceSpan = new AbsoluteSourceSpan(value.span.start, this.currentAbsoluteOffset);
            return new VariableBinding(sourceSpan, key, value);
        }
        /**
         * Return the binding for a variable declared using `let`. For example,
         * ```
         *   *ngFor="let item of items; let i=index;"
         *           ^^^^^^^^           ^^^^^^^^^^^
         * ```
         * In the first binding, `item` is bound to `NgForOfContext.$implicit`.
         * In the second binding, `i` is bound to `NgForOfContext.index`.
         */
        parseLetBinding() {
            if (!this.peekKeywordLet()) {
                return null;
            }
            const spanStart = this.currentAbsoluteOffset;
            this.advance(); // consume the 'let' keyword
            const key = this.expectTemplateBindingKey();
            let value = null;
            if (this.consumeOptionalOperator('=')) {
                value = this.expectTemplateBindingKey();
            }
            this.consumeStatementTerminator();
            const sourceSpan = new AbsoluteSourceSpan(spanStart, this.currentAbsoluteOffset);
            return new VariableBinding(sourceSpan, key, value);
        }
        /**
         * Consume the optional statement terminator: semicolon or comma.
         */
        consumeStatementTerminator() {
            this.consumeOptionalCharacter($SEMICOLON) || this.consumeOptionalCharacter($COMMA);
        }
        /**
         * Records an error and skips over the token stream until reaching a recoverable point. See
         * `this.skip` for more details on token skipping.
         */
        error(message, index = null) {
            this.errors.push(new ParserError(message, this.input, this.locationText(index), this.location));
            this.skip();
        }
        locationText(index = null) {
            if (index == null)
                index = this.index;
            return (index < this.tokens.length) ? `at column ${this.tokens[index].index + 1} in` :
                `at the end of the expression`;
        }
        /**
         * Records an error for an unexpected private identifier being discovered.
         * @param token Token representing a private identifier.
         * @param extraMessage Optional additional message being appended to the error.
         */
        _reportErrorForPrivateIdentifier(token, extraMessage) {
            let errorMessage = `Private identifiers are not supported. Unexpected private identifier: ${token}`;
            if (extraMessage !== null) {
                errorMessage += `, ${extraMessage}`;
            }
            this.error(errorMessage);
        }
        /**
         * Error recovery should skip tokens until it encounters a recovery point.
         *
         * The following are treated as unconditional recovery points:
         *   - end of input
         *   - ';' (parseChain() is always the root production, and it expects a ';')
         *   - '|' (since pipes may be chained and each pipe expression may be treated independently)
         *
         * The following are conditional recovery points:
         *   - ')', '}', ']' if one of calling productions is expecting one of these symbols
         *     - This allows skip() to recover from errors such as '(a.) + 1' allowing more of the AST to
         *       be retained (it doesn't skip any tokens as the ')' is retained because of the '(' begins
         *       an '(' <expr> ')' production).
         *       The recovery points of grouping symbols must be conditional as they must be skipped if
         *       none of the calling productions are not expecting the closing token else we will never
         *       make progress in the case of an extraneous group closing symbol (such as a stray ')').
         *       That is, we skip a closing symbol if we are not in a grouping production.
         *   - '=' in a `Writable` context
         *     - In this context, we are able to recover after seeing the `=` operator, which
         *       signals the presence of an independent rvalue expression following the `=` operator.
         *
         * If a production expects one of these token it increments the corresponding nesting count,
         * and then decrements it just prior to checking if the token is in the input.
         */
        skip() {
            let n = this.next;
            while (this.index < this.tokens.length && !n.isCharacter($SEMICOLON) &&
                !n.isOperator('|') && (this.rparensExpected <= 0 || !n.isCharacter($RPAREN)) &&
                (this.rbracesExpected <= 0 || !n.isCharacter($RBRACE)) &&
                (this.rbracketsExpected <= 0 || !n.isCharacter($RBRACKET)) &&
                (!(this.context & ParseContextFlags.Writable) || !n.isOperator('='))) {
                if (this.next.isError()) {
                    this.errors.push(new ParserError(this.next.toString(), this.input, this.locationText(), this.location));
                }
                this.advance();
                n = this.next;
            }
        }
    }
    class SimpleExpressionChecker {
        constructor() {
            this.errors = [];
        }
        visitImplicitReceiver(ast, context) { }
        visitThisReceiver(ast, context) { }
        visitInterpolation(ast, context) { }
        visitLiteralPrimitive(ast, context) { }
        visitPropertyRead(ast, context) { }
        visitPropertyWrite(ast, context) { }
        visitSafePropertyRead(ast, context) { }
        visitMethodCall(ast, context) { }
        visitSafeMethodCall(ast, context) { }
        visitFunctionCall(ast, context) { }
        visitLiteralArray(ast, context) {
            this.visitAll(ast.expressions, context);
        }
        visitLiteralMap(ast, context) {
            this.visitAll(ast.values, context);
        }
        visitUnary(ast, context) { }
        visitBinary(ast, context) { }
        visitPrefixNot(ast, context) { }
        visitNonNullAssert(ast, context) { }
        visitConditional(ast, context) { }
        visitPipe(ast, context) {
            this.errors.push('pipes');
        }
        visitKeyedRead(ast, context) { }
        visitKeyedWrite(ast, context) { }
        visitAll(asts, context) {
            return asts.map(node => node.visit(this, context));
        }
        visitChain(ast, context) { }
        visitQuote(ast, context) { }
        visitSafeKeyedRead(ast, context) { }
    }
    /**
     * This class implements SimpleExpressionChecker used in View Engine and performs more strict checks
     * to make sure host bindings do not contain pipes. In View Engine, having pipes in host bindings is
     * not supported as well, but in some cases (like `!(value | async)`) the error is not triggered at
     * compile time. In order to preserve View Engine behavior, more strict checks are introduced for
     * Ivy mode only.
     */
    class IvySimpleExpressionChecker extends RecursiveAstVisitor {
        constructor() {
            super(...arguments);
            this.errors = [];
        }
        visitPipe() {
            this.errors.push('pipes');
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function mapLiteral(obj, quoted = false) {
        return literalMap(Object.keys(obj).map(key => ({
            key,
            quoted,
            value: obj[key],
        })));
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    // =================================================================================================
    // =================================================================================================
    // =========== S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P  ===========
    // =================================================================================================
    // =================================================================================================
    //
    //        DO NOT EDIT THIS LIST OF SECURITY SENSITIVE PROPERTIES WITHOUT A SECURITY REVIEW!
    //                               Reach out to mprobst for details.
    //
    // =================================================================================================
    /** Map from tagName|propertyName to SecurityContext. Properties applying to all tags use '*'. */
    let _SECURITY_SCHEMA;
    function SECURITY_SCHEMA() {
        if (!_SECURITY_SCHEMA) {
            _SECURITY_SCHEMA = {};
            // Case is insignificant below, all element and attribute names are lower-cased for lookup.
            registerContext(SecurityContext.HTML, [
                'iframe|srcdoc',
                '*|innerHTML',
                '*|outerHTML',
            ]);
            registerContext(SecurityContext.STYLE, ['*|style']);
            // NB: no SCRIPT contexts here, they are never allowed due to the parser stripping them.
            registerContext(SecurityContext.URL, [
                '*|formAction', 'area|href', 'area|ping', 'audio|src', 'a|href',
                'a|ping', 'blockquote|cite', 'body|background', 'del|cite', 'form|action',
                'img|src', 'img|srcset', 'input|src', 'ins|cite', 'q|cite',
                'source|src', 'source|srcset', 'track|src', 'video|poster', 'video|src',
            ]);
            registerContext(SecurityContext.RESOURCE_URL, [
                'applet|code',
                'applet|codebase',
                'base|href',
                'embed|src',
                'frame|src',
                'head|profile',
                'html|manifest',
                'iframe|src',
                'link|href',
                'media|src',
                'object|codebase',
                'object|data',
                'script|src',
            ]);
        }
        return _SECURITY_SCHEMA;
    }
    function registerContext(ctx, specs) {
        for (const spec of specs)
            _SECURITY_SCHEMA[spec.toLowerCase()] = ctx;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class ElementSchemaRegistry {
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const BOOLEAN = 'boolean';
    const NUMBER = 'number';
    const STRING = 'string';
    const OBJECT = 'object';
    /**
     * This array represents the DOM schema. It encodes inheritance, properties, and events.
     *
     * ## Overview
     *
     * Each line represents one kind of element. The `element_inheritance` and properties are joined
     * using `element_inheritance|properties` syntax.
     *
     * ## Element Inheritance
     *
     * The `element_inheritance` can be further subdivided as `element1,element2,...^parentElement`.
     * Here the individual elements are separated by `,` (commas). Every element in the list
     * has identical properties.
     *
     * An `element` may inherit additional properties from `parentElement` If no `^parentElement` is
     * specified then `""` (blank) element is assumed.
     *
     * NOTE: The blank element inherits from root `[Element]` element, the super element of all
     * elements.
     *
     * NOTE an element prefix such as `:svg:` has no special meaning to the schema.
     *
     * ## Properties
     *
     * Each element has a set of properties separated by `,` (commas). Each property can be prefixed
     * by a special character designating its type:
     *
     * - (no prefix): property is a string.
     * - `*`: property represents an event.
     * - `!`: property is a boolean.
     * - `#`: property is a number.
     * - `%`: property is an object.
     *
     * ## Query
     *
     * The class creates an internal squas representation which allows to easily answer the query of
     * if a given property exist on a given element.
     *
     * NOTE: We don't yet support querying for types or events.
     * NOTE: This schema is auto extracted from `schema_extractor.ts` located in the test folder,
     *       see dom_element_schema_registry_spec.ts
     */
    // =================================================================================================
    // =================================================================================================
    // =========== S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P  ===========
    // =================================================================================================
    // =================================================================================================
    //
    //                       DO NOT EDIT THIS DOM SCHEMA WITHOUT A SECURITY REVIEW!
    //
    // Newly added properties must be security reviewed and assigned an appropriate SecurityContext in
    // dom_security_schema.ts. Reach out to mprobst & rjamet for details.
    //
    // =================================================================================================
    const SCHEMA = [
        '[Element]|textContent,%classList,className,id,innerHTML,*beforecopy,*beforecut,*beforepaste,*copy,*cut,*paste,*search,*selectstart,*webkitfullscreenchange,*webkitfullscreenerror,*wheel,outerHTML,#scrollLeft,#scrollTop,slot' +
            /* added manually to avoid breaking changes */
            ',*message,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored',
        '[HTMLElement]^[Element]|accessKey,contentEditable,dir,!draggable,!hidden,innerText,lang,*abort,*auxclick,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,outerText,!spellcheck,%style,#tabIndex,title,!translate',
        'abbr,address,article,aside,b,bdi,bdo,cite,code,dd,dfn,dt,em,figcaption,figure,footer,header,i,kbd,main,mark,nav,noscript,rb,rp,rt,rtc,ruby,s,samp,section,small,strong,sub,sup,u,var,wbr^[HTMLElement]|accessKey,contentEditable,dir,!draggable,!hidden,innerText,lang,*abort,*auxclick,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,outerText,!spellcheck,%style,#tabIndex,title,!translate',
        'media^[HTMLElement]|!autoplay,!controls,%controlsList,%crossOrigin,#currentTime,!defaultMuted,#defaultPlaybackRate,!disableRemotePlayback,!loop,!muted,*encrypted,*waitingforkey,#playbackRate,preload,src,%srcObject,#volume',
        ':svg:^[HTMLElement]|*abort,*auxclick,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,%style,#tabIndex',
        ':svg:graphics^:svg:|',
        ':svg:animation^:svg:|*begin,*end,*repeat',
        ':svg:geometry^:svg:|',
        ':svg:componentTransferFunction^:svg:|',
        ':svg:gradient^:svg:|',
        ':svg:textContent^:svg:graphics|',
        ':svg:textPositioning^:svg:textContent|',
        'a^[HTMLElement]|charset,coords,download,hash,host,hostname,href,hreflang,name,password,pathname,ping,port,protocol,referrerPolicy,rel,rev,search,shape,target,text,type,username',
        'area^[HTMLElement]|alt,coords,download,hash,host,hostname,href,!noHref,password,pathname,ping,port,protocol,referrerPolicy,rel,search,shape,target,username',
        'audio^media|',
        'br^[HTMLElement]|clear',
        'base^[HTMLElement]|href,target',
        'body^[HTMLElement]|aLink,background,bgColor,link,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,text,vLink',
        'button^[HTMLElement]|!autofocus,!disabled,formAction,formEnctype,formMethod,!formNoValidate,formTarget,name,type,value',
        'canvas^[HTMLElement]|#height,#width',
        'content^[HTMLElement]|select',
        'dl^[HTMLElement]|!compact',
        'datalist^[HTMLElement]|',
        'details^[HTMLElement]|!open',
        'dialog^[HTMLElement]|!open,returnValue',
        'dir^[HTMLElement]|!compact',
        'div^[HTMLElement]|align',
        'embed^[HTMLElement]|align,height,name,src,type,width',
        'fieldset^[HTMLElement]|!disabled,name',
        'font^[HTMLElement]|color,face,size',
        'form^[HTMLElement]|acceptCharset,action,autocomplete,encoding,enctype,method,name,!noValidate,target',
        'frame^[HTMLElement]|frameBorder,longDesc,marginHeight,marginWidth,name,!noResize,scrolling,src',
        'frameset^[HTMLElement]|cols,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,rows',
        'hr^[HTMLElement]|align,color,!noShade,size,width',
        'head^[HTMLElement]|',
        'h1,h2,h3,h4,h5,h6^[HTMLElement]|align',
        'html^[HTMLElement]|version',
        'iframe^[HTMLElement]|align,!allowFullscreen,frameBorder,height,longDesc,marginHeight,marginWidth,name,referrerPolicy,%sandbox,scrolling,src,srcdoc,width',
        'img^[HTMLElement]|align,alt,border,%crossOrigin,#height,#hspace,!isMap,longDesc,lowsrc,name,referrerPolicy,sizes,src,srcset,useMap,#vspace,#width',
        'input^[HTMLElement]|accept,align,alt,autocapitalize,autocomplete,!autofocus,!checked,!defaultChecked,defaultValue,dirName,!disabled,%files,formAction,formEnctype,formMethod,!formNoValidate,formTarget,#height,!incremental,!indeterminate,max,#maxLength,min,#minLength,!multiple,name,pattern,placeholder,!readOnly,!required,selectionDirection,#selectionEnd,#selectionStart,#size,src,step,type,useMap,value,%valueAsDate,#valueAsNumber,#width',
        'li^[HTMLElement]|type,#value',
        'label^[HTMLElement]|htmlFor',
        'legend^[HTMLElement]|align',
        'link^[HTMLElement]|as,charset,%crossOrigin,!disabled,href,hreflang,integrity,media,referrerPolicy,rel,%relList,rev,%sizes,target,type',
        'map^[HTMLElement]|name',
        'marquee^[HTMLElement]|behavior,bgColor,direction,height,#hspace,#loop,#scrollAmount,#scrollDelay,!trueSpeed,#vspace,width',
        'menu^[HTMLElement]|!compact',
        'meta^[HTMLElement]|content,httpEquiv,name,scheme',
        'meter^[HTMLElement]|#high,#low,#max,#min,#optimum,#value',
        'ins,del^[HTMLElement]|cite,dateTime',
        'ol^[HTMLElement]|!compact,!reversed,#start,type',
        'object^[HTMLElement]|align,archive,border,code,codeBase,codeType,data,!declare,height,#hspace,name,standby,type,useMap,#vspace,width',
        'optgroup^[HTMLElement]|!disabled,label',
        'option^[HTMLElement]|!defaultSelected,!disabled,label,!selected,text,value',
        'output^[HTMLElement]|defaultValue,%htmlFor,name,value',
        'p^[HTMLElement]|align',
        'param^[HTMLElement]|name,type,value,valueType',
        'picture^[HTMLElement]|',
        'pre^[HTMLElement]|#width',
        'progress^[HTMLElement]|#max,#value',
        'q,blockquote,cite^[HTMLElement]|',
        'script^[HTMLElement]|!async,charset,%crossOrigin,!defer,event,htmlFor,integrity,src,text,type',
        'select^[HTMLElement]|autocomplete,!autofocus,!disabled,#length,!multiple,name,!required,#selectedIndex,#size,value',
        'shadow^[HTMLElement]|',
        'slot^[HTMLElement]|name',
        'source^[HTMLElement]|media,sizes,src,srcset,type',
        'span^[HTMLElement]|',
        'style^[HTMLElement]|!disabled,media,type',
        'caption^[HTMLElement]|align',
        'th,td^[HTMLElement]|abbr,align,axis,bgColor,ch,chOff,#colSpan,headers,height,!noWrap,#rowSpan,scope,vAlign,width',
        'col,colgroup^[HTMLElement]|align,ch,chOff,#span,vAlign,width',
        'table^[HTMLElement]|align,bgColor,border,%caption,cellPadding,cellSpacing,frame,rules,summary,%tFoot,%tHead,width',
        'tr^[HTMLElement]|align,bgColor,ch,chOff,vAlign',
        'tfoot,thead,tbody^[HTMLElement]|align,ch,chOff,vAlign',
        'template^[HTMLElement]|',
        'textarea^[HTMLElement]|autocapitalize,autocomplete,!autofocus,#cols,defaultValue,dirName,!disabled,#maxLength,#minLength,name,placeholder,!readOnly,!required,#rows,selectionDirection,#selectionEnd,#selectionStart,value,wrap',
        'title^[HTMLElement]|text',
        'track^[HTMLElement]|!default,kind,label,src,srclang',
        'ul^[HTMLElement]|!compact,type',
        'unknown^[HTMLElement]|',
        'video^media|#height,poster,#width',
        ':svg:a^:svg:graphics|',
        ':svg:animate^:svg:animation|',
        ':svg:animateMotion^:svg:animation|',
        ':svg:animateTransform^:svg:animation|',
        ':svg:circle^:svg:geometry|',
        ':svg:clipPath^:svg:graphics|',
        ':svg:defs^:svg:graphics|',
        ':svg:desc^:svg:|',
        ':svg:discard^:svg:|',
        ':svg:ellipse^:svg:geometry|',
        ':svg:feBlend^:svg:|',
        ':svg:feColorMatrix^:svg:|',
        ':svg:feComponentTransfer^:svg:|',
        ':svg:feComposite^:svg:|',
        ':svg:feConvolveMatrix^:svg:|',
        ':svg:feDiffuseLighting^:svg:|',
        ':svg:feDisplacementMap^:svg:|',
        ':svg:feDistantLight^:svg:|',
        ':svg:feDropShadow^:svg:|',
        ':svg:feFlood^:svg:|',
        ':svg:feFuncA^:svg:componentTransferFunction|',
        ':svg:feFuncB^:svg:componentTransferFunction|',
        ':svg:feFuncG^:svg:componentTransferFunction|',
        ':svg:feFuncR^:svg:componentTransferFunction|',
        ':svg:feGaussianBlur^:svg:|',
        ':svg:feImage^:svg:|',
        ':svg:feMerge^:svg:|',
        ':svg:feMergeNode^:svg:|',
        ':svg:feMorphology^:svg:|',
        ':svg:feOffset^:svg:|',
        ':svg:fePointLight^:svg:|',
        ':svg:feSpecularLighting^:svg:|',
        ':svg:feSpotLight^:svg:|',
        ':svg:feTile^:svg:|',
        ':svg:feTurbulence^:svg:|',
        ':svg:filter^:svg:|',
        ':svg:foreignObject^:svg:graphics|',
        ':svg:g^:svg:graphics|',
        ':svg:image^:svg:graphics|',
        ':svg:line^:svg:geometry|',
        ':svg:linearGradient^:svg:gradient|',
        ':svg:mpath^:svg:|',
        ':svg:marker^:svg:|',
        ':svg:mask^:svg:|',
        ':svg:metadata^:svg:|',
        ':svg:path^:svg:geometry|',
        ':svg:pattern^:svg:|',
        ':svg:polygon^:svg:geometry|',
        ':svg:polyline^:svg:geometry|',
        ':svg:radialGradient^:svg:gradient|',
        ':svg:rect^:svg:geometry|',
        ':svg:svg^:svg:graphics|#currentScale,#zoomAndPan',
        ':svg:script^:svg:|type',
        ':svg:set^:svg:animation|',
        ':svg:stop^:svg:|',
        ':svg:style^:svg:|!disabled,media,title,type',
        ':svg:switch^:svg:graphics|',
        ':svg:symbol^:svg:|',
        ':svg:tspan^:svg:textPositioning|',
        ':svg:text^:svg:textPositioning|',
        ':svg:textPath^:svg:textContent|',
        ':svg:title^:svg:|',
        ':svg:use^:svg:graphics|',
        ':svg:view^:svg:|#zoomAndPan',
        'data^[HTMLElement]|value',
        'keygen^[HTMLElement]|!autofocus,challenge,!disabled,form,keytype,name',
        'menuitem^[HTMLElement]|type,label,icon,!disabled,!checked,radiogroup,!default',
        'summary^[HTMLElement]|',
        'time^[HTMLElement]|dateTime',
        ':svg:cursor^:svg:|',
    ];
    const _ATTR_TO_PROP = {
        'class': 'className',
        'for': 'htmlFor',
        'formaction': 'formAction',
        'innerHtml': 'innerHTML',
        'readonly': 'readOnly',
        'tabindex': 'tabIndex',
    };
    // Invert _ATTR_TO_PROP.
    const _PROP_TO_ATTR = Object.keys(_ATTR_TO_PROP).reduce((inverted, attr) => {
        inverted[_ATTR_TO_PROP[attr]] = attr;
        return inverted;
    }, {});
    class DomElementSchemaRegistry extends ElementSchemaRegistry {
        constructor() {
            super();
            this._schema = {};
            SCHEMA.forEach(encodedType => {
                const type = {};
                const [strType, strProperties] = encodedType.split('|');
                const properties = strProperties.split(',');
                const [typeNames, superName] = strType.split('^');
                typeNames.split(',').forEach(tag => this._schema[tag.toLowerCase()] = type);
                const superType = superName && this._schema[superName.toLowerCase()];
                if (superType) {
                    Object.keys(superType).forEach((prop) => {
                        type[prop] = superType[prop];
                    });
                }
                properties.forEach((property) => {
                    if (property.length > 0) {
                        switch (property[0]) {
                            case '*':
                                // We don't yet support events.
                                // If ever allowing to bind to events, GO THROUGH A SECURITY REVIEW, allowing events
                                // will
                                // almost certainly introduce bad XSS vulnerabilities.
                                // type[property.substring(1)] = EVENT;
                                break;
                            case '!':
                                type[property.substring(1)] = BOOLEAN;
                                break;
                            case '#':
                                type[property.substring(1)] = NUMBER;
                                break;
                            case '%':
                                type[property.substring(1)] = OBJECT;
                                break;
                            default:
                                type[property] = STRING;
                        }
                    }
                });
            });
        }
        hasProperty(tagName, propName, schemaMetas) {
            if (schemaMetas.some((schema) => schema.name === NO_ERRORS_SCHEMA.name)) {
                return true;
            }
            if (tagName.indexOf('-') > -1) {
                if (isNgContainer(tagName) || isNgContent(tagName)) {
                    return false;
                }
                if (schemaMetas.some((schema) => schema.name === CUSTOM_ELEMENTS_SCHEMA.name)) {
                    // Can't tell now as we don't know which properties a custom element will get
                    // once it is instantiated
                    return true;
                }
            }
            const elementProperties = this._schema[tagName.toLowerCase()] || this._schema['unknown'];
            return !!elementProperties[propName];
        }
        hasElement(tagName, schemaMetas) {
            if (schemaMetas.some((schema) => schema.name === NO_ERRORS_SCHEMA.name)) {
                return true;
            }
            if (tagName.indexOf('-') > -1) {
                if (isNgContainer(tagName) || isNgContent(tagName)) {
                    return true;
                }
                if (schemaMetas.some((schema) => schema.name === CUSTOM_ELEMENTS_SCHEMA.name)) {
                    // Allow any custom elements
                    return true;
                }
            }
            return !!this._schema[tagName.toLowerCase()];
        }
        /**
         * securityContext returns the security context for the given property on the given DOM tag.
         *
         * Tag and property name are statically known and cannot change at runtime, i.e. it is not
         * possible to bind a value into a changing attribute or tag name.
         *
         * The filtering is based on a list of allowed tags|attributes. All attributes in the schema
         * above are assumed to have the 'NONE' security context, i.e. that they are safe inert
         * string values. Only specific well known attack vectors are assigned their appropriate context.
         */
        securityContext(tagName, propName, isAttribute) {
            if (isAttribute) {
                // NB: For security purposes, use the mapped property name, not the attribute name.
                propName = this.getMappedPropName(propName);
            }
            // Make sure comparisons are case insensitive, so that case differences between attribute and
            // property names do not have a security impact.
            tagName = tagName.toLowerCase();
            propName = propName.toLowerCase();
            let ctx = SECURITY_SCHEMA()[tagName + '|' + propName];
            if (ctx) {
                return ctx;
            }
            ctx = SECURITY_SCHEMA()['*|' + propName];
            return ctx ? ctx : SecurityContext.NONE;
        }
        getMappedPropName(propName) {
            return _ATTR_TO_PROP[propName] || propName;
        }
        getDefaultComponentElementName() {
            return 'ng-component';
        }
        validateProperty(name) {
            if (name.toLowerCase().startsWith('on')) {
                const msg = `Binding to event property '${name}' is disallowed for security reasons, ` +
                    `please use (${name.slice(2)})=...` +
                    `\nIf '${name}' is a directive input, make sure the directive is imported by the` +
                    ` current module.`;
                return { error: true, msg: msg };
            }
            else {
                return { error: false };
            }
        }
        validateAttribute(name) {
            if (name.toLowerCase().startsWith('on')) {
                const msg = `Binding to event attribute '${name}' is disallowed for security reasons, ` +
                    `please use (${name.slice(2)})=...`;
                return { error: true, msg: msg };
            }
            else {
                return { error: false };
            }
        }
        allKnownElementNames() {
            return Object.keys(this._schema);
        }
        allKnownAttributesOfElement(tagName) {
            const elementProperties = this._schema[tagName.toLowerCase()] || this._schema['unknown'];
            // Convert properties to attributes.
            return Object.keys(elementProperties).map(prop => { var _a; return (_a = _PROP_TO_ATTR[prop]) !== null && _a !== void 0 ? _a : prop; });
        }
        normalizeAnimationStyleProperty(propName) {
            return dashCaseToCamelCase(propName);
        }
        normalizeAnimationStyleValue(camelCaseProp, userProvidedProp, val) {
            let unit = '';
            const strVal = val.toString().trim();
            let errorMsg = null;
            if (_isPixelDimensionStyle(camelCaseProp) && val !== 0 && val !== '0') {
                if (typeof val === 'number') {
                    unit = 'px';
                }
                else {
                    const valAndSuffixMatch = val.match(/^[+-]?[\d\.]+([a-z]*)$/);
                    if (valAndSuffixMatch && valAndSuffixMatch[1].length == 0) {
                        errorMsg = `Please provide a CSS unit value for ${userProvidedProp}:${val}`;
                    }
                }
            }
            return { error: errorMsg, value: strVal + unit };
        }
    }
    function _isPixelDimensionStyle(prop) {
        switch (prop) {
            case 'width':
            case 'height':
            case 'minWidth':
            case 'minHeight':
            case 'maxWidth':
            case 'maxHeight':
            case 'left':
            case 'top':
            case 'bottom':
            case 'right':
            case 'fontSize':
            case 'outlineWidth':
            case 'outlineOffset':
            case 'paddingTop':
            case 'paddingLeft':
            case 'paddingBottom':
            case 'paddingRight':
            case 'marginTop':
            case 'marginLeft':
            case 'marginBottom':
            case 'marginRight':
            case 'borderRadius':
            case 'borderWidth':
            case 'borderTopWidth':
            case 'borderLeftWidth':
            case 'borderRightWidth':
            case 'borderBottomWidth':
            case 'textIndent':
                return true;
            default:
                return false;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Set of tagName|propertyName corresponding to Trusted Types sinks. Properties applying to all
     * tags use '*'.
     *
     * Extracted from, and should be kept in sync with
     * https://w3c.github.io/webappsec-trusted-types/dist/spec/#integrations
     */
    const TRUSTED_TYPES_SINKS = new Set([
        // NOTE: All strings in this set *must* be lowercase!
        // TrustedHTML
        'iframe|srcdoc',
        '*|innerhtml',
        '*|outerhtml',
        // NB: no TrustedScript here, as the corresponding tags are stripped by the compiler.
        // TrustedScriptURL
        'embed|src',
        'object|codebase',
        'object|data',
    ]);
    /**
     * isTrustedTypesSink returns true if the given property on the given DOM tag is a Trusted Types
     * sink. In that case, use `ElementSchemaRegistry.securityContext` to determine which particular
     * Trusted Type is required for values passed to the sink:
     * - SecurityContext.HTML corresponds to TrustedHTML
     * - SecurityContext.RESOURCE_URL corresponds to TrustedScriptURL
     */
    function isTrustedTypesSink(tagName, propName) {
        // Make sure comparisons are case insensitive, so that case differences between attribute and
        // property names do not have a security impact.
        tagName = tagName.toLowerCase();
        propName = propName.toLowerCase();
        return TRUSTED_TYPES_SINKS.has(tagName + '|' + propName) ||
            TRUSTED_TYPES_SINKS.has('*|' + propName);
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const BIND_NAME_REGEXP = /^(?:(bind-)|(let-)|(ref-|#)|(on-)|(bindon-)|(@))(.*)$/;
    // Group 1 = "bind-"
    const KW_BIND_IDX = 1;
    // Group 2 = "let-"
    const KW_LET_IDX = 2;
    // Group 3 = "ref-/#"
    const KW_REF_IDX = 3;
    // Group 4 = "on-"
    const KW_ON_IDX = 4;
    // Group 5 = "bindon-"
    const KW_BINDON_IDX = 5;
    // Group 6 = "@"
    const KW_AT_IDX = 6;
    // Group 7 = the identifier after "bind-", "let-", "ref-/#", "on-", "bindon-" or "@"
    const IDENT_KW_IDX = 7;
    const BINDING_DELIMS = {
        BANANA_BOX: { start: '[(', end: ')]' },
        PROPERTY: { start: '[', end: ']' },
        EVENT: { start: '(', end: ')' },
    };
    const TEMPLATE_ATTR_PREFIX$1 = '*';
    function htmlAstToRender3Ast(htmlNodes, bindingParser, options) {
        const transformer = new HtmlAstToIvyAst(bindingParser, options);
        const ivyNodes = visitAll$1(transformer, htmlNodes);
        // Errors might originate in either the binding parser or the html to ivy transformer
        const allErrors = bindingParser.errors.concat(transformer.errors);
        const result = {
            nodes: ivyNodes,
            errors: allErrors,
            styleUrls: transformer.styleUrls,
            styles: transformer.styles,
            ngContentSelectors: transformer.ngContentSelectors
        };
        if (options.collectCommentNodes) {
            result.commentNodes = transformer.commentNodes;
        }
        return result;
    }
    class HtmlAstToIvyAst {
        constructor(bindingParser, options) {
            this.bindingParser = bindingParser;
            this.options = options;
            this.errors = [];
            this.styles = [];
            this.styleUrls = [];
            this.ngContentSelectors = [];
            // This array will be populated if `Render3ParseOptions['collectCommentNodes']` is true
            this.commentNodes = [];
            this.inI18nBlock = false;
        }
        // HTML visitor
        visitElement(element) {
            const isI18nRootElement = isI18nRootNode(element.i18n);
            if (isI18nRootElement) {
                if (this.inI18nBlock) {
                    this.reportError('Cannot mark an element as translatable inside of a translatable section. Please remove the nested i18n marker.', element.sourceSpan);
                }
                this.inI18nBlock = true;
            }
            const preparsedElement = preparseElement(element);
            if (preparsedElement.type === PreparsedElementType.SCRIPT) {
                return null;
            }
            else if (preparsedElement.type === PreparsedElementType.STYLE) {
                const contents = textContents(element);
                if (contents !== null) {
                    this.styles.push(contents);
                }
                return null;
            }
            else if (preparsedElement.type === PreparsedElementType.STYLESHEET &&
                isStyleUrlResolvable(preparsedElement.hrefAttr)) {
                this.styleUrls.push(preparsedElement.hrefAttr);
                return null;
            }
            // Whether the element is a `<ng-template>`
            const isTemplateElement = isNgTemplate(element.name);
            const parsedProperties = [];
            const boundEvents = [];
            const variables = [];
            const references = [];
            const attributes = [];
            const i18nAttrsMeta = {};
            const templateParsedProperties = [];
            const templateVariables = [];
            // Whether the element has any *-attribute
            let elementHasInlineTemplate = false;
            for (const attribute of element.attrs) {
                let hasBinding = false;
                const normalizedName = normalizeAttributeName(attribute.name);
                // `*attr` defines template bindings
                let isTemplateBinding = false;
                if (attribute.i18n) {
                    i18nAttrsMeta[attribute.name] = attribute.i18n;
                }
                if (normalizedName.startsWith(TEMPLATE_ATTR_PREFIX$1)) {
                    // *-attributes
                    if (elementHasInlineTemplate) {
                        this.reportError(`Can't have multiple template bindings on one element. Use only one attribute prefixed with *`, attribute.sourceSpan);
                    }
                    isTemplateBinding = true;
                    elementHasInlineTemplate = true;
                    const templateValue = attribute.value;
                    const templateKey = normalizedName.substring(TEMPLATE_ATTR_PREFIX$1.length);
                    const parsedVariables = [];
                    const absoluteValueOffset = attribute.valueSpan ?
                        attribute.valueSpan.start.offset :
                        // If there is no value span the attribute does not have a value, like `attr` in
                        //`<div attr></div>`. In this case, point to one character beyond the last character of
                        // the attribute name.
                        attribute.sourceSpan.start.offset + attribute.name.length;
                    this.bindingParser.parseInlineTemplateBinding(templateKey, templateValue, attribute.sourceSpan, absoluteValueOffset, [], templateParsedProperties, parsedVariables, true /* isIvyAst */);
                    templateVariables.push(...parsedVariables.map(v => new Variable(v.name, v.value, v.sourceSpan, v.keySpan, v.valueSpan)));
                }
                else {
                    // Check for variables, events, property bindings, interpolation
                    hasBinding = this.parseAttribute(isTemplateElement, attribute, [], parsedProperties, boundEvents, variables, references);
                }
                if (!hasBinding && !isTemplateBinding) {
                    // don't include the bindings as attributes as well in the AST
                    attributes.push(this.visitAttribute(attribute));
                }
            }
            const children = visitAll$1(preparsedElement.nonBindable ? NON_BINDABLE_VISITOR : this, element.children);
            let parsedElement;
            if (preparsedElement.type === PreparsedElementType.NG_CONTENT) {
                // `<ng-content>`
                if (element.children &&
                    !element.children.every((node) => isEmptyTextNode(node) || isCommentNode(node))) {
                    this.reportError(`<ng-content> element cannot have content.`, element.sourceSpan);
                }
                const selector = preparsedElement.selectAttr;
                const attrs = element.attrs.map(attr => this.visitAttribute(attr));
                parsedElement = new Content(selector, attrs, element.sourceSpan, element.i18n);
                this.ngContentSelectors.push(selector);
            }
            else if (isTemplateElement) {
                // `<ng-template>`
                const attrs = this.extractAttributes(element.name, parsedProperties, i18nAttrsMeta);
                parsedElement = new Template(element.name, attributes, attrs.bound, boundEvents, [ /* no template attributes */], children, references, variables, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);
            }
            else {
                const attrs = this.extractAttributes(element.name, parsedProperties, i18nAttrsMeta);
                parsedElement = new Element(element.name, attributes, attrs.bound, boundEvents, children, references, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);
            }
            if (elementHasInlineTemplate) {
                // If this node is an inline-template (e.g. has *ngFor) then we need to create a template
                // node that contains this node.
                // Moreover, if the node is an element, then we need to hoist its attributes to the template
                // node for matching against content projection selectors.
                const attrs = this.extractAttributes('ng-template', templateParsedProperties, i18nAttrsMeta);
                const templateAttrs = [];
                attrs.literal.forEach(attr => templateAttrs.push(attr));
                attrs.bound.forEach(attr => templateAttrs.push(attr));
                const hoistedAttrs = parsedElement instanceof Element ?
                    {
                        attributes: parsedElement.attributes,
                        inputs: parsedElement.inputs,
                        outputs: parsedElement.outputs,
                    } :
                    { attributes: [], inputs: [], outputs: [] };
                // For <ng-template>s with structural directives on them, avoid passing i18n information to
                // the wrapping template to prevent unnecessary i18n instructions from being generated. The
                // necessary i18n meta information will be extracted from child elements.
                const i18n = isTemplateElement && isI18nRootElement ? undefined : element.i18n;
                // TODO(pk): test for this case
                parsedElement = new Template(parsedElement.name, hoistedAttrs.attributes, hoistedAttrs.inputs, hoistedAttrs.outputs, templateAttrs, [parsedElement], [ /* no references */], templateVariables, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, i18n);
            }
            if (isI18nRootElement) {
                this.inI18nBlock = false;
            }
            return parsedElement;
        }
        visitAttribute(attribute) {
            return new TextAttribute(attribute.name, attribute.value, attribute.sourceSpan, attribute.keySpan, attribute.valueSpan, attribute.i18n);
        }
        visitText(text) {
            return this._visitTextWithInterpolation(text.value, text.sourceSpan, text.i18n);
        }
        visitExpansion(expansion) {
            if (!expansion.i18n) {
                // do not generate Icu in case it was created
                // outside of i18n block in a template
                return null;
            }
            if (!isI18nRootNode(expansion.i18n)) {
                throw new Error(`Invalid type "${expansion.i18n.constructor}" for "i18n" property of ${expansion.sourceSpan.toString()}. Expected a "Message"`);
            }
            const message = expansion.i18n;
            const vars = {};
            const placeholders = {};
            // extract VARs from ICUs - we process them separately while
            // assembling resulting message via goog.getMsg function, since
            // we need to pass them to top-level goog.getMsg call
            Object.keys(message.placeholders).forEach(key => {
                const value = message.placeholders[key];
                if (key.startsWith(I18N_ICU_VAR_PREFIX)) {
                    // Currently when the `plural` or `select` keywords in an ICU contain trailing spaces (e.g.
                    // `{count, select , ...}`), these spaces are also included into the key names in ICU vars
                    // (e.g. "VAR_SELECT "). These trailing spaces are not desirable, since they will later be
                    // converted into `_` symbols while normalizing placeholder names, which might lead to
                    // mismatches at runtime (i.e. placeholder will not be replaced with the correct value).
                    const formattedKey = key.trim();
                    const ast = this.bindingParser.parseInterpolationExpression(value.text, value.sourceSpan);
                    vars[formattedKey] = new BoundText(ast, value.sourceSpan);
                }
                else {
                    placeholders[key] = this._visitTextWithInterpolation(value.text, value.sourceSpan);
                }
            });
            return new Icu(vars, placeholders, expansion.sourceSpan, message);
        }
        visitExpansionCase(expansionCase) {
            return null;
        }
        visitComment(comment) {
            if (this.options.collectCommentNodes) {
                this.commentNodes.push(new Comment(comment.value || '', comment.sourceSpan));
            }
            return null;
        }
        // convert view engine `ParsedProperty` to a format suitable for IVY
        extractAttributes(elementName, properties, i18nPropsMeta) {
            const bound = [];
            const literal = [];
            properties.forEach(prop => {
                const i18n = i18nPropsMeta[prop.name];
                if (prop.isLiteral) {
                    literal.push(new TextAttribute(prop.name, prop.expression.source || '', prop.sourceSpan, prop.keySpan, prop.valueSpan, i18n));
                }
                else {
                    // Note that validation is skipped and property mapping is disabled
                    // due to the fact that we need to make sure a given prop is not an
                    // input of a directive and directive matching happens at runtime.
                    const bep = this.bindingParser.createBoundElementProperty(elementName, prop, /* skipValidation */ true, /* mapPropertyName */ false);
                    bound.push(BoundAttribute.fromBoundElementProperty(bep, i18n));
                }
            });
            return { bound, literal };
        }
        parseAttribute(isTemplateElement, attribute, matchableAttributes, parsedProperties, boundEvents, variables, references) {
            const name = normalizeAttributeName(attribute.name);
            const value = attribute.value;
            const srcSpan = attribute.sourceSpan;
            const absoluteOffset = attribute.valueSpan ? attribute.valueSpan.start.offset : srcSpan.start.offset;
            function createKeySpan(srcSpan, prefix, identifier) {
                // We need to adjust the start location for the keySpan to account for the removed 'data-'
                // prefix from `normalizeAttributeName`.
                const normalizationAdjustment = attribute.name.length - name.length;
                const keySpanStart = srcSpan.start.moveBy(prefix.length + normalizationAdjustment);
                const keySpanEnd = keySpanStart.moveBy(identifier.length);
                return new ParseSourceSpan(keySpanStart, keySpanEnd, keySpanStart, identifier);
            }
            const bindParts = name.match(BIND_NAME_REGEXP);
            if (bindParts) {
                if (bindParts[KW_BIND_IDX] != null) {
                    const identifier = bindParts[IDENT_KW_IDX];
                    const keySpan = createKeySpan(srcSpan, bindParts[KW_BIND_IDX], identifier);
                    this.bindingParser.parsePropertyBinding(identifier, value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan);
                }
                else if (bindParts[KW_LET_IDX]) {
                    if (isTemplateElement) {
                        const identifier = bindParts[IDENT_KW_IDX];
                        const keySpan = createKeySpan(srcSpan, bindParts[KW_LET_IDX], identifier);
                        this.parseVariable(identifier, value, srcSpan, keySpan, attribute.valueSpan, variables);
                    }
                    else {
                        this.reportError(`"let-" is only supported on ng-template elements.`, srcSpan);
                    }
                }
                else if (bindParts[KW_REF_IDX]) {
                    const identifier = bindParts[IDENT_KW_IDX];
                    const keySpan = createKeySpan(srcSpan, bindParts[KW_REF_IDX], identifier);
                    this.parseReference(identifier, value, srcSpan, keySpan, attribute.valueSpan, references);
                }
                else if (bindParts[KW_ON_IDX]) {
                    const events = [];
                    const identifier = bindParts[IDENT_KW_IDX];
                    const keySpan = createKeySpan(srcSpan, bindParts[KW_ON_IDX], identifier);
                    this.bindingParser.parseEvent(identifier, value, srcSpan, attribute.valueSpan || srcSpan, matchableAttributes, events, keySpan);
                    addEvents(events, boundEvents);
                }
                else if (bindParts[KW_BINDON_IDX]) {
                    const identifier = bindParts[IDENT_KW_IDX];
                    const keySpan = createKeySpan(srcSpan, bindParts[KW_BINDON_IDX], identifier);
                    this.bindingParser.parsePropertyBinding(identifier, value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan);
                    this.parseAssignmentEvent(identifier, value, srcSpan, attribute.valueSpan, matchableAttributes, boundEvents, keySpan);
                }
                else if (bindParts[KW_AT_IDX]) {
                    const keySpan = createKeySpan(srcSpan, '', name);
                    this.bindingParser.parseLiteralAttr(name, value, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan);
                }
                return true;
            }
            // We didn't see a kw-prefixed property binding, but we have not yet checked
            // for the []/()/[()] syntax.
            let delims = null;
            if (name.startsWith(BINDING_DELIMS.BANANA_BOX.start)) {
                delims = BINDING_DELIMS.BANANA_BOX;
            }
            else if (name.startsWith(BINDING_DELIMS.PROPERTY.start)) {
                delims = BINDING_DELIMS.PROPERTY;
            }
            else if (name.startsWith(BINDING_DELIMS.EVENT.start)) {
                delims = BINDING_DELIMS.EVENT;
            }
            if (delims !== null &&
                // NOTE: older versions of the parser would match a start/end delimited
                // binding iff the property name was terminated by the ending delimiter
                // and the identifier in the binding was non-empty.
                // TODO(ayazhafiz): update this to handle malformed bindings.
                name.endsWith(delims.end) && name.length > delims.start.length + delims.end.length) {
                const identifier = name.substring(delims.start.length, name.length - delims.end.length);
                const keySpan = createKeySpan(srcSpan, delims.start, identifier);
                if (delims.start === BINDING_DELIMS.BANANA_BOX.start) {
                    this.bindingParser.parsePropertyBinding(identifier, value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan);
                    this.parseAssignmentEvent(identifier, value, srcSpan, attribute.valueSpan, matchableAttributes, boundEvents, keySpan);
                }
                else if (delims.start === BINDING_DELIMS.PROPERTY.start) {
                    this.bindingParser.parsePropertyBinding(identifier, value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan);
                }
                else {
                    const events = [];
                    this.bindingParser.parseEvent(identifier, value, srcSpan, attribute.valueSpan || srcSpan, matchableAttributes, events, keySpan);
                    addEvents(events, boundEvents);
                }
                return true;
            }
            // No explicit binding found.
            const keySpan = createKeySpan(srcSpan, '' /* prefix */, name);
            const hasBinding = this.bindingParser.parsePropertyInterpolation(name, value, srcSpan, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan);
            return hasBinding;
        }
        _visitTextWithInterpolation(value, sourceSpan, i18n) {
            const valueNoNgsp = replaceNgsp(value);
            const expr = this.bindingParser.parseInterpolation(valueNoNgsp, sourceSpan);
            return expr ? new BoundText(expr, sourceSpan, i18n) : new Text(valueNoNgsp, sourceSpan);
        }
        parseVariable(identifier, value, sourceSpan, keySpan, valueSpan, variables) {
            if (identifier.indexOf('-') > -1) {
                this.reportError(`"-" is not allowed in variable names`, sourceSpan);
            }
            else if (identifier.length === 0) {
                this.reportError(`Variable does not have a name`, sourceSpan);
            }
            variables.push(new Variable(identifier, value, sourceSpan, keySpan, valueSpan));
        }
        parseReference(identifier, value, sourceSpan, keySpan, valueSpan, references) {
            if (identifier.indexOf('-') > -1) {
                this.reportError(`"-" is not allowed in reference names`, sourceSpan);
            }
            else if (identifier.length === 0) {
                this.reportError(`Reference does not have a name`, sourceSpan);
            }
            else if (references.some(reference => reference.name === identifier)) {
                this.reportError(`Reference "#${identifier}" is defined more than once`, sourceSpan);
            }
            references.push(new Reference(identifier, value, sourceSpan, keySpan, valueSpan));
        }
        parseAssignmentEvent(name, expression, sourceSpan, valueSpan, targetMatchableAttrs, boundEvents, keySpan) {
            const events = [];
            this.bindingParser.parseEvent(`${name}Change`, `${expression}=$event`, sourceSpan, valueSpan || sourceSpan, targetMatchableAttrs, events, keySpan);
            addEvents(events, boundEvents);
        }
        reportError(message, sourceSpan, level = ParseErrorLevel.ERROR) {
            this.errors.push(new ParseError(sourceSpan, message, level));
        }
    }
    class NonBindableVisitor {
        visitElement(ast) {
            const preparsedElement = preparseElement(ast);
            if (preparsedElement.type === PreparsedElementType.SCRIPT ||
                preparsedElement.type === PreparsedElementType.STYLE ||
                preparsedElement.type === PreparsedElementType.STYLESHEET) {
                // Skipping <script> for security reasons
                // Skipping <style> and stylesheets as we already processed them
                // in the StyleCompiler
                return null;
            }
            const children = visitAll$1(this, ast.children, null);
            return new Element(ast.name, visitAll$1(this, ast.attrs), 
            /* inputs */ [], /* outputs */ [], children, /* references */ [], ast.sourceSpan, ast.startSourceSpan, ast.endSourceSpan);
        }
        visitComment(comment) {
            return null;
        }
        visitAttribute(attribute) {
            return new TextAttribute(attribute.name, attribute.value, attribute.sourceSpan, attribute.keySpan, attribute.valueSpan, attribute.i18n);
        }
        visitText(text) {
            return new Text(text.value, text.sourceSpan);
        }
        visitExpansion(expansion) {
            return null;
        }
        visitExpansionCase(expansionCase) {
            return null;
        }
    }
    const NON_BINDABLE_VISITOR = new NonBindableVisitor();
    function normalizeAttributeName(attrName) {
        return /^data-/i.test(attrName) ? attrName.substring(5) : attrName;
    }
    function addEvents(events, boundEvents) {
        boundEvents.push(...events.map(e => BoundEvent.fromParsedEvent(e)));
    }
    function isEmptyTextNode(node) {
        return node instanceof Text$2 && node.value.trim().length == 0;
    }
    function isCommentNode(node) {
        return node instanceof Comment$1;
    }
    function textContents(node) {
        if (node.children.length !== 1 || !(node.children[0] instanceof Text$2)) {
            return null;
        }
        else {
            return node.children[0].value;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var TagType;
    (function (TagType) {
        TagType[TagType["ELEMENT"] = 0] = "ELEMENT";
        TagType[TagType["TEMPLATE"] = 1] = "TEMPLATE";
    })(TagType || (TagType = {}));
    /**
     * Generates an object that is used as a shared state between parent and all child contexts.
     */
    function setupRegistry() {
        return { getUniqueId: getSeqNumberGenerator(), icus: new Map() };
    }
    /**
     * I18nContext is a helper class which keeps track of all i18n-related aspects
     * (accumulates placeholders, bindings, etc) between i18nStart and i18nEnd instructions.
     *
     * When we enter a nested template, the top-level context is being passed down
     * to the nested component, which uses this context to generate a child instance
     * of I18nContext class (to handle nested template) and at the end, reconciles it back
     * with the parent context.
     *
     * @param index Instruction index of i18nStart, which initiates this context
     * @param ref Reference to a translation const that represents the content if thus context
     * @param level Nestng level defined for child contexts
     * @param templateIndex Instruction index of a template which this context belongs to
     * @param meta Meta information (id, meaning, description, etc) associated with this context
     */
    class I18nContext {
        constructor(index, ref, level = 0, templateIndex = null, meta, registry) {
            this.index = index;
            this.ref = ref;
            this.level = level;
            this.templateIndex = templateIndex;
            this.meta = meta;
            this.registry = registry;
            this.bindings = new Set();
            this.placeholders = new Map();
            this.isEmitted = false;
            this._unresolvedCtxCount = 0;
            this._registry = registry || setupRegistry();
            this.id = this._registry.getUniqueId();
        }
        appendTag(type, node, index, closed) {
            if (node.isVoid && closed) {
                return; // ignore "close" for void tags
            }
            const ph = node.isVoid || !closed ? node.startName : node.closeName;
            const content = { type, index, ctx: this.id, isVoid: node.isVoid, closed };
            updatePlaceholderMap(this.placeholders, ph, content);
        }
        get icus() {
            return this._registry.icus;
        }
        get isRoot() {
            return this.level === 0;
        }
        get isResolved() {
            return this._unresolvedCtxCount === 0;
        }
        getSerializedPlaceholders() {
            const result = new Map();
            this.placeholders.forEach((values, key) => result.set(key, values.map(serializePlaceholderValue)));
            return result;
        }
        // public API to accumulate i18n-related content
        appendBinding(binding) {
            this.bindings.add(binding);
        }
        appendIcu(name, ref) {
            updatePlaceholderMap(this._registry.icus, name, ref);
        }
        appendBoundText(node) {
            const phs = assembleBoundTextPlaceholders(node, this.bindings.size, this.id);
            phs.forEach((values, key) => updatePlaceholderMap(this.placeholders, key, ...values));
        }
        appendTemplate(node, index) {
            // add open and close tags at the same time,
            // since we process nested templates separately
            this.appendTag(TagType.TEMPLATE, node, index, false);
            this.appendTag(TagType.TEMPLATE, node, index, true);
            this._unresolvedCtxCount++;
        }
        appendElement(node, index, closed) {
            this.appendTag(TagType.ELEMENT, node, index, closed);
        }
        appendProjection(node, index) {
            // Add open and close tags at the same time, since `<ng-content>` has no content,
            // so when we come across `<ng-content>` we can register both open and close tags.
            // Note: runtime i18n logic doesn't distinguish `<ng-content>` tag placeholders and
            // regular element tag placeholders, so we generate element placeholders for both types.
            this.appendTag(TagType.ELEMENT, node, index, false);
            this.appendTag(TagType.ELEMENT, node, index, true);
        }
        /**
         * Generates an instance of a child context based on the root one,
         * when we enter a nested template within I18n section.
         *
         * @param index Instruction index of corresponding i18nStart, which initiates this context
         * @param templateIndex Instruction index of a template which this context belongs to
         * @param meta Meta information (id, meaning, description, etc) associated with this context
         *
         * @returns I18nContext instance
         */
        forkChildContext(index, templateIndex, meta) {
            return new I18nContext(index, this.ref, this.level + 1, templateIndex, meta, this._registry);
        }
        /**
         * Reconciles child context into parent one once the end of the i18n block is reached (i18nEnd).
         *
         * @param context Child I18nContext instance to be reconciled with parent context.
         */
        reconcileChildContext(context) {
            // set the right context id for open and close
            // template tags, so we can use it as sub-block ids
            ['start', 'close'].forEach((op) => {
                const key = context.meta[`${op}Name`];
                const phs = this.placeholders.get(key) || [];
                const tag = phs.find(findTemplateFn(this.id, context.templateIndex));
                if (tag) {
                    tag.ctx = context.id;
                }
            });
            // reconcile placeholders
            const childPhs = context.placeholders;
            childPhs.forEach((values, key) => {
                const phs = this.placeholders.get(key);
                if (!phs) {
                    this.placeholders.set(key, values);
                    return;
                }
                // try to find matching template...
                const tmplIdx = phs.findIndex(findTemplateFn(context.id, context.templateIndex));
                if (tmplIdx >= 0) {
                    // ... if found - replace it with nested template content
                    const isCloseTag = key.startsWith('CLOSE');
                    const isTemplateTag = key.endsWith('NG-TEMPLATE');
                    if (isTemplateTag) {
                        // current template's content is placed before or after
                        // parent template tag, depending on the open/close atrribute
                        phs.splice(tmplIdx + (isCloseTag ? 0 : 1), 0, ...values);
                    }
                    else {
                        const idx = isCloseTag ? values.length - 1 : 0;
                        values[idx].tmpl = phs[tmplIdx];
                        phs.splice(tmplIdx, 1, ...values);
                    }
                }
                else {
                    // ... otherwise just append content to placeholder value
                    phs.push(...values);
                }
                this.placeholders.set(key, phs);
            });
            this._unresolvedCtxCount--;
        }
    }
    //
    // Helper methods
    //
    function wrap(symbol, index, contextId, closed) {
        const state = closed ? '/' : '';
        return wrapI18nPlaceholder(`${state}${symbol}${index}`, contextId);
    }
    function wrapTag(symbol, { index, ctx, isVoid }, closed) {
        return isVoid ? wrap(symbol, index, ctx) + wrap(symbol, index, ctx, true) :
            wrap(symbol, index, ctx, closed);
    }
    function findTemplateFn(ctx, templateIndex) {
        return (token) => typeof token === 'object' && token.type === TagType.TEMPLATE &&
            token.index === templateIndex && token.ctx === ctx;
    }
    function serializePlaceholderValue(value) {
        const element = (data, closed) => wrapTag('#', data, closed);
        const template = (data, closed) => wrapTag('*', data, closed);
        switch (value.type) {
            case TagType.ELEMENT:
                // close element tag
                if (value.closed) {
                    return element(value, true) + (value.tmpl ? template(value.tmpl, true) : '');
                }
                // open element tag that also initiates a template
                if (value.tmpl) {
                    return template(value.tmpl) + element(value) +
                        (value.isVoid ? template(value.tmpl, true) : '');
                }
                return element(value);
            case TagType.TEMPLATE:
                return template(value, value.closed);
            default:
                return value;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class IcuSerializerVisitor {
        visitText(text) {
            return text.value;
        }
        visitContainer(container) {
            return container.children.map(child => child.visit(this)).join('');
        }
        visitIcu(icu) {
            const strCases = Object.keys(icu.cases).map((k) => `${k} {${icu.cases[k].visit(this)}}`);
            const result = `{${icu.expressionPlaceholder}, ${icu.type}, ${strCases.join(' ')}}`;
            return result;
        }
        visitTagPlaceholder(ph) {
            return ph.isVoid ?
                this.formatPh(ph.startName) :
                `${this.formatPh(ph.startName)}${ph.children.map(child => child.visit(this)).join('')}${this.formatPh(ph.closeName)}`;
        }
        visitPlaceholder(ph) {
            return this.formatPh(ph.name);
        }
        visitIcuPlaceholder(ph, context) {
            return this.formatPh(ph.name);
        }
        formatPh(value) {
            return `{${formatI18nPlaceholderName(value, /* useCamelCase */ false)}}`;
        }
    }
    const serializer = new IcuSerializerVisitor();
    function serializeIcuNode(icu) {
        return icu.visit(serializer);
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const TAG_TO_PLACEHOLDER_NAMES = {
        'A': 'LINK',
        'B': 'BOLD_TEXT',
        'BR': 'LINE_BREAK',
        'EM': 'EMPHASISED_TEXT',
        'H1': 'HEADING_LEVEL1',
        'H2': 'HEADING_LEVEL2',
        'H3': 'HEADING_LEVEL3',
        'H4': 'HEADING_LEVEL4',
        'H5': 'HEADING_LEVEL5',
        'H6': 'HEADING_LEVEL6',
        'HR': 'HORIZONTAL_RULE',
        'I': 'ITALIC_TEXT',
        'LI': 'LIST_ITEM',
        'LINK': 'MEDIA_LINK',
        'OL': 'ORDERED_LIST',
        'P': 'PARAGRAPH',
        'Q': 'QUOTATION',
        'S': 'STRIKETHROUGH_TEXT',
        'SMALL': 'SMALL_TEXT',
        'SUB': 'SUBSTRIPT',
        'SUP': 'SUPERSCRIPT',
        'TBODY': 'TABLE_BODY',
        'TD': 'TABLE_CELL',
        'TFOOT': 'TABLE_FOOTER',
        'TH': 'TABLE_HEADER_CELL',
        'THEAD': 'TABLE_HEADER',
        'TR': 'TABLE_ROW',
        'TT': 'MONOSPACED_TEXT',
        'U': 'UNDERLINED_TEXT',
        'UL': 'UNORDERED_LIST',
    };
    /**
     * Creates unique names for placeholder with different content.
     *
     * Returns the same placeholder name when the content is identical.
     */
    class PlaceholderRegistry {
        constructor() {
            // Count the occurrence of the base name top generate a unique name
            this._placeHolderNameCounts = {};
            // Maps signature to placeholder names
            this._signatureToName = {};
        }
        getStartTagPlaceholderName(tag, attrs, isVoid) {
            const signature = this._hashTag(tag, attrs, isVoid);
            if (this._signatureToName[signature]) {
                return this._signatureToName[signature];
            }
            const upperTag = tag.toUpperCase();
            const baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;
            const name = this._generateUniqueName(isVoid ? baseName : `START_${baseName}`);
            this._signatureToName[signature] = name;
            return name;
        }
        getCloseTagPlaceholderName(tag) {
            const signature = this._hashClosingTag(tag);
            if (this._signatureToName[signature]) {
                return this._signatureToName[signature];
            }
            const upperTag = tag.toUpperCase();
            const baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;
            const name = this._generateUniqueName(`CLOSE_${baseName}`);
            this._signatureToName[signature] = name;
            return name;
        }
        getPlaceholderName(name, content) {
            const upperName = name.toUpperCase();
            const signature = `PH: ${upperName}=${content}`;
            if (this._signatureToName[signature]) {
                return this._signatureToName[signature];
            }
            const uniqueName = this._generateUniqueName(upperName);
            this._signatureToName[signature] = uniqueName;
            return uniqueName;
        }
        getUniquePlaceholder(name) {
            return this._generateUniqueName(name.toUpperCase());
        }
        // Generate a hash for a tag - does not take attribute order into account
        _hashTag(tag, attrs, isVoid) {
            const start = `<${tag}`;
            const strAttrs = Object.keys(attrs).sort().map((name) => ` ${name}=${attrs[name]}`).join('');
            const end = isVoid ? '/>' : `></${tag}>`;
            return start + strAttrs + end;
        }
        _hashClosingTag(tag) {
            return this._hashTag(`/${tag}`, {}, false);
        }
        _generateUniqueName(base) {
            const seen = this._placeHolderNameCounts.hasOwnProperty(base);
            if (!seen) {
                this._placeHolderNameCounts[base] = 1;
                return base;
            }
            const id = this._placeHolderNameCounts[base];
            this._placeHolderNameCounts[base] = id + 1;
            return `${base}_${id}`;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const _expParser = new Parser$1(new Lexer());
    /**
     * Returns a function converting html nodes to an i18n Message given an interpolationConfig
     */
    function createI18nMessageFactory(interpolationConfig) {
        const visitor = new _I18nVisitor(_expParser, interpolationConfig);
        return (nodes, meaning, description, customId, visitNodeFn) => visitor.toI18nMessage(nodes, meaning, description, customId, visitNodeFn);
    }
    function noopVisitNodeFn(_html, i18n) {
        return i18n;
    }
    class _I18nVisitor {
        constructor(_expressionParser, _interpolationConfig) {
            this._expressionParser = _expressionParser;
            this._interpolationConfig = _interpolationConfig;
        }
        toI18nMessage(nodes, meaning = '', description = '', customId = '', visitNodeFn) {
            const context = {
                isIcu: nodes.length == 1 && nodes[0] instanceof Expansion,
                icuDepth: 0,
                placeholderRegistry: new PlaceholderRegistry(),
                placeholderToContent: {},
                placeholderToMessage: {},
                visitNodeFn: visitNodeFn || noopVisitNodeFn,
            };
            const i18nodes = visitAll$1(this, nodes, context);
            return new Message(i18nodes, context.placeholderToContent, context.placeholderToMessage, meaning, description, customId);
        }
        visitElement(el, context) {
            var _a;
            const children = visitAll$1(this, el.children, context);
            const attrs = {};
            el.attrs.forEach(attr => {
                // Do not visit the attributes, translatable ones are top-level ASTs
                attrs[attr.name] = attr.value;
            });
            const isVoid = getHtmlTagDefinition(el.name).isVoid;
            const startPhName = context.placeholderRegistry.getStartTagPlaceholderName(el.name, attrs, isVoid);
            context.placeholderToContent[startPhName] = {
                text: el.startSourceSpan.toString(),
                sourceSpan: el.startSourceSpan,
            };
            let closePhName = '';
            if (!isVoid) {
                closePhName = context.placeholderRegistry.getCloseTagPlaceholderName(el.name);
                context.placeholderToContent[closePhName] = {
                    text: `</${el.name}>`,
                    sourceSpan: (_a = el.endSourceSpan) !== null && _a !== void 0 ? _a : el.sourceSpan,
                };
            }
            const node = new TagPlaceholder(el.name, attrs, startPhName, closePhName, children, isVoid, el.sourceSpan, el.startSourceSpan, el.endSourceSpan);
            return context.visitNodeFn(el, node);
        }
        visitAttribute(attribute, context) {
            const node = attribute.valueTokens === undefined || attribute.valueTokens.length === 1 ?
                new Text$1(attribute.value, attribute.valueSpan || attribute.sourceSpan) :
                this._visitTextWithInterpolation(attribute.valueTokens, attribute.valueSpan || attribute.sourceSpan, context, attribute.i18n);
            return context.visitNodeFn(attribute, node);
        }
        visitText(text, context) {
            const node = text.tokens.length === 1 ?
                new Text$1(text.value, text.sourceSpan) :
                this._visitTextWithInterpolation(text.tokens, text.sourceSpan, context, text.i18n);
            return context.visitNodeFn(text, node);
        }
        visitComment(comment, context) {
            return null;
        }
        visitExpansion(icu, context) {
            context.icuDepth++;
            const i18nIcuCases = {};
            const i18nIcu = new Icu$1(icu.switchValue, icu.type, i18nIcuCases, icu.sourceSpan);
            icu.cases.forEach((caze) => {
                i18nIcuCases[caze.value] = new Container(caze.expression.map((node) => node.visit(this, context)), caze.expSourceSpan);
            });
            context.icuDepth--;
            if (context.isIcu || context.icuDepth > 0) {
                // Returns an ICU node when:
                // - the message (vs a part of the message) is an ICU message, or
                // - the ICU message is nested.
                const expPh = context.placeholderRegistry.getUniquePlaceholder(`VAR_${icu.type}`);
                i18nIcu.expressionPlaceholder = expPh;
                context.placeholderToContent[expPh] = {
                    text: icu.switchValue,
                    sourceSpan: icu.switchValueSourceSpan,
                };
                return context.visitNodeFn(icu, i18nIcu);
            }
            // Else returns a placeholder
            // ICU placeholders should not be replaced with their original content but with the their
            // translations.
            // TODO(vicb): add a html.Node -> i18n.Message cache to avoid having to re-create the msg
            const phName = context.placeholderRegistry.getPlaceholderName('ICU', icu.sourceSpan.toString());
            context.placeholderToMessage[phName] = this.toI18nMessage([icu], '', '', '', undefined);
            const node = new IcuPlaceholder(i18nIcu, phName, icu.sourceSpan);
            return context.visitNodeFn(icu, node);
        }
        visitExpansionCase(_icuCase, _context) {
            throw new Error('Unreachable code');
        }
        /**
         * Convert, text and interpolated tokens up into text and placeholder pieces.
         *
         * @param tokens The text and interpolated tokens.
         * @param sourceSpan The span of the whole of the `text` string.
         * @param context The current context of the visitor, used to compute and store placeholders.
         * @param previousI18n Any i18n metadata associated with this `text` from a previous pass.
         */
        _visitTextWithInterpolation(tokens, sourceSpan, context, previousI18n) {
            // Return a sequence of `Text` and `Placeholder` nodes grouped in a `Container`.
            const nodes = [];
            // We will only create a container if there are actually interpolations,
            // so this flag tracks that.
            let hasInterpolation = false;
            for (const token of tokens) {
                switch (token.type) {
                    case 8 /* INTERPOLATION */:
                    case 17 /* ATTR_VALUE_INTERPOLATION */:
                        hasInterpolation = true;
                        const expression = token.parts[1];
                        const baseName = extractPlaceholderName(expression) || 'INTERPOLATION';
                        const phName = context.placeholderRegistry.getPlaceholderName(baseName, expression);
                        context.placeholderToContent[phName] = {
                            text: token.parts.join(''),
                            sourceSpan: token.sourceSpan
                        };
                        nodes.push(new Placeholder(expression, phName, token.sourceSpan));
                        break;
                    default:
                        if (token.parts[0].length > 0) {
                            // This token is text or an encoded entity.
                            // If it is following on from a previous text node then merge it into that node
                            // Otherwise, if it is following an interpolation, then add a new node.
                            const previous = nodes[nodes.length - 1];
                            if (previous instanceof Text$1) {
                                previous.value += token.parts[0];
                                previous.sourceSpan = new ParseSourceSpan(previous.sourceSpan.start, token.sourceSpan.end, previous.sourceSpan.fullStart, previous.sourceSpan.details);
                            }
                            else {
                                nodes.push(new Text$1(token.parts[0], token.sourceSpan));
                            }
                        }
                        break;
                }
            }
            if (hasInterpolation) {
                // Whitespace removal may have invalidated the interpolation source-spans.
                reusePreviousSourceSpans(nodes, previousI18n);
                return new Container(nodes, sourceSpan);
            }
            else {
                return nodes[0];
            }
        }
    }
    /**
     * Re-use the source-spans from `previousI18n` metadata for the `nodes`.
     *
     * Whitespace removal can invalidate the source-spans of interpolation nodes, so we
     * reuse the source-span stored from a previous pass before the whitespace was removed.
     *
     * @param nodes The `Text` and `Placeholder` nodes to be processed.
     * @param previousI18n Any i18n metadata for these `nodes` stored from a previous pass.
     */
    function reusePreviousSourceSpans(nodes, previousI18n) {
        if (previousI18n instanceof Message) {
            // The `previousI18n` is an i18n `Message`, so we are processing an `Attribute` with i18n
            // metadata. The `Message` should consist only of a single `Container` that contains the
            // parts (`Text` and `Placeholder`) to process.
            assertSingleContainerMessage(previousI18n);
            previousI18n = previousI18n.nodes[0];
        }
        if (previousI18n instanceof Container) {
            // The `previousI18n` is a `Container`, which means that this is a second i18n extraction pass
            // after whitespace has been removed from the AST nodes.
            assertEquivalentNodes(previousI18n.children, nodes);
            // Reuse the source-spans from the first pass.
            for (let i = 0; i < nodes.length; i++) {
                nodes[i].sourceSpan = previousI18n.children[i].sourceSpan;
            }
        }
    }
    /**
     * Asserts that the `message` contains exactly one `Container` node.
     */
    function assertSingleContainerMessage(message) {
        const nodes = message.nodes;
        if (nodes.length !== 1 || !(nodes[0] instanceof Container)) {
            throw new Error('Unexpected previous i18n message - expected it to consist of only a single `Container` node.');
        }
    }
    /**
     * Asserts that the `previousNodes` and `node` collections have the same number of elements and
     * corresponding elements have the same node type.
     */
    function assertEquivalentNodes(previousNodes, nodes) {
        if (previousNodes.length !== nodes.length) {
            throw new Error('The number of i18n message children changed between first and second pass.');
        }
        if (previousNodes.some((node, i) => nodes[i].constructor !== node.constructor)) {
            throw new Error('The types of the i18n message children changed between first and second pass.');
        }
    }
    const _CUSTOM_PH_EXP = /\/\/[\s\S]*i18n[\s\S]*\([\s\S]*ph[\s\S]*=[\s\S]*("|')([\s\S]*?)\1[\s\S]*\)/g;
    function extractPlaceholderName(input) {
        return input.split(_CUSTOM_PH_EXP)[2];
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * An i18n error.
     */
    class I18nError extends ParseError {
        constructor(span, msg) {
            super(span, msg);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const setI18nRefs = (htmlNode, i18nNode) => {
        if (htmlNode instanceof NodeWithI18n) {
            if (i18nNode instanceof IcuPlaceholder && htmlNode.i18n instanceof Message) {
                // This html node represents an ICU but this is a second processing pass, and the legacy id
                // was computed in the previous pass and stored in the `i18n` property as a message.
                // We are about to wipe out that property so capture the previous message to be reused when
                // generating the message for this ICU later. See `_generateI18nMessage()`.
                i18nNode.previousMessage = htmlNode.i18n;
            }
            htmlNode.i18n = i18nNode;
        }
        return i18nNode;
    };
    /**
     * This visitor walks over HTML parse tree and converts information stored in
     * i18n-related attributes ("i18n" and "i18n-*") into i18n meta object that is
     * stored with other element's and attribute's information.
     */
    class I18nMetaVisitor {
        constructor(interpolationConfig = DEFAULT_INTERPOLATION_CONFIG, keepI18nAttrs = false, enableI18nLegacyMessageIdFormat = false) {
            this.interpolationConfig = interpolationConfig;
            this.keepI18nAttrs = keepI18nAttrs;
            this.enableI18nLegacyMessageIdFormat = enableI18nLegacyMessageIdFormat;
            // whether visited nodes contain i18n information
            this.hasI18nMeta = false;
            this._errors = [];
            // i18n message generation factory
            this._createI18nMessage = createI18nMessageFactory(this.interpolationConfig);
        }
        _generateI18nMessage(nodes, meta = '', visitNodeFn) {
            const { meaning, description, customId } = this._parseMetadata(meta);
            const message = this._createI18nMessage(nodes, meaning, description, customId, visitNodeFn);
            this._setMessageId(message, meta);
            this._setLegacyIds(message, meta);
            return message;
        }
        visitAllWithErrors(nodes) {
            const result = nodes.map(node => node.visit(this, null));
            return new ParseTreeResult(result, this._errors);
        }
        visitElement(element) {
            if (hasI18nAttrs(element)) {
                this.hasI18nMeta = true;
                const attrs = [];
                const attrsMeta = {};
                for (const attr of element.attrs) {
                    if (attr.name === I18N_ATTR) {
                        // root 'i18n' node attribute
                        const i18n = element.i18n || attr.value;
                        const message = this._generateI18nMessage(element.children, i18n, setI18nRefs);
                        // do not assign empty i18n meta
                        if (message.nodes.length) {
                            element.i18n = message;
                        }
                    }
                    else if (attr.name.startsWith(I18N_ATTR_PREFIX)) {
                        // 'i18n-*' attributes
                        const name = attr.name.slice(I18N_ATTR_PREFIX.length);
                        if (isTrustedTypesSink(element.name, name)) {
                            this._reportError(attr, `Translating attribute '${name}' is disallowed for security reasons.`);
                        }
                        else {
                            attrsMeta[name] = attr.value;
                        }
                    }
                    else {
                        // non-i18n attributes
                        attrs.push(attr);
                    }
                }
                // set i18n meta for attributes
                if (Object.keys(attrsMeta).length) {
                    for (const attr of attrs) {
                        const meta = attrsMeta[attr.name];
                        // do not create translation for empty attributes
                        if (meta !== undefined && attr.value) {
                            attr.i18n = this._generateI18nMessage([attr], attr.i18n || meta);
                        }
                    }
                }
                if (!this.keepI18nAttrs) {
                    // update element's attributes,
                    // keeping only non-i18n related ones
                    element.attrs = attrs;
                }
            }
            visitAll$1(this, element.children, element.i18n);
            return element;
        }
        visitExpansion(expansion, currentMessage) {
            let message;
            const meta = expansion.i18n;
            this.hasI18nMeta = true;
            if (meta instanceof IcuPlaceholder) {
                // set ICU placeholder name (e.g. "ICU_1"),
                // generated while processing root element contents,
                // so we can reference it when we output translation
                const name = meta.name;
                message = this._generateI18nMessage([expansion], meta);
                const icu = icuFromI18nMessage(message);
                icu.name = name;
            }
            else {
                // ICU is a top level message, try to use metadata from container element if provided via
                // `context` argument. Note: context may not be available for standalone ICUs (without
                // wrapping element), so fallback to ICU metadata in this case.
                message = this._generateI18nMessage([expansion], currentMessage || meta);
            }
            expansion.i18n = message;
            return expansion;
        }
        visitText(text) {
            return text;
        }
        visitAttribute(attribute) {
            return attribute;
        }
        visitComment(comment) {
            return comment;
        }
        visitExpansionCase(expansionCase) {
            return expansionCase;
        }
        /**
         * Parse the general form `meta` passed into extract the explicit metadata needed to create a
         * `Message`.
         *
         * There are three possibilities for the `meta` variable
         * 1) a string from an `i18n` template attribute: parse it to extract the metadata values.
         * 2) a `Message` from a previous processing pass: reuse the metadata values in the message.
         * 4) other: ignore this and just process the message metadata as normal
         *
         * @param meta the bucket that holds information about the message
         * @returns the parsed metadata.
         */
        _parseMetadata(meta) {
            return typeof meta === 'string' ? parseI18nMeta(meta) :
                meta instanceof Message ? meta : {};
        }
        /**
         * Generate (or restore) message id if not specified already.
         */
        _setMessageId(message, meta) {
            if (!message.id) {
                message.id = meta instanceof Message && meta.id || decimalDigest(message);
            }
        }
        /**
         * Update the `message` with a `legacyId` if necessary.
         *
         * @param message the message whose legacy id should be set
         * @param meta information about the message being processed
         */
        _setLegacyIds(message, meta) {
            if (this.enableI18nLegacyMessageIdFormat) {
                message.legacyIds = [computeDigest(message), computeDecimalDigest(message)];
            }
            else if (typeof meta !== 'string') {
                // This occurs if we are doing the 2nd pass after whitespace removal (see `parseTemplate()` in
                // `packages/compiler/src/render3/view/template.ts`).
                // In that case we want to reuse the legacy message generated in the 1st pass (see
                // `setI18nRefs()`).
                const previousMessage = meta instanceof Message ?
                    meta :
                    meta instanceof IcuPlaceholder ? meta.previousMessage : undefined;
                message.legacyIds = previousMessage ? previousMessage.legacyIds : [];
            }
        }
        _reportError(node, msg) {
            this._errors.push(new I18nError(node.sourceSpan, msg));
        }
    }
    /** I18n separators for metadata **/
    const I18N_MEANING_SEPARATOR = '|';
    const I18N_ID_SEPARATOR = '@@';
    /**
     * Parses i18n metas like:
     *  - "@@id",
     *  - "description[@@id]",
     *  - "meaning|description[@@id]"
     * and returns an object with parsed output.
     *
     * @param meta String that represents i18n meta
     * @returns Object with id, meaning and description fields
     */
    function parseI18nMeta(meta = '') {
        let customId;
        let meaning;
        let description;
        meta = meta.trim();
        if (meta) {
            const idIndex = meta.indexOf(I18N_ID_SEPARATOR);
            const descIndex = meta.indexOf(I18N_MEANING_SEPARATOR);
            let meaningAndDesc;
            [meaningAndDesc, customId] =
                (idIndex > -1) ? [meta.slice(0, idIndex), meta.slice(idIndex + 2)] : [meta, ''];
            [meaning, description] = (descIndex > -1) ?
                [meaningAndDesc.slice(0, descIndex), meaningAndDesc.slice(descIndex + 1)] :
                ['', meaningAndDesc];
        }
        return { customId, meaning, description };
    }
    // Converts i18n meta information for a message (id, description, meaning)
    // to a JsDoc statement formatted as expected by the Closure compiler.
    function i18nMetaToJSDoc(meta) {
        const tags = [];
        if (meta.description) {
            tags.push({ tagName: "desc" /* Desc */, text: meta.description });
        }
        if (meta.meaning) {
            tags.push({ tagName: "meaning" /* Meaning */, text: meta.meaning });
        }
        return tags.length == 0 ? null : jsDocComment(tags);
    }

    /** Closure uses `goog.getMsg(message)` to lookup translations */
    const GOOG_GET_MSG = 'goog.getMsg';
    function createGoogleGetMsgStatements(variable$1, message, closureVar, params) {
        const messageString = serializeI18nMessageForGetMsg(message);
        const args = [literal(messageString)];
        if (Object.keys(params).length) {
            args.push(mapLiteral(params, true));
        }
        // /**
        //  * @desc description of message
        //  * @meaning meaning of message
        //  */
        // const MSG_... = goog.getMsg(..);
        // I18N_X = MSG_...;
        const googGetMsgStmt = closureVar.set(variable(GOOG_GET_MSG).callFn(args)).toConstDecl();
        const metaComment = i18nMetaToJSDoc(message);
        if (metaComment !== null) {
            googGetMsgStmt.addLeadingComment(metaComment);
        }
        const i18nAssignmentStmt = new ExpressionStatement(variable$1.set(closureVar));
        return [googGetMsgStmt, i18nAssignmentStmt];
    }
    /**
     * This visitor walks over i18n tree and generates its string representation, including ICUs and
     * placeholders in `{$placeholder}` (for plain messages) or `{PLACEHOLDER}` (inside ICUs) format.
     */
    class GetMsgSerializerVisitor {
        formatPh(value) {
            return `{$${formatI18nPlaceholderName(value)}}`;
        }
        visitText(text) {
            return text.value;
        }
        visitContainer(container) {
            return container.children.map(child => child.visit(this)).join('');
        }
        visitIcu(icu) {
            return serializeIcuNode(icu);
        }
        visitTagPlaceholder(ph) {
            return ph.isVoid ?
                this.formatPh(ph.startName) :
                `${this.formatPh(ph.startName)}${ph.children.map(child => child.visit(this)).join('')}${this.formatPh(ph.closeName)}`;
        }
        visitPlaceholder(ph) {
            return this.formatPh(ph.name);
        }
        visitIcuPlaceholder(ph, context) {
            return this.formatPh(ph.name);
        }
    }
    const serializerVisitor$1 = new GetMsgSerializerVisitor();
    function serializeI18nMessageForGetMsg(message) {
        return message.nodes.map(node => node.visit(serializerVisitor$1, null)).join('');
    }

    function createLocalizeStatements(variable, message, params) {
        const { messageParts, placeHolders } = serializeI18nMessageForLocalize(message);
        const sourceSpan = getSourceSpan(message);
        const expressions = placeHolders.map(ph => params[ph.text]);
        const localizedString$1 = localizedString(message, messageParts, placeHolders, expressions, sourceSpan);
        const variableInitialization = variable.set(localizedString$1);
        return [new ExpressionStatement(variableInitialization)];
    }
    /**
     * This visitor walks over an i18n tree, capturing literal strings and placeholders.
     *
     * The result can be used for generating the `$localize` tagged template literals.
     */
    class LocalizeSerializerVisitor {
        visitText(text, context) {
            if (context[context.length - 1] instanceof LiteralPiece) {
                // Two literal pieces in a row means that there was some comment node in-between.
                context[context.length - 1].text += text.value;
            }
            else {
                const sourceSpan = new ParseSourceSpan(text.sourceSpan.fullStart, text.sourceSpan.end, text.sourceSpan.fullStart, text.sourceSpan.details);
                context.push(new LiteralPiece(text.value, sourceSpan));
            }
        }
        visitContainer(container, context) {
            container.children.forEach(child => child.visit(this, context));
        }
        visitIcu(icu, context) {
            context.push(new LiteralPiece(serializeIcuNode(icu), icu.sourceSpan));
        }
        visitTagPlaceholder(ph, context) {
            var _a, _b;
            context.push(this.createPlaceholderPiece(ph.startName, (_a = ph.startSourceSpan) !== null && _a !== void 0 ? _a : ph.sourceSpan));
            if (!ph.isVoid) {
                ph.children.forEach(child => child.visit(this, context));
                context.push(this.createPlaceholderPiece(ph.closeName, (_b = ph.endSourceSpan) !== null && _b !== void 0 ? _b : ph.sourceSpan));
            }
        }
        visitPlaceholder(ph, context) {
            context.push(this.createPlaceholderPiece(ph.name, ph.sourceSpan));
        }
        visitIcuPlaceholder(ph, context) {
            context.push(this.createPlaceholderPiece(ph.name, ph.sourceSpan));
        }
        createPlaceholderPiece(name, sourceSpan) {
            return new PlaceholderPiece(formatI18nPlaceholderName(name, /* useCamelCase */ false), sourceSpan);
        }
    }
    const serializerVisitor$2 = new LocalizeSerializerVisitor();
    /**
     * Serialize an i18n message into two arrays: messageParts and placeholders.
     *
     * These arrays will be used to generate `$localize` tagged template literals.
     *
     * @param message The message to be serialized.
     * @returns an object containing the messageParts and placeholders.
     */
    function serializeI18nMessageForLocalize(message) {
        const pieces = [];
        message.nodes.forEach(node => node.visit(serializerVisitor$2, pieces));
        return processMessagePieces(pieces);
    }
    function getSourceSpan(message) {
        const startNode = message.nodes[0];
        const endNode = message.nodes[message.nodes.length - 1];
        return new ParseSourceSpan(startNode.sourceSpan.fullStart, endNode.sourceSpan.end, startNode.sourceSpan.fullStart, startNode.sourceSpan.details);
    }
    /**
     * Convert the list of serialized MessagePieces into two arrays.
     *
     * One contains the literal string pieces and the other the placeholders that will be replaced by
     * expressions when rendering `$localize` tagged template literals.
     *
     * @param pieces The pieces to process.
     * @returns an object containing the messageParts and placeholders.
     */
    function processMessagePieces(pieces) {
        const messageParts = [];
        const placeHolders = [];
        if (pieces[0] instanceof PlaceholderPiece) {
            // The first piece was a placeholder so we need to add an initial empty message part.
            messageParts.push(createEmptyMessagePart(pieces[0].sourceSpan.start));
        }
        for (let i = 0; i < pieces.length; i++) {
            const part = pieces[i];
            if (part instanceof LiteralPiece) {
                messageParts.push(part);
            }
            else {
                placeHolders.push(part);
                if (pieces[i - 1] instanceof PlaceholderPiece) {
                    // There were two placeholders in a row, so we need to add an empty message part.
                    messageParts.push(createEmptyMessagePart(pieces[i - 1].sourceSpan.end));
                }
            }
        }
        if (pieces[pieces.length - 1] instanceof PlaceholderPiece) {
            // The last piece was a placeholder so we need to add a final empty message part.
            messageParts.push(createEmptyMessagePart(pieces[pieces.length - 1].sourceSpan.end));
        }
        return { messageParts, placeHolders };
    }
    function createEmptyMessagePart(location) {
        return new LiteralPiece('', new ParseSourceSpan(location, location));
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    // Selector attribute name of `<ng-content>`
    const NG_CONTENT_SELECT_ATTR$1 = 'select';
    // Attribute name of `ngProjectAs`.
    const NG_PROJECT_AS_ATTR_NAME = 'ngProjectAs';
    // Global symbols available only inside event bindings.
    const EVENT_BINDING_SCOPE_GLOBALS = new Set(['$event']);
    // List of supported global targets for event listeners
    const GLOBAL_TARGET_RESOLVERS = new Map([['window', Identifiers.resolveWindow], ['document', Identifiers.resolveDocument], ['body', Identifiers.resolveBody]]);
    const LEADING_TRIVIA_CHARS = [' ', '\n', '\r', '\t'];
    //  if (rf & flags) { .. }
    function renderFlagCheckIfStmt(flags, statements) {
        return ifStmt(variable(RENDER_FLAGS).bitwiseAnd(literal(flags), null, false), statements);
    }
    function prepareEventListenerParameters(eventAst, handlerName = null, scope = null) {
        const { type, name, target, phase, handler } = eventAst;
        if (target && !GLOBAL_TARGET_RESOLVERS.has(target)) {
            throw new Error(`Unexpected global target '${target}' defined for '${name}' event.
        Supported list of global targets: ${Array.from(GLOBAL_TARGET_RESOLVERS.keys())}.`);
        }
        const eventArgumentName = '$event';
        const implicitReceiverAccesses = new Set();
        const implicitReceiverExpr = (scope === null || scope.bindingLevel === 0) ?
            variable(CONTEXT_NAME) :
            scope.getOrCreateSharedContextVar(0);
        const bindingExpr = convertActionBinding(scope, implicitReceiverExpr, handler, 'b', () => error('Unexpected interpolation'), eventAst.handlerSpan, implicitReceiverAccesses, EVENT_BINDING_SCOPE_GLOBALS);
        const statements = [];
        if (scope) {
            // `variableDeclarations` needs to run first, because
            // `restoreViewStatement` depends on the result.
            statements.push(...scope.variableDeclarations());
            statements.unshift(...scope.restoreViewStatement());
        }
        statements.push(...bindingExpr.render3Stmts);
        const eventName = type === 1 /* Animation */ ? prepareSyntheticListenerName(name, phase) : name;
        const fnName = handlerName && sanitizeIdentifier(handlerName);
        const fnArgs = [];
        if (implicitReceiverAccesses.has(eventArgumentName)) {
            fnArgs.push(new FnParam(eventArgumentName, DYNAMIC_TYPE));
        }
        const handlerFn = fn(fnArgs, statements, INFERRED_TYPE, null, fnName);
        const params = [literal(eventName), handlerFn];
        if (target) {
            params.push(literal(false), // `useCapture` flag, defaults to `false`
            importExpr(GLOBAL_TARGET_RESOLVERS.get(target)));
        }
        return params;
    }
    function createComponentDefConsts() {
        return {
            prepareStatements: [],
            constExpressions: [],
            i18nVarRefsCache: new Map(),
        };
    }
    class TemplateDefinitionBuilder {
        constructor(constantPool, parentBindingScope, level = 0, contextName, i18nContext, templateIndex, templateName, directiveMatcher, directives, pipeTypeByName, pipes, _namespace, relativeContextFilePath, i18nUseExternalIds, _constants = createComponentDefConsts()) {
            this.constantPool = constantPool;
            this.level = level;
            this.contextName = contextName;
            this.i18nContext = i18nContext;
            this.templateIndex = templateIndex;
            this.templateName = templateName;
            this.directiveMatcher = directiveMatcher;
            this.directives = directives;
            this.pipeTypeByName = pipeTypeByName;
            this.pipes = pipes;
            this._namespace = _namespace;
            this.i18nUseExternalIds = i18nUseExternalIds;
            this._constants = _constants;
            this._dataIndex = 0;
            this._bindingContext = 0;
            this._prefixCode = [];
            /**
             * List of callbacks to generate creation mode instructions. We store them here as we process
             * the template so bindings in listeners are resolved only once all nodes have been visited.
             * This ensures all local refs and context variables are available for matching.
             */
            this._creationCodeFns = [];
            /**
             * List of callbacks to generate update mode instructions. We store them here as we process
             * the template so bindings are resolved only once all nodes have been visited. This ensures
             * all local refs and context variables are available for matching.
             */
            this._updateCodeFns = [];
            /** Index of the currently-selected node. */
            this._currentIndex = 0;
            /** Temporary variable declarations generated from visiting pipes, literals, etc. */
            this._tempVariables = [];
            /**
             * List of callbacks to build nested templates. Nested templates must not be visited until
             * after the parent template has finished visiting all of its nodes. This ensures that all
             * local ref bindings in nested templates are able to find local ref values if the refs
             * are defined after the template declaration.
             */
            this._nestedTemplateFns = [];
            this._unsupported = unsupported;
            // i18n context local to this template
            this.i18n = null;
            // Number of slots to reserve for pureFunctions
            this._pureFunctionSlots = 0;
            // Number of binding slots
            this._bindingSlots = 0;
            // Projection slots found in the template. Projection slots can distribute projected
            // nodes based on a selector, or can just use the wildcard selector to match
            // all nodes which aren't matching any selector.
            this._ngContentReservedSlots = [];
            // Number of non-default selectors found in all parent templates of this template. We need to
            // track it to properly adjust projection slot index in the `projection` instruction.
            this._ngContentSelectorsOffset = 0;
            // Expression that should be used as implicit receiver when converting template
            // expressions to output AST.
            this._implicitReceiverExpr = null;
            // These should be handled in the template or element directly.
            this.visitReference = invalid$1;
            this.visitVariable = invalid$1;
            this.visitTextAttribute = invalid$1;
            this.visitBoundAttribute = invalid$1;
            this.visitBoundEvent = invalid$1;
            this._bindingScope = parentBindingScope.nestedScope(level);
            // Turn the relative context file path into an identifier by replacing non-alphanumeric
            // characters with underscores.
            this.fileBasedI18nSuffix = relativeContextFilePath.replace(/[^A-Za-z0-9]/g, '_') + '_';
            this._valueConverter = new ValueConverter(constantPool, () => this.allocateDataSlot(), (numSlots) => this.allocatePureFunctionSlots(numSlots), (name, localName, slot, value) => {
                const pipeType = pipeTypeByName.get(name);
                if (pipeType) {
                    this.pipes.add(pipeType);
                }
                this._bindingScope.set(this.level, localName, value);
                this.creationInstruction(null, Identifiers.pipe, [literal(slot), literal(name)]);
            });
        }
        buildTemplateFunction(nodes, variables, ngContentSelectorsOffset = 0, i18n) {
            this._ngContentSelectorsOffset = ngContentSelectorsOffset;
            if (this._namespace !== Identifiers.namespaceHTML) {
                this.creationInstruction(null, this._namespace);
            }
            // Create variable bindings
            variables.forEach(v => this.registerContextVariables(v));
            // Initiate i18n context in case:
            // - this template has parent i18n context
            // - or the template has i18n meta associated with it,
            //   but it's not initiated by the Element (e.g. <ng-template i18n>)
            const initI18nContext = this.i18nContext ||
                (isI18nRootNode(i18n) && !isSingleI18nIcu(i18n) &&
                    !(isSingleElementTemplate(nodes) && nodes[0].i18n === i18n));
            const selfClosingI18nInstruction = hasTextChildrenOnly(nodes);
            if (initI18nContext) {
                this.i18nStart(null, i18n, selfClosingI18nInstruction);
            }
            // This is the initial pass through the nodes of this template. In this pass, we
            // queue all creation mode and update mode instructions for generation in the second
            // pass. It's necessary to separate the passes to ensure local refs are defined before
            // resolving bindings. We also count bindings in this pass as we walk bound expressions.
            visitAll(this, nodes);
            // Add total binding count to pure function count so pure function instructions are
            // generated with the correct slot offset when update instructions are processed.
            this._pureFunctionSlots += this._bindingSlots;
            // Pipes are walked in the first pass (to enqueue `pipe()` creation instructions and
            // `pipeBind` update instructions), so we have to update the slot offsets manually
            // to account for bindings.
            this._valueConverter.updatePipeSlotOffsets(this._bindingSlots);
            // Nested templates must be processed before creation instructions so template()
            // instructions can be generated with the correct internal const count.
            this._nestedTemplateFns.forEach(buildTemplateFn => buildTemplateFn());
            // Output the `projectionDef` instruction when some `<ng-content>` tags are present.
            // The `projectionDef` instruction is only emitted for the component template and
            // is skipped for nested templates (<ng-template> tags).
            if (this.level === 0 && this._ngContentReservedSlots.length) {
                const parameters = [];
                // By default the `projectionDef` instructions creates one slot for the wildcard
                // selector if no parameters are passed. Therefore we only want to allocate a new
                // array for the projection slots if the default projection slot is not sufficient.
                if (this._ngContentReservedSlots.length > 1 || this._ngContentReservedSlots[0] !== '*') {
                    const r3ReservedSlots = this._ngContentReservedSlots.map(s => s !== '*' ? parseSelectorToR3Selector(s) : s);
                    parameters.push(this.constantPool.getConstLiteral(asLiteral(r3ReservedSlots), true));
                }
                // Since we accumulate ngContent selectors while processing template elements,
                // we *prepend* `projectionDef` to creation instructions block, to put it before
                // any `projection` instructions
                this.creationInstruction(null, Identifiers.projectionDef, parameters, /* prepend */ true);
            }
            if (initI18nContext) {
                this.i18nEnd(null, selfClosingI18nInstruction);
            }
            // Generate all the creation mode instructions (e.g. resolve bindings in listeners)
            const creationStatements = this._creationCodeFns.map((fn) => fn());
            // Generate all the update mode instructions (e.g. resolve property or text bindings)
            const updateStatements = this._updateCodeFns.map((fn) => fn());
            //  Variable declaration must occur after binding resolution so we can generate context
            //  instructions that build on each other.
            // e.g. const b = nextContext().$implicit(); const b = nextContext();
            const creationVariables = this._bindingScope.viewSnapshotStatements();
            const updateVariables = this._bindingScope.variableDeclarations().concat(this._tempVariables);
            const creationBlock = creationStatements.length > 0 ?
                [renderFlagCheckIfStmt(1 /* Create */, creationVariables.concat(creationStatements))] :
                [];
            const updateBlock = updateStatements.length > 0 ?
                [renderFlagCheckIfStmt(2 /* Update */, updateVariables.concat(updateStatements))] :
                [];
            return fn(
            // i.e. (rf: RenderFlags, ctx: any)
            [new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null)], [
                // Temporary variable declarations for query refresh (i.e. let _t: any;)
                ...this._prefixCode,
                // Creating mode (i.e. if (rf & RenderFlags.Create) { ... })
                ...creationBlock,
                // Binding and refresh mode (i.e. if (rf & RenderFlags.Update) {...})
                ...updateBlock,
            ], INFERRED_TYPE, null, this.templateName);
        }
        // LocalResolver
        getLocal(name) {
            return this._bindingScope.get(name);
        }
        // LocalResolver
        notifyImplicitReceiverUse() {
            this._bindingScope.notifyImplicitReceiverUse();
        }
        // LocalResolver
        maybeRestoreView() {
            this._bindingScope.maybeRestoreView();
        }
        i18nTranslate(message, params = {}, ref, transformFn) {
            const _ref = ref || this.i18nGenerateMainBlockVar();
            // Closure Compiler requires const names to start with `MSG_` but disallows any other const to
            // start with `MSG_`. We define a variable starting with `MSG_` just for the `goog.getMsg` call
            const closureVar = this.i18nGenerateClosureVar(message.id);
            const statements = getTranslationDeclStmts(message, _ref, closureVar, params, transformFn);
            this._constants.prepareStatements.push(...statements);
            return _ref;
        }
        registerContextVariables(variable$1) {
            const scopedName = this._bindingScope.freshReferenceName();
            const retrievalLevel = this.level;
            const lhs = variable(variable$1.name + scopedName);
            this._bindingScope.set(retrievalLevel, variable$1.name, lhs, 1 /* CONTEXT */, (scope, relativeLevel) => {
                let rhs;
                if (scope.bindingLevel === retrievalLevel) {
                    if (scope.isListenerScope() && scope.hasRestoreViewVariable()) {
                        // e.g. restoredCtx.
                        // We have to get the context from a view reference, if one is available, because
                        // the context that was passed in during creation may not be correct anymore.
                        // For more information see: https://github.com/angular/angular/pull/40360.
                        rhs = variable(RESTORED_VIEW_CONTEXT_NAME);
                        scope.notifyRestoredViewContextUse();
                    }
                    else {
                        // e.g. ctx
                        rhs = variable(CONTEXT_NAME);
                    }
                }
                else {
                    const sharedCtxVar = scope.getSharedContextName(retrievalLevel);
                    // e.g. ctx_r0   OR  x(2);
                    rhs = sharedCtxVar ? sharedCtxVar : generateNextContextExpr(relativeLevel);
                }
                // e.g. const $item$ = x(2).$implicit;
                return [lhs.set(rhs.prop(variable$1.value || IMPLICIT_REFERENCE)).toConstDecl()];
            });
        }
        i18nAppendBindings(expressions) {
            if (expressions.length > 0) {
                expressions.forEach(expression => this.i18n.appendBinding(expression));
            }
        }
        i18nBindProps(props) {
            const bound = {};
            Object.keys(props).forEach(key => {
                const prop = props[key];
                if (prop instanceof Text) {
                    bound[key] = literal(prop.value);
                }
                else {
                    const value = prop.value.visit(this._valueConverter);
                    this.allocateBindingSlots(value);
                    if (value instanceof Interpolation) {
                        const { strings, expressions } = value;
                        const { id, bindings } = this.i18n;
                        const label = assembleI18nBoundString(strings, bindings.size, id);
                        this.i18nAppendBindings(expressions);
                        bound[key] = literal(label);
                    }
                }
            });
            return bound;
        }
        // Generates top level vars for i18n blocks (i.e. `i18n_N`).
        i18nGenerateMainBlockVar() {
            return variable(this.constantPool.uniqueName(TRANSLATION_VAR_PREFIX));
        }
        // Generates vars with Closure-specific names for i18n blocks (i.e. `MSG_XXX`).
        i18nGenerateClosureVar(messageId) {
            let name;
            const suffix = this.fileBasedI18nSuffix.toUpperCase();
            if (this.i18nUseExternalIds) {
                const prefix = getTranslationConstPrefix(`EXTERNAL_`);
                const uniqueSuffix = this.constantPool.uniqueName(suffix);
                name = `${prefix}${sanitizeIdentifier(messageId)}$$${uniqueSuffix}`;
            }
            else {
                const prefix = getTranslationConstPrefix(suffix);
                name = this.constantPool.uniqueName(prefix);
            }
            return variable(name);
        }
        i18nUpdateRef(context) {
            const { icus, meta, isRoot, isResolved, isEmitted } = context;
            if (isRoot && isResolved && !isEmitted && !isSingleI18nIcu(meta)) {
                context.isEmitted = true;
                const placeholders = context.getSerializedPlaceholders();
                let icuMapping = {};
                let params = placeholders.size ? placeholdersToParams(placeholders) : {};
                if (icus.size) {
                    icus.forEach((refs, key) => {
                        if (refs.length === 1) {
                            // if we have one ICU defined for a given
                            // placeholder - just output its reference
                            params[key] = refs[0];
                        }
                        else {
                            // ... otherwise we need to activate post-processing
                            // to replace ICU placeholders with proper values
                            const placeholder = wrapI18nPlaceholder(`${I18N_ICU_MAPPING_PREFIX}${key}`);
                            params[key] = literal(placeholder);
                            icuMapping[key] = literalArr(refs);
                        }
                    });
                }
                // translation requires post processing in 2 cases:
                // - if we have placeholders with multiple values (ex. `START_DIV`: [#1, #2, ...])
                // - if we have multiple ICUs that refer to the same placeholder name
                const needsPostprocessing = Array.from(placeholders.values()).some((value) => value.length > 1) ||
                    Object.keys(icuMapping).length;
                let transformFn;
                if (needsPostprocessing) {
                    transformFn = (raw) => {
                        const args = [raw];
                        if (Object.keys(icuMapping).length) {
                            args.push(mapLiteral(icuMapping, true));
                        }
                        return instruction(null, Identifiers.i18nPostprocess, args);
                    };
                }
                this.i18nTranslate(meta, params, context.ref, transformFn);
            }
        }
        i18nStart(span = null, meta, selfClosing) {
            const index = this.allocateDataSlot();
            this.i18n = this.i18nContext ?
                this.i18nContext.forkChildContext(index, this.templateIndex, meta) :
                new I18nContext(index, this.i18nGenerateMainBlockVar(), 0, this.templateIndex, meta);
            // generate i18nStart instruction
            const { id, ref } = this.i18n;
            const params = [literal(index), this.addToConsts(ref)];
            if (id > 0) {
                // do not push 3rd argument (sub-block id)
                // into i18nStart call for top level i18n context
                params.push(literal(id));
            }
            this.creationInstruction(span, selfClosing ? Identifiers.i18n : Identifiers.i18nStart, params);
        }
        i18nEnd(span = null, selfClosing) {
            if (!this.i18n) {
                throw new Error('i18nEnd is executed with no i18n context present');
            }
            if (this.i18nContext) {
                this.i18nContext.reconcileChildContext(this.i18n);
                this.i18nUpdateRef(this.i18nContext);
            }
            else {
                this.i18nUpdateRef(this.i18n);
            }
            // setup accumulated bindings
            const { index, bindings } = this.i18n;
            if (bindings.size) {
                const chainBindings = [];
                bindings.forEach(binding => {
                    chainBindings.push({ sourceSpan: span, value: () => this.convertPropertyBinding(binding) });
                });
                // for i18n block, advance to the most recent element index (by taking the current number of
                // elements and subtracting one) before invoking `i18nExp` instructions, to make sure the
                // necessary lifecycle hooks of components/directives are properly flushed.
                this.updateInstructionChainWithAdvance(this.getConstCount() - 1, Identifiers.i18nExp, chainBindings);
                this.updateInstruction(span, Identifiers.i18nApply, [literal(index)]);
            }
            if (!selfClosing) {
                this.creationInstruction(span, Identifiers.i18nEnd);
            }
            this.i18n = null; // reset local i18n context
        }
        i18nAttributesInstruction(nodeIndex, attrs, sourceSpan) {
            let hasBindings = false;
            const i18nAttrArgs = [];
            const bindings = [];
            attrs.forEach(attr => {
                const message = attr.i18n;
                const converted = attr.value.visit(this._valueConverter);
                this.allocateBindingSlots(converted);
                if (converted instanceof Interpolation) {
                    const placeholders = assembleBoundTextPlaceholders(message);
                    const params = placeholdersToParams(placeholders);
                    i18nAttrArgs.push(literal(attr.name), this.i18nTranslate(message, params));
                    converted.expressions.forEach(expression => {
                        hasBindings = true;
                        bindings.push({
                            sourceSpan,
                            value: () => this.convertPropertyBinding(expression),
                        });
                    });
                }
            });
            if (bindings.length > 0) {
                this.updateInstructionChainWithAdvance(nodeIndex, Identifiers.i18nExp, bindings);
            }
            if (i18nAttrArgs.length > 0) {
                const index = literal(this.allocateDataSlot());
                const constIndex = this.addToConsts(literalArr(i18nAttrArgs));
                this.creationInstruction(sourceSpan, Identifiers.i18nAttributes, [index, constIndex]);
                if (hasBindings) {
                    this.updateInstruction(sourceSpan, Identifiers.i18nApply, [index]);
                }
            }
        }
        getNamespaceInstruction(namespaceKey) {
            switch (namespaceKey) {
                case 'math':
                    return Identifiers.namespaceMathML;
                case 'svg':
                    return Identifiers.namespaceSVG;
                default:
                    return Identifiers.namespaceHTML;
            }
        }
        addNamespaceInstruction(nsInstruction, element) {
            this._namespace = nsInstruction;
            this.creationInstruction(element.startSourceSpan, nsInstruction);
        }
        /**
         * Adds an update instruction for an interpolated property or attribute, such as
         * `prop="{{value}}"` or `attr.title="{{value}}"`
         */
        interpolatedUpdateInstruction(instruction, elementIndex, attrName, input, value, params) {
            this.updateInstructionWithAdvance(elementIndex, input.sourceSpan, instruction, () => [literal(attrName), ...this.getUpdateInstructionArguments(value), ...params]);
        }
        visitContent(ngContent) {
            const slot = this.allocateDataSlot();
            const projectionSlotIdx = this._ngContentSelectorsOffset + this._ngContentReservedSlots.length;
            const parameters = [literal(slot)];
            this._ngContentReservedSlots.push(ngContent.selector);
            const nonContentSelectAttributes = ngContent.attributes.filter(attr => attr.name.toLowerCase() !== NG_CONTENT_SELECT_ATTR$1);
            const attributes = this.getAttributeExpressions(ngContent.name, nonContentSelectAttributes, [], []);
            if (attributes.length > 0) {
                parameters.push(literal(projectionSlotIdx), literalArr(attributes));
            }
            else if (projectionSlotIdx !== 0) {
                parameters.push(literal(projectionSlotIdx));
            }
            this.creationInstruction(ngContent.sourceSpan, Identifiers.projection, parameters);
            if (this.i18n) {
                this.i18n.appendProjection(ngContent.i18n, slot);
            }
        }
        visitElement(element) {
            var _a, _b;
            const elementIndex = this.allocateDataSlot();
            const stylingBuilder = new StylingBuilder(null);
            let isNonBindableMode = false;
            const isI18nRootElement = isI18nRootNode(element.i18n) && !isSingleI18nIcu(element.i18n);
            const outputAttrs = [];
            const [namespaceKey, elementName] = splitNsName(element.name);
            const isNgContainer$1 = isNgContainer(element.name);
            // Handle styling, i18n, ngNonBindable attributes
            for (const attr of element.attributes) {
                const { name, value } = attr;
                if (name === NON_BINDABLE_ATTR) {
                    isNonBindableMode = true;
                }
                else if (name === 'style') {
                    stylingBuilder.registerStyleAttr(value);
                }
                else if (name === 'class') {
                    stylingBuilder.registerClassAttr(value);
                }
                else {
                    outputAttrs.push(attr);
                }
            }
            // Match directives on non i18n attributes
            this.matchDirectives(element.name, element);
            // Regular element or ng-container creation mode
            const parameters = [literal(elementIndex)];
            if (!isNgContainer$1) {
                parameters.push(literal(elementName));
            }
            // Add the attributes
            const allOtherInputs = [];
            const boundI18nAttrs = [];
            element.inputs.forEach(input => {
                const stylingInputWasSet = stylingBuilder.registerBoundInput(input);
                if (!stylingInputWasSet) {
                    if (input.type === 0 /* Property */ && input.i18n) {
                        boundI18nAttrs.push(input);
                    }
                    else {
                        allOtherInputs.push(input);
                    }
                }
            });
            // add attributes for directive and projection matching purposes
            const attributes = this.getAttributeExpressions(element.name, outputAttrs, allOtherInputs, element.outputs, stylingBuilder, [], boundI18nAttrs);
            parameters.push(this.addAttrsToConsts(attributes));
            // local refs (ex.: <div #foo #bar="baz">)
            const refs = this.prepareRefsArray(element.references);
            parameters.push(this.addToConsts(refs));
            const wasInNamespace = this._namespace;
            const currentNamespace = this.getNamespaceInstruction(namespaceKey);
            // If the namespace is changing now, include an instruction to change it
            // during element creation.
            if (currentNamespace !== wasInNamespace) {
                this.addNamespaceInstruction(currentNamespace, element);
            }
            if (this.i18n) {
                this.i18n.appendElement(element.i18n, elementIndex);
            }
            // Note that we do not append text node instructions and ICUs inside i18n section,
            // so we exclude them while calculating whether current element has children
            const hasChildren = (!isI18nRootElement && this.i18n) ? !hasTextChildrenOnly(element.children) :
                element.children.length > 0;
            const createSelfClosingInstruction = !stylingBuilder.hasBindingsWithPipes &&
                element.outputs.length === 0 && boundI18nAttrs.length === 0 && !hasChildren;
            const createSelfClosingI18nInstruction = !createSelfClosingInstruction && hasTextChildrenOnly(element.children);
            if (createSelfClosingInstruction) {
                this.creationInstruction(element.sourceSpan, isNgContainer$1 ? Identifiers.elementContainer : Identifiers.element, trimTrailingNulls(parameters));
            }
            else {
                this.creationInstruction(element.startSourceSpan, isNgContainer$1 ? Identifiers.elementContainerStart : Identifiers.elementStart, trimTrailingNulls(parameters));
                if (isNonBindableMode) {
                    this.creationInstruction(element.startSourceSpan, Identifiers.disableBindings);
                }
                if (boundI18nAttrs.length > 0) {
                    this.i18nAttributesInstruction(elementIndex, boundI18nAttrs, (_a = element.startSourceSpan) !== null && _a !== void 0 ? _a : element.sourceSpan);
                }
                // Generate Listeners (outputs)
                if (element.outputs.length > 0) {
                    const listeners = element.outputs.map((outputAst) => ({
                        sourceSpan: outputAst.sourceSpan,
                        params: this.prepareListenerParameter(element.name, outputAst, elementIndex)
                    }));
                    this.creationInstructionChain(Identifiers.listener, listeners);
                }
                // Note: it's important to keep i18n/i18nStart instructions after i18nAttributes and
                // listeners, to make sure i18nAttributes instruction targets current element at runtime.
                if (isI18nRootElement) {
                    this.i18nStart(element.startSourceSpan, element.i18n, createSelfClosingI18nInstruction);
                }
            }
            // the code here will collect all update-level styling instructions and add them to the
            // update block of the template function AOT code. Instructions like `styleProp`,
            // `styleMap`, `classMap`, `classProp`
            // are all generated and assigned in the code below.
            const stylingInstructions = stylingBuilder.buildUpdateLevelInstructions(this._valueConverter);
            const limit = stylingInstructions.length - 1;
            for (let i = 0; i <= limit; i++) {
                const instruction = stylingInstructions[i];
                this._bindingSlots += this.processStylingUpdateInstruction(elementIndex, instruction);
            }
            // the reason why `undefined` is used is because the renderer understands this as a
            // special value to symbolize that there is no RHS to this binding
            // TODO (matsko): revisit this once FW-959 is approached
            const emptyValueBindInstruction = literal(undefined);
            const propertyBindings = [];
            const attributeBindings = [];
            // Generate element input bindings
            allOtherInputs.forEach(input => {
                const inputType = input.type;
                if (inputType === 4 /* Animation */) {
                    const value = input.value.visit(this._valueConverter);
                    // animation bindings can be presented in the following formats:
                    // 1. [@binding]="fooExp"
                    // 2. [@binding]="{value:fooExp, params:{...}}"
                    // 3. [@binding]
                    // 4. @binding
                    // All formats will be valid for when a synthetic binding is created.
                    // The reasoning for this is because the renderer should get each
                    // synthetic binding value in the order of the array that they are
                    // defined in...
                    const hasValue = value instanceof LiteralPrimitive ? !!value.value : true;
                    this.allocateBindingSlots(value);
                    propertyBindings.push({
                        name: prepareSyntheticPropertyName(input.name),
                        sourceSpan: input.sourceSpan,
                        value: () => hasValue ? this.convertPropertyBinding(value) : emptyValueBindInstruction
                    });
                }
                else {
                    // we must skip attributes with associated i18n context, since these attributes are handled
                    // separately and corresponding `i18nExp` and `i18nApply` instructions will be generated
                    if (input.i18n)
                        return;
                    const value = input.value.visit(this._valueConverter);
                    if (value !== undefined) {
                        const params = [];
                        const [attrNamespace, attrName] = splitNsName(input.name);
                        const isAttributeBinding = inputType === 1 /* Attribute */;
                        const sanitizationRef = resolveSanitizationFn(input.securityContext, isAttributeBinding);
                        if (sanitizationRef)
                            params.push(sanitizationRef);
                        if (attrNamespace) {
                            const namespaceLiteral = literal(attrNamespace);
                            if (sanitizationRef) {
                                params.push(namespaceLiteral);
                            }
                            else {
                                // If there wasn't a sanitization ref, we need to add
                                // an extra param so that we can pass in the namespace.
                                params.push(literal(null), namespaceLiteral);
                            }
                        }
                        this.allocateBindingSlots(value);
                        if (inputType === 0 /* Property */) {
                            if (value instanceof Interpolation) {
                                // prop="{{value}}" and friends
                                this.interpolatedUpdateInstruction(getPropertyInterpolationExpression(value), elementIndex, attrName, input, value, params);
                            }
                            else {
                                // [prop]="value"
                                // Collect all the properties so that we can chain into a single function at the end.
                                propertyBindings.push({
                                    name: attrName,
                                    sourceSpan: input.sourceSpan,
                                    value: () => this.convertPropertyBinding(value),
                                    params
                                });
                            }
                        }
                        else if (inputType === 1 /* Attribute */) {
                            if (value instanceof Interpolation && getInterpolationArgsLength(value) > 1) {
                                // attr.name="text{{value}}" and friends
                                this.interpolatedUpdateInstruction(getAttributeInterpolationExpression(value), elementIndex, attrName, input, value, params);
                            }
                            else {
                                const boundValue = value instanceof Interpolation ? value.expressions[0] : value;
                                // [attr.name]="value" or attr.name="{{value}}"
                                // Collect the attribute bindings so that they can be chained at the end.
                                attributeBindings.push({
                                    name: attrName,
                                    sourceSpan: input.sourceSpan,
                                    value: () => this.convertPropertyBinding(boundValue),
                                    params
                                });
                            }
                        }
                        else {
                            // class prop
                            this.updateInstructionWithAdvance(elementIndex, input.sourceSpan, Identifiers.classProp, () => {
                                return [
                                    literal(elementIndex), literal(attrName), this.convertPropertyBinding(value),
                                    ...params
                                ];
                            });
                        }
                    }
                }
            });
            if (propertyBindings.length > 0) {
                this.updateInstructionChainWithAdvance(elementIndex, Identifiers.property, propertyBindings);
            }
            if (attributeBindings.length > 0) {
                this.updateInstructionChainWithAdvance(elementIndex, Identifiers.attribute, attributeBindings);
            }
            // Traverse element child nodes
            visitAll(this, element.children);
            if (!isI18nRootElement && this.i18n) {
                this.i18n.appendElement(element.i18n, elementIndex, true);
            }
            if (!createSelfClosingInstruction) {
                // Finish element construction mode.
                const span = (_b = element.endSourceSpan) !== null && _b !== void 0 ? _b : element.sourceSpan;
                if (isI18nRootElement) {
                    this.i18nEnd(span, createSelfClosingI18nInstruction);
                }
                if (isNonBindableMode) {
                    this.creationInstruction(span, Identifiers.enableBindings);
                }
                this.creationInstruction(span, isNgContainer$1 ? Identifiers.elementContainerEnd : Identifiers.elementEnd);
            }
        }
        visitTemplate(template) {
            var _a;
            const NG_TEMPLATE_TAG_NAME = 'ng-template';
            const templateIndex = this.allocateDataSlot();
            if (this.i18n) {
                this.i18n.appendTemplate(template.i18n, templateIndex);
            }
            const tagNameWithoutNamespace = template.tagName ? splitNsName(template.tagName)[1] : template.tagName;
            const contextName = `${this.contextName}${template.tagName ? '_' + sanitizeIdentifier(template.tagName) : ''}_${templateIndex}`;
            const templateName = `${contextName}_Template`;
            const parameters = [
                literal(templateIndex),
                variable(templateName),
                // We don't care about the tag's namespace here, because we infer
                // it based on the parent nodes inside the template instruction.
                literal(tagNameWithoutNamespace),
            ];
            // find directives matching on a given <ng-template> node
            this.matchDirectives(NG_TEMPLATE_TAG_NAME, template);
            // prepare attributes parameter (including attributes used for directive matching)
            const attrsExprs = this.getAttributeExpressions(NG_TEMPLATE_TAG_NAME, template.attributes, template.inputs, template.outputs, undefined /* styles */, template.templateAttrs);
            parameters.push(this.addAttrsToConsts(attrsExprs));
            // local refs (ex.: <ng-template #foo>)
            if (template.references && template.references.length) {
                const refs = this.prepareRefsArray(template.references);
                parameters.push(this.addToConsts(refs));
                parameters.push(importExpr(Identifiers.templateRefExtractor));
            }
            // Create the template function
            const templateVisitor = new TemplateDefinitionBuilder(this.constantPool, this._bindingScope, this.level + 1, contextName, this.i18n, templateIndex, templateName, this.directiveMatcher, this.directives, this.pipeTypeByName, this.pipes, this._namespace, this.fileBasedI18nSuffix, this.i18nUseExternalIds, this._constants);
            // Nested templates must not be visited until after their parent templates have completed
            // processing, so they are queued here until after the initial pass. Otherwise, we wouldn't
            // be able to support bindings in nested templates to local refs that occur after the
            // template definition. e.g. <div *ngIf="showing">{{ foo }}</div>  <div #foo></div>
            this._nestedTemplateFns.push(() => {
                const templateFunctionExpr = templateVisitor.buildTemplateFunction(template.children, template.variables, this._ngContentReservedSlots.length + this._ngContentSelectorsOffset, template.i18n);
                this.constantPool.statements.push(templateFunctionExpr.toDeclStmt(templateName));
                if (templateVisitor._ngContentReservedSlots.length) {
                    this._ngContentReservedSlots.push(...templateVisitor._ngContentReservedSlots);
                }
            });
            // e.g. template(1, MyComp_Template_1)
            this.creationInstruction(template.sourceSpan, Identifiers.templateCreate, () => {
                parameters.splice(2, 0, literal(templateVisitor.getConstCount()), literal(templateVisitor.getVarCount()));
                return trimTrailingNulls(parameters);
            });
            // handle property bindings e.g. property('ngForOf', ctx.items), et al;
            this.templatePropertyBindings(templateIndex, template.templateAttrs);
            // Only add normal input/output binding instructions on explicit <ng-template> elements.
            if (tagNameWithoutNamespace === NG_TEMPLATE_TAG_NAME) {
                const [i18nInputs, inputs] = partitionArray(template.inputs, hasI18nMeta);
                // Add i18n attributes that may act as inputs to directives. If such attributes are present,
                // generate `i18nAttributes` instruction. Note: we generate it only for explicit <ng-template>
                // elements, in case of inline templates, corresponding instructions will be generated in the
                // nested template function.
                if (i18nInputs.length > 0) {
                    this.i18nAttributesInstruction(templateIndex, i18nInputs, (_a = template.startSourceSpan) !== null && _a !== void 0 ? _a : template.sourceSpan);
                }
                // Add the input bindings
                if (inputs.length > 0) {
                    this.templatePropertyBindings(templateIndex, inputs);
                }
                // Generate listeners for directive output
                if (template.outputs.length > 0) {
                    const listeners = template.outputs.map((outputAst) => ({
                        sourceSpan: outputAst.sourceSpan,
                        params: this.prepareListenerParameter('ng_template', outputAst, templateIndex)
                    }));
                    this.creationInstructionChain(Identifiers.listener, listeners);
                }
            }
        }
        visitBoundText(text) {
            if (this.i18n) {
                const value = text.value.visit(this._valueConverter);
                this.allocateBindingSlots(value);
                if (value instanceof Interpolation) {
                    this.i18n.appendBoundText(text.i18n);
                    this.i18nAppendBindings(value.expressions);
                }
                return;
            }
            const nodeIndex = this.allocateDataSlot();
            this.creationInstruction(text.sourceSpan, Identifiers.text, [literal(nodeIndex)]);
            const value = text.value.visit(this._valueConverter);
            this.allocateBindingSlots(value);
            if (value instanceof Interpolation) {
                this.updateInstructionWithAdvance(nodeIndex, text.sourceSpan, getTextInterpolationExpression(value), () => this.getUpdateInstructionArguments(value));
            }
            else {
                error('Text nodes should be interpolated and never bound directly.');
            }
        }
        visitText(text) {
            // when a text element is located within a translatable
            // block, we exclude this text element from instructions set,
            // since it will be captured in i18n content and processed at runtime
            if (!this.i18n) {
                this.creationInstruction(text.sourceSpan, Identifiers.text, [literal(this.allocateDataSlot()), literal(text.value)]);
            }
        }
        visitIcu(icu) {
            let initWasInvoked = false;
            // if an ICU was created outside of i18n block, we still treat
            // it as a translatable entity and invoke i18nStart and i18nEnd
            // to generate i18n context and the necessary instructions
            if (!this.i18n) {
                initWasInvoked = true;
                this.i18nStart(null, icu.i18n, true);
            }
            const i18n = this.i18n;
            const vars = this.i18nBindProps(icu.vars);
            const placeholders = this.i18nBindProps(icu.placeholders);
            // output ICU directly and keep ICU reference in context
            const message = icu.i18n;
            // we always need post-processing function for ICUs, to make sure that:
            // - all placeholders in a form of {PLACEHOLDER} are replaced with actual values (note:
            // `goog.getMsg` does not process ICUs and uses the `{PLACEHOLDER}` format for placeholders
            // inside ICUs)
            // - all ICU vars (such as `VAR_SELECT` or `VAR_PLURAL`) are replaced with correct values
            const transformFn = (raw) => {
                const params = Object.assign(Object.assign({}, vars), placeholders);
                const formatted = i18nFormatPlaceholderNames(params, /* useCamelCase */ false);
                return instruction(null, Identifiers.i18nPostprocess, [raw, mapLiteral(formatted, true)]);
            };
            // in case the whole i18n message is a single ICU - we do not need to
            // create a separate top-level translation, we can use the root ref instead
            // and make this ICU a top-level translation
            // note: ICU placeholders are replaced with actual values in `i18nPostprocess` function
            // separately, so we do not pass placeholders into `i18nTranslate` function.
            if (isSingleI18nIcu(i18n.meta)) {
                this.i18nTranslate(message, /* placeholders */ {}, i18n.ref, transformFn);
            }
            else {
                // output ICU directly and keep ICU reference in context
                const ref = this.i18nTranslate(message, /* placeholders */ {}, /* ref */ undefined, transformFn);
                i18n.appendIcu(icuFromI18nMessage(message).name, ref);
            }
            if (initWasInvoked) {
                this.i18nEnd(null, true);
            }
            return null;
        }
        allocateDataSlot() {
            return this._dataIndex++;
        }
        getConstCount() {
            return this._dataIndex;
        }
        getVarCount() {
            return this._pureFunctionSlots;
        }
        getConsts() {
            return this._constants;
        }
        getNgContentSelectors() {
            return this._ngContentReservedSlots.length ?
                this.constantPool.getConstLiteral(asLiteral(this._ngContentReservedSlots), true) :
                null;
        }
        bindingContext() {
            return `${this._bindingContext++}`;
        }
        templatePropertyBindings(templateIndex, attrs) {
            const propertyBindings = [];
            attrs.forEach(input => {
                if (input instanceof BoundAttribute) {
                    const value = input.value.visit(this._valueConverter);
                    if (value !== undefined) {
                        this.allocateBindingSlots(value);
                        if (value instanceof Interpolation) {
                            // Params typically contain attribute namespace and value sanitizer, which is applicable
                            // for regular HTML elements, but not applicable for <ng-template> (since props act as
                            // inputs to directives), so keep params array empty.
                            const params = [];
                            // prop="{{value}}" case
                            this.interpolatedUpdateInstruction(getPropertyInterpolationExpression(value), templateIndex, input.name, input, value, params);
                        }
                        else {
                            // [prop]="value" case
                            propertyBindings.push({
                                name: input.name,
                                sourceSpan: input.sourceSpan,
                                value: () => this.convertPropertyBinding(value)
                            });
                        }
                    }
                }
            });
            if (propertyBindings.length > 0) {
                this.updateInstructionChainWithAdvance(templateIndex, Identifiers.property, propertyBindings);
            }
        }
        // Bindings must only be resolved after all local refs have been visited, so all
        // instructions are queued in callbacks that execute once the initial pass has completed.
        // Otherwise, we wouldn't be able to support local refs that are defined after their
        // bindings. e.g. {{ foo }} <div #foo></div>
        instructionFn(fns, span, reference, paramsOrFn, prepend = false) {
            fns[prepend ? 'unshift' : 'push'](() => {
                const params = Array.isArray(paramsOrFn) ? paramsOrFn : paramsOrFn();
                return instruction(span, reference, params).toStmt();
            });
        }
        processStylingUpdateInstruction(elementIndex, instruction) {
            let allocateBindingSlots = 0;
            if (instruction) {
                const calls = [];
                instruction.calls.forEach(call => {
                    allocateBindingSlots += call.allocateBindingSlots;
                    calls.push({
                        sourceSpan: call.sourceSpan,
                        value: () => {
                            return call.params(value => (call.supportsInterpolation && value instanceof Interpolation) ?
                                this.getUpdateInstructionArguments(value) :
                                this.convertPropertyBinding(value));
                        }
                    });
                });
                this.updateInstructionChainWithAdvance(elementIndex, instruction.reference, calls);
            }
            return allocateBindingSlots;
        }
        creationInstruction(span, reference, paramsOrFn, prepend) {
            this.instructionFn(this._creationCodeFns, span, reference, paramsOrFn || [], prepend);
        }
        creationInstructionChain(reference, calls) {
            const span = calls.length ? calls[0].sourceSpan : null;
            this._creationCodeFns.push(() => {
                return chainedInstruction(reference, calls.map(call => call.params()), span).toStmt();
            });
        }
        updateInstructionWithAdvance(nodeIndex, span, reference, paramsOrFn) {
            this.addAdvanceInstructionIfNecessary(nodeIndex, span);
            this.updateInstruction(span, reference, paramsOrFn);
        }
        updateInstruction(span, reference, paramsOrFn) {
            this.instructionFn(this._updateCodeFns, span, reference, paramsOrFn || []);
        }
        updateInstructionChain(reference, bindings) {
            const span = bindings.length ? bindings[0].sourceSpan : null;
            this._updateCodeFns.push(() => {
                const calls = bindings.map(property => {
                    const value = property.value();
                    const fnParams = Array.isArray(value) ? value : [value];
                    if (property.params) {
                        fnParams.push(...property.params);
                    }
                    if (property.name) {
                        // We want the property name to always be the first function parameter.
                        fnParams.unshift(literal(property.name));
                    }
                    return fnParams;
                });
                return chainedInstruction(reference, calls, span).toStmt();
            });
        }
        updateInstructionChainWithAdvance(nodeIndex, reference, bindings) {
            this.addAdvanceInstructionIfNecessary(nodeIndex, bindings.length ? bindings[0].sourceSpan : null);
            this.updateInstructionChain(reference, bindings);
        }
        addAdvanceInstructionIfNecessary(nodeIndex, span) {
            if (nodeIndex !== this._currentIndex) {
                const delta = nodeIndex - this._currentIndex;
                if (delta < 1) {
                    throw new Error('advance instruction can only go forwards');
                }
                this.instructionFn(this._updateCodeFns, span, Identifiers.advance, [literal(delta)]);
                this._currentIndex = nodeIndex;
            }
        }
        allocatePureFunctionSlots(numSlots) {
            const originalSlots = this._pureFunctionSlots;
            this._pureFunctionSlots += numSlots;
            return originalSlots;
        }
        allocateBindingSlots(value) {
            this._bindingSlots += value instanceof Interpolation ? value.expressions.length : 1;
        }
        /**
         * Gets an expression that refers to the implicit receiver. The implicit
         * receiver is always the root level context.
         */
        getImplicitReceiverExpr() {
            if (this._implicitReceiverExpr) {
                return this._implicitReceiverExpr;
            }
            return this._implicitReceiverExpr = this.level === 0 ?
                variable(CONTEXT_NAME) :
                this._bindingScope.getOrCreateSharedContextVar(0);
        }
        convertPropertyBinding(value) {
            const convertedPropertyBinding = convertPropertyBinding(this, this.getImplicitReceiverExpr(), value, this.bindingContext(), BindingForm.Expression, () => error('Unexpected interpolation'));
            const valExpr = convertedPropertyBinding.currValExpr;
            this._tempVariables.push(...convertedPropertyBinding.stmts);
            return valExpr;
        }
        /**
         * Gets a list of argument expressions to pass to an update instruction expression. Also updates
         * the temp variables state with temp variables that were identified as needing to be created
         * while visiting the arguments.
         * @param value The original expression we will be resolving an arguments list from.
         */
        getUpdateInstructionArguments(value) {
            const { args, stmts } = convertUpdateArguments(this, this.getImplicitReceiverExpr(), value, this.bindingContext());
            this._tempVariables.push(...stmts);
            return args;
        }
        matchDirectives(elementName, elOrTpl) {
            if (this.directiveMatcher) {
                const selector = createCssSelector(elementName, getAttrsForDirectiveMatching(elOrTpl));
                this.directiveMatcher.match(selector, (cssSelector, staticType) => {
                    this.directives.add(staticType);
                });
            }
        }
        /**
         * Prepares all attribute expression values for the `TAttributes` array.
         *
         * The purpose of this function is to properly construct an attributes array that
         * is passed into the `elementStart` (or just `element`) functions. Because there
         * are many different types of attributes, the array needs to be constructed in a
         * special way so that `elementStart` can properly evaluate them.
         *
         * The format looks like this:
         *
         * ```
         * attrs = [prop, value, prop2, value2,
         *   PROJECT_AS, selector,
         *   CLASSES, class1, class2,
         *   STYLES, style1, value1, style2, value2,
         *   BINDINGS, name1, name2, name3,
         *   TEMPLATE, name4, name5, name6,
         *   I18N, name7, name8, ...]
         * ```
         *
         * Note that this function will fully ignore all synthetic (@foo) attribute values
         * because those values are intended to always be generated as property instructions.
         */
        getAttributeExpressions(elementName, renderAttributes, inputs, outputs, styles, templateAttrs = [], boundI18nAttrs = []) {
            const alreadySeen = new Set();
            const attrExprs = [];
            let ngProjectAsAttr;
            for (const attr of renderAttributes) {
                if (attr.name === NG_PROJECT_AS_ATTR_NAME) {
                    ngProjectAsAttr = attr;
                }
                // Note that static i18n attributes aren't in the i18n array,
                // because they're treated in the same way as regular attributes.
                if (attr.i18n) {
                    // When i18n attributes are present on elements with structural directives
                    // (e.g. `<div *ngIf title="Hello" i18n-title>`), we want to avoid generating
                    // duplicate i18n translation blocks for `template` and `element` instruction
                    // attributes. So we do a cache lookup to see if suitable i18n translation block
                    // already exists.
                    const { i18nVarRefsCache } = this._constants;
                    let i18nVarRef;
                    if (i18nVarRefsCache.has(attr.i18n)) {
                        i18nVarRef = i18nVarRefsCache.get(attr.i18n);
                    }
                    else {
                        i18nVarRef = this.i18nTranslate(attr.i18n);
                        i18nVarRefsCache.set(attr.i18n, i18nVarRef);
                    }
                    attrExprs.push(literal(attr.name), i18nVarRef);
                }
                else {
                    attrExprs.push(...getAttributeNameLiterals(attr.name), trustedConstAttribute(elementName, attr));
                }
            }
            // Keep ngProjectAs next to the other name, value pairs so we can verify that we match
            // ngProjectAs marker in the attribute name slot.
            if (ngProjectAsAttr) {
                attrExprs.push(...getNgProjectAsLiteral(ngProjectAsAttr));
            }
            function addAttrExpr(key, value) {
                if (typeof key === 'string') {
                    if (!alreadySeen.has(key)) {
                        attrExprs.push(...getAttributeNameLiterals(key));
                        value !== undefined && attrExprs.push(value);
                        alreadySeen.add(key);
                    }
                }
                else {
                    attrExprs.push(literal(key));
                }
            }
            // it's important that this occurs before BINDINGS and TEMPLATE because once `elementStart`
            // comes across the BINDINGS or TEMPLATE markers then it will continue reading each value as
            // as single property value cell by cell.
            if (styles) {
                styles.populateInitialStylingAttrs(attrExprs);
            }
            if (inputs.length || outputs.length) {
                const attrsLengthBeforeInputs = attrExprs.length;
                for (let i = 0; i < inputs.length; i++) {
                    const input = inputs[i];
                    // We don't want the animation and attribute bindings in the
                    // attributes array since they aren't used for directive matching.
                    if (input.type !== 4 /* Animation */ && input.type !== 1 /* Attribute */) {
                        addAttrExpr(input.name);
                    }
                }
                for (let i = 0; i < outputs.length; i++) {
                    const output = outputs[i];
                    if (output.type !== 1 /* Animation */) {
                        addAttrExpr(output.name);
                    }
                }
                // this is a cheap way of adding the marker only after all the input/output
                // values have been filtered (by not including the animation ones) and added
                // to the expressions. The marker is important because it tells the runtime
                // code that this is where attributes without values start...
                if (attrExprs.length !== attrsLengthBeforeInputs) {
                    attrExprs.splice(attrsLengthBeforeInputs, 0, literal(3 /* Bindings */));
                }
            }
            if (templateAttrs.length) {
                attrExprs.push(literal(4 /* Template */));
                templateAttrs.forEach(attr => addAttrExpr(attr.name));
            }
            if (boundI18nAttrs.length) {
                attrExprs.push(literal(6 /* I18n */));
                boundI18nAttrs.forEach(attr => addAttrExpr(attr.name));
            }
            return attrExprs;
        }
        addToConsts(expression) {
            if (isNull(expression)) {
                return TYPED_NULL_EXPR;
            }
            const consts = this._constants.constExpressions;
            // Try to reuse a literal that's already in the array, if possible.
            for (let i = 0; i < consts.length; i++) {
                if (consts[i].isEquivalent(expression)) {
                    return literal(i);
                }
            }
            return literal(consts.push(expression) - 1);
        }
        addAttrsToConsts(attrs) {
            return attrs.length > 0 ? this.addToConsts(literalArr(attrs)) : TYPED_NULL_EXPR;
        }
        prepareRefsArray(references) {
            if (!references || references.length === 0) {
                return TYPED_NULL_EXPR;
            }
            const refsParam = flatten(references.map(reference => {
                const slot = this.allocateDataSlot();
                // Generate the update temporary.
                const variableName = this._bindingScope.freshReferenceName();
                const retrievalLevel = this.level;
                const lhs = variable(variableName);
                this._bindingScope.set(retrievalLevel, reference.name, lhs, 0 /* DEFAULT */, (scope, relativeLevel) => {
                    // e.g. nextContext(2);
                    const nextContextStmt = relativeLevel > 0 ? [generateNextContextExpr(relativeLevel).toStmt()] : [];
                    // e.g. const $foo$ = reference(1);
                    const refExpr = lhs.set(importExpr(Identifiers.reference).callFn([literal(slot)]));
                    return nextContextStmt.concat(refExpr.toConstDecl());
                }, true);
                return [reference.name, reference.value];
            }));
            return asLiteral(refsParam);
        }
        prepareListenerParameter(tagName, outputAst, index) {
            return () => {
                const eventName = outputAst.name;
                const bindingFnName = outputAst.type === 1 /* Animation */ ?
                    // synthetic @listener.foo values are treated the exact same as are standard listeners
                    prepareSyntheticListenerFunctionName(eventName, outputAst.phase) :
                    sanitizeIdentifier(eventName);
                const handlerName = `${this.templateName}_${tagName}_${bindingFnName}_${index}_listener`;
                const scope = this._bindingScope.nestedScope(this._bindingScope.bindingLevel, EVENT_BINDING_SCOPE_GLOBALS);
                return prepareEventListenerParameters(outputAst, handlerName, scope);
            };
        }
    }
    class ValueConverter extends AstMemoryEfficientTransformer {
        constructor(constantPool, allocateSlot, allocatePureFunctionSlots, definePipe) {
            super();
            this.constantPool = constantPool;
            this.allocateSlot = allocateSlot;
            this.allocatePureFunctionSlots = allocatePureFunctionSlots;
            this.definePipe = definePipe;
            this._pipeBindExprs = [];
        }
        // AstMemoryEfficientTransformer
        visitPipe(pipe, context) {
            // Allocate a slot to create the pipe
            const slot = this.allocateSlot();
            const slotPseudoLocal = `PIPE:${slot}`;
            // Allocate one slot for the result plus one slot per pipe argument
            const pureFunctionSlot = this.allocatePureFunctionSlots(2 + pipe.args.length);
            const target = new PropertyRead(pipe.span, pipe.sourceSpan, pipe.nameSpan, new ImplicitReceiver(pipe.span, pipe.sourceSpan), slotPseudoLocal);
            const { identifier, isVarLength } = pipeBindingCallInfo(pipe.args);
            this.definePipe(pipe.name, slotPseudoLocal, slot, importExpr(identifier));
            const args = [pipe.exp, ...pipe.args];
            const convertedArgs = isVarLength ?
                this.visitAll([new LiteralArray(pipe.span, pipe.sourceSpan, args)]) :
                this.visitAll(args);
            const pipeBindExpr = new FunctionCall(pipe.span, pipe.sourceSpan, target, [
                new LiteralPrimitive(pipe.span, pipe.sourceSpan, slot),
                new LiteralPrimitive(pipe.span, pipe.sourceSpan, pureFunctionSlot),
                ...convertedArgs,
            ]);
            this._pipeBindExprs.push(pipeBindExpr);
            return pipeBindExpr;
        }
        updatePipeSlotOffsets(bindingSlots) {
            this._pipeBindExprs.forEach((pipe) => {
                // update the slot offset arg (index 1) to account for binding slots
                const slotOffset = pipe.args[1];
                slotOffset.value += bindingSlots;
            });
        }
        visitLiteralArray(array, context) {
            return new BuiltinFunctionCall(array.span, array.sourceSpan, this.visitAll(array.expressions), values => {
                // If the literal has calculated (non-literal) elements transform it into
                // calls to literal factories that compose the literal and will cache intermediate
                // values.
                const literal = literalArr(values);
                return getLiteralFactory(this.constantPool, literal, this.allocatePureFunctionSlots);
            });
        }
        visitLiteralMap(map, context) {
            return new BuiltinFunctionCall(map.span, map.sourceSpan, this.visitAll(map.values), values => {
                // If the literal has calculated (non-literal) elements  transform it into
                // calls to literal factories that compose the literal and will cache intermediate
                // values.
                const literal = literalMap(values.map((value, index) => ({ key: map.keys[index].key, value, quoted: map.keys[index].quoted })));
                return getLiteralFactory(this.constantPool, literal, this.allocatePureFunctionSlots);
            });
        }
    }
    // Pipes always have at least one parameter, the value they operate on
    const pipeBindingIdentifiers = [Identifiers.pipeBind1, Identifiers.pipeBind2, Identifiers.pipeBind3, Identifiers.pipeBind4];
    function pipeBindingCallInfo(args) {
        const identifier = pipeBindingIdentifiers[args.length];
        return {
            identifier: identifier || Identifiers.pipeBindV,
            isVarLength: !identifier,
        };
    }
    const pureFunctionIdentifiers = [
        Identifiers.pureFunction0, Identifiers.pureFunction1, Identifiers.pureFunction2, Identifiers.pureFunction3, Identifiers.pureFunction4,
        Identifiers.pureFunction5, Identifiers.pureFunction6, Identifiers.pureFunction7, Identifiers.pureFunction8
    ];
    function pureFunctionCallInfo(args) {
        const identifier = pureFunctionIdentifiers[args.length];
        return {
            identifier: identifier || Identifiers.pureFunctionV,
            isVarLength: !identifier,
        };
    }
    function instruction(span, reference, params) {
        return importExpr(reference, null, span).callFn(params, span);
    }
    // e.g. x(2);
    function generateNextContextExpr(relativeLevelDiff) {
        return importExpr(Identifiers.nextContext)
            .callFn(relativeLevelDiff > 1 ? [literal(relativeLevelDiff)] : []);
    }
    function getLiteralFactory(constantPool, literal$1, allocateSlots) {
        const { literalFactory, literalFactoryArguments } = constantPool.getLiteralFactory(literal$1);
        // Allocate 1 slot for the result plus 1 per argument
        const startSlot = allocateSlots(1 + literalFactoryArguments.length);
        const { identifier, isVarLength } = pureFunctionCallInfo(literalFactoryArguments);
        // Literal factories are pure functions that only need to be re-invoked when the parameters
        // change.
        const args = [literal(startSlot), literalFactory];
        if (isVarLength) {
            args.push(literalArr(literalFactoryArguments));
        }
        else {
            args.push(...literalFactoryArguments);
        }
        return importExpr(identifier).callFn(args);
    }
    /**
     * Gets an array of literals that can be added to an expression
     * to represent the name and namespace of an attribute. E.g.
     * `:xlink:href` turns into `[AttributeMarker.NamespaceURI, 'xlink', 'href']`.
     *
     * @param name Name of the attribute, including the namespace.
     */
    function getAttributeNameLiterals(name) {
        const [attributeNamespace, attributeName] = splitNsName(name);
        const nameLiteral = literal(attributeName);
        if (attributeNamespace) {
            return [
                literal(0 /* NamespaceURI */), literal(attributeNamespace), nameLiteral
            ];
        }
        return [nameLiteral];
    }
    /** The prefix used to get a shared context in BindingScope's map. */
    const SHARED_CONTEXT_KEY = '$$shared_ctx$$';
    class BindingScope {
        constructor(bindingLevel = 0, parent = null, globals) {
            this.bindingLevel = bindingLevel;
            this.parent = parent;
            this.globals = globals;
            /** Keeps a map from local variables to their BindingData. */
            this.map = new Map();
            this.referenceNameIndex = 0;
            this.restoreViewVariable = null;
            this.usesRestoredViewContext = false;
            if (globals !== undefined) {
                for (const name of globals) {
                    this.set(0, name, variable(name));
                }
            }
        }
        static createRootScope() {
            return new BindingScope();
        }
        get(name) {
            let current = this;
            while (current) {
                let value = current.map.get(name);
                if (value != null) {
                    if (current !== this) {
                        // make a local copy and reset the `declare` state
                        value = {
                            retrievalLevel: value.retrievalLevel,
                            lhs: value.lhs,
                            declareLocalCallback: value.declareLocalCallback,
                            declare: false,
                            priority: value.priority
                        };
                        // Cache the value locally.
                        this.map.set(name, value);
                        // Possibly generate a shared context var
                        this.maybeGenerateSharedContextVar(value);
                        this.maybeRestoreView();
                    }
                    if (value.declareLocalCallback && !value.declare) {
                        value.declare = true;
                    }
                    return value.lhs;
                }
                current = current.parent;
            }
            // If we get to this point, we are looking for a property on the top level component
            // - If level === 0, we are on the top and don't need to re-declare `ctx`.
            // - If level > 0, we are in an embedded view. We need to retrieve the name of the
            // local var we used to store the component context, e.g. const $comp$ = x();
            return this.bindingLevel === 0 ? null : this.getComponentProperty(name);
        }
        /**
         * Create a local variable for later reference.
         *
         * @param retrievalLevel The level from which this value can be retrieved
         * @param name Name of the variable.
         * @param lhs AST representing the left hand side of the `let lhs = rhs;`.
         * @param priority The sorting priority of this var
         * @param declareLocalCallback The callback to invoke when declaring this local var
         * @param localRef Whether or not this is a local ref
         */
        set(retrievalLevel, name, lhs, priority = 0 /* DEFAULT */, declareLocalCallback, localRef) {
            if (this.map.has(name)) {
                if (localRef) {
                    // Do not throw an error if it's a local ref and do not update existing value,
                    // so the first defined ref is always returned.
                    return this;
                }
                error(`The name ${name} is already defined in scope to be ${this.map.get(name)}`);
            }
            this.map.set(name, {
                retrievalLevel: retrievalLevel,
                lhs: lhs,
                declare: false,
                declareLocalCallback: declareLocalCallback,
                priority: priority,
            });
            return this;
        }
        // Implemented as part of LocalResolver.
        getLocal(name) {
            return this.get(name);
        }
        // Implemented as part of LocalResolver.
        notifyImplicitReceiverUse() {
            if (this.bindingLevel !== 0) {
                // Since the implicit receiver is accessed in an embedded view, we need to
                // ensure that we declare a shared context variable for the current template
                // in the update variables.
                this.map.get(SHARED_CONTEXT_KEY + 0).declare = true;
            }
        }
        nestedScope(level, globals) {
            const newScope = new BindingScope(level, this, globals);
            if (level > 0)
                newScope.generateSharedContextVar(0);
            return newScope;
        }
        /**
         * Gets or creates a shared context variable and returns its expression. Note that
         * this does not mean that the shared variable will be declared. Variables in the
         * binding scope will be only declared if they are used.
         */
        getOrCreateSharedContextVar(retrievalLevel) {
            const bindingKey = SHARED_CONTEXT_KEY + retrievalLevel;
            if (!this.map.has(bindingKey)) {
                this.generateSharedContextVar(retrievalLevel);
            }
            // Shared context variables are always generated as "ReadVarExpr".
            return this.map.get(bindingKey).lhs;
        }
        getSharedContextName(retrievalLevel) {
            const sharedCtxObj = this.map.get(SHARED_CONTEXT_KEY + retrievalLevel);
            // Shared context variables are always generated as "ReadVarExpr".
            return sharedCtxObj && sharedCtxObj.declare ? sharedCtxObj.lhs : null;
        }
        maybeGenerateSharedContextVar(value) {
            if (value.priority === 1 /* CONTEXT */ &&
                value.retrievalLevel < this.bindingLevel) {
                const sharedCtxObj = this.map.get(SHARED_CONTEXT_KEY + value.retrievalLevel);
                if (sharedCtxObj) {
                    sharedCtxObj.declare = true;
                }
                else {
                    this.generateSharedContextVar(value.retrievalLevel);
                }
            }
        }
        generateSharedContextVar(retrievalLevel) {
            const lhs = variable(CONTEXT_NAME + this.freshReferenceName());
            this.map.set(SHARED_CONTEXT_KEY + retrievalLevel, {
                retrievalLevel: retrievalLevel,
                lhs: lhs,
                declareLocalCallback: (scope, relativeLevel) => {
                    // const ctx_r0 = nextContext(2);
                    return [lhs.set(generateNextContextExpr(relativeLevel)).toConstDecl()];
                },
                declare: false,
                priority: 2 /* SHARED_CONTEXT */,
            });
        }
        getComponentProperty(name) {
            const componentValue = this.map.get(SHARED_CONTEXT_KEY + 0);
            componentValue.declare = true;
            this.maybeRestoreView();
            return componentValue.lhs.prop(name);
        }
        maybeRestoreView() {
            // View restoration is required for listener instructions inside embedded views, because
            // they only run in creation mode and they can have references to the context object.
            // If the context object changes in update mode, the reference will be incorrect, because
            // it was established during creation.
            if (this.isListenerScope()) {
                if (!this.parent.restoreViewVariable) {
                    // parent saves variable to generate a shared `const $s$ = getCurrentView();` instruction
                    this.parent.restoreViewVariable = variable(this.parent.freshReferenceName());
                }
                this.restoreViewVariable = this.parent.restoreViewVariable;
            }
        }
        restoreViewStatement() {
            const statements = [];
            if (this.restoreViewVariable) {
                const restoreCall = instruction(null, Identifiers.restoreView, [this.restoreViewVariable]);
                // Either `const restoredCtx = restoreView($state$);` or `restoreView($state$);`
                // depending on whether it is being used.
                statements.push(this.usesRestoredViewContext ?
                    variable(RESTORED_VIEW_CONTEXT_NAME).set(restoreCall).toConstDecl() :
                    restoreCall.toStmt());
            }
            return statements;
        }
        viewSnapshotStatements() {
            // const $state$ = getCurrentView();
            return this.restoreViewVariable ?
                [this.restoreViewVariable.set(instruction(null, Identifiers.getCurrentView, [])).toConstDecl()] :
                [];
        }
        isListenerScope() {
            return this.parent && this.parent.bindingLevel === this.bindingLevel;
        }
        variableDeclarations() {
            let currentContextLevel = 0;
            return Array.from(this.map.values())
                .filter(value => value.declare)
                .sort((a, b) => b.retrievalLevel - a.retrievalLevel || b.priority - a.priority)
                .reduce((stmts, value) => {
                const levelDiff = this.bindingLevel - value.retrievalLevel;
                const currStmts = value.declareLocalCallback(this, levelDiff - currentContextLevel);
                currentContextLevel = levelDiff;
                return stmts.concat(currStmts);
            }, []);
        }
        freshReferenceName() {
            let current = this;
            // Find the top scope as it maintains the global reference count
            while (current.parent)
                current = current.parent;
            const ref = `${REFERENCE_PREFIX}${current.referenceNameIndex++}`;
            return ref;
        }
        hasRestoreViewVariable() {
            return !!this.restoreViewVariable;
        }
        notifyRestoredViewContextUse() {
            this.usesRestoredViewContext = true;
        }
    }
    /**
     * Creates a `CssSelector` given a tag name and a map of attributes
     */
    function createCssSelector(elementName, attributes) {
        const cssSelector = new CssSelector();
        const elementNameNoNs = splitNsName(elementName)[1];
        cssSelector.setElement(elementNameNoNs);
        Object.getOwnPropertyNames(attributes).forEach((name) => {
            const nameNoNs = splitNsName(name)[1];
            const value = attributes[name];
            cssSelector.addAttribute(nameNoNs, value);
            if (name.toLowerCase() === 'class') {
                const classes = value.trim().split(/\s+/);
                classes.forEach(className => cssSelector.addClassName(className));
            }
        });
        return cssSelector;
    }
    /**
     * Creates an array of expressions out of an `ngProjectAs` attributes
     * which can be added to the instruction parameters.
     */
    function getNgProjectAsLiteral(attribute) {
        // Parse the attribute value into a CssSelectorList. Note that we only take the
        // first selector, because we don't support multiple selectors in ngProjectAs.
        const parsedR3Selector = parseSelectorToR3Selector(attribute.value)[0];
        return [literal(5 /* ProjectAs */), asLiteral(parsedR3Selector)];
    }
    /**
     * Gets the instruction to generate for an interpolated property
     * @param interpolation An Interpolation AST
     */
    function getPropertyInterpolationExpression(interpolation) {
        switch (getInterpolationArgsLength(interpolation)) {
            case 1:
                return Identifiers.propertyInterpolate;
            case 3:
                return Identifiers.propertyInterpolate1;
            case 5:
                return Identifiers.propertyInterpolate2;
            case 7:
                return Identifiers.propertyInterpolate3;
            case 9:
                return Identifiers.propertyInterpolate4;
            case 11:
                return Identifiers.propertyInterpolate5;
            case 13:
                return Identifiers.propertyInterpolate6;
            case 15:
                return Identifiers.propertyInterpolate7;
            case 17:
                return Identifiers.propertyInterpolate8;
            default:
                return Identifiers.propertyInterpolateV;
        }
    }
    /**
     * Gets the instruction to generate for an interpolated attribute
     * @param interpolation An Interpolation AST
     */
    function getAttributeInterpolationExpression(interpolation) {
        switch (getInterpolationArgsLength(interpolation)) {
            case 3:
                return Identifiers.attributeInterpolate1;
            case 5:
                return Identifiers.attributeInterpolate2;
            case 7:
                return Identifiers.attributeInterpolate3;
            case 9:
                return Identifiers.attributeInterpolate4;
            case 11:
                return Identifiers.attributeInterpolate5;
            case 13:
                return Identifiers.attributeInterpolate6;
            case 15:
                return Identifiers.attributeInterpolate7;
            case 17:
                return Identifiers.attributeInterpolate8;
            default:
                return Identifiers.attributeInterpolateV;
        }
    }
    /**
     * Gets the instruction to generate for interpolated text.
     * @param interpolation An Interpolation AST
     */
    function getTextInterpolationExpression(interpolation) {
        switch (getInterpolationArgsLength(interpolation)) {
            case 1:
                return Identifiers.textInterpolate;
            case 3:
                return Identifiers.textInterpolate1;
            case 5:
                return Identifiers.textInterpolate2;
            case 7:
                return Identifiers.textInterpolate3;
            case 9:
                return Identifiers.textInterpolate4;
            case 11:
                return Identifiers.textInterpolate5;
            case 13:
                return Identifiers.textInterpolate6;
            case 15:
                return Identifiers.textInterpolate7;
            case 17:
                return Identifiers.textInterpolate8;
            default:
                return Identifiers.textInterpolateV;
        }
    }
    /**
     * Parse a template into render3 `Node`s and additional metadata, with no other dependencies.
     *
     * @param template text of the template to parse
     * @param templateUrl URL to use for source mapping of the parsed template
     * @param options options to modify how the template is parsed
     */
    function parseTemplate(template, templateUrl, options = {}) {
        const { interpolationConfig, preserveWhitespaces, enableI18nLegacyMessageIdFormat } = options;
        const bindingParser = makeBindingParser(interpolationConfig);
        const htmlParser = new HtmlParser();
        const parseResult = htmlParser.parse(template, templateUrl, Object.assign(Object.assign({ leadingTriviaChars: LEADING_TRIVIA_CHARS }, options), { tokenizeExpansionForms: true }));
        if (!options.alwaysAttemptHtmlToR3AstConversion && parseResult.errors &&
            parseResult.errors.length > 0) {
            const parsedTemplate = {
                interpolationConfig,
                preserveWhitespaces,
                errors: parseResult.errors,
                nodes: [],
                styleUrls: [],
                styles: [],
                ngContentSelectors: []
            };
            if (options.collectCommentNodes) {
                parsedTemplate.commentNodes = [];
            }
            return parsedTemplate;
        }
        let rootNodes = parseResult.rootNodes;
        // process i18n meta information (scan attributes, generate ids)
        // before we run whitespace removal process, because existing i18n
        // extraction process (ng extract-i18n) relies on a raw content to generate
        // message ids
        const i18nMetaVisitor = new I18nMetaVisitor(interpolationConfig, /* keepI18nAttrs */ !preserveWhitespaces, enableI18nLegacyMessageIdFormat);
        const i18nMetaResult = i18nMetaVisitor.visitAllWithErrors(rootNodes);
        if (!options.alwaysAttemptHtmlToR3AstConversion && i18nMetaResult.errors &&
            i18nMetaResult.errors.length > 0) {
            const parsedTemplate = {
                interpolationConfig,
                preserveWhitespaces,
                errors: i18nMetaResult.errors,
                nodes: [],
                styleUrls: [],
                styles: [],
                ngContentSelectors: []
            };
            if (options.collectCommentNodes) {
                parsedTemplate.commentNodes = [];
            }
            return parsedTemplate;
        }
        rootNodes = i18nMetaResult.rootNodes;
        if (!preserveWhitespaces) {
            rootNodes = visitAll$1(new WhitespaceVisitor(), rootNodes);
            // run i18n meta visitor again in case whitespaces are removed (because that might affect
            // generated i18n message content) and first pass indicated that i18n content is present in a
            // template. During this pass i18n IDs generated at the first pass will be preserved, so we can
            // mimic existing extraction process (ng extract-i18n)
            if (i18nMetaVisitor.hasI18nMeta) {
                rootNodes = visitAll$1(new I18nMetaVisitor(interpolationConfig, /* keepI18nAttrs */ false), rootNodes);
            }
        }
        const { nodes, errors, styleUrls, styles, ngContentSelectors, commentNodes } = htmlAstToRender3Ast(rootNodes, bindingParser, { collectCommentNodes: !!options.collectCommentNodes });
        errors.push(...parseResult.errors, ...i18nMetaResult.errors);
        const parsedTemplate = {
            interpolationConfig,
            preserveWhitespaces,
            errors: errors.length > 0 ? errors : null,
            nodes,
            styleUrls,
            styles,
            ngContentSelectors
        };
        if (options.collectCommentNodes) {
            parsedTemplate.commentNodes = commentNodes;
        }
        return parsedTemplate;
    }
    const elementRegistry = new DomElementSchemaRegistry();
    /**
     * Construct a `BindingParser` with a default configuration.
     */
    function makeBindingParser(interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {
        return new BindingParser(new IvyParser(new Lexer()), interpolationConfig, elementRegistry, null, []);
    }
    function resolveSanitizationFn(context, isAttribute) {
        switch (context) {
            case SecurityContext.HTML:
                return importExpr(Identifiers.sanitizeHtml);
            case SecurityContext.SCRIPT:
                return importExpr(Identifiers.sanitizeScript);
            case SecurityContext.STYLE:
                // the compiler does not fill in an instruction for [style.prop?] binding
                // values because the style algorithm knows internally what props are subject
                // to sanitization (only [attr.style] values are explicitly sanitized)
                return isAttribute ? importExpr(Identifiers.sanitizeStyle) : null;
            case SecurityContext.URL:
                return importExpr(Identifiers.sanitizeUrl);
            case SecurityContext.RESOURCE_URL:
                return importExpr(Identifiers.sanitizeResourceUrl);
            default:
                return null;
        }
    }
    function trustedConstAttribute(tagName, attr) {
        const value = asLiteral(attr.value);
        if (isTrustedTypesSink(tagName, attr.name)) {
            switch (elementRegistry.securityContext(tagName, attr.name, /* isAttribute */ true)) {
                case SecurityContext.HTML:
                    return taggedTemplate(importExpr(Identifiers.trustConstantHtml), new TemplateLiteral([new TemplateLiteralElement(attr.value)], []), undefined, attr.valueSpan);
                // NB: no SecurityContext.SCRIPT here, as the corresponding tags are stripped by the compiler.
                case SecurityContext.RESOURCE_URL:
                    return taggedTemplate(importExpr(Identifiers.trustConstantResourceUrl), new TemplateLiteral([new TemplateLiteralElement(attr.value)], []), undefined, attr.valueSpan);
                default:
                    return value;
            }
        }
        else {
            return value;
        }
    }
    function isSingleElementTemplate(children) {
        return children.length === 1 && children[0] instanceof Element;
    }
    function isTextNode(node) {
        return node instanceof Text || node instanceof BoundText || node instanceof Icu;
    }
    function hasTextChildrenOnly(children) {
        return children.every(isTextNode);
    }
    /** Name of the global variable that is used to determine if we use Closure translations or not */
    const NG_I18N_CLOSURE_MODE = 'ngI18nClosureMode';
    /**
     * Generate statements that define a given translation message.
     *
     * ```
     * var I18N_1;
     * if (typeof ngI18nClosureMode !== undefined && ngI18nClosureMode) {
     *     var MSG_EXTERNAL_XXX = goog.getMsg(
     *          "Some message with {$interpolation}!",
     *          { "interpolation": "\uFFFD0\uFFFD" }
     *     );
     *     I18N_1 = MSG_EXTERNAL_XXX;
     * }
     * else {
     *     I18N_1 = $localize`Some message with ${'\uFFFD0\uFFFD'}!`;
     * }
     * ```
     *
     * @param message The original i18n AST message node
     * @param variable The variable that will be assigned the translation, e.g. `I18N_1`.
     * @param closureVar The variable for Closure `goog.getMsg` calls, e.g. `MSG_EXTERNAL_XXX`.
     * @param params Object mapping placeholder names to their values (e.g.
     * `{ "interpolation": "\uFFFD0\uFFFD" }`).
     * @param transformFn Optional transformation function that will be applied to the translation (e.g.
     * post-processing).
     * @returns An array of statements that defined a given translation.
     */
    function getTranslationDeclStmts(message, variable, closureVar, params = {}, transformFn) {
        const statements = [
            declareI18nVariable(variable),
            ifStmt(createClosureModeGuard(), createGoogleGetMsgStatements(variable, message, closureVar, i18nFormatPlaceholderNames(params, /* useCamelCase */ true)), createLocalizeStatements(variable, message, i18nFormatPlaceholderNames(params, /* useCamelCase */ false))),
        ];
        if (transformFn) {
            statements.push(new ExpressionStatement(variable.set(transformFn(variable))));
        }
        return statements;
    }
    /**
     * Create the expression that will be used to guard the closure mode block
     * It is equivalent to:
     *
     * ```
     * typeof ngI18nClosureMode !== undefined && ngI18nClosureMode
     * ```
     */
    function createClosureModeGuard() {
        return typeofExpr(variable(NG_I18N_CLOSURE_MODE))
            .notIdentical(literal('undefined', STRING_TYPE))
            .and(variable(NG_I18N_CLOSURE_MODE));
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    // This regex matches any binding names that contain the "attr." prefix, e.g. "attr.required"
    // If there is a match, the first matching group will contain the attribute name to bind.
    const ATTR_REGEX = /attr\.([^\]]+)/;
    function baseDirectiveFields(meta, constantPool, bindingParser) {
        const definitionMap = new DefinitionMap();
        const selectors = parseSelectorToR3Selector(meta.selector);
        // e.g. `type: MyDirective`
        definitionMap.set('type', meta.internalType);
        // e.g. `selectors: [['', 'someDir', '']]`
        if (selectors.length > 0) {
            definitionMap.set('selectors', asLiteral(selectors));
        }
        if (meta.queries.length > 0) {
            // e.g. `contentQueries: (rf, ctx, dirIndex) => { ... }
            definitionMap.set('contentQueries', createContentQueriesFunction(meta.queries, constantPool, meta.name));
        }
        if (meta.viewQueries.length) {
            definitionMap.set('viewQuery', createViewQueriesFunction(meta.viewQueries, constantPool, meta.name));
        }
        // e.g. `hostBindings: (rf, ctx) => { ... }
        definitionMap.set('hostBindings', createHostBindingsFunction(meta.host, meta.typeSourceSpan, bindingParser, constantPool, meta.selector || '', meta.name, definitionMap));
        // e.g 'inputs: {a: 'a'}`
        definitionMap.set('inputs', conditionallyCreateMapObjectLiteral(meta.inputs, true));
        // e.g 'outputs: {a: 'a'}`
        definitionMap.set('outputs', conditionallyCreateMapObjectLiteral(meta.outputs));
        if (meta.exportAs !== null) {
            definitionMap.set('exportAs', literalArr(meta.exportAs.map(e => literal(e))));
        }
        return definitionMap;
    }
    /**
     * Add features to the definition map.
     */
    function addFeatures(definitionMap, meta) {
        // e.g. `features: [NgOnChangesFeature]`
        const features = [];
        const providers = meta.providers;
        const viewProviders = meta.viewProviders;
        if (providers || viewProviders) {
            const args = [providers || new LiteralArrayExpr([])];
            if (viewProviders) {
                args.push(viewProviders);
            }
            features.push(importExpr(Identifiers.ProvidersFeature).callFn(args));
        }
        if (meta.usesInheritance) {
            features.push(importExpr(Identifiers.InheritDefinitionFeature));
        }
        if (meta.fullInheritance) {
            features.push(importExpr(Identifiers.CopyDefinitionFeature));
        }
        if (meta.lifecycle.usesOnChanges) {
            features.push(importExpr(Identifiers.NgOnChangesFeature));
        }
        if (features.length) {
            definitionMap.set('features', literalArr(features));
        }
    }
    /**
     * Compile a directive for the render3 runtime as defined by the `R3DirectiveMetadata`.
     */
    function compileDirectiveFromMetadata(meta, constantPool, bindingParser) {
        const definitionMap = baseDirectiveFields(meta, constantPool, bindingParser);
        addFeatures(definitionMap, meta);
        const expression = importExpr(Identifiers.defineDirective).callFn([definitionMap.toLiteralMap()], undefined, true);
        const type = createDirectiveType(meta);
        return { expression, type, statements: [] };
    }
    /**
     * Compile a component for the render3 runtime as defined by the `R3ComponentMetadata`.
     */
    function compileComponentFromMetadata(meta, constantPool, bindingParser) {
        const definitionMap = baseDirectiveFields(meta, constantPool, bindingParser);
        addFeatures(definitionMap, meta);
        const selector = meta.selector && CssSelector.parse(meta.selector);
        const firstSelector = selector && selector[0];
        // e.g. `attr: ["class", ".my.app"]`
        // This is optional an only included if the first selector of a component specifies attributes.
        if (firstSelector) {
            const selectorAttributes = firstSelector.getAttrs();
            if (selectorAttributes.length) {
                definitionMap.set('attrs', constantPool.getConstLiteral(literalArr(selectorAttributes.map(value => value != null ? literal(value) : literal(undefined))), 
                /* forceShared */ true));
            }
        }
        // Generate the CSS matcher that recognize directive
        let directiveMatcher = null;
        if (meta.directives.length > 0) {
            const matcher = new SelectorMatcher();
            for (const { selector, type } of meta.directives) {
                matcher.addSelectables(CssSelector.parse(selector), type);
            }
            directiveMatcher = matcher;
        }
        // e.g. `template: function MyComponent_Template(_ctx, _cm) {...}`
        const templateTypeName = meta.name;
        const templateName = templateTypeName ? `${templateTypeName}_Template` : null;
        const directivesUsed = new Set();
        const pipesUsed = new Set();
        const changeDetection = meta.changeDetection;
        const template = meta.template;
        const templateBuilder = new TemplateDefinitionBuilder(constantPool, BindingScope.createRootScope(), 0, templateTypeName, null, null, templateName, directiveMatcher, directivesUsed, meta.pipes, pipesUsed, Identifiers.namespaceHTML, meta.relativeContextFilePath, meta.i18nUseExternalIds);
        const templateFunctionExpression = templateBuilder.buildTemplateFunction(template.nodes, []);
        // We need to provide this so that dynamically generated components know what
        // projected content blocks to pass through to the component when it is instantiated.
        const ngContentSelectors = templateBuilder.getNgContentSelectors();
        if (ngContentSelectors) {
            definitionMap.set('ngContentSelectors', ngContentSelectors);
        }
        // e.g. `decls: 2`
        definitionMap.set('decls', literal(templateBuilder.getConstCount()));
        // e.g. `vars: 2`
        definitionMap.set('vars', literal(templateBuilder.getVarCount()));
        // Generate `consts` section of ComponentDef:
        // - either as an array:
        //   `consts: [['one', 'two'], ['three', 'four']]`
        // - or as a factory function in case additional statements are present (to support i18n):
        //   `consts: function() { var i18n_0; if (ngI18nClosureMode) {...} else {...} return [i18n_0]; }`
        const { constExpressions, prepareStatements } = templateBuilder.getConsts();
        if (constExpressions.length > 0) {
            let constsExpr = literalArr(constExpressions);
            // Prepare statements are present - turn `consts` into a function.
            if (prepareStatements.length > 0) {
                constsExpr = fn([], [...prepareStatements, new ReturnStatement(constsExpr)]);
            }
            definitionMap.set('consts', constsExpr);
        }
        definitionMap.set('template', templateFunctionExpression);
        // e.g. `directives: [MyDirective]`
        if (directivesUsed.size) {
            const directivesList = literalArr(Array.from(directivesUsed));
            const directivesExpr = compileDeclarationList(directivesList, meta.declarationListEmitMode);
            definitionMap.set('directives', directivesExpr);
        }
        // e.g. `pipes: [MyPipe]`
        if (pipesUsed.size) {
            const pipesList = literalArr(Array.from(pipesUsed));
            const pipesExpr = compileDeclarationList(pipesList, meta.declarationListEmitMode);
            definitionMap.set('pipes', pipesExpr);
        }
        if (meta.encapsulation === null) {
            meta.encapsulation = ViewEncapsulation.Emulated;
        }
        // e.g. `styles: [str1, str2]`
        if (meta.styles && meta.styles.length) {
            const styleValues = meta.encapsulation == ViewEncapsulation.Emulated ?
                compileStyles(meta.styles, CONTENT_ATTR, HOST_ATTR) :
                meta.styles;
            const strings = styleValues.map(str => constantPool.getConstLiteral(literal(str)));
            definitionMap.set('styles', literalArr(strings));
        }
        else if (meta.encapsulation === ViewEncapsulation.Emulated) {
            // If there is no style, don't generate css selectors on elements
            meta.encapsulation = ViewEncapsulation.None;
        }
        // Only set view encapsulation if it's not the default value
        if (meta.encapsulation !== ViewEncapsulation.Emulated) {
            definitionMap.set('encapsulation', literal(meta.encapsulation));
        }
        // e.g. `animation: [trigger('123', [])]`
        if (meta.animations !== null) {
            definitionMap.set('data', literalMap([{ key: 'animation', value: meta.animations, quoted: false }]));
        }
        // Only set the change detection flag if it's defined and it's not the default.
        if (changeDetection != null && changeDetection !== ChangeDetectionStrategy.Default) {
            definitionMap.set('changeDetection', literal(changeDetection));
        }
        const expression = importExpr(Identifiers.defineComponent).callFn([definitionMap.toLiteralMap()], undefined, true);
        const type = createComponentType(meta);
        return { expression, type, statements: [] };
    }
    /**
     * Creates the type specification from the component meta. This type is inserted into .d.ts files
     * to be consumed by upstream compilations.
     */
    function createComponentType(meta) {
        const typeParams = createDirectiveTypeParams(meta);
        typeParams.push(stringArrayAsType(meta.template.ngContentSelectors));
        return expressionType(importExpr(Identifiers.ComponentDeclaration, typeParams));
    }
    /**
     * Compiles the array literal of declarations into an expression according to the provided emit
     * mode.
     */
    function compileDeclarationList(list, mode) {
        switch (mode) {
            case 0 /* Direct */:
                // directives: [MyDir],
                return list;
            case 1 /* Closure */:
                // directives: function () { return [MyDir]; }
                return fn([], [new ReturnStatement(list)]);
            case 2 /* ClosureResolved */:
                // directives: function () { return [MyDir].map(ng.resolveForwardRef); }
                const resolvedList = list.callMethod('map', [importExpr(Identifiers.resolveForwardRef)]);
                return fn([], [new ReturnStatement(resolvedList)]);
        }
    }
    function prepareQueryParams(query, constantPool) {
        const parameters = [getQueryPredicate(query, constantPool), literal(toQueryFlags(query))];
        if (query.read) {
            parameters.push(query.read);
        }
        return parameters;
    }
    /**
     * Translates query flags into `TQueryFlags` type in packages/core/src/render3/interfaces/query.ts
     * @param query
     */
    function toQueryFlags(query) {
        return (query.descendants ? 1 /* descendants */ : 0 /* none */) |
            (query.static ? 2 /* isStatic */ : 0 /* none */) |
            (query.emitDistinctChangesOnly ? 4 /* emitDistinctChangesOnly */ : 0 /* none */);
    }
    function convertAttributesToExpressions(attributes) {
        const values = [];
        for (let key of Object.getOwnPropertyNames(attributes)) {
            const value = attributes[key];
            values.push(literal(key), value);
        }
        return values;
    }
    // Define and update any content queries
    function createContentQueriesFunction(queries, constantPool, name) {
        const createStatements = [];
        const updateStatements = [];
        const tempAllocator = temporaryAllocator(updateStatements, TEMPORARY_NAME);
        for (const query of queries) {
            // creation, e.g. r3.contentQuery(dirIndex, somePredicate, true, null);
            createStatements.push(importExpr(Identifiers.contentQuery)
                .callFn([variable('dirIndex'), ...prepareQueryParams(query, constantPool)])
                .toStmt());
            // update, e.g. (r3.queryRefresh(tmp = r3.loadQuery()) && (ctx.someDir = tmp));
            const temporary = tempAllocator();
            const getQueryList = importExpr(Identifiers.loadQuery).callFn([]);
            const refresh = importExpr(Identifiers.queryRefresh).callFn([temporary.set(getQueryList)]);
            const updateDirective = variable(CONTEXT_NAME)
                .prop(query.propertyName)
                .set(query.first ? temporary.prop('first') : temporary);
            updateStatements.push(refresh.and(updateDirective).toStmt());
        }
        const contentQueriesFnName = name ? `${name}_ContentQueries` : null;
        return fn([
            new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null),
            new FnParam('dirIndex', null)
        ], [
            renderFlagCheckIfStmt(1 /* Create */, createStatements),
            renderFlagCheckIfStmt(2 /* Update */, updateStatements)
        ], INFERRED_TYPE, null, contentQueriesFnName);
    }
    function stringAsType(str) {
        return expressionType(literal(str));
    }
    function stringMapAsType(map) {
        const mapValues = Object.keys(map).map(key => {
            const value = Array.isArray(map[key]) ? map[key][0] : map[key];
            return {
                key,
                value: literal(value),
                quoted: true,
            };
        });
        return expressionType(literalMap(mapValues));
    }
    function stringArrayAsType(arr) {
        return arr.length > 0 ? expressionType(literalArr(arr.map(value => literal(value)))) :
            NONE_TYPE;
    }
    function createDirectiveTypeParams(meta) {
        // On the type side, remove newlines from the selector as it will need to fit into a TypeScript
        // string literal, which must be on one line.
        const selectorForType = meta.selector !== null ? meta.selector.replace(/\n/g, '') : null;
        return [
            typeWithParameters(meta.type.type, meta.typeArgumentCount),
            selectorForType !== null ? stringAsType(selectorForType) : NONE_TYPE,
            meta.exportAs !== null ? stringArrayAsType(meta.exportAs) : NONE_TYPE,
            stringMapAsType(meta.inputs),
            stringMapAsType(meta.outputs),
            stringArrayAsType(meta.queries.map(q => q.propertyName)),
        ];
    }
    /**
     * Creates the type specification from the directive meta. This type is inserted into .d.ts files
     * to be consumed by upstream compilations.
     */
    function createDirectiveType(meta) {
        const typeParams = createDirectiveTypeParams(meta);
        return expressionType(importExpr(Identifiers.DirectiveDeclaration, typeParams));
    }
    // Define and update any view queries
    function createViewQueriesFunction(viewQueries, constantPool, name) {
        const createStatements = [];
        const updateStatements = [];
        const tempAllocator = temporaryAllocator(updateStatements, TEMPORARY_NAME);
        viewQueries.forEach((query) => {
            // creation, e.g. r3.viewQuery(somePredicate, true);
            const queryDefinition = importExpr(Identifiers.viewQuery).callFn(prepareQueryParams(query, constantPool));
            createStatements.push(queryDefinition.toStmt());
            // update, e.g. (r3.queryRefresh(tmp = r3.loadQuery()) && (ctx.someDir = tmp));
            const temporary = tempAllocator();
            const getQueryList = importExpr(Identifiers.loadQuery).callFn([]);
            const refresh = importExpr(Identifiers.queryRefresh).callFn([temporary.set(getQueryList)]);
            const updateDirective = variable(CONTEXT_NAME)
                .prop(query.propertyName)
                .set(query.first ? temporary.prop('first') : temporary);
            updateStatements.push(refresh.and(updateDirective).toStmt());
        });
        const viewQueryFnName = name ? `${name}_Query` : null;
        return fn([new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null)], [
            renderFlagCheckIfStmt(1 /* Create */, createStatements),
            renderFlagCheckIfStmt(2 /* Update */, updateStatements)
        ], INFERRED_TYPE, null, viewQueryFnName);
    }
    // Return a host binding function or null if one is not necessary.
    function createHostBindingsFunction(hostBindingsMetadata, typeSourceSpan, bindingParser, constantPool, selector, name, definitionMap) {
        const bindingContext = variable(CONTEXT_NAME);
        const styleBuilder = new StylingBuilder(bindingContext);
        const { styleAttr, classAttr } = hostBindingsMetadata.specialAttributes;
        if (styleAttr !== undefined) {
            styleBuilder.registerStyleAttr(styleAttr);
        }
        if (classAttr !== undefined) {
            styleBuilder.registerClassAttr(classAttr);
        }
        const createStatements = [];
        const updateStatements = [];
        const hostBindingSourceSpan = typeSourceSpan;
        const directiveSummary = metadataAsSummary(hostBindingsMetadata);
        // Calculate host event bindings
        const eventBindings = bindingParser.createDirectiveHostEventAsts(directiveSummary, hostBindingSourceSpan);
        if (eventBindings && eventBindings.length) {
            const listeners = createHostListeners(eventBindings, name);
            createStatements.push(...listeners);
        }
        // Calculate the host property bindings
        const bindings = bindingParser.createBoundHostProperties(directiveSummary, hostBindingSourceSpan);
        const allOtherBindings = [];
        // We need to calculate the total amount of binding slots required by
        // all the instructions together before any value conversions happen.
        // Value conversions may require additional slots for interpolation and
        // bindings with pipes. These calculates happen after this block.
        let totalHostVarsCount = 0;
        bindings && bindings.forEach((binding) => {
            const stylingInputWasSet = styleBuilder.registerInputBasedOnName(binding.name, binding.expression, hostBindingSourceSpan);
            if (stylingInputWasSet) {
                totalHostVarsCount += MIN_STYLING_BINDING_SLOTS_REQUIRED;
            }
            else {
                allOtherBindings.push(binding);
                totalHostVarsCount++;
            }
        });
        let valueConverter;
        const getValueConverter = () => {
            if (!valueConverter) {
                const hostVarsCountFn = (numSlots) => {
                    const originalVarsCount = totalHostVarsCount;
                    totalHostVarsCount += numSlots;
                    return originalVarsCount;
                };
                valueConverter = new ValueConverter(constantPool, () => error('Unexpected node'), // new nodes are illegal here
                hostVarsCountFn, () => error('Unexpected pipe')); // pipes are illegal here
            }
            return valueConverter;
        };
        const propertyBindings = [];
        const attributeBindings = [];
        const syntheticHostBindings = [];
        allOtherBindings.forEach((binding) => {
            // resolve literal arrays and literal objects
            const value = binding.expression.visit(getValueConverter());
            const bindingExpr = bindingFn(bindingContext, value);
            const { bindingName, instruction, isAttribute } = getBindingNameAndInstruction(binding);
            const securityContexts = bindingParser.calcPossibleSecurityContexts(selector, bindingName, isAttribute)
                .filter(context => context !== SecurityContext.NONE);
            let sanitizerFn = null;
            if (securityContexts.length) {
                if (securityContexts.length === 2 &&
                    securityContexts.indexOf(SecurityContext.URL) > -1 &&
                    securityContexts.indexOf(SecurityContext.RESOURCE_URL) > -1) {
                    // Special case for some URL attributes (such as "src" and "href") that may be a part
                    // of different security contexts. In this case we use special sanitization function and
                    // select the actual sanitizer at runtime based on a tag name that is provided while
                    // invoking sanitization function.
                    sanitizerFn = importExpr(Identifiers.sanitizeUrlOrResourceUrl);
                }
                else {
                    sanitizerFn = resolveSanitizationFn(securityContexts[0], isAttribute);
                }
            }
            const instructionParams = [literal(bindingName), bindingExpr.currValExpr];
            if (sanitizerFn) {
                instructionParams.push(sanitizerFn);
            }
            updateStatements.push(...bindingExpr.stmts);
            if (instruction === Identifiers.hostProperty) {
                propertyBindings.push(instructionParams);
            }
            else if (instruction === Identifiers.attribute) {
                attributeBindings.push(instructionParams);
            }
            else if (instruction === Identifiers.syntheticHostProperty) {
                syntheticHostBindings.push(instructionParams);
            }
            else {
                updateStatements.push(importExpr(instruction).callFn(instructionParams).toStmt());
            }
        });
        if (propertyBindings.length > 0) {
            updateStatements.push(chainedInstruction(Identifiers.hostProperty, propertyBindings).toStmt());
        }
        if (attributeBindings.length > 0) {
            updateStatements.push(chainedInstruction(Identifiers.attribute, attributeBindings).toStmt());
        }
        if (syntheticHostBindings.length > 0) {
            updateStatements.push(chainedInstruction(Identifiers.syntheticHostProperty, syntheticHostBindings).toStmt());
        }
        // since we're dealing with directives/components and both have hostBinding
        // functions, we need to generate a special hostAttrs instruction that deals
        // with both the assignment of styling as well as static attributes to the host
        // element. The instruction below will instruct all initial styling (styling
        // that is inside of a host binding within a directive/component) to be attached
        // to the host element alongside any of the provided host attributes that were
        // collected earlier.
        const hostAttrs = convertAttributesToExpressions(hostBindingsMetadata.attributes);
        styleBuilder.assignHostAttrs(hostAttrs, definitionMap);
        if (styleBuilder.hasBindings) {
            // finally each binding that was registered in the statement above will need to be added to
            // the update block of a component/directive templateFn/hostBindingsFn so that the bindings
            // are evaluated and updated for the element.
            styleBuilder.buildUpdateLevelInstructions(getValueConverter()).forEach(instruction => {
                if (instruction.calls.length > 0) {
                    const calls = [];
                    instruction.calls.forEach(call => {
                        // we subtract a value of `1` here because the binding slot was already allocated
                        // at the top of this method when all the input bindings were counted.
                        totalHostVarsCount +=
                            Math.max(call.allocateBindingSlots - MIN_STYLING_BINDING_SLOTS_REQUIRED, 0);
                        calls.push(convertStylingCall(call, bindingContext, bindingFn));
                    });
                    updateStatements.push(chainedInstruction(instruction.reference, calls).toStmt());
                }
            });
        }
        if (totalHostVarsCount) {
            definitionMap.set('hostVars', literal(totalHostVarsCount));
        }
        if (createStatements.length > 0 || updateStatements.length > 0) {
            const hostBindingsFnName = name ? `${name}_HostBindings` : null;
            const statements = [];
            if (createStatements.length > 0) {
                statements.push(renderFlagCheckIfStmt(1 /* Create */, createStatements));
            }
            if (updateStatements.length > 0) {
                statements.push(renderFlagCheckIfStmt(2 /* Update */, updateStatements));
            }
            return fn([new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null)], statements, INFERRED_TYPE, null, hostBindingsFnName);
        }
        return null;
    }
    function bindingFn(implicit, value) {
        return convertPropertyBinding(null, implicit, value, 'b', BindingForm.Expression, () => error('Unexpected interpolation'));
    }
    function convertStylingCall(call, bindingContext, bindingFn) {
        return call.params(value => bindingFn(bindingContext, value).currValExpr);
    }
    function getBindingNameAndInstruction(binding) {
        let bindingName = binding.name;
        let instruction;
        // Check to see if this is an attr binding or a property binding
        const attrMatches = bindingName.match(ATTR_REGEX);
        if (attrMatches) {
            bindingName = attrMatches[1];
            instruction = Identifiers.attribute;
        }
        else {
            if (binding.isAnimation) {
                bindingName = prepareSyntheticPropertyName(bindingName);
                // host bindings that have a synthetic property (e.g. @foo) should always be rendered
                // in the context of the component and not the parent. Therefore there is a special
                // compatibility instruction available for this purpose.
                instruction = Identifiers.syntheticHostProperty;
            }
            else {
                instruction = Identifiers.hostProperty;
            }
        }
        return { bindingName, instruction, isAttribute: !!attrMatches };
    }
    function createHostListeners(eventBindings, name) {
        const listeners = [];
        const syntheticListeners = [];
        const instructions = [];
        eventBindings.forEach(binding => {
            let bindingName = binding.name && sanitizeIdentifier(binding.name);
            const bindingFnName = binding.type === 1 /* Animation */ ?
                prepareSyntheticListenerFunctionName(bindingName, binding.targetOrPhase) :
                bindingName;
            const handlerName = name && bindingName ? `${name}_${bindingFnName}_HostBindingHandler` : null;
            const params = prepareEventListenerParameters(BoundEvent.fromParsedEvent(binding), handlerName);
            if (binding.type == 1 /* Animation */) {
                syntheticListeners.push(params);
            }
            else {
                listeners.push(params);
            }
        });
        if (syntheticListeners.length > 0) {
            instructions.push(chainedInstruction(Identifiers.syntheticHostListener, syntheticListeners).toStmt());
        }
        if (listeners.length > 0) {
            instructions.push(chainedInstruction(Identifiers.listener, listeners).toStmt());
        }
        return instructions;
    }
    function metadataAsSummary(meta) {
        // clang-format off
        return {
            // This is used by the BindingParser, which only deals with listeners and properties. There's no
            // need to pass attributes to it.
            hostAttributes: {},
            hostListeners: meta.listeners,
            hostProperties: meta.properties,
        };
        // clang-format on
    }
    const HOST_REG_EXP = /^(?:\[([^\]]+)\])|(?:\(([^\)]+)\))$/;
    function parseHostBindings(host) {
        const attributes = {};
        const listeners = {};
        const properties = {};
        const specialAttributes = {};
        for (const key of Object.keys(host)) {
            const value = host[key];
            const matches = key.match(HOST_REG_EXP);
            if (matches === null) {
                switch (key) {
                    case 'class':
                        if (typeof value !== 'string') {
                            // TODO(alxhub): make this a diagnostic.
                            throw new Error(`Class binding must be string`);
                        }
                        specialAttributes.classAttr = value;
                        break;
                    case 'style':
                        if (typeof value !== 'string') {
                            // TODO(alxhub): make this a diagnostic.
                            throw new Error(`Style binding must be string`);
                        }
                        specialAttributes.styleAttr = value;
                        break;
                    default:
                        if (typeof value === 'string') {
                            attributes[key] = literal(value);
                        }
                        else {
                            attributes[key] = value;
                        }
                }
            }
            else if (matches[1 /* Binding */] != null) {
                if (typeof value !== 'string') {
                    // TODO(alxhub): make this a diagnostic.
                    throw new Error(`Property binding must be string`);
                }
                // synthetic properties (the ones that have a `@` as a prefix)
                // are still treated the same as regular properties. Therefore
                // there is no point in storing them in a separate map.
                properties[matches[1 /* Binding */]] = value;
            }
            else if (matches[2 /* Event */] != null) {
                if (typeof value !== 'string') {
                    // TODO(alxhub): make this a diagnostic.
                    throw new Error(`Event binding must be string`);
                }
                listeners[matches[2 /* Event */]] = value;
            }
        }
        return { attributes, listeners, properties, specialAttributes };
    }
    /**
     * Verifies host bindings and returns the list of errors (if any). Empty array indicates that a
     * given set of host bindings has no errors.
     *
     * @param bindings set of host bindings to verify.
     * @param sourceSpan source span where host bindings were defined.
     * @returns array of errors associated with a given set of host bindings.
     */
    function verifyHostBindings(bindings, sourceSpan) {
        const summary = metadataAsSummary(bindings);
        // TODO: abstract out host bindings verification logic and use it instead of
        // creating events and properties ASTs to detect errors (FW-996)
        const bindingParser = makeBindingParser();
        bindingParser.createDirectiveHostEventAsts(summary, sourceSpan);
        bindingParser.createBoundHostProperties(summary, sourceSpan);
        return bindingParser.errors;
    }
    function compileStyles(styles, selector, hostSelector) {
        const shadowCss = new ShadowCss();
        return styles.map(style => {
            return shadowCss.shimCssText(style, selector, hostSelector);
        });
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * An interface for retrieving documents by URL that the compiler uses to
     * load templates.
     *
     * This is an abstract class, rather than an interface, so that it can be used
     * as injection token.
     */
    class ResourceLoader {
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class CompilerFacadeImpl {
        constructor(jitEvaluator = new JitEvaluator()) {
            this.jitEvaluator = jitEvaluator;
            this.FactoryTarget = FactoryTarget;
            this.ResourceLoader = ResourceLoader;
            this.elementSchemaRegistry = new DomElementSchemaRegistry();
        }
        compilePipe(angularCoreEnv, sourceMapUrl, facade) {
            const metadata = {
                name: facade.name,
                type: wrapReference(facade.type),
                internalType: new WrappedNodeExpr(facade.type),
                typeArgumentCount: 0,
                deps: null,
                pipeName: facade.pipeName,
                pure: facade.pure,
            };
            const res = compilePipeFromMetadata(metadata);
            return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);
        }
        compilePipeDeclaration(angularCoreEnv, sourceMapUrl, declaration) {
            const meta = convertDeclarePipeFacadeToMetadata(declaration);
            const res = compilePipeFromMetadata(meta);
            return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);
        }
        compileInjectable(angularCoreEnv, sourceMapUrl, facade) {
            var _a;
            const { expression, statements } = compileInjectable({
                name: facade.name,
                type: wrapReference(facade.type),
                internalType: new WrappedNodeExpr(facade.type),
                typeArgumentCount: facade.typeArgumentCount,
                providedIn: computeProvidedIn(facade.providedIn),
                useClass: convertToProviderExpression(facade, USE_CLASS),
                useFactory: wrapExpression(facade, USE_FACTORY),
                useValue: convertToProviderExpression(facade, USE_VALUE),
                useExisting: convertToProviderExpression(facade, USE_EXISTING),
                deps: (_a = facade.deps) === null || _a === void 0 ? void 0 : _a.map(convertR3DependencyMetadata),
            }, 
            /* resolveForwardRefs */ true);
            return this.jitExpression(expression, angularCoreEnv, sourceMapUrl, statements);
        }
        compileInjectableDeclaration(angularCoreEnv, sourceMapUrl, facade) {
            var _a;
            const { expression, statements } = compileInjectable({
                name: facade.type.name,
                type: wrapReference(facade.type),
                internalType: new WrappedNodeExpr(facade.type),
                typeArgumentCount: 0,
                providedIn: computeProvidedIn(facade.providedIn),
                useClass: convertToProviderExpression(facade, USE_CLASS),
                useFactory: wrapExpression(facade, USE_FACTORY),
                useValue: convertToProviderExpression(facade, USE_VALUE),
                useExisting: convertToProviderExpression(facade, USE_EXISTING),
                deps: (_a = facade.deps) === null || _a === void 0 ? void 0 : _a.map(convertR3DeclareDependencyMetadata),
            }, 
            /* resolveForwardRefs */ true);
            return this.jitExpression(expression, angularCoreEnv, sourceMapUrl, statements);
        }
        compileInjector(angularCoreEnv, sourceMapUrl, facade) {
            const meta = {
                name: facade.name,
                type: wrapReference(facade.type),
                internalType: new WrappedNodeExpr(facade.type),
                providers: new WrappedNodeExpr(facade.providers),
                imports: facade.imports.map(i => new WrappedNodeExpr(i)),
            };
            const res = compileInjector(meta);
            return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);
        }
        compileInjectorDeclaration(angularCoreEnv, sourceMapUrl, declaration) {
            const meta = convertDeclareInjectorFacadeToMetadata(declaration);
            const res = compileInjector(meta);
            return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);
        }
        compileNgModule(angularCoreEnv, sourceMapUrl, facade) {
            const meta = {
                type: wrapReference(facade.type),
                internalType: new WrappedNodeExpr(facade.type),
                adjacentType: new WrappedNodeExpr(facade.type),
                bootstrap: facade.bootstrap.map(wrapReference),
                declarations: facade.declarations.map(wrapReference),
                imports: facade.imports.map(wrapReference),
                exports: facade.exports.map(wrapReference),
                emitInline: true,
                containsForwardDecls: false,
                schemas: facade.schemas ? facade.schemas.map(wrapReference) : null,
                id: facade.id ? new WrappedNodeExpr(facade.id) : null,
            };
            const res = compileNgModule(meta);
            return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);
        }
        compileNgModuleDeclaration(angularCoreEnv, sourceMapUrl, declaration) {
            const expression = compileNgModuleDeclarationExpression(declaration);
            return this.jitExpression(expression, angularCoreEnv, sourceMapUrl, []);
        }
        compileDirective(angularCoreEnv, sourceMapUrl, facade) {
            const meta = convertDirectiveFacadeToMetadata(facade);
            return this.compileDirectiveFromMeta(angularCoreEnv, sourceMapUrl, meta);
        }
        compileDirectiveDeclaration(angularCoreEnv, sourceMapUrl, declaration) {
            const typeSourceSpan = this.createParseSourceSpan('Directive', declaration.type.name, sourceMapUrl);
            const meta = convertDeclareDirectiveFacadeToMetadata(declaration, typeSourceSpan);
            return this.compileDirectiveFromMeta(angularCoreEnv, sourceMapUrl, meta);
        }
        compileDirectiveFromMeta(angularCoreEnv, sourceMapUrl, meta) {
            const constantPool = new ConstantPool();
            const bindingParser = makeBindingParser();
            const res = compileDirectiveFromMetadata(meta, constantPool, bindingParser);
            return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, constantPool.statements);
        }
        compileComponent(angularCoreEnv, sourceMapUrl, facade) {
            // Parse the template and check for errors.
            const { template, interpolation } = parseJitTemplate(facade.template, facade.name, sourceMapUrl, facade.preserveWhitespaces, facade.interpolation);
            // Compile the component metadata, including template, into an expression.
            const meta = Object.assign(Object.assign(Object.assign({}, facade), convertDirectiveFacadeToMetadata(facade)), { selector: facade.selector || this.elementSchemaRegistry.getDefaultComponentElementName(), template, declarationListEmitMode: 0 /* Direct */, styles: [...facade.styles, ...template.styles], encapsulation: facade.encapsulation, interpolation, changeDetection: facade.changeDetection, animations: facade.animations != null ? new WrappedNodeExpr(facade.animations) : null, viewProviders: facade.viewProviders != null ? new WrappedNodeExpr(facade.viewProviders) :
                    null, relativeContextFilePath: '', i18nUseExternalIds: true });
            const jitExpressionSourceMap = `ng:///${facade.name}.js`;
            return this.compileComponentFromMeta(angularCoreEnv, jitExpressionSourceMap, meta);
        }
        compileComponentDeclaration(angularCoreEnv, sourceMapUrl, declaration) {
            const typeSourceSpan = this.createParseSourceSpan('Component', declaration.type.name, sourceMapUrl);
            const meta = convertDeclareComponentFacadeToMetadata(declaration, typeSourceSpan, sourceMapUrl);
            return this.compileComponentFromMeta(angularCoreEnv, sourceMapUrl, meta);
        }
        compileComponentFromMeta(angularCoreEnv, sourceMapUrl, meta) {
            const constantPool = new ConstantPool();
            const bindingParser = makeBindingParser(meta.interpolation);
            const res = compileComponentFromMetadata(meta, constantPool, bindingParser);
            return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, constantPool.statements);
        }
        compileFactory(angularCoreEnv, sourceMapUrl, meta) {
            const factoryRes = compileFactoryFunction({
                name: meta.name,
                type: wrapReference(meta.type),
                internalType: new WrappedNodeExpr(meta.type),
                typeArgumentCount: meta.typeArgumentCount,
                deps: convertR3DependencyMetadataArray(meta.deps),
                target: meta.target,
            });
            return this.jitExpression(factoryRes.expression, angularCoreEnv, sourceMapUrl, factoryRes.statements);
        }
        compileFactoryDeclaration(angularCoreEnv, sourceMapUrl, meta) {
            const factoryRes = compileFactoryFunction({
                name: meta.type.name,
                type: wrapReference(meta.type),
                internalType: new WrappedNodeExpr(meta.type),
                typeArgumentCount: 0,
                deps: Array.isArray(meta.deps) ? meta.deps.map(convertR3DeclareDependencyMetadata) :
                    meta.deps,
                target: meta.target,
            });
            return this.jitExpression(factoryRes.expression, angularCoreEnv, sourceMapUrl, factoryRes.statements);
        }
        createParseSourceSpan(kind, typeName, sourceUrl) {
            return r3JitTypeSourceSpan(kind, typeName, sourceUrl);
        }
        /**
         * JIT compiles an expression and returns the result of executing that expression.
         *
         * @param def the definition which will be compiled and executed to get the value to patch
         * @param context an object map of @angular/core symbol names to symbols which will be available
         * in the context of the compiled expression
         * @param sourceUrl a URL to use for the source map of the compiled expression
         * @param preStatements a collection of statements that should be evaluated before the expression.
         */
        jitExpression(def, context, sourceUrl, preStatements) {
            // The ConstantPool may contain Statements which declare variables used in the final expression.
            // Therefore, its statements need to precede the actual JIT operation. The final statement is a
            // declaration of $def which is set to the expression being compiled.
            const statements = [
                ...preStatements,
                new DeclareVarStmt('$def', def, undefined, [StmtModifier.Exported]),
            ];
            const res = this.jitEvaluator.evaluateStatements(sourceUrl, statements, new R3JitReflector(context), /* enableSourceMaps */ true);
            return res['$def'];
        }
    }
    const USE_CLASS = Object.keys({ useClass: null })[0];
    const USE_FACTORY = Object.keys({ useFactory: null })[0];
    const USE_VALUE = Object.keys({ useValue: null })[0];
    const USE_EXISTING = Object.keys({ useExisting: null })[0];
    function convertToR3QueryMetadata(facade) {
        return Object.assign(Object.assign({}, facade), { predicate: Array.isArray(facade.predicate) ? facade.predicate :
                new WrappedNodeExpr(facade.predicate), read: facade.read ? new WrappedNodeExpr(facade.read) : null, static: facade.static, emitDistinctChangesOnly: facade.emitDistinctChangesOnly });
    }
    function convertQueryDeclarationToMetadata(declaration) {
        var _a, _b, _c, _d;
        return {
            propertyName: declaration.propertyName,
            first: (_a = declaration.first) !== null && _a !== void 0 ? _a : false,
            predicate: Array.isArray(declaration.predicate) ? declaration.predicate :
                new WrappedNodeExpr(declaration.predicate),
            descendants: (_b = declaration.descendants) !== null && _b !== void 0 ? _b : false,
            read: declaration.read ? new WrappedNodeExpr(declaration.read) : null,
            static: (_c = declaration.static) !== null && _c !== void 0 ? _c : false,
            emitDistinctChangesOnly: (_d = declaration.emitDistinctChangesOnly) !== null && _d !== void 0 ? _d : true,
        };
    }
    function convertDirectiveFacadeToMetadata(facade) {
        const inputsFromMetadata = parseInputOutputs(facade.inputs || []);
        const outputsFromMetadata = parseInputOutputs(facade.outputs || []);
        const propMetadata = facade.propMetadata;
        const inputsFromType = {};
        const outputsFromType = {};
        for (const field in propMetadata) {
            if (propMetadata.hasOwnProperty(field)) {
                propMetadata[field].forEach(ann => {
                    if (isInput(ann)) {
                        inputsFromType[field] =
                            ann.bindingPropertyName ? [ann.bindingPropertyName, field] : field;
                    }
                    else if (isOutput(ann)) {
                        outputsFromType[field] = ann.bindingPropertyName || field;
                    }
                });
            }
        }
        return Object.assign(Object.assign({}, facade), { typeArgumentCount: 0, typeSourceSpan: facade.typeSourceSpan, type: wrapReference(facade.type), internalType: new WrappedNodeExpr(facade.type), deps: null, host: extractHostBindings(facade.propMetadata, facade.typeSourceSpan, facade.host), inputs: Object.assign(Object.assign({}, inputsFromMetadata), inputsFromType), outputs: Object.assign(Object.assign({}, outputsFromMetadata), outputsFromType), queries: facade.queries.map(convertToR3QueryMetadata), providers: facade.providers != null ? new WrappedNodeExpr(facade.providers) : null, viewQueries: facade.viewQueries.map(convertToR3QueryMetadata), fullInheritance: false });
    }
    function convertDeclareDirectiveFacadeToMetadata(declaration, typeSourceSpan) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        return {
            name: declaration.type.name,
            type: wrapReference(declaration.type),
            typeSourceSpan,
            internalType: new WrappedNodeExpr(declaration.type),
            selector: (_a = declaration.selector) !== null && _a !== void 0 ? _a : null,
            inputs: (_b = declaration.inputs) !== null && _b !== void 0 ? _b : {},
            outputs: (_c = declaration.outputs) !== null && _c !== void 0 ? _c : {},
            host: convertHostDeclarationToMetadata(declaration.host),
            queries: ((_d = declaration.queries) !== null && _d !== void 0 ? _d : []).map(convertQueryDeclarationToMetadata),
            viewQueries: ((_e = declaration.viewQueries) !== null && _e !== void 0 ? _e : []).map(convertQueryDeclarationToMetadata),
            providers: declaration.providers !== undefined ? new WrappedNodeExpr(declaration.providers) :
                null,
            exportAs: (_f = declaration.exportAs) !== null && _f !== void 0 ? _f : null,
            usesInheritance: (_g = declaration.usesInheritance) !== null && _g !== void 0 ? _g : false,
            lifecycle: { usesOnChanges: (_h = declaration.usesOnChanges) !== null && _h !== void 0 ? _h : false },
            deps: null,
            typeArgumentCount: 0,
            fullInheritance: false,
        };
    }
    function convertHostDeclarationToMetadata(host = {}) {
        var _a, _b, _c;
        return {
            attributes: convertOpaqueValuesToExpressions((_a = host.attributes) !== null && _a !== void 0 ? _a : {}),
            listeners: (_b = host.listeners) !== null && _b !== void 0 ? _b : {},
            properties: (_c = host.properties) !== null && _c !== void 0 ? _c : {},
            specialAttributes: {
                classAttr: host.classAttribute,
                styleAttr: host.styleAttribute,
            },
        };
    }
    function convertOpaqueValuesToExpressions(obj) {
        const result = {};
        for (const key of Object.keys(obj)) {
            result[key] = new WrappedNodeExpr(obj[key]);
        }
        return result;
    }
    function convertDeclareComponentFacadeToMetadata(declaration, typeSourceSpan, sourceMapUrl) {
        var _a, _b, _c, _d, _e, _f;
        const { template, interpolation } = parseJitTemplate(declaration.template, declaration.type.name, sourceMapUrl, (_a = declaration.preserveWhitespaces) !== null && _a !== void 0 ? _a : false, declaration.interpolation);
        return Object.assign(Object.assign({}, convertDeclareDirectiveFacadeToMetadata(declaration, typeSourceSpan)), { template, styles: (_b = declaration.styles) !== null && _b !== void 0 ? _b : [], directives: ((_c = declaration.components) !== null && _c !== void 0 ? _c : [])
                .concat((_d = declaration.directives) !== null && _d !== void 0 ? _d : [])
                .map(convertUsedDirectiveDeclarationToMetadata), pipes: convertUsedPipesToMetadata(declaration.pipes), viewProviders: declaration.viewProviders !== undefined ?
                new WrappedNodeExpr(declaration.viewProviders) :
                null, animations: declaration.animations !== undefined ? new WrappedNodeExpr(declaration.animations) :
                null, changeDetection: (_e = declaration.changeDetection) !== null && _e !== void 0 ? _e : ChangeDetectionStrategy.Default, encapsulation: (_f = declaration.encapsulation) !== null && _f !== void 0 ? _f : ViewEncapsulation.Emulated, interpolation, declarationListEmitMode: 2 /* ClosureResolved */, relativeContextFilePath: '', i18nUseExternalIds: true });
    }
    function convertUsedDirectiveDeclarationToMetadata(declaration) {
        var _a, _b, _c;
        return {
            selector: declaration.selector,
            type: new WrappedNodeExpr(declaration.type),
            inputs: (_a = declaration.inputs) !== null && _a !== void 0 ? _a : [],
            outputs: (_b = declaration.outputs) !== null && _b !== void 0 ? _b : [],
            exportAs: (_c = declaration.exportAs) !== null && _c !== void 0 ? _c : null,
        };
    }
    function convertUsedPipesToMetadata(declaredPipes) {
        const pipes = new Map();
        if (declaredPipes === undefined) {
            return pipes;
        }
        for (const pipeName of Object.keys(declaredPipes)) {
            const pipeType = declaredPipes[pipeName];
            pipes.set(pipeName, new WrappedNodeExpr(pipeType));
        }
        return pipes;
    }
    function parseJitTemplate(template, typeName, sourceMapUrl, preserveWhitespaces, interpolation) {
        const interpolationConfig = interpolation ? InterpolationConfig.fromArray(interpolation) : DEFAULT_INTERPOLATION_CONFIG;
        // Parse the template and check for errors.
        const parsed = parseTemplate(template, sourceMapUrl, { preserveWhitespaces: preserveWhitespaces, interpolationConfig });
        if (parsed.errors !== null) {
            const errors = parsed.errors.map(err => err.toString()).join(', ');
            throw new Error(`Errors during JIT compilation of template for ${typeName}: ${errors}`);
        }
        return { template: parsed, interpolation: interpolationConfig };
    }
    /**
     * Convert the expression, if present to an `R3ProviderExpression`.
     *
     * In JIT mode we do not want the compiler to wrap the expression in a `forwardRef()` call because,
     * if it is referencing a type that has not yet been defined, it will have already been wrapped in
     * a `forwardRef()` - either by the application developer or during partial-compilation. Thus we can
     * set `isForwardRef` to `false`.
     */
    function convertToProviderExpression(obj, property) {
        if (obj.hasOwnProperty(property)) {
            return createR3ProviderExpression(new WrappedNodeExpr(obj[property]), /* isForwardRef */ false);
        }
        else {
            return undefined;
        }
    }
    function wrapExpression(obj, property) {
        if (obj.hasOwnProperty(property)) {
            return new WrappedNodeExpr(obj[property]);
        }
        else {
            return undefined;
        }
    }
    function computeProvidedIn(providedIn) {
        const expression = (providedIn == null || typeof providedIn === 'string') ?
            new LiteralExpr(providedIn !== null && providedIn !== void 0 ? providedIn : null) :
            new WrappedNodeExpr(providedIn);
        // See `convertToProviderExpression()` for why `isForwardRef` is false.
        return createR3ProviderExpression(expression, /* isForwardRef */ false);
    }
    function convertR3DependencyMetadataArray(facades) {
        return facades == null ? null : facades.map(convertR3DependencyMetadata);
    }
    function convertR3DependencyMetadata(facade) {
        const isAttributeDep = facade.attribute != null; // both `null` and `undefined`
        const rawToken = facade.token === null ? null : new WrappedNodeExpr(facade.token);
        // In JIT mode, if the dep is an `@Attribute()` then we use the attribute name given in
        // `attribute` rather than the `token`.
        const token = isAttributeDep ? new WrappedNodeExpr(facade.attribute) : rawToken;
        return createR3DependencyMetadata(token, isAttributeDep, facade.host, facade.optional, facade.self, facade.skipSelf);
    }
    function convertR3DeclareDependencyMetadata(facade) {
        var _a, _b, _c, _d, _e;
        const isAttributeDep = (_a = facade.attribute) !== null && _a !== void 0 ? _a : false;
        const token = facade.token === null ? null : new WrappedNodeExpr(facade.token);
        return createR3DependencyMetadata(token, isAttributeDep, (_b = facade.host) !== null && _b !== void 0 ? _b : false, (_c = facade.optional) !== null && _c !== void 0 ? _c : false, (_d = facade.self) !== null && _d !== void 0 ? _d : false, (_e = facade.skipSelf) !== null && _e !== void 0 ? _e : false);
    }
    function createR3DependencyMetadata(token, isAttributeDep, host, optional, self, skipSelf) {
        // If the dep is an `@Attribute()` the `attributeNameType` ought to be the `unknown` type.
        // But types are not available at runtime so we just use a literal `"<unknown>"` string as a dummy
        // marker.
        const attributeNameType = isAttributeDep ? literal('unknown') : null;
        return { token, attributeNameType, host, optional, self, skipSelf };
    }
    function extractHostBindings(propMetadata, sourceSpan, host) {
        // First parse the declarations from the metadata.
        const bindings = parseHostBindings(host || {});
        // After that check host bindings for errors
        const errors = verifyHostBindings(bindings, sourceSpan);
        if (errors.length) {
            throw new Error(errors.map((error) => error.msg).join('\n'));
        }
        // Next, loop over the properties of the object, looking for @HostBinding and @HostListener.
        for (const field in propMetadata) {
            if (propMetadata.hasOwnProperty(field)) {
                propMetadata[field].forEach(ann => {
                    if (isHostBinding(ann)) {
                        // Since this is a decorator, we know that the value is a class member. Always access it
                        // through `this` so that further down the line it can't be confused for a literal value
                        // (e.g. if there's a property called `true`).
                        bindings.properties[ann.hostPropertyName || field] =
                            getSafePropertyAccessString('this', field);
                    }
                    else if (isHostListener(ann)) {
                        bindings.listeners[ann.eventName || field] = `${field}(${(ann.args || []).join(',')})`;
                    }
                });
            }
        }
        return bindings;
    }
    function isHostBinding(value) {
        return value.ngMetadataName === 'HostBinding';
    }
    function isHostListener(value) {
        return value.ngMetadataName === 'HostListener';
    }
    function isInput(value) {
        return value.ngMetadataName === 'Input';
    }
    function isOutput(value) {
        return value.ngMetadataName === 'Output';
    }
    function parseInputOutputs(values) {
        return values.reduce((map, value) => {
            const [field, property] = value.split(',').map(piece => piece.trim());
            map[field] = property || field;
            return map;
        }, {});
    }
    function convertDeclarePipeFacadeToMetadata(declaration) {
        var _a;
        return {
            name: declaration.type.name,
            type: wrapReference(declaration.type),
            internalType: new WrappedNodeExpr(declaration.type),
            typeArgumentCount: 0,
            pipeName: declaration.name,
            deps: null,
            pure: (_a = declaration.pure) !== null && _a !== void 0 ? _a : true,
        };
    }
    function convertDeclareInjectorFacadeToMetadata(declaration) {
        return {
            name: declaration.type.name,
            type: wrapReference(declaration.type),
            internalType: new WrappedNodeExpr(declaration.type),
            providers: declaration.providers !== undefined ? new WrappedNodeExpr(declaration.providers) :
                null,
            imports: declaration.imports !== undefined ?
                declaration.imports.map(i => new WrappedNodeExpr(i)) :
                [],
        };
    }
    function publishFacade(global) {
        const ng = global.ng || (global.ng = {});
        ng.compilerFacade = new CompilerFacadeImpl();
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const VERSION$1 = new Version('12.2.12');

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var _VisitorMode;
    (function (_VisitorMode) {
        _VisitorMode[_VisitorMode["Extract"] = 0] = "Extract";
        _VisitorMode[_VisitorMode["Merge"] = 1] = "Merge";
    })(_VisitorMode || (_VisitorMode = {}));

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var LifecycleHooks;
    (function (LifecycleHooks) {
        LifecycleHooks[LifecycleHooks["OnInit"] = 0] = "OnInit";
        LifecycleHooks[LifecycleHooks["OnDestroy"] = 1] = "OnDestroy";
        LifecycleHooks[LifecycleHooks["DoCheck"] = 2] = "DoCheck";
        LifecycleHooks[LifecycleHooks["OnChanges"] = 3] = "OnChanges";
        LifecycleHooks[LifecycleHooks["AfterContentInit"] = 4] = "AfterContentInit";
        LifecycleHooks[LifecycleHooks["AfterContentChecked"] = 5] = "AfterContentChecked";
        LifecycleHooks[LifecycleHooks["AfterViewInit"] = 6] = "AfterViewInit";
        LifecycleHooks[LifecycleHooks["AfterViewChecked"] = 7] = "AfterViewChecked";
    })(LifecycleHooks || (LifecycleHooks = {}));
    const LIFECYCLE_HOOKS_VALUES = [
        LifecycleHooks.OnInit, LifecycleHooks.OnDestroy, LifecycleHooks.DoCheck, LifecycleHooks.OnChanges,
        LifecycleHooks.AfterContentInit, LifecycleHooks.AfterContentChecked, LifecycleHooks.AfterViewInit,
        LifecycleHooks.AfterViewChecked
    ];

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const LOG_VAR = variable('_l');

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const LOG_VAR$1 = variable('_l');
    const VIEW_VAR = variable('_v');
    const CHECK_VAR = variable('_ck');
    const COMP_VAR = variable('_co');
    const EVENT_NAME_VAR = variable('en');
    const ALLOW_DEFAULT_VAR = variable(`ad`);

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * The index of each URI component in the return value of goog.uri.utils.split.
     * @enum {number}
     */
    var _ComponentIndex;
    (function (_ComponentIndex) {
        _ComponentIndex[_ComponentIndex["Scheme"] = 1] = "Scheme";
        _ComponentIndex[_ComponentIndex["UserInfo"] = 2] = "UserInfo";
        _ComponentIndex[_ComponentIndex["Domain"] = 3] = "Domain";
        _ComponentIndex[_ComponentIndex["Port"] = 4] = "Port";
        _ComponentIndex[_ComponentIndex["Path"] = 5] = "Path";
        _ComponentIndex[_ComponentIndex["QueryData"] = 6] = "QueryData";
        _ComponentIndex[_ComponentIndex["Fragment"] = 7] = "Fragment";
    })(_ComponentIndex || (_ComponentIndex = {}));

    var FactoryTarget$1;
    (function (FactoryTarget) {
        FactoryTarget[FactoryTarget["Directive"] = 0] = "Directive";
        FactoryTarget[FactoryTarget["Component"] = 1] = "Component";
        FactoryTarget[FactoryTarget["Injectable"] = 2] = "Injectable";
        FactoryTarget[FactoryTarget["Pipe"] = 3] = "Pipe";
        FactoryTarget[FactoryTarget["NgModule"] = 4] = "NgModule";
    })(FactoryTarget$1 || (FactoryTarget$1 = {}));

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Processes `Target`s with a given set of directives and performs a binding operation, which
     * returns an object similar to TypeScript's `ts.TypeChecker` that contains knowledge about the
     * target.
     */
    class R3TargetBinder {
        constructor(directiveMatcher) {
            this.directiveMatcher = directiveMatcher;
        }
        /**
         * Perform a binding operation on the given `Target` and return a `BoundTarget` which contains
         * metadata about the types referenced in the template.
         */
        bind(target) {
            if (!target.template) {
                // TODO(alxhub): handle targets which contain things like HostBindings, etc.
                throw new Error('Binding without a template not yet supported');
            }
            // First, parse the template into a `Scope` structure. This operation captures the syntactic
            // scopes in the template and makes them available for later use.
            const scope = Scope.apply(target.template);
            // Use the `Scope` to extract the entities present at every level of the template.
            const templateEntities = extractTemplateEntities(scope);
            // Next, perform directive matching on the template using the `DirectiveBinder`. This returns:
            //   - directives: Map of nodes (elements & ng-templates) to the directives on them.
            //   - bindings: Map of inputs, outputs, and attributes to the directive/element that claims
            //     them. TODO(alxhub): handle multiple directives claiming an input/output/etc.
            //   - references: Map of #references to their targets.
            const { directives, bindings, references } = DirectiveBinder.apply(target.template, this.directiveMatcher);
            // Finally, run the TemplateBinder to bind references, variables, and other entities within the
            // template. This extracts all the metadata that doesn't depend on directive matching.
            const { expressions, symbols, nestingLevel, usedPipes } = TemplateBinder.applyWithScope(target.template, scope);
            return new R3BoundTarget(target, directives, bindings, references, expressions, symbols, nestingLevel, templateEntities, usedPipes);
        }
    }
    /**
     * Represents a binding scope within a template.
     *
     * Any variables, references, or other named entities declared within the template will
     * be captured and available by name in `namedEntities`. Additionally, child templates will
     * be analyzed and have their child `Scope`s available in `childScopes`.
     */
    class Scope {
        constructor(parentScope, template) {
            this.parentScope = parentScope;
            this.template = template;
            /**
             * Named members of the `Scope`, such as `Reference`s or `Variable`s.
             */
            this.namedEntities = new Map();
            /**
             * Child `Scope`s for immediately nested `Template`s.
             */
            this.childScopes = new Map();
        }
        static newRootScope() {
            return new Scope(null, null);
        }
        /**
         * Process a template (either as a `Template` sub-template with variables, or a plain array of
         * template `Node`s) and construct its `Scope`.
         */
        static apply(template) {
            const scope = Scope.newRootScope();
            scope.ingest(template);
            return scope;
        }
        /**
         * Internal method to process the template and populate the `Scope`.
         */
        ingest(template) {
            if (template instanceof Template) {
                // Variables on an <ng-template> are defined in the inner scope.
                template.variables.forEach(node => this.visitVariable(node));
                // Process the nodes of the template.
                template.children.forEach(node => node.visit(this));
            }
            else {
                // No overarching `Template` instance, so process the nodes directly.
                template.forEach(node => node.visit(this));
            }
        }
        visitElement(element) {
            // `Element`s in the template may have `Reference`s which are captured in the scope.
            element.references.forEach(node => this.visitReference(node));
            // Recurse into the `Element`'s children.
            element.children.forEach(node => node.visit(this));
        }
        visitTemplate(template) {
            // References on a <ng-template> are defined in the outer scope, so capture them before
            // processing the template's child scope.
            template.references.forEach(node => this.visitReference(node));
            // Next, create an inner scope and process the template within it.
            const scope = new Scope(this, template);
            scope.ingest(template);
            this.childScopes.set(template, scope);
        }
        visitVariable(variable) {
            // Declare the variable if it's not already.
            this.maybeDeclare(variable);
        }
        visitReference(reference) {
            // Declare the variable if it's not already.
            this.maybeDeclare(reference);
        }
        // Unused visitors.
        visitContent(content) { }
        visitBoundAttribute(attr) { }
        visitBoundEvent(event) { }
        visitBoundText(text) { }
        visitText(text) { }
        visitTextAttribute(attr) { }
        visitIcu(icu) { }
        maybeDeclare(thing) {
            // Declare something with a name, as long as that name isn't taken.
            if (!this.namedEntities.has(thing.name)) {
                this.namedEntities.set(thing.name, thing);
            }
        }
        /**
         * Look up a variable within this `Scope`.
         *
         * This can recurse into a parent `Scope` if it's available.
         */
        lookup(name) {
            if (this.namedEntities.has(name)) {
                // Found in the local scope.
                return this.namedEntities.get(name);
            }
            else if (this.parentScope !== null) {
                // Not in the local scope, but there's a parent scope so check there.
                return this.parentScope.lookup(name);
            }
            else {
                // At the top level and it wasn't found.
                return null;
            }
        }
        /**
         * Get the child scope for a `Template`.
         *
         * This should always be defined.
         */
        getChildScope(template) {
            const res = this.childScopes.get(template);
            if (res === undefined) {
                throw new Error(`Assertion error: child scope for ${template} not found`);
            }
            return res;
        }
    }
    /**
     * Processes a template and matches directives on nodes (elements and templates).
     *
     * Usually used via the static `apply()` method.
     */
    class DirectiveBinder {
        constructor(matcher, directives, bindings, references) {
            this.matcher = matcher;
            this.directives = directives;
            this.bindings = bindings;
            this.references = references;
        }
        /**
         * Process a template (list of `Node`s) and perform directive matching against each node.
         *
         * @param template the list of template `Node`s to match (recursively).
         * @param selectorMatcher a `SelectorMatcher` containing the directives that are in scope for
         * this template.
         * @returns three maps which contain information about directives in the template: the
         * `directives` map which lists directives matched on each node, the `bindings` map which
         * indicates which directives claimed which bindings (inputs, outputs, etc), and the `references`
         * map which resolves #references (`Reference`s) within the template to the named directive or
         * template node.
         */
        static apply(template, selectorMatcher) {
            const directives = new Map();
            const bindings = new Map();
            const references = new Map();
            const matcher = new DirectiveBinder(selectorMatcher, directives, bindings, references);
            matcher.ingest(template);
            return { directives, bindings, references };
        }
        ingest(template) {
            template.forEach(node => node.visit(this));
        }
        visitElement(element) {
            this.visitElementOrTemplate(element.name, element);
        }
        visitTemplate(template) {
            this.visitElementOrTemplate('ng-template', template);
        }
        visitElementOrTemplate(elementName, node) {
            // First, determine the HTML shape of the node for the purpose of directive matching.
            // Do this by building up a `CssSelector` for the node.
            const cssSelector = createCssSelector(elementName, getAttrsForDirectiveMatching(node));
            // Next, use the `SelectorMatcher` to get the list of directives on the node.
            const directives = [];
            this.matcher.match(cssSelector, (_, directive) => directives.push(directive));
            if (directives.length > 0) {
                this.directives.set(node, directives);
            }
            // Resolve any references that are created on this node.
            node.references.forEach(ref => {
                let dirTarget = null;
                // If the reference expression is empty, then it matches the "primary" directive on the node
                // (if there is one). Otherwise it matches the host node itself (either an element or
                // <ng-template> node).
                if (ref.value.trim() === '') {
                    // This could be a reference to a component if there is one.
                    dirTarget = directives.find(dir => dir.isComponent) || null;
                }
                else {
                    // This should be a reference to a directive exported via exportAs.
                    dirTarget =
                        directives.find(dir => dir.exportAs !== null && dir.exportAs.some(value => value === ref.value)) ||
                            null;
                    // Check if a matching directive was found.
                    if (dirTarget === null) {
                        // No matching directive was found - this reference points to an unknown target. Leave it
                        // unmapped.
                        return;
                    }
                }
                if (dirTarget !== null) {
                    // This reference points to a directive.
                    this.references.set(ref, { directive: dirTarget, node });
                }
                else {
                    // This reference points to the node itself.
                    this.references.set(ref, node);
                }
            });
            const setAttributeBinding = (attribute, ioType) => {
                const dir = directives.find(dir => dir[ioType].hasBindingPropertyName(attribute.name));
                const binding = dir !== undefined ? dir : node;
                this.bindings.set(attribute, binding);
            };
            // Node inputs (bound attributes) and text attributes can be bound to an
            // input on a directive.
            node.inputs.forEach(input => setAttributeBinding(input, 'inputs'));
            node.attributes.forEach(attr => setAttributeBinding(attr, 'inputs'));
            if (node instanceof Template) {
                node.templateAttrs.forEach(attr => setAttributeBinding(attr, 'inputs'));
            }
            // Node outputs (bound events) can be bound to an output on a directive.
            node.outputs.forEach(output => setAttributeBinding(output, 'outputs'));
            // Recurse into the node's children.
            node.children.forEach(child => child.visit(this));
        }
        // Unused visitors.
        visitContent(content) { }
        visitVariable(variable) { }
        visitReference(reference) { }
        visitTextAttribute(attribute) { }
        visitBoundAttribute(attribute) { }
        visitBoundEvent(attribute) { }
        visitBoundAttributeOrEvent(node) { }
        visitText(text) { }
        visitBoundText(text) { }
        visitIcu(icu) { }
    }
    /**
     * Processes a template and extract metadata about expressions and symbols within.
     *
     * This is a companion to the `DirectiveBinder` that doesn't require knowledge of directives matched
     * within the template in order to operate.
     *
     * Expressions are visited by the superclass `RecursiveAstVisitor`, with custom logic provided
     * by overridden methods from that visitor.
     */
    class TemplateBinder extends RecursiveAstVisitor {
        constructor(bindings, symbols, usedPipes, nestingLevel, scope, template, level) {
            super();
            this.bindings = bindings;
            this.symbols = symbols;
            this.usedPipes = usedPipes;
            this.nestingLevel = nestingLevel;
            this.scope = scope;
            this.template = template;
            this.level = level;
            this.pipesUsed = [];
            // Save a bit of processing time by constructing this closure in advance.
            this.visitNode = (node) => node.visit(this);
        }
        // This method is defined to reconcile the type of TemplateBinder since both
        // RecursiveAstVisitor and Visitor define the visit() method in their
        // interfaces.
        visit(node, context) {
            if (node instanceof AST) {
                node.visit(this, context);
            }
            else {
                node.visit(this);
            }
        }
        /**
         * Process a template and extract metadata about expressions and symbols within.
         *
         * @param template the nodes of the template to process
         * @param scope the `Scope` of the template being processed.
         * @returns three maps which contain metadata about the template: `expressions` which interprets
         * special `AST` nodes in expressions as pointing to references or variables declared within the
         * template, `symbols` which maps those variables and references to the nested `Template` which
         * declares them, if any, and `nestingLevel` which associates each `Template` with a integer
         * nesting level (how many levels deep within the template structure the `Template` is), starting
         * at 1.
         */
        static applyWithScope(template, scope) {
            const expressions = new Map();
            const symbols = new Map();
            const nestingLevel = new Map();
            const usedPipes = new Set();
            // The top-level template has nesting level 0.
            const binder = new TemplateBinder(expressions, symbols, usedPipes, nestingLevel, scope, template instanceof Template ? template : null, 0);
            binder.ingest(template);
            return { expressions, symbols, nestingLevel, usedPipes };
        }
        ingest(template) {
            if (template instanceof Template) {
                // For <ng-template>s, process only variables and child nodes. Inputs, outputs, templateAttrs,
                // and references were all processed in the scope of the containing template.
                template.variables.forEach(this.visitNode);
                template.children.forEach(this.visitNode);
                // Set the nesting level.
                this.nestingLevel.set(template, this.level);
            }
            else {
                // Visit each node from the top-level template.
                template.forEach(this.visitNode);
            }
        }
        visitElement(element) {
            // Visit the inputs, outputs, and children of the element.
            element.inputs.forEach(this.visitNode);
            element.outputs.forEach(this.visitNode);
            element.children.forEach(this.visitNode);
        }
        visitTemplate(template) {
            // First, visit inputs, outputs and template attributes of the template node.
            template.inputs.forEach(this.visitNode);
            template.outputs.forEach(this.visitNode);
            template.templateAttrs.forEach(this.visitNode);
            // References are also evaluated in the outer context.
            template.references.forEach(this.visitNode);
            // Next, recurse into the template using its scope, and bumping the nesting level up by one.
            const childScope = this.scope.getChildScope(template);
            const binder = new TemplateBinder(this.bindings, this.symbols, this.usedPipes, this.nestingLevel, childScope, template, this.level + 1);
            binder.ingest(template);
        }
        visitVariable(variable) {
            // Register the `Variable` as a symbol in the current `Template`.
            if (this.template !== null) {
                this.symbols.set(variable, this.template);
            }
        }
        visitReference(reference) {
            // Register the `Reference` as a symbol in the current `Template`.
            if (this.template !== null) {
                this.symbols.set(reference, this.template);
            }
        }
        // Unused template visitors
        visitText(text) { }
        visitContent(content) { }
        visitTextAttribute(attribute) { }
        visitIcu(icu) {
            Object.keys(icu.vars).forEach(key => icu.vars[key].visit(this));
            Object.keys(icu.placeholders).forEach(key => icu.placeholders[key].visit(this));
        }
        // The remaining visitors are concerned with processing AST expressions within template bindings
        visitBoundAttribute(attribute) {
            attribute.value.visit(this);
        }
        visitBoundEvent(event) {
            event.handler.visit(this);
        }
        visitBoundText(text) {
            text.value.visit(this);
        }
        visitPipe(ast, context) {
            this.usedPipes.add(ast.name);
            return super.visitPipe(ast, context);
        }
        // These five types of AST expressions can refer to expression roots, which could be variables
        // or references in the current scope.
        visitPropertyRead(ast, context) {
            this.maybeMap(context, ast, ast.name);
            return super.visitPropertyRead(ast, context);
        }
        visitSafePropertyRead(ast, context) {
            this.maybeMap(context, ast, ast.name);
            return super.visitSafePropertyRead(ast, context);
        }
        visitPropertyWrite(ast, context) {
            this.maybeMap(context, ast, ast.name);
            return super.visitPropertyWrite(ast, context);
        }
        visitMethodCall(ast, context) {
            this.maybeMap(context, ast, ast.name);
            return super.visitMethodCall(ast, context);
        }
        visitSafeMethodCall(ast, context) {
            this.maybeMap(context, ast, ast.name);
            return super.visitSafeMethodCall(ast, context);
        }
        maybeMap(scope, ast, name) {
            // If the receiver of the expression isn't the `ImplicitReceiver`, this isn't the root of an
            // `AST` expression that maps to a `Variable` or `Reference`.
            if (!(ast.receiver instanceof ImplicitReceiver)) {
                return;
            }
            // Check whether the name exists in the current scope. If so, map it. Otherwise, the name is
            // probably a property on the top-level component context.
            let target = this.scope.lookup(name);
            if (target !== null) {
                this.bindings.set(ast, target);
            }
        }
    }
    /**
     * Metadata container for a `Target` that allows queries for specific bits of metadata.
     *
     * See `BoundTarget` for documentation on the individual methods.
     */
    class R3BoundTarget {
        constructor(target, directives, bindings, references, exprTargets, symbols, nestingLevel, templateEntities, usedPipes) {
            this.target = target;
            this.directives = directives;
            this.bindings = bindings;
            this.references = references;
            this.exprTargets = exprTargets;
            this.symbols = symbols;
            this.nestingLevel = nestingLevel;
            this.templateEntities = templateEntities;
            this.usedPipes = usedPipes;
        }
        getEntitiesInTemplateScope(template) {
            var _a;
            return (_a = this.templateEntities.get(template)) !== null && _a !== void 0 ? _a : new Set();
        }
        getDirectivesOfNode(node) {
            return this.directives.get(node) || null;
        }
        getReferenceTarget(ref) {
            return this.references.get(ref) || null;
        }
        getConsumerOfBinding(binding) {
            return this.bindings.get(binding) || null;
        }
        getExpressionTarget(expr) {
            return this.exprTargets.get(expr) || null;
        }
        getTemplateOfSymbol(symbol) {
            return this.symbols.get(symbol) || null;
        }
        getNestingLevel(template) {
            return this.nestingLevel.get(template) || 0;
        }
        getUsedDirectives() {
            const set = new Set();
            this.directives.forEach(dirs => dirs.forEach(dir => set.add(dir)));
            return Array.from(set.values());
        }
        getUsedPipes() {
            return Array.from(this.usedPipes);
        }
    }
    function extractTemplateEntities(rootScope) {
        const entityMap = new Map();
        function extractScopeEntities(scope) {
            if (entityMap.has(scope.template)) {
                return entityMap.get(scope.template);
            }
            const currentEntities = scope.namedEntities;
            let templateEntities;
            if (scope.parentScope !== null) {
                templateEntities = new Map([...extractScopeEntities(scope.parentScope), ...currentEntities]);
            }
            else {
                templateEntities = new Map(currentEntities);
            }
            entityMap.set(scope.template, templateEntities);
            return templateEntities;
        }
        const scopesToProcess = [rootScope];
        while (scopesToProcess.length > 0) {
            const scope = scopesToProcess.pop();
            for (const childScope of scope.childScopes.values()) {
                scopesToProcess.push(childScope);
            }
            extractScopeEntities(scope);
        }
        const templateEntities = new Map();
        for (const [template, entities] of entityMap) {
            templateEntities.set(template, new Set(entities.values()));
        }
        return templateEntities;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function compileClassMetadata(metadata) {
        var _a, _b;
        // Generate an ngDevMode guarded call to setClassMetadata with the class identifier and its
        // metadata.
        const fnCall = importExpr(Identifiers.setClassMetadata).callFn([
            metadata.type,
            metadata.decorators,
            (_a = metadata.ctorParameters) !== null && _a !== void 0 ? _a : literal(null),
            (_b = metadata.propDecorators) !== null && _b !== void 0 ? _b : literal(null),
        ]);
        const iife = fn([], [devOnlyGuardedExpression(fnCall).toStmt()]);
        return iife.callFn([]);
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Every time we make a breaking change to the declaration interface or partial-linker behavior, we
     * must update this constant to prevent old partial-linkers from incorrectly processing the
     * declaration.
     *
     * Do not include any prerelease in these versions as they are ignored.
     */
    const MINIMUM_PARTIAL_LINKER_VERSION = '12.0.0';
    function compileDeclareClassMetadata(metadata) {
        const definitionMap = new DefinitionMap();
        definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_VERSION));
        definitionMap.set('version', literal('12.2.12'));
        definitionMap.set('ngImport', importExpr(Identifiers.core));
        definitionMap.set('type', metadata.type);
        definitionMap.set('decorators', metadata.decorators);
        definitionMap.set('ctorParameters', metadata.ctorParameters);
        definitionMap.set('propDecorators', metadata.propDecorators);
        return importExpr(Identifiers.declareClassMetadata).callFn([definitionMap.toLiteralMap()]);
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Every time we make a breaking change to the declaration interface or partial-linker behavior, we
     * must update this constant to prevent old partial-linkers from incorrectly processing the
     * declaration.
     *
     * Do not include any prerelease in these versions as they are ignored.
     */
    const MINIMUM_PARTIAL_LINKER_VERSION$1 = '12.0.0';
    /**
     * Compile a directive declaration defined by the `R3DirectiveMetadata`.
     */
    function compileDeclareDirectiveFromMetadata(meta) {
        const definitionMap = createDirectiveDefinitionMap(meta);
        const expression = importExpr(Identifiers.declareDirective).callFn([definitionMap.toLiteralMap()]);
        const type = createDirectiveType(meta);
        return { expression, type, statements: [] };
    }
    /**
     * Gathers the declaration fields for a directive into a `DefinitionMap`. This allows for reusing
     * this logic for components, as they extend the directive metadata.
     */
    function createDirectiveDefinitionMap(meta) {
        const definitionMap = new DefinitionMap();
        definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_VERSION$1));
        definitionMap.set('version', literal('12.2.12'));
        // e.g. `type: MyDirective`
        definitionMap.set('type', meta.internalType);
        // e.g. `selector: 'some-dir'`
        if (meta.selector !== null) {
            definitionMap.set('selector', literal(meta.selector));
        }
        definitionMap.set('inputs', conditionallyCreateMapObjectLiteral(meta.inputs, true));
        definitionMap.set('outputs', conditionallyCreateMapObjectLiteral(meta.outputs));
        definitionMap.set('host', compileHostMetadata(meta.host));
        definitionMap.set('providers', meta.providers);
        if (meta.queries.length > 0) {
            definitionMap.set('queries', literalArr(meta.queries.map(compileQuery)));
        }
        if (meta.viewQueries.length > 0) {
            definitionMap.set('viewQueries', literalArr(meta.viewQueries.map(compileQuery)));
        }
        if (meta.exportAs !== null) {
            definitionMap.set('exportAs', asLiteral(meta.exportAs));
        }
        if (meta.usesInheritance) {
            definitionMap.set('usesInheritance', literal(true));
        }
        if (meta.lifecycle.usesOnChanges) {
            definitionMap.set('usesOnChanges', literal(true));
        }
        definitionMap.set('ngImport', importExpr(Identifiers.core));
        return definitionMap;
    }
    /**
     * Compiles the metadata of a single query into its partial declaration form as declared
     * by `R3DeclareQueryMetadata`.
     */
    function compileQuery(query) {
        const meta = new DefinitionMap();
        meta.set('propertyName', literal(query.propertyName));
        if (query.first) {
            meta.set('first', literal(true));
        }
        meta.set('predicate', Array.isArray(query.predicate) ? asLiteral(query.predicate) : query.predicate);
        if (!query.emitDistinctChangesOnly) {
            // `emitDistinctChangesOnly` is special because we expect it to be `true`.
            // Therefore we explicitly emit the field, and explicitly place it only when it's `false`.
            meta.set('emitDistinctChangesOnly', literal(false));
        }
        if (query.descendants) {
            meta.set('descendants', literal(true));
        }
        meta.set('read', query.read);
        if (query.static) {
            meta.set('static', literal(true));
        }
        return meta.toLiteralMap();
    }
    /**
     * Compiles the host metadata into its partial declaration form as declared
     * in `R3DeclareDirectiveMetadata['host']`
     */
    function compileHostMetadata(meta) {
        const hostMetadata = new DefinitionMap();
        hostMetadata.set('attributes', toOptionalLiteralMap(meta.attributes, expression => expression));
        hostMetadata.set('listeners', toOptionalLiteralMap(meta.listeners, literal));
        hostMetadata.set('properties', toOptionalLiteralMap(meta.properties, literal));
        if (meta.specialAttributes.styleAttr) {
            hostMetadata.set('styleAttribute', literal(meta.specialAttributes.styleAttr));
        }
        if (meta.specialAttributes.classAttr) {
            hostMetadata.set('classAttribute', literal(meta.specialAttributes.classAttr));
        }
        if (hostMetadata.values.length > 0) {
            return hostMetadata.toLiteralMap();
        }
        else {
            return null;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Compile a component declaration defined by the `R3ComponentMetadata`.
     */
    function compileDeclareComponentFromMetadata(meta, template, additionalTemplateInfo) {
        const definitionMap = createComponentDefinitionMap(meta, template, additionalTemplateInfo);
        const expression = importExpr(Identifiers.declareComponent).callFn([definitionMap.toLiteralMap()]);
        const type = createComponentType(meta);
        return { expression, type, statements: [] };
    }
    /**
     * Gathers the declaration fields for a component into a `DefinitionMap`.
     */
    function createComponentDefinitionMap(meta, template, templateInfo) {
        const definitionMap = createDirectiveDefinitionMap(meta);
        definitionMap.set('template', getTemplateExpression(template, templateInfo));
        if (templateInfo.isInline) {
            definitionMap.set('isInline', literal(true));
        }
        definitionMap.set('styles', toOptionalLiteralArray(meta.styles, literal));
        definitionMap.set('components', compileUsedDirectiveMetadata(meta, directive => directive.isComponent === true));
        definitionMap.set('directives', compileUsedDirectiveMetadata(meta, directive => directive.isComponent !== true));
        definitionMap.set('pipes', compileUsedPipeMetadata(meta));
        definitionMap.set('viewProviders', meta.viewProviders);
        definitionMap.set('animations', meta.animations);
        if (meta.changeDetection !== undefined) {
            definitionMap.set('changeDetection', importExpr(Identifiers.ChangeDetectionStrategy)
                .prop(ChangeDetectionStrategy[meta.changeDetection]));
        }
        if (meta.encapsulation !== ViewEncapsulation.Emulated) {
            definitionMap.set('encapsulation', importExpr(Identifiers.ViewEncapsulation).prop(ViewEncapsulation[meta.encapsulation]));
        }
        if (meta.interpolation !== DEFAULT_INTERPOLATION_CONFIG) {
            definitionMap.set('interpolation', literalArr([literal(meta.interpolation.start), literal(meta.interpolation.end)]));
        }
        if (template.preserveWhitespaces === true) {
            definitionMap.set('preserveWhitespaces', literal(true));
        }
        return definitionMap;
    }
    function getTemplateExpression(template, templateInfo) {
        // If the template has been defined using a direct literal, we use that expression directly
        // without any modifications. This is ensures proper source mapping from the partially
        // compiled code to the source file declaring the template. Note that this does not capture
        // template literals referenced indirectly through an identifier.
        if (templateInfo.inlineTemplateLiteralExpression !== null) {
            return templateInfo.inlineTemplateLiteralExpression;
        }
        // If the template is defined inline but not through a literal, the template has been resolved
        // through static interpretation. We create a literal but cannot provide any source span. Note
        // that we cannot use the expression defining the template because the linker expects the template
        // to be defined as a literal in the declaration.
        if (templateInfo.isInline) {
            return literal(templateInfo.content, null, null);
        }
        // The template is external so we must synthesize an expression node with
        // the appropriate source-span.
        const contents = templateInfo.content;
        const file = new ParseSourceFile(contents, templateInfo.sourceUrl);
        const start = new ParseLocation(file, 0, 0, 0);
        const end = computeEndLocation(file, contents);
        const span = new ParseSourceSpan(start, end);
        return literal(contents, null, span);
    }
    function computeEndLocation(file, contents) {
        const length = contents.length;
        let lineStart = 0;
        let lastLineStart = 0;
        let line = 0;
        do {
            lineStart = contents.indexOf('\n', lastLineStart);
            if (lineStart !== -1) {
                lastLineStart = lineStart + 1;
                line++;
            }
        } while (lineStart !== -1);
        return new ParseLocation(file, length, line, length - lastLineStart);
    }
    /**
     * Compiles the directives as registered in the component metadata into an array literal of the
     * individual directives. If the component does not use any directives, then null is returned.
     */
    function compileUsedDirectiveMetadata(meta, predicate) {
        const wrapType = meta.declarationListEmitMode !== 0 /* Direct */ ?
            generateForwardRef :
            (expr) => expr;
        const directives = meta.directives.filter(predicate);
        return toOptionalLiteralArray(directives, directive => {
            const dirMeta = new DefinitionMap();
            dirMeta.set('type', wrapType(directive.type));
            dirMeta.set('selector', literal(directive.selector));
            dirMeta.set('inputs', toOptionalLiteralArray(directive.inputs, literal));
            dirMeta.set('outputs', toOptionalLiteralArray(directive.outputs, literal));
            dirMeta.set('exportAs', toOptionalLiteralArray(directive.exportAs, literal));
            return dirMeta.toLiteralMap();
        });
    }
    /**
     * Compiles the pipes as registered in the component metadata into an object literal, where the
     * pipe's name is used as key and a reference to its type as value. If the component does not use
     * any pipes, then null is returned.
     */
    function compileUsedPipeMetadata(meta) {
        if (meta.pipes.size === 0) {
            return null;
        }
        const wrapType = meta.declarationListEmitMode !== 0 /* Direct */ ?
            generateForwardRef :
            (expr) => expr;
        const entries = [];
        for (const [name, pipe] of meta.pipes) {
            entries.push({ key: name, value: wrapType(pipe), quoted: true });
        }
        return literalMap(entries);
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Every time we make a breaking change to the declaration interface or partial-linker behavior, we
     * must update this constant to prevent old partial-linkers from incorrectly processing the
     * declaration.
     *
     * Do not include any prerelease in these versions as they are ignored.
     */
    const MINIMUM_PARTIAL_LINKER_VERSION$2 = '12.0.0';
    function compileDeclareFactoryFunction(meta) {
        const definitionMap = new DefinitionMap();
        definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_VERSION$2));
        definitionMap.set('version', literal('12.2.12'));
        definitionMap.set('ngImport', importExpr(Identifiers.core));
        definitionMap.set('type', meta.internalType);
        definitionMap.set('deps', compileDependencies(meta.deps));
        definitionMap.set('target', importExpr(Identifiers.FactoryTarget).prop(FactoryTarget[meta.target]));
        return {
            expression: importExpr(Identifiers.declareFactory).callFn([definitionMap.toLiteralMap()]),
            statements: [],
            type: createFactoryType(meta),
        };
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Every time we make a breaking change to the declaration interface or partial-linker behavior, we
     * must update this constant to prevent old partial-linkers from incorrectly processing the
     * declaration.
     *
     * Do not include any prerelease in these versions as they are ignored.
     */
    const MINIMUM_PARTIAL_LINKER_VERSION$3 = '12.0.0';
    /**
     * Compile a Injectable declaration defined by the `R3InjectableMetadata`.
     */
    function compileDeclareInjectableFromMetadata(meta) {
        const definitionMap = createInjectableDefinitionMap(meta);
        const expression = importExpr(Identifiers.declareInjectable).callFn([definitionMap.toLiteralMap()]);
        const type = createInjectableType(meta);
        return { expression, type, statements: [] };
    }
    /**
     * Gathers the declaration fields for a Injectable into a `DefinitionMap`.
     */
    function createInjectableDefinitionMap(meta) {
        const definitionMap = new DefinitionMap();
        definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_VERSION$3));
        definitionMap.set('version', literal('12.2.12'));
        definitionMap.set('ngImport', importExpr(Identifiers.core));
        definitionMap.set('type', meta.internalType);
        // Only generate providedIn property if it has a non-null value
        if (meta.providedIn !== undefined) {
            const providedIn = convertFromProviderExpression(meta.providedIn);
            if (providedIn.value !== null) {
                definitionMap.set('providedIn', providedIn);
            }
        }
        if (meta.useClass !== undefined) {
            definitionMap.set('useClass', convertFromProviderExpression(meta.useClass));
        }
        if (meta.useExisting !== undefined) {
            definitionMap.set('useExisting', convertFromProviderExpression(meta.useExisting));
        }
        if (meta.useValue !== undefined) {
            definitionMap.set('useValue', convertFromProviderExpression(meta.useValue));
        }
        // Factories do not contain `ForwardRef`s since any types are already wrapped in a function call
        // so the types will not be eagerly evaluated. Therefore we do not need to process this expression
        // with `convertFromProviderExpression()`.
        if (meta.useFactory !== undefined) {
            definitionMap.set('useFactory', meta.useFactory);
        }
        if (meta.deps !== undefined) {
            definitionMap.set('deps', literalArr(meta.deps.map(compileDependency)));
        }
        return definitionMap;
    }
    /**
     * Convert an `R3ProviderExpression` to an `Expression`, possibly wrapping its expression in a
     * `forwardRef()` call.
     *
     * If `R3ProviderExpression.isForwardRef` is true then the expression was originally wrapped in a
     * `forwardRef()` call to prevent the value from being eagerly evaluated in the code.
     *
     * Normally, the linker will statically process the code, putting the `expression` inside a factory
     * function so the `forwardRef()` wrapper is not evaluated before it has been defined. But if the
     * partial declaration is evaluated by the JIT compiler the `forwardRef()` call is still needed to
     * prevent eager evaluation of the `expression`.
     *
     * So in partial declarations, expressions that could be forward-refs are wrapped in `forwardRef()`
     * calls, and this is then unwrapped in the linker as necessary.
     *
     * See `packages/compiler-cli/src/ngtsc/annotations/src/injectable.ts` and
     * `packages/compiler/src/jit_compiler_facade.ts` for more information.
     */
    function convertFromProviderExpression({ expression, isForwardRef }) {
        return isForwardRef ? generateForwardRef(expression) : expression;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Every time we make a breaking change to the declaration interface or partial-linker behavior, we
     * must update this constant to prevent old partial-linkers from incorrectly processing the
     * declaration.
     *
     * Do not include any prerelease in these versions as they are ignored.
     */
    const MINIMUM_PARTIAL_LINKER_VERSION$4 = '12.0.0';
    function compileDeclareInjectorFromMetadata(meta) {
        const definitionMap = createInjectorDefinitionMap(meta);
        const expression = importExpr(Identifiers.declareInjector).callFn([definitionMap.toLiteralMap()]);
        const type = createInjectorType(meta);
        return { expression, type, statements: [] };
    }
    /**
     * Gathers the declaration fields for an Injector into a `DefinitionMap`.
     */
    function createInjectorDefinitionMap(meta) {
        const definitionMap = new DefinitionMap();
        definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_VERSION$4));
        definitionMap.set('version', literal('12.2.12'));
        definitionMap.set('ngImport', importExpr(Identifiers.core));
        definitionMap.set('type', meta.internalType);
        definitionMap.set('providers', meta.providers);
        if (meta.imports.length > 0) {
            definitionMap.set('imports', literalArr(meta.imports));
        }
        return definitionMap;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Every time we make a breaking change to the declaration interface or partial-linker behavior, we
     * must update this constant to prevent old partial-linkers from incorrectly processing the
     * declaration.
     *
     * Do not include any prerelease in these versions as they are ignored.
     */
    const MINIMUM_PARTIAL_LINKER_VERSION$5 = '12.0.0';
    function compileDeclareNgModuleFromMetadata(meta) {
        const definitionMap = createNgModuleDefinitionMap(meta);
        const expression = importExpr(Identifiers.declareNgModule).callFn([definitionMap.toLiteralMap()]);
        const type = createNgModuleType(meta);
        return { expression, type, statements: [] };
    }
    /**
     * Gathers the declaration fields for an NgModule into a `DefinitionMap`.
     */
    function createNgModuleDefinitionMap(meta) {
        const definitionMap = new DefinitionMap();
        definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_VERSION$5));
        definitionMap.set('version', literal('12.2.12'));
        definitionMap.set('ngImport', importExpr(Identifiers.core));
        definitionMap.set('type', meta.internalType);
        // We only generate the keys in the metadata if the arrays contain values.
        // We must wrap the arrays inside a function if any of the values are a forward reference to a
        // not-yet-declared class. This is to support JIT execution of the `ngDeclareNgModule()` call.
        // In the linker these wrappers are stripped and then reapplied for the `defineNgModule()` call.
        if (meta.bootstrap.length > 0) {
            definitionMap.set('bootstrap', refsToArray(meta.bootstrap, meta.containsForwardDecls));
        }
        if (meta.declarations.length > 0) {
            definitionMap.set('declarations', refsToArray(meta.declarations, meta.containsForwardDecls));
        }
        if (meta.imports.length > 0) {
            definitionMap.set('imports', refsToArray(meta.imports, meta.containsForwardDecls));
        }
        if (meta.exports.length > 0) {
            definitionMap.set('exports', refsToArray(meta.exports, meta.containsForwardDecls));
        }
        if (meta.schemas !== null && meta.schemas.length > 0) {
            definitionMap.set('schemas', literalArr(meta.schemas.map(ref => ref.value)));
        }
        if (meta.id !== null) {
            definitionMap.set('id', meta.id);
        }
        return definitionMap;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Every time we make a breaking change to the declaration interface or partial-linker behavior, we
     * must update this constant to prevent old partial-linkers from incorrectly processing the
     * declaration.
     *
     * Do not include any prerelease in these versions as they are ignored.
     */
    const MINIMUM_PARTIAL_LINKER_VERSION$6 = '12.0.0';
    /**
     * Compile a Pipe declaration defined by the `R3PipeMetadata`.
     */
    function compileDeclarePipeFromMetadata(meta) {
        const definitionMap = createPipeDefinitionMap(meta);
        const expression = importExpr(Identifiers.declarePipe).callFn([definitionMap.toLiteralMap()]);
        const type = createPipeType(meta);
        return { expression, type, statements: [] };
    }
    /**
     * Gathers the declaration fields for a Pipe into a `DefinitionMap`.
     */
    function createPipeDefinitionMap(meta) {
        const definitionMap = new DefinitionMap();
        definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_VERSION$6));
        definitionMap.set('version', literal('12.2.12'));
        definitionMap.set('ngImport', importExpr(Identifiers.core));
        // e.g. `type: MyPipe`
        definitionMap.set('type', meta.internalType);
        // e.g. `name: "myPipe"`
        definitionMap.set('name', literal(meta.pipeName));
        if (meta.pure === false) {
            // e.g. `pure: false`
            definitionMap.set('pure', literal(meta.pure));
        }
        return definitionMap;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    // This file only reexports content of the `src` folder. Keep it that way.
    // This function call has a global side effects and publishes the compiler into global namespace for
    // the late binding of the Compiler to the @angular/core for jit compilation.
    publishFacade(_global);

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const VERSION$2 = new Version('12.2.12');

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    // In TypeScript 2.1 the spread element kind was renamed.
    const spreadElementSyntaxKind = ts$1.SyntaxKind.SpreadElement || ts$1.SyntaxKind.SpreadElementExpression;
    const empty = ts$1.createNodeArray();

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const UNKNOWN_ERROR_CODE = 500;
    var EmitFlags;
    (function (EmitFlags) {
        EmitFlags[EmitFlags["DTS"] = 1] = "DTS";
        EmitFlags[EmitFlags["JS"] = 2] = "JS";
        EmitFlags[EmitFlags["Metadata"] = 4] = "Metadata";
        EmitFlags[EmitFlags["I18nBundle"] = 8] = "I18nBundle";
        EmitFlags[EmitFlags["Codegen"] = 16] = "Codegen";
        EmitFlags[EmitFlags["Default"] = 19] = "Default";
        EmitFlags[EmitFlags["All"] = 31] = "All";
    })(EmitFlags || (EmitFlags = {}));

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * @publicApi
     */
    var ErrorCode;
    (function (ErrorCode) {
        ErrorCode[ErrorCode["DECORATOR_ARG_NOT_LITERAL"] = 1001] = "DECORATOR_ARG_NOT_LITERAL";
        ErrorCode[ErrorCode["DECORATOR_ARITY_WRONG"] = 1002] = "DECORATOR_ARITY_WRONG";
        ErrorCode[ErrorCode["DECORATOR_NOT_CALLED"] = 1003] = "DECORATOR_NOT_CALLED";
        ErrorCode[ErrorCode["DECORATOR_ON_ANONYMOUS_CLASS"] = 1004] = "DECORATOR_ON_ANONYMOUS_CLASS";
        ErrorCode[ErrorCode["DECORATOR_UNEXPECTED"] = 1005] = "DECORATOR_UNEXPECTED";
        /**
         * This error code indicates that there are incompatible decorators on a type or a class field.
         */
        ErrorCode[ErrorCode["DECORATOR_COLLISION"] = 1006] = "DECORATOR_COLLISION";
        ErrorCode[ErrorCode["VALUE_HAS_WRONG_TYPE"] = 1010] = "VALUE_HAS_WRONG_TYPE";
        ErrorCode[ErrorCode["VALUE_NOT_LITERAL"] = 1011] = "VALUE_NOT_LITERAL";
        ErrorCode[ErrorCode["COMPONENT_MISSING_TEMPLATE"] = 2001] = "COMPONENT_MISSING_TEMPLATE";
        ErrorCode[ErrorCode["PIPE_MISSING_NAME"] = 2002] = "PIPE_MISSING_NAME";
        ErrorCode[ErrorCode["PARAM_MISSING_TOKEN"] = 2003] = "PARAM_MISSING_TOKEN";
        ErrorCode[ErrorCode["DIRECTIVE_MISSING_SELECTOR"] = 2004] = "DIRECTIVE_MISSING_SELECTOR";
        /** Raised when an undecorated class is passed in as a provider to a module or a directive. */
        ErrorCode[ErrorCode["UNDECORATED_PROVIDER"] = 2005] = "UNDECORATED_PROVIDER";
        /**
         * Raised when a Directive inherits its constructor from a base class without an Angular
         * decorator.
         */
        ErrorCode[ErrorCode["DIRECTIVE_INHERITS_UNDECORATED_CTOR"] = 2006] = "DIRECTIVE_INHERITS_UNDECORATED_CTOR";
        /**
         * Raised when an undecorated class that is using Angular features
         * has been discovered.
         */
        ErrorCode[ErrorCode["UNDECORATED_CLASS_USING_ANGULAR_FEATURES"] = 2007] = "UNDECORATED_CLASS_USING_ANGULAR_FEATURES";
        /**
         * Raised when an component cannot resolve an external resource, such as a template or a style
         * sheet.
         */
        ErrorCode[ErrorCode["COMPONENT_RESOURCE_NOT_FOUND"] = 2008] = "COMPONENT_RESOURCE_NOT_FOUND";
        /**
         * Raised when a component uses `ShadowDom` view encapsulation, but its selector
         * does not match the shadow DOM tag name requirements.
         */
        ErrorCode[ErrorCode["COMPONENT_INVALID_SHADOW_DOM_SELECTOR"] = 2009] = "COMPONENT_INVALID_SHADOW_DOM_SELECTOR";
        ErrorCode[ErrorCode["SYMBOL_NOT_EXPORTED"] = 3001] = "SYMBOL_NOT_EXPORTED";
        ErrorCode[ErrorCode["SYMBOL_EXPORTED_UNDER_DIFFERENT_NAME"] = 3002] = "SYMBOL_EXPORTED_UNDER_DIFFERENT_NAME";
        /**
         * Raised when a relationship between directives and/or pipes would cause a cyclic import to be
         * created that cannot be handled, such as in partial compilation mode.
         */
        ErrorCode[ErrorCode["IMPORT_CYCLE_DETECTED"] = 3003] = "IMPORT_CYCLE_DETECTED";
        ErrorCode[ErrorCode["CONFIG_FLAT_MODULE_NO_INDEX"] = 4001] = "CONFIG_FLAT_MODULE_NO_INDEX";
        ErrorCode[ErrorCode["CONFIG_STRICT_TEMPLATES_IMPLIES_FULL_TEMPLATE_TYPECHECK"] = 4002] = "CONFIG_STRICT_TEMPLATES_IMPLIES_FULL_TEMPLATE_TYPECHECK";
        /**
         * Raised when a host expression has a parse error, such as a host listener or host binding
         * expression containing a pipe.
         */
        ErrorCode[ErrorCode["HOST_BINDING_PARSE_ERROR"] = 5001] = "HOST_BINDING_PARSE_ERROR";
        /**
         * Raised when the compiler cannot parse a component's template.
         */
        ErrorCode[ErrorCode["TEMPLATE_PARSE_ERROR"] = 5002] = "TEMPLATE_PARSE_ERROR";
        /**
         * Raised when an NgModule contains an invalid reference in `declarations`.
         */
        ErrorCode[ErrorCode["NGMODULE_INVALID_DECLARATION"] = 6001] = "NGMODULE_INVALID_DECLARATION";
        /**
         * Raised when an NgModule contains an invalid type in `imports`.
         */
        ErrorCode[ErrorCode["NGMODULE_INVALID_IMPORT"] = 6002] = "NGMODULE_INVALID_IMPORT";
        /**
         * Raised when an NgModule contains an invalid type in `exports`.
         */
        ErrorCode[ErrorCode["NGMODULE_INVALID_EXPORT"] = 6003] = "NGMODULE_INVALID_EXPORT";
        /**
         * Raised when an NgModule contains a type in `exports` which is neither in `declarations` nor
         * otherwise imported.
         */
        ErrorCode[ErrorCode["NGMODULE_INVALID_REEXPORT"] = 6004] = "NGMODULE_INVALID_REEXPORT";
        /**
         * Raised when a `ModuleWithProviders` with a missing
         * generic type argument is passed into an `NgModule`.
         */
        ErrorCode[ErrorCode["NGMODULE_MODULE_WITH_PROVIDERS_MISSING_GENERIC"] = 6005] = "NGMODULE_MODULE_WITH_PROVIDERS_MISSING_GENERIC";
        /**
         * Raised when an NgModule exports multiple directives/pipes of the same name and the compiler
         * attempts to generate private re-exports within the NgModule file.
         */
        ErrorCode[ErrorCode["NGMODULE_REEXPORT_NAME_COLLISION"] = 6006] = "NGMODULE_REEXPORT_NAME_COLLISION";
        /**
         * Raised when a directive/pipe is part of the declarations of two or more NgModules.
         */
        ErrorCode[ErrorCode["NGMODULE_DECLARATION_NOT_UNIQUE"] = 6007] = "NGMODULE_DECLARATION_NOT_UNIQUE";
        /**
         * Not actually raised by the compiler, but reserved for documentation of a View Engine error when
         * a View Engine build depends on an Ivy-compiled NgModule.
         */
        ErrorCode[ErrorCode["NGMODULE_VE_DEPENDENCY_ON_IVY_LIB"] = 6999] = "NGMODULE_VE_DEPENDENCY_ON_IVY_LIB";
        /**
         * An element name failed validation against the DOM schema.
         */
        ErrorCode[ErrorCode["SCHEMA_INVALID_ELEMENT"] = 8001] = "SCHEMA_INVALID_ELEMENT";
        /**
         * An element's attribute name failed validation against the DOM schema.
         */
        ErrorCode[ErrorCode["SCHEMA_INVALID_ATTRIBUTE"] = 8002] = "SCHEMA_INVALID_ATTRIBUTE";
        /**
         * No matching directive was found for a `#ref="target"` expression.
         */
        ErrorCode[ErrorCode["MISSING_REFERENCE_TARGET"] = 8003] = "MISSING_REFERENCE_TARGET";
        /**
         * No matching pipe was found for a
         */
        ErrorCode[ErrorCode["MISSING_PIPE"] = 8004] = "MISSING_PIPE";
        /**
         * The left-hand side of an assignment expression was a template variable. Effectively, the
         * template looked like:
         *
         * ```
         * <ng-template let-something>
         *   <button (click)="something = ...">...</button>
         * </ng-template>
         * ```
         *
         * Template variables are read-only.
         */
        ErrorCode[ErrorCode["WRITE_TO_READ_ONLY_VARIABLE"] = 8005] = "WRITE_TO_READ_ONLY_VARIABLE";
        /**
         * A template variable was declared twice. For example:
         *
         * ```html
         * <div *ngFor="let i of items; let i = index">
         * </div>
         * ```
         */
        ErrorCode[ErrorCode["DUPLICATE_VARIABLE_DECLARATION"] = 8006] = "DUPLICATE_VARIABLE_DECLARATION";
        /**
         * A template has a two way binding (two bindings created by a single syntactial element)
         * in which the input and output are going to different places.
         */
        ErrorCode[ErrorCode["SPLIT_TWO_WAY_BINDING"] = 8007] = "SPLIT_TWO_WAY_BINDING";
        /**
         * A two way binding in a template has an incorrect syntax,
         * parentheses outside brackets. For example:
         *
         * ```
         * <div ([foo])="bar" />
         * ```
         */
        ErrorCode[ErrorCode["INVALID_BANANA_IN_BOX"] = 8101] = "INVALID_BANANA_IN_BOX";
        /**
         * The left side of a nullish coalescing operation is not nullable.
         *
         * ```
         * {{ foo ?? bar }}
         * ```
         * When the type of foo doesn't include `null` or `undefined`.
         */
        ErrorCode[ErrorCode["NULLISH_COALESCING_NOT_NULLABLE"] = 8102] = "NULLISH_COALESCING_NOT_NULLABLE";
        /**
         * The template type-checking engine would need to generate an inline type check block for a
         * component, but the current type-checking environment doesn't support it.
         */
        ErrorCode[ErrorCode["INLINE_TCB_REQUIRED"] = 8900] = "INLINE_TCB_REQUIRED";
        /**
         * The template type-checking engine would need to generate an inline type constructor for a
         * directive or component, but the current type-checking environment doesn't support it.
         */
        ErrorCode[ErrorCode["INLINE_TYPE_CTOR_REQUIRED"] = 8901] = "INLINE_TYPE_CTOR_REQUIRED";
        /**
         * An injectable already has a `prov` property.
         */
        ErrorCode[ErrorCode["INJECTABLE_DUPLICATE_PROV"] = 9001] = "INJECTABLE_DUPLICATE_PROV";
        // 10XXX error codes are reserved for diagnostics with categories other than
        // `ts.DiagnosticCategory.Error`. These diagnostics are generated by the compiler when configured
        // to do so by a tool such as the Language Service, or by the Language Service itself.
        /**
         * Suggest users to enable `strictTemplates` to make use of full capabilities
         * provided by Angular language service.
         */
        ErrorCode[ErrorCode["SUGGEST_STRICT_TEMPLATES"] = 10001] = "SUGGEST_STRICT_TEMPLATES";
        /**
         * Indicates that a particular structural directive provides advanced type narrowing
         * functionality, but the current template type-checking configuration does not allow its usage in
         * type inference.
         */
        ErrorCode[ErrorCode["SUGGEST_SUBOPTIMAL_TYPE_INFERENCE"] = 10002] = "SUGGEST_SUBOPTIMAL_TYPE_INFERENCE";
    })(ErrorCode || (ErrorCode = {}));
    /**
     * @internal
     * Base URL for the error details page.
     * Keep this value in sync with a similar const in
     * `packages/core/src/render3/error_code.ts`.
     */
    const ERROR_DETAILS_PAGE_BASE_URL = 'https://angular.io/errors';
    /**
     * @internal
     * Contains a set of error messages that have detailed guides at angular.io.
     * Full list of available error guides can be found at https://angular.io/errors
     */
    const COMPILER_ERRORS_WITH_GUIDES = new Set([
        ErrorCode.DECORATOR_ARG_NOT_LITERAL,
        ErrorCode.IMPORT_CYCLE_DETECTED,
        ErrorCode.PARAM_MISSING_TOKEN,
        ErrorCode.SCHEMA_INVALID_ELEMENT,
        ErrorCode.SCHEMA_INVALID_ATTRIBUTE,
        ErrorCode.MISSING_REFERENCE_TARGET,
        ErrorCode.COMPONENT_INVALID_SHADOW_DOM_SELECTOR,
    ]);
    /**
     * @internal
     */
    function ngErrorCode(code) {
        return parseInt('-99' + code);
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class FatalDiagnosticError {
        constructor(code, node, message, relatedInformation) {
            this.code = code;
            this.node = node;
            this.message = message;
            this.relatedInformation = relatedInformation;
            /**
             * @internal
             */
            this._isFatalDiagnosticError = true;
        }
        toDiagnostic() {
            return makeDiagnostic(this.code, this.node, this.message, this.relatedInformation);
        }
    }
    function makeDiagnostic(code, node, messageText, relatedInformation) {
        node = ts$1.getOriginalNode(node);
        return {
            category: ts$1.DiagnosticCategory.Error,
            code: ngErrorCode(code),
            file: ts$1.getOriginalNode(node).getSourceFile(),
            start: node.getStart(undefined, false),
            length: node.getWidth(),
            messageText,
            relatedInformation,
        };
    }
    function makeRelatedInformation(node, messageText) {
        node = ts$1.getOriginalNode(node);
        return {
            category: ts$1.DiagnosticCategory.Message,
            code: 0,
            file: node.getSourceFile(),
            start: node.getStart(),
            length: node.getWidth(),
            messageText,
        };
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const D_TS = /\.d\.ts$/i;
    function isSymbolWithValueDeclaration(symbol) {
        // If there is a value declaration set, then the `declarations` property is never undefined. We
        // still check for the property to exist as this matches with the type that `symbol` is narrowed
        // to.
        return symbol != null && symbol.valueDeclaration !== undefined &&
            symbol.declarations !== undefined;
    }
    function isDtsPath(filePath) {
        return D_TS.test(filePath);
    }
    function nodeNameForError(node) {
        if (node.name !== undefined && ts$1.isIdentifier(node.name)) {
            return node.name.text;
        }
        else {
            const kind = ts$1.SyntaxKind[node.kind];
            const { line, character } = ts$1.getLineAndCharacterOfPosition(node.getSourceFile(), node.getStart());
            return `${kind}@${line}:${character}`;
        }
    }
    function getSourceFile(node) {
        // In certain transformation contexts, `ts.Node.getSourceFile()` can actually return `undefined`,
        // despite the type signature not allowing it. In that event, get the `ts.SourceFile` via the
        // original node instead (which works).
        const directSf = node.getSourceFile();
        return directSf !== undefined ? directSf : ts$1.getOriginalNode(node).getSourceFile();
    }
    function getSourceFileOrNull(program, fileName) {
        return program.getSourceFile(fileName) || null;
    }
    function getTokenAtPosition(sf, pos) {
        // getTokenAtPosition is part of TypeScript's private API.
        return ts$1.getTokenAtPosition(sf, pos);
    }
    function identifierOfNode(decl) {
        if (decl.name !== undefined && ts$1.isIdentifier(decl.name)) {
            return decl.name;
        }
        else {
            return null;
        }
    }
    function isDeclaration(node) {
        return isValueDeclaration(node) || isTypeDeclaration(node);
    }
    function isValueDeclaration(node) {
        return ts$1.isClassDeclaration(node) || ts$1.isFunctionDeclaration(node) ||
            ts$1.isVariableDeclaration(node);
    }
    function isTypeDeclaration(node) {
        return ts$1.isEnumDeclaration(node) || ts$1.isTypeAliasDeclaration(node) ||
            ts$1.isInterfaceDeclaration(node);
    }
    function isNamedDeclaration(node) {
        const namedNode = node;
        return namedNode.name !== undefined && ts$1.isIdentifier(namedNode.name);
    }
    function getRootDirs(host, options) {
        const rootDirs = [];
        const cwd = host.getCurrentDirectory();
        const fs = getFileSystem();
        if (options.rootDirs !== undefined) {
            rootDirs.push(...options.rootDirs);
        }
        else if (options.rootDir !== undefined) {
            rootDirs.push(options.rootDir);
        }
        else {
            rootDirs.push(cwd);
        }
        // In Windows the above might not always return posix separated paths
        // See:
        // https://github.com/Microsoft/TypeScript/blob/3f7357d37f66c842d70d835bc925ec2a873ecfec/src/compiler/sys.ts#L650
        // Also compiler options might be set via an API which doesn't normalize paths
        return rootDirs.map(rootDir => fs.resolve(cwd, host.getCanonicalFileName(rootDir)));
    }
    function nodeDebugInfo(node) {
        const sf = getSourceFile(node);
        const { line, character } = ts$1.getLineAndCharacterOfPosition(sf, node.pos);
        return `[${sf.fileName}: ${ts$1.SyntaxKind[node.kind]} @ ${line}:${character}]`;
    }
    /**
     * Resolve the specified `moduleName` using the given `compilerOptions` and `compilerHost`.
     *
     * This helper will attempt to use the `CompilerHost.resolveModuleNames()` method if available.
     * Otherwise it will fallback on the `ts.ResolveModuleName()` function.
     */
    function resolveModuleName(moduleName, containingFile, compilerOptions, compilerHost, moduleResolutionCache) {
        if (compilerHost.resolveModuleNames) {
            return compilerHost.resolveModuleNames([moduleName], containingFile, undefined, // reusedNames
            undefined, // redirectedReference
            compilerOptions)[0];
        }
        else {
            return ts$1.resolveModuleName(moduleName, containingFile, compilerOptions, compilerHost, moduleResolutionCache !== null ? moduleResolutionCache : undefined)
                .resolvedModule;
        }
    }
    /** Returns true if the node is an assignment expression. */
    function isAssignment(node) {
        return ts$1.isBinaryExpression(node) && node.operatorToken.kind === ts$1.SyntaxKind.EqualsToken;
    }
    /**
     * Obtains the non-redirected source file for `sf`.
     */
    function toUnredirectedSourceFile(sf) {
        const redirectInfo = sf.redirectInfo;
        if (redirectInfo === undefined) {
            return sf;
        }
        return redirectInfo.unredirected;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Find the name, if any, by which a node is exported from a given file.
     */
    function findExportedNameOfNode(target, file, reflector) {
        const exports = reflector.getExportsOfModule(file);
        if (exports === null) {
            return null;
        }
        const declaredName = isNamedDeclaration(target) ? target.name.text : null;
        // Look for the export which declares the node.
        let foundExportName = null;
        for (const [exportName, declaration] of exports) {
            if (declaration.node !== target) {
                continue;
            }
            if (exportName === declaredName) {
                // A non-alias export exists which is always preferred, so use that one.
                return exportName;
            }
            foundExportName = exportName;
        }
        if (foundExportName === null) {
            throw new Error(`Failed to find exported name of node (${target.getText()}) in '${file.fileName}'.`);
        }
        return foundExportName;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Flags which alter the imports generated by the `ReferenceEmitter`.
     */
    var ImportFlags;
    (function (ImportFlags) {
        ImportFlags[ImportFlags["None"] = 0] = "None";
        /**
         * Force the generation of a new import when generating a reference, even if an identifier already
         * exists in the target file which could be used instead.
         *
         * This is sometimes required if there's a risk TypeScript might remove imports during emit.
         */
        ImportFlags[ImportFlags["ForceNewImport"] = 1] = "ForceNewImport";
        /**
         * Don't make use of any aliasing information when emitting a reference.
         *
         * This is sometimes required if emitting into a context where generated references will be fed
         * into TypeScript and type-checked (such as in template type-checking).
         */
        ImportFlags[ImportFlags["NoAliasing"] = 2] = "NoAliasing";
        /**
         * Indicates that an import to a type-only declaration is allowed.
         *
         * For references that occur in type-positions, the referred declaration may be a type-only
         * declaration that is not retained during emit. Including this flag allows to emit references to
         * type-only declarations as used in e.g. template type-checking.
         */
        ImportFlags[ImportFlags["AllowTypeImports"] = 4] = "AllowTypeImports";
    })(ImportFlags || (ImportFlags = {}));
    /**
     * Generates `Expression`s which refer to `Reference`s in a given context.
     *
     * A `ReferenceEmitter` uses one or more `ReferenceEmitStrategy` implementations to produce an
     * `Expression` which refers to a `Reference` in the context of a particular file.
     */
    class ReferenceEmitter {
        constructor(strategies) {
            this.strategies = strategies;
        }
        emit(ref, context, importFlags = ImportFlags.None) {
            for (const strategy of this.strategies) {
                const emitted = strategy.emit(ref, context, importFlags);
                if (emitted !== null) {
                    return emitted;
                }
            }
            throw new Error(`Unable to write a reference to ${nodeNameForError(ref.node)} in ${ref.node.getSourceFile().fileName} from ${context.fileName}`);
        }
    }
    /**
     * A `ReferenceEmitStrategy` which will refer to declarations by any local `ts.Identifier`s, if
     * such identifiers are available.
     */
    class LocalIdentifierStrategy {
        emit(ref, context, importFlags) {
            const refSf = getSourceFile(ref.node);
            // If the emitter has specified ForceNewImport, then LocalIdentifierStrategy should not use a
            // local identifier at all, *except* in the source file where the node is actually declared.
            if (importFlags & ImportFlags.ForceNewImport && refSf !== context) {
                return null;
            }
            // If referenced node is not an actual TS declaration (e.g. `class Foo` or `function foo() {}`,
            // etc) and it is in the current file then just use it directly.
            // This is important because the reference could be a property access (e.g. `exports.foo`). In
            // such a case, the reference's `identities` property would be `[foo]`, which would result in an
            // invalid emission of a free-standing `foo` identifier, rather than `exports.foo`.
            if (!isDeclaration(ref.node) && refSf === context) {
                return {
                    expression: new WrappedNodeExpr(ref.node),
                    importedFile: null,
                };
            }
            // A Reference can have multiple identities in different files, so it may already have an
            // Identifier in the requested context file.
            const identifier = ref.getIdentityIn(context);
            if (identifier !== null) {
                return {
                    expression: new WrappedNodeExpr(identifier),
                    importedFile: null,
                };
            }
            else {
                return null;
            }
        }
    }
    /**
     * A `ReferenceEmitStrategy` which will refer to declarations that come from `node_modules` using
     * an absolute import.
     *
     * Part of this strategy involves looking at the target entry point and identifying the exported
     * name of the targeted declaration, as it might be different from the declared name (e.g. a
     * directive might be declared as FooDirImpl, but exported as FooDir). If no export can be found
     * which maps back to the original directive, an error is thrown.
     */
    class AbsoluteModuleStrategy {
        constructor(program, checker, moduleResolver, reflectionHost) {
            this.program = program;
            this.checker = checker;
            this.moduleResolver = moduleResolver;
            this.reflectionHost = reflectionHost;
            /**
             * A cache of the exports of specific modules, because resolving a module to its exports is a
             * costly operation.
             */
            this.moduleExportsCache = new Map();
        }
        emit(ref, context, importFlags) {
            if (ref.bestGuessOwningModule === null) {
                // There is no module name available for this Reference, meaning it was arrived at via a
                // relative path.
                return null;
            }
            else if (!isDeclaration(ref.node)) {
                // It's not possible to import something which isn't a declaration.
                throw new Error(`Debug assert: unable to import a Reference to non-declaration of type ${ts$1.SyntaxKind[ref.node.kind]}.`);
            }
            else if ((importFlags & ImportFlags.AllowTypeImports) === 0 && isTypeDeclaration(ref.node)) {
                throw new Error(`Importing a type-only declaration of type ${ts$1.SyntaxKind[ref.node.kind]} in a value position is not allowed.`);
            }
            // Try to find the exported name of the declaration, if one is available.
            const { specifier, resolutionContext } = ref.bestGuessOwningModule;
            const exports = this.getExportsOfModule(specifier, resolutionContext);
            if (exports === null || !exports.exportMap.has(ref.node)) {
                // TODO(alxhub): make this error a ts.Diagnostic pointing at whatever caused this import to be
                // triggered.
                throw new Error(`Symbol ${ref.debugName} declared in ${getSourceFile(ref.node).fileName} is not exported from ${specifier} (import into ${context.fileName})`);
            }
            const symbolName = exports.exportMap.get(ref.node);
            return {
                expression: new ExternalExpr(new ExternalReference(specifier, symbolName)),
                importedFile: exports.module,
            };
        }
        getExportsOfModule(moduleName, fromFile) {
            if (!this.moduleExportsCache.has(moduleName)) {
                this.moduleExportsCache.set(moduleName, this.enumerateExportsOfModule(moduleName, fromFile));
            }
            return this.moduleExportsCache.get(moduleName);
        }
        enumerateExportsOfModule(specifier, fromFile) {
            // First, resolve the module specifier to its entry point, and get the ts.Symbol for it.
            const entryPointFile = this.moduleResolver.resolveModule(specifier, fromFile);
            if (entryPointFile === null) {
                return null;
            }
            const exports = this.reflectionHost.getExportsOfModule(entryPointFile);
            if (exports === null) {
                return null;
            }
            const exportMap = new Map();
            for (const [name, declaration] of exports) {
                if (exportMap.has(declaration.node)) {
                    // An export for this declaration has already been registered. We prefer an export that
                    // has the same name as the declared name, i.e. is not an aliased export. This is relevant
                    // for partial compilations where emitted references should import symbols using a stable
                    // name. This is particularly relevant for declarations inside VE-generated libraries, as
                    // such libraries contain private, unstable reexports of symbols.
                    const existingExport = exportMap.get(declaration.node);
                    if (isNamedDeclaration(declaration.node) && declaration.node.name.text === existingExport) {
                        continue;
                    }
                }
                exportMap.set(declaration.node, name);
            }
            return { module: entryPointFile, exportMap };
        }
    }
    /**
     * A `ReferenceEmitStrategy` which will refer to declarations via relative paths, provided they're
     * both in the logical project "space" of paths.
     *
     * This is trickier than it sounds, as the two files may be in different root directories in the
     * project. Simply calculating a file system relative path between the two is not sufficient.
     * Instead, `LogicalProjectPath`s are used.
     */
    class LogicalProjectStrategy {
        constructor(reflector, logicalFs) {
            this.reflector = reflector;
            this.logicalFs = logicalFs;
        }
        emit(ref, context) {
            const destSf = getSourceFile(ref.node);
            // Compute the relative path from the importing file to the file being imported. This is done
            // as a logical path computation, because the two files might be in different rootDirs.
            const destPath = this.logicalFs.logicalPathOfSf(destSf);
            if (destPath === null) {
                // The imported file is not within the logical project filesystem.
                return null;
            }
            const originPath = this.logicalFs.logicalPathOfSf(context);
            if (originPath === null) {
                throw new Error(`Debug assert: attempt to import from ${context.fileName} but it's outside the program?`);
            }
            // There's no way to emit a relative reference from a file to itself.
            if (destPath === originPath) {
                return null;
            }
            const name = findExportedNameOfNode(ref.node, destSf, this.reflector);
            if (name === null) {
                // The target declaration isn't exported from the file it's declared in. This is an issue!
                return null;
            }
            // With both files expressed as LogicalProjectPaths, getting the module specifier as a relative
            // path is now straightforward.
            const moduleName = LogicalProjectPath.relativePathBetween(originPath, destPath);
            return {
                expression: new ExternalExpr({ moduleName, name }),
                importedFile: destSf,
            };
        }
    }
    /**
     * A `ReferenceEmitStrategy` which constructs relatives paths between `ts.SourceFile`s.
     *
     * This strategy can be used if there is no `rootDir`/`rootDirs` structure for the project which
     * necessitates the stronger logic of `LogicalProjectStrategy`.
     */
    class RelativePathStrategy {
        constructor(reflector) {
            this.reflector = reflector;
        }
        emit(ref, context) {
            const destSf = getSourceFile(ref.node);
            const relativePath = relative(dirname(absoluteFromSourceFile(context)), absoluteFromSourceFile(destSf));
            const moduleName = toRelativeImport(stripExtension(relativePath));
            const name = findExportedNameOfNode(ref.node, destSf, this.reflector);
            return { expression: new ExternalExpr({ moduleName, name }), importedFile: destSf };
        }
    }
    /**
     * A `ReferenceEmitStrategy` which uses a `UnifiedModulesHost` to generate absolute import
     * references.
     */
    class UnifiedModulesStrategy {
        constructor(reflector, unifiedModulesHost) {
            this.reflector = reflector;
            this.unifiedModulesHost = unifiedModulesHost;
        }
        emit(ref, context) {
            const destSf = getSourceFile(ref.node);
            const name = findExportedNameOfNode(ref.node, destSf, this.reflector);
            if (name === null) {
                return null;
            }
            const moduleName = this.unifiedModulesHost.fileNameToModuleName(destSf.fileName, context.fileName);
            return {
                expression: new ExternalExpr({ moduleName, name }),
                importedFile: destSf,
            };
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    // Escape anything that isn't alphanumeric, '/' or '_'.
    const CHARS_TO_ESCAPE = /[^a-zA-Z0-9/_]/g;
    /**
     * An `AliasingHost` which generates and consumes alias re-exports when module names for each file
     * are determined by a `UnifiedModulesHost`.
     *
     * When using a `UnifiedModulesHost`, aliasing prevents issues with transitive dependencies. See the
     * README.md for more details.
     */
    class UnifiedModulesAliasingHost {
        constructor(unifiedModulesHost) {
            this.unifiedModulesHost = unifiedModulesHost;
            /**
             * With a `UnifiedModulesHost`, aliases are chosen automatically without the need to look through
             * the exports present in a .d.ts file, so we can avoid cluttering the .d.ts files.
             */
            this.aliasExportsInDts = false;
        }
        maybeAliasSymbolAs(ref, context, ngModuleName, isReExport) {
            if (!isReExport) {
                // Aliasing is used with a UnifiedModulesHost to prevent transitive dependencies. Thus,
                // aliases
                // only need to be created for directives/pipes which are not direct declarations of an
                // NgModule which exports them.
                return null;
            }
            return this.aliasName(ref.node, context);
        }
        /**
         * Generates an `Expression` to import `decl` from `via`, assuming an export was added when `via`
         * was compiled per `maybeAliasSymbolAs` above.
         */
        getAliasIn(decl, via, isReExport) {
            if (!isReExport) {
                // Directly exported directives/pipes don't require an alias, per the logic in
                // `maybeAliasSymbolAs`.
                return null;
            }
            // viaModule is the module it'll actually be imported from.
            const moduleName = this.unifiedModulesHost.fileNameToModuleName(via.fileName, via.fileName);
            return new ExternalExpr({ moduleName, name: this.aliasName(decl, via) });
        }
        /**
         * Generates an alias name based on the full module name of the file which declares the aliased
         * directive/pipe.
         */
        aliasName(decl, context) {
            // The declared module is used to get the name of the alias.
            const declModule = this.unifiedModulesHost.fileNameToModuleName(decl.getSourceFile().fileName, context.fileName);
            const replaced = declModule.replace(CHARS_TO_ESCAPE, '_').replace(/\//g, '$');
            return 'ng$' + replaced + '$$' + decl.name.text;
        }
    }
    /**
     * An `AliasingHost` which exports directives from any file containing an NgModule in which they're
     * declared/exported, under a private symbol name.
     *
     * These exports support cases where an NgModule is imported deeply from an absolute module path
     * (that is, it's not part of an Angular Package Format entrypoint), and the compiler needs to
     * import any matched directives/pipes from the same path (to the NgModule file). See README.md for
     * more details.
     */
    class PrivateExportAliasingHost {
        constructor(host) {
            this.host = host;
            /**
             * Under private export aliasing, the `AbsoluteModuleStrategy` used for emitting references will
             * will select aliased exports that it finds in the .d.ts file for an NgModule's file. Thus,
             * emitting these exports in .d.ts is a requirement for the `PrivateExportAliasingHost` to
             * function correctly.
             */
            this.aliasExportsInDts = true;
        }
        maybeAliasSymbolAs(ref, context, ngModuleName) {
            if (ref.hasOwningModuleGuess) {
                // Skip nodes that already have an associated absolute module specifier, since they can be
                // safely imported from that specifier.
                return null;
            }
            // Look for a user-provided export of `decl` in `context`. If one exists, then an alias export
            // is not needed.
            // TODO(alxhub): maybe add a host method to check for the existence of an export without going
            // through the entire list of exports.
            const exports = this.host.getExportsOfModule(context);
            if (exports === null) {
                // Something went wrong, and no exports were available at all. Bail rather than risk creating
                // re-exports when they're not needed.
                throw new Error(`Could not determine the exports of: ${context.fileName}`);
            }
            let found = false;
            exports.forEach(value => {
                if (value.node === ref.node) {
                    found = true;
                }
            });
            if (found) {
                // The module exports the declared class directly, no alias is necessary.
                return null;
            }
            return `ngExport${ngModuleName}${ref.node.name.text}`;
        }
        /**
         * A `PrivateExportAliasingHost` only generates re-exports and does not direct the compiler to
         * directly consume the aliases it creates.
         *
         * Instead, they're consumed indirectly: `AbsoluteModuleStrategy` `ReferenceEmitterStrategy` will
         * select these alias exports automatically when looking for an export of the directive/pipe from
         * the same path as the NgModule was imported.
         *
         * Thus, `getAliasIn` always returns `null`.
         */
        getAliasIn() {
            return null;
        }
    }
    /**
     * A `ReferenceEmitStrategy` which will consume the alias attached to a particular `Reference` to a
     * directive or pipe, if it exists.
     */
    class AliasStrategy {
        emit(ref, context, importMode) {
            if (importMode & ImportFlags.NoAliasing || ref.alias === null) {
                return null;
            }
            return { expression: ref.alias, importedFile: 'unknown' };
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function relativePathBetween(from, to) {
        const relativePath = stripExtension(relative(dirname(resolve(from)), resolve(to)));
        return relativePath !== '' ? toRelativeImport(relativePath) : null;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * `ImportRewriter` that does no rewriting.
     */
    class NoopImportRewriter {
        shouldImportSymbol(symbol, specifier) {
            return true;
        }
        rewriteSymbol(symbol, specifier) {
            return symbol;
        }
        rewriteSpecifier(specifier, inContextOfFile) {
            return specifier;
        }
    }
    /**
     * A mapping of supported symbols that can be imported from within @angular/core, and the names by
     * which they're exported from r3_symbols.
     */
    const CORE_SUPPORTED_SYMBOLS = new Map([
        ['defineInjectable', 'defineInjectable'],
        ['defineInjector', 'defineInjector'],
        ['defineNgModule', 'defineNgModule'],
        ['setNgModuleScope', 'setNgModuleScope'],
        ['inject', 'inject'],
        ['FactoryDeclaration', 'FactoryDeclaration'],
        ['setClassMetadata', 'setClassMetadata'],
        ['InjectableDeclaration', 'InjectableDeclaration'],
        ['InjectorDeclaration', 'InjectorDeclaration'],
        ['NgModuleDeclaration', 'NgModuleDeclaration'],
        ['NgModuleFactory', 'NgModuleFactory'],
        ['noSideEffects', 'noSideEffects'],
    ]);
    const CORE_MODULE = '@angular/core';
    /**
     * `ImportRewriter` that rewrites imports from '@angular/core' to be imported from the r3_symbols.ts
     * file instead.
     */
    class R3SymbolsImportRewriter {
        constructor(r3SymbolsPath) {
            this.r3SymbolsPath = r3SymbolsPath;
        }
        shouldImportSymbol(symbol, specifier) {
            return true;
        }
        rewriteSymbol(symbol, specifier) {
            if (specifier !== CORE_MODULE) {
                // This import isn't from core, so ignore it.
                return symbol;
            }
            return validateAndRewriteCoreSymbol(symbol);
        }
        rewriteSpecifier(specifier, inContextOfFile) {
            if (specifier !== CORE_MODULE) {
                // This module isn't core, so ignore it.
                return specifier;
            }
            const relativePathToR3Symbols = relativePathBetween(inContextOfFile, this.r3SymbolsPath);
            if (relativePathToR3Symbols === null) {
                throw new Error(`Failed to rewrite import inside ${CORE_MODULE}: ${inContextOfFile} -> ${this.r3SymbolsPath}`);
            }
            return relativePathToR3Symbols;
        }
    }
    function validateAndRewriteCoreSymbol(name) {
        if (!CORE_SUPPORTED_SYMBOLS.has(name)) {
            throw new Error(`Importing unexpected symbol ${name} while compiling ${CORE_MODULE}`);
        }
        return CORE_SUPPORTED_SYMBOLS.get(name);
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const DefaultImportDeclaration = Symbol('DefaultImportDeclaration');
    /**
     * Attaches a default import declaration to `expr` to indicate the dependency of `expr` on the
     * default import.
     */
    function attachDefaultImportDeclaration(expr, importDecl) {
        expr[DefaultImportDeclaration] = importDecl;
    }
    /**
     * Obtains the default import declaration that `expr` depends on, or `null` if there is no such
     * dependency.
     */
    function getDefaultImportDeclaration(expr) {
        var _a;
        return (_a = expr[DefaultImportDeclaration]) !== null && _a !== void 0 ? _a : null;
    }
    /**
     * TypeScript has trouble with generating default imports inside of transformers for some module
     * formats. The issue is that for the statement:
     *
     * import X from 'some/module';
     * console.log(X);
     *
     * TypeScript will not use the "X" name in generated code. For normal user code, this is fine
     * because references to X will also be renamed. However, if both the import and any references are
     * added in a transformer, TypeScript does not associate the two, and will leave the "X" references
     * dangling while renaming the import variable. The generated code looks something like:
     *
     * const module_1 = require('some/module');
     * console.log(X); // now X is a dangling reference.
     *
     * Therefore, we cannot synthetically add default imports, and must reuse the imports that users
     * include. Doing this poses a challenge for imports that are only consumed in the type position in
     * the user's code. If Angular reuses the imported symbol in a value position (for example, we
     * see a constructor parameter of type Foo and try to write "inject(Foo)") we will also end up with
     * a dangling reference, as TS will elide the import because it was only used in the type position
     * originally.
     *
     * To avoid this, the compiler must "touch" the imports with `ts.getMutableClone`, and should
     * only do this for imports which are actually consumed. The `DefaultImportTracker` keeps track of
     * these imports as they're encountered and emitted, and implements a transform which can correctly
     * flag the imports as required.
     *
     * This problem does not exist for non-default imports as the compiler can easily insert
     * "import * as X" style imports for those, and the "X" identifier survives transformation.
     */
    class DefaultImportTracker {
        constructor() {
            /**
             * A `Map` which tracks the `Set` of `ts.ImportDeclaration`s for default imports that were used in
             * a given `ts.SourceFile` and need to be preserved.
             */
            this.sourceFileToUsedImports = new Map();
        }
        recordUsedImport(importDecl) {
            const sf = getSourceFile(importDecl);
            // Add the default import declaration to the set of used import declarations for the file.
            if (!this.sourceFileToUsedImports.has(sf)) {
                this.sourceFileToUsedImports.set(sf, new Set());
            }
            this.sourceFileToUsedImports.get(sf).add(importDecl);
        }
        /**
         * Get a `ts.TransformerFactory` which will preserve default imports that were previously marked
         * as used.
         *
         * This transformer must run after any other transformers which call `recordUsedImport`.
         */
        importPreservingTransformer() {
            return (context) => {
                return (sf) => {
                    return this.transformSourceFile(sf);
                };
            };
        }
        /**
         * Process a `ts.SourceFile` and replace any `ts.ImportDeclaration`s.
         */
        transformSourceFile(sf) {
            const originalSf = ts$1.getOriginalNode(sf);
            // Take a fast path if no import declarations need to be preserved in the file.
            if (!this.sourceFileToUsedImports.has(originalSf)) {
                return sf;
            }
            // There are declarations that need to be preserved.
            const importsToPreserve = this.sourceFileToUsedImports.get(originalSf);
            // Generate a new statement list which preserves any imports present in `importsToPreserve`.
            const statements = sf.statements.map(stmt => {
                if (ts$1.isImportDeclaration(stmt) && importsToPreserve.has(stmt)) {
                    // Preserving an import that's marked as unreferenced (type-only) is tricky in TypeScript.
                    //
                    // Various approaches have been tried, with mixed success:
                    //
                    // 1. Using `ts.updateImportDeclaration` does not cause the import to be retained.
                    //
                    // 2. Using `ts.createImportDeclaration` with the same `ts.ImportClause` causes the import
                    //    to correctly be retained, but when emitting CommonJS module format code, references
                    //    to the imported value will not match the import variable.
                    //
                    // 3. Emitting "import * as" imports instead generates the correct import variable, but
                    //    references are missing the ".default" access. This happens to work for tsickle code
                    //    with goog.module transformations as tsickle strips the ".default" anyway.
                    //
                    // 4. It's possible to trick TypeScript by setting `ts.NodeFlag.Synthesized` on the import
                    //    declaration. This causes the import to be correctly retained and generated, but can
                    //    violate invariants elsewhere in the compiler and cause crashes.
                    //
                    // 5. Using `ts.getMutableClone` seems to correctly preserve the import and correctly
                    //    generate references to the import variable across all module types.
                    //
                    // Therefore, option 5 is the one used here. It seems to be implemented as the correct way
                    // to perform option 4, which preserves all the compiler's invariants.
                    //
                    // TODO(alxhub): discuss with the TypeScript team and determine if there's a better way to
                    // deal with this issue.
                    stmt = ts$1.getMutableClone(stmt);
                }
                return stmt;
            });
            // Save memory - there's no need to keep these around once the transform has run for the given
            // file.
            this.sourceFileToUsedImports.delete(originalSf);
            return ts$1.updateSourceFileNode(sf, statements);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A `ts.Node` plus the context in which it was discovered.
     *
     * A `Reference` is a pointer to a `ts.Node` that was extracted from the program somehow. It
     * contains not only the node itself, but the information regarding how the node was located. In
     * particular, it might track different identifiers by which the node is exposed, as well as
     * potentially a module specifier which might expose the node.
     *
     * The Angular compiler uses `Reference`s instead of `ts.Node`s when tracking classes or generating
     * imports.
     */
    class Reference$1 {
        constructor(node, bestGuessOwningModule = null) {
            this.node = node;
            this.identifiers = [];
            /**
             * Indicates that the Reference was created synthetically, not as a result of natural value
             * resolution.
             *
             * This is used to avoid misinterpreting the Reference in certain contexts.
             */
            this.synthetic = false;
            this._alias = null;
            this.bestGuessOwningModule = bestGuessOwningModule;
            const id = identifierOfNode(node);
            if (id !== null) {
                this.identifiers.push(id);
            }
        }
        /**
         * The best guess at which module specifier owns this particular reference, or `null` if there
         * isn't one.
         */
        get ownedByModuleGuess() {
            if (this.bestGuessOwningModule !== null) {
                return this.bestGuessOwningModule.specifier;
            }
            else {
                return null;
            }
        }
        /**
         * Whether this reference has a potential owning module or not.
         *
         * See `bestGuessOwningModule`.
         */
        get hasOwningModuleGuess() {
            return this.bestGuessOwningModule !== null;
        }
        /**
         * A name for the node, if one is available.
         *
         * This is only suited for debugging. Any actual references to this node should be made with
         * `ts.Identifier`s (see `getIdentityIn`).
         */
        get debugName() {
            const id = identifierOfNode(this.node);
            return id !== null ? id.text : null;
        }
        get alias() {
            return this._alias;
        }
        /**
         * Record a `ts.Identifier` by which it's valid to refer to this node, within the context of this
         * `Reference`.
         */
        addIdentifier(identifier) {
            this.identifiers.push(identifier);
        }
        /**
         * Get a `ts.Identifier` within this `Reference` that can be used to refer within the context of a
         * given `ts.SourceFile`, if any.
         */
        getIdentityIn(context) {
            return this.identifiers.find(id => id.getSourceFile() === context) || null;
        }
        /**
         * Get a `ts.Identifier` for this `Reference` that exists within the given expression.
         *
         * This is very useful for producing `ts.Diagnostic`s that reference `Reference`s that were
         * extracted from some larger expression, as it can be used to pinpoint the `ts.Identifier` within
         * the expression from which the `Reference` originated.
         */
        getIdentityInExpression(expr) {
            const sf = expr.getSourceFile();
            return this.identifiers.find(id => {
                if (id.getSourceFile() !== sf) {
                    return false;
                }
                // This identifier is a match if its position lies within the given expression.
                return id.pos >= expr.pos && id.end <= expr.end;
            }) ||
                null;
        }
        /**
         * Given the 'container' expression from which this `Reference` was extracted, produce a
         * `ts.Expression` to use in a diagnostic which best indicates the position within the container
         * expression that generated the `Reference`.
         *
         * For example, given a `Reference` to the class 'Bar' and the containing expression:
         * `[Foo, Bar, Baz]`, this function would attempt to return the `ts.Identifier` for `Bar` within
         * the array. This could be used to produce a nice diagnostic context:
         *
         * ```text
         * [Foo, Bar, Baz]
         *       ~~~
         * ```
         *
         * If no specific node can be found, then the `fallback` expression is used, which defaults to the
         * entire containing expression.
         */
        getOriginForDiagnostics(container, fallback = container) {
            const id = this.getIdentityInExpression(container);
            return id !== null ? id : fallback;
        }
        cloneWithAlias(alias) {
            const ref = new Reference$1(this.node, this.bestGuessOwningModule);
            ref.identifiers = [...this.identifiers];
            ref._alias = alias;
            return ref;
        }
        cloneWithNoIdentifiers() {
            const ref = new Reference$1(this.node, this.bestGuessOwningModule);
            ref._alias = this._alias;
            ref.identifiers = [];
            return ref;
        }
    }

    /**
     * Used by `RouterEntryPointManager` and `NgModuleRouteAnalyzer` (which is in turn is used by
     * `NgModuleDecoratorHandler`) for resolving the module source-files references in lazy-loaded
     * routes (relative to the source-file containing the `NgModule` that provides the route
     * definitions).
     */
    class ModuleResolver {
        constructor(program, compilerOptions, host, moduleResolutionCache) {
            this.program = program;
            this.compilerOptions = compilerOptions;
            this.host = host;
            this.moduleResolutionCache = moduleResolutionCache;
        }
        resolveModule(moduleName, containingFile) {
            const resolved = resolveModuleName(moduleName, containingFile, this.compilerOptions, this.host, this.moduleResolutionCache);
            if (resolved === undefined) {
                return null;
            }
            return getSourceFileOrNull(this.program, absoluteFrom(resolved.resolvedFileName));
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Represents a symbol that is recognizable across incremental rebuilds, which enables the captured
     * metadata to be compared to the prior compilation. This allows for semantic understanding of
     * the changes that have been made in a rebuild, which potentially enables more reuse of work
     * from the prior compilation.
     */
    class SemanticSymbol {
        constructor(
        /**
         * The declaration for this symbol.
         */
        decl) {
            this.decl = decl;
            this.path = absoluteFromSourceFile(decl.getSourceFile());
            this.identifier = getSymbolIdentifier(decl);
        }
    }
    function getSymbolIdentifier(decl) {
        if (!ts$1.isSourceFile(decl.parent)) {
            return null;
        }
        // If this is a top-level class declaration, the class name is used as unique identifier.
        // Other scenarios are currently not supported and causes the symbol not to be identified
        // across rebuilds, unless the declaration node has not changed.
        return decl.name.text;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Represents a declaration for which no semantic symbol has been registered. For example,
     * declarations from external dependencies have not been explicitly registered and are represented
     * by this symbol. This allows the unresolved symbol to still be compared to a symbol from a prior
     * compilation.
     */
    class OpaqueSymbol extends SemanticSymbol {
        isPublicApiAffected() {
            return false;
        }
        isTypeCheckApiAffected() {
            return false;
        }
    }
    /**
     * The semantic dependency graph of a single compilation.
     */
    class SemanticDepGraph {
        constructor() {
            this.files = new Map();
            this.symbolByDecl = new Map();
        }
        /**
         * Registers a symbol in the graph. The symbol is given a unique identifier if possible, such that
         * its equivalent symbol can be obtained from a prior graph even if its declaration node has
         * changed across rebuilds. Symbols without an identifier are only able to find themselves in a
         * prior graph if their declaration node is identical.
         */
        registerSymbol(symbol) {
            this.symbolByDecl.set(symbol.decl, symbol);
            if (symbol.identifier !== null) {
                // If the symbol has a unique identifier, record it in the file that declares it. This enables
                // the symbol to be requested by its unique name.
                if (!this.files.has(symbol.path)) {
                    this.files.set(symbol.path, new Map());
                }
                this.files.get(symbol.path).set(symbol.identifier, symbol);
            }
        }
        /**
         * Attempts to resolve a symbol in this graph that represents the given symbol from another graph.
         * If no matching symbol could be found, null is returned.
         *
         * @param symbol The symbol from another graph for which its equivalent in this graph should be
         * found.
         */
        getEquivalentSymbol(symbol) {
            // First lookup the symbol by its declaration. It is typical for the declaration to not have
            // changed across rebuilds, so this is likely to find the symbol. Using the declaration also
            // allows to diff symbols for which no unique identifier could be determined.
            let previousSymbol = this.getSymbolByDecl(symbol.decl);
            if (previousSymbol === null && symbol.identifier !== null) {
                // The declaration could not be resolved to a symbol in a prior compilation, which may
                // happen because the file containing the declaration has changed. In that case we want to
                // lookup the symbol based on its unique identifier, as that allows us to still compare the
                // changed declaration to the prior compilation.
                previousSymbol = this.getSymbolByName(symbol.path, symbol.identifier);
            }
            return previousSymbol;
        }
        /**
         * Attempts to find the symbol by its identifier.
         */
        getSymbolByName(path, identifier) {
            if (!this.files.has(path)) {
                return null;
            }
            const file = this.files.get(path);
            if (!file.has(identifier)) {
                return null;
            }
            return file.get(identifier);
        }
        /**
         * Attempts to resolve the declaration to its semantic symbol.
         */
        getSymbolByDecl(decl) {
            if (!this.symbolByDecl.has(decl)) {
                return null;
            }
            return this.symbolByDecl.get(decl);
        }
    }
    /**
     * Implements the logic to go from a previous dependency graph to a new one, along with information
     * on which files have been affected.
     */
    class SemanticDepGraphUpdater {
        constructor(
        /**
         * The semantic dependency graph of the most recently succeeded compilation, or null if this
         * is the initial build.
         */
        priorGraph) {
            this.priorGraph = priorGraph;
            this.newGraph = new SemanticDepGraph();
            /**
             * Contains opaque symbols that were created for declarations for which there was no symbol
             * registered, which happens for e.g. external declarations.
             */
            this.opaqueSymbols = new Map();
        }
        /**
         * Registers the symbol in the new graph that is being created.
         */
        registerSymbol(symbol) {
            this.newGraph.registerSymbol(symbol);
        }
        /**
         * Takes all facts that have been gathered to create a new semantic dependency graph. In this
         * process, the semantic impact of the changes is determined which results in a set of files that
         * need to be emitted and/or type-checked.
         */
        finalize() {
            if (this.priorGraph === null) {
                // If no prior dependency graph is available then this was the initial build, in which case
                // we don't need to determine the semantic impact as everything is already considered
                // logically changed.
                return {
                    needsEmit: new Set(),
                    needsTypeCheckEmit: new Set(),
                    newGraph: this.newGraph,
                };
            }
            const needsEmit = this.determineInvalidatedFiles(this.priorGraph);
            const needsTypeCheckEmit = this.determineInvalidatedTypeCheckFiles(this.priorGraph);
            return {
                needsEmit,
                needsTypeCheckEmit,
                newGraph: this.newGraph,
            };
        }
        determineInvalidatedFiles(priorGraph) {
            const isPublicApiAffected = new Set();
            // The first phase is to collect all symbols which have their public API affected. Any symbols
            // that cannot be matched up with a symbol from the prior graph are considered affected.
            for (const symbol of this.newGraph.symbolByDecl.values()) {
                const previousSymbol = priorGraph.getEquivalentSymbol(symbol);
                if (previousSymbol === null || symbol.isPublicApiAffected(previousSymbol)) {
                    isPublicApiAffected.add(symbol);
                }
            }
            // The second phase is to find all symbols for which the emit result is affected, either because
            // their used declarations have changed or any of those used declarations has had its public API
            // affected as determined in the first phase.
            const needsEmit = new Set();
            for (const symbol of this.newGraph.symbolByDecl.values()) {
                if (symbol.isEmitAffected === undefined) {
                    continue;
                }
                const previousSymbol = priorGraph.getEquivalentSymbol(symbol);
                if (previousSymbol === null || symbol.isEmitAffected(previousSymbol, isPublicApiAffected)) {
                    needsEmit.add(symbol.path);
                }
            }
            return needsEmit;
        }
        determineInvalidatedTypeCheckFiles(priorGraph) {
            const isTypeCheckApiAffected = new Set();
            // The first phase is to collect all symbols which have their public API affected. Any symbols
            // that cannot be matched up with a symbol from the prior graph are considered affected.
            for (const symbol of this.newGraph.symbolByDecl.values()) {
                const previousSymbol = priorGraph.getEquivalentSymbol(symbol);
                if (previousSymbol === null || symbol.isTypeCheckApiAffected(previousSymbol)) {
                    isTypeCheckApiAffected.add(symbol);
                }
            }
            // The second phase is to find all symbols for which the emit result is affected, either because
            // their used declarations have changed or any of those used declarations has had its public API
            // affected as determined in the first phase.
            const needsTypeCheckEmit = new Set();
            for (const symbol of this.newGraph.symbolByDecl.values()) {
                if (symbol.isTypeCheckBlockAffected === undefined) {
                    continue;
                }
                const previousSymbol = priorGraph.getEquivalentSymbol(symbol);
                if (previousSymbol === null ||
                    symbol.isTypeCheckBlockAffected(previousSymbol, isTypeCheckApiAffected)) {
                    needsTypeCheckEmit.add(symbol.path);
                }
            }
            return needsTypeCheckEmit;
        }
        /**
         * Creates a `SemanticReference` for the reference to `decl` using the expression `expr`. See
         * the documentation of `SemanticReference` for details.
         */
        getSemanticReference(decl, expr) {
            return {
                symbol: this.getSymbol(decl),
                importPath: getImportPath(expr),
            };
        }
        /**
         * Gets the `SemanticSymbol` that was registered for `decl` during the current compilation, or
         * returns an opaque symbol that represents `decl`.
         */
        getSymbol(decl) {
            const symbol = this.newGraph.getSymbolByDecl(decl);
            if (symbol === null) {
                // No symbol has been recorded for the provided declaration, which would be the case if the
                // declaration is external. Return an opaque symbol in that case, to allow the external
                // declaration to be compared to a prior compilation.
                return this.getOpaqueSymbol(decl);
            }
            return symbol;
        }
        /**
         * Gets or creates an `OpaqueSymbol` for the provided class declaration.
         */
        getOpaqueSymbol(decl) {
            if (this.opaqueSymbols.has(decl)) {
                return this.opaqueSymbols.get(decl);
            }
            const symbol = new OpaqueSymbol(decl);
            this.opaqueSymbols.set(decl, symbol);
            return symbol;
        }
    }
    function getImportPath(expr) {
        if (expr instanceof ExternalExpr) {
            return `${expr.value.moduleName}\$${expr.value.name}`;
        }
        else {
            return null;
        }
    }

    /**
     * Determines whether the provided symbols represent the same declaration.
     */
    function isSymbolEqual(a, b) {
        if (a.decl === b.decl) {
            // If the declaration is identical then it must represent the same symbol.
            return true;
        }
        if (a.identifier === null || b.identifier === null) {
            // Unidentifiable symbols are assumed to be different.
            return false;
        }
        return a.path === b.path && a.identifier === b.identifier;
    }
    /**
     * Determines whether the provided references to a semantic symbol are still equal, i.e. represent
     * the same symbol and are imported by the same path.
     */
    function isReferenceEqual(a, b) {
        if (!isSymbolEqual(a.symbol, b.symbol)) {
            // If the reference's target symbols are different, the reference itself is different.
            return false;
        }
        // The reference still corresponds with the same symbol, now check that the path by which it is
        // imported has not changed.
        return a.importPath === b.importPath;
    }
    function referenceEquality(a, b) {
        return a === b;
    }
    /**
     * Determines if the provided arrays are equal to each other, using the provided equality tester
     * that is called for all entries in the array.
     */
    function isArrayEqual(a, b, equalityTester = referenceEquality) {
        if (a === null || b === null) {
            return a === b;
        }
        if (a.length !== b.length) {
            return false;
        }
        return !a.some((item, index) => !equalityTester(item, b[index]));
    }
    /**
     * Determines if the provided sets are equal to each other, using the provided equality tester.
     * Sets that only differ in ordering are considered equal.
     */
    function isSetEqual(a, b, equalityTester = referenceEquality) {
        if (a === null || b === null) {
            return a === b;
        }
        if (a.size !== b.size) {
            return false;
        }
        for (const itemA of a) {
            let found = false;
            for (const itemB of b) {
                if (equalityTester(itemA, itemB)) {
                    found = true;
                    break;
                }
            }
            if (!found) {
                return false;
            }
        }
        return true;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Converts the type parameters of the given class into their semantic representation. If the class
     * does not have any type parameters, then `null` is returned.
     */
    function extractSemanticTypeParameters(node) {
        if (!ts$1.isClassDeclaration(node) || node.typeParameters === undefined) {
            return null;
        }
        return node.typeParameters.map(typeParam => ({ hasGenericTypeBound: typeParam.constraint !== undefined }));
    }
    /**
     * Compares the list of type parameters to determine if they can be considered equal.
     */
    function areTypeParametersEqual(current, previous) {
        // First compare all type parameters one-to-one; any differences mean that the list of type
        // parameters has changed.
        if (!isArrayEqual(current, previous, isTypeParameterEqual)) {
            return false;
        }
        // If there is a current list of type parameters and if any of them has a generic type constraint,
        // then the meaning of that type parameter may have changed without us being aware; as such we
        // have to assume that the type parameters have in fact changed.
        if (current !== null && current.some(typeParam => typeParam.hasGenericTypeBound)) {
            return false;
        }
        return true;
    }
    function isTypeParameterEqual(a, b) {
        return a.hasGenericTypeBound === b.hasGenericTypeBound;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var MetaType;
    (function (MetaType) {
        MetaType[MetaType["Pipe"] = 0] = "Pipe";
        MetaType[MetaType["Directive"] = 1] = "Directive";
    })(MetaType || (MetaType = {}));

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const Decorator = {
        nodeForError: (decorator) => {
            if (decorator.node !== null) {
                return decorator.node;
            }
            else {
                // TODO(alxhub): we can't rely on narrowing until TS 3.6 is in g3.
                return decorator.synthesizedFor;
            }
        },
    };
    function isDecoratorIdentifier(exp) {
        return ts$1.isIdentifier(exp) ||
            ts$1.isPropertyAccessExpression(exp) && ts$1.isIdentifier(exp.expression) &&
                ts$1.isIdentifier(exp.name);
    }
    /**
     * An enumeration of possible kinds of class members.
     */
    var ClassMemberKind;
    (function (ClassMemberKind) {
        ClassMemberKind[ClassMemberKind["Constructor"] = 0] = "Constructor";
        ClassMemberKind[ClassMemberKind["Getter"] = 1] = "Getter";
        ClassMemberKind[ClassMemberKind["Setter"] = 2] = "Setter";
        ClassMemberKind[ClassMemberKind["Property"] = 3] = "Property";
        ClassMemberKind[ClassMemberKind["Method"] = 4] = "Method";
    })(ClassMemberKind || (ClassMemberKind = {}));
    /**
     * Possible declarations of known values, such as built-in objects/functions or TypeScript helpers.
     */
    var KnownDeclaration;
    (function (KnownDeclaration) {
        /**
         * Indicates the JavaScript global `Object` class.
         */
        KnownDeclaration[KnownDeclaration["JsGlobalObject"] = 0] = "JsGlobalObject";
        /**
         * Indicates the `__assign` TypeScript helper function.
         */
        KnownDeclaration[KnownDeclaration["TsHelperAssign"] = 1] = "TsHelperAssign";
        /**
         * Indicates the `__spread` TypeScript helper function.
         */
        KnownDeclaration[KnownDeclaration["TsHelperSpread"] = 2] = "TsHelperSpread";
        /**
         * Indicates the `__spreadArrays` TypeScript helper function.
         */
        KnownDeclaration[KnownDeclaration["TsHelperSpreadArrays"] = 3] = "TsHelperSpreadArrays";
        /**
         * Indicates the `__spreadArray` TypeScript helper function.
         */
        KnownDeclaration[KnownDeclaration["TsHelperSpreadArray"] = 4] = "TsHelperSpreadArray";
        /**
         * Indicates the `__read` TypeScript helper function.
         */
        KnownDeclaration[KnownDeclaration["TsHelperRead"] = 5] = "TsHelperRead";
    })(KnownDeclaration || (KnownDeclaration = {}));
    /**
     * Returns true if the `decl` is a `ConcreteDeclaration` (ie. that its `node` property is a
     * `ts.Declaration`).
     */
    function isConcreteDeclaration(decl) {
        return decl.kind === 0 /* Concrete */;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Potentially convert a `ts.TypeNode` to a `TypeValueReference`, which indicates how to use the
     * type given in the `ts.TypeNode` in a value position.
     *
     * This can return `null` if the `typeNode` is `null`, if it does not refer to a symbol with a value
     * declaration, or if it is not possible to statically understand.
     */
    function typeToValue(typeNode, checker) {
        // It's not possible to get a value expression if the parameter doesn't even have a type.
        if (typeNode === null) {
            return missingType();
        }
        if (!ts$1.isTypeReferenceNode(typeNode)) {
            return unsupportedType(typeNode);
        }
        const symbols = resolveTypeSymbols(typeNode, checker);
        if (symbols === null) {
            return unknownReference(typeNode);
        }
        const { local, decl } = symbols;
        // It's only valid to convert a type reference to a value reference if the type actually
        // has a value declaration associated with it. Note that const enums are an exception,
        // because while they do have a value declaration, they don't exist at runtime.
        if (decl.valueDeclaration === undefined || decl.flags & ts$1.SymbolFlags.ConstEnum) {
            let typeOnlyDecl = null;
            if (decl.declarations !== undefined && decl.declarations.length > 0) {
                typeOnlyDecl = decl.declarations[0];
            }
            return noValueDeclaration(typeNode, typeOnlyDecl);
        }
        // The type points to a valid value declaration. Rewrite the TypeReference into an
        // Expression which references the value pointed to by the TypeReference, if possible.
        // Look at the local `ts.Symbol`'s declarations and see if it comes from an import
        // statement. If so, extract the module specifier and the name of the imported type.
        const firstDecl = local.declarations && local.declarations[0];
        if (firstDecl !== undefined) {
            if (ts$1.isImportClause(firstDecl) && firstDecl.name !== undefined) {
                // This is a default import.
                //   import Foo from 'foo';
                if (firstDecl.isTypeOnly) {
                    // Type-only imports cannot be represented as value.
                    return typeOnlyImport(typeNode, firstDecl);
                }
                return {
                    kind: 0 /* LOCAL */,
                    expression: firstDecl.name,
                    defaultImportStatement: firstDecl.parent,
                };
            }
            else if (ts$1.isImportSpecifier(firstDecl)) {
                // The symbol was imported by name
                //   import {Foo} from 'foo';
                // or
                //   import {Foo as Bar} from 'foo';
                if (firstDecl.parent.parent.isTypeOnly) {
                    // Type-only imports cannot be represented as value.
                    return typeOnlyImport(typeNode, firstDecl.parent.parent);
                }
                // Determine the name to import (`Foo`) from the import specifier, as the symbol names of
                // the imported type could refer to a local alias (like `Bar` in the example above).
                const importedName = (firstDecl.propertyName || firstDecl.name).text;
                // The first symbol name refers to the local name, which is replaced by `importedName` above.
                // Any remaining symbol names make up the complete path to the value.
                const [_localName, ...nestedPath] = symbols.symbolNames;
                const moduleName = extractModuleName(firstDecl.parent.parent.parent);
                return {
                    kind: 1 /* IMPORTED */,
                    valueDeclaration: decl.valueDeclaration,
                    moduleName,
                    importedName,
                    nestedPath
                };
            }
            else if (ts$1.isNamespaceImport(firstDecl)) {
                // The import is a namespace import
                //   import * as Foo from 'foo';
                if (firstDecl.parent.isTypeOnly) {
                    // Type-only imports cannot be represented as value.
                    return typeOnlyImport(typeNode, firstDecl.parent);
                }
                if (symbols.symbolNames.length === 1) {
                    // The type refers to the namespace itself, which cannot be represented as a value.
                    return namespaceImport(typeNode, firstDecl.parent);
                }
                // The first symbol name refers to the local name of the namespace, which is is discarded
                // as a new namespace import will be generated. This is followed by the symbol name that needs
                // to be imported and any remaining names that constitute the complete path to the value.
                const [_ns, importedName, ...nestedPath] = symbols.symbolNames;
                const moduleName = extractModuleName(firstDecl.parent.parent);
                return {
                    kind: 1 /* IMPORTED */,
                    valueDeclaration: decl.valueDeclaration,
                    moduleName,
                    importedName,
                    nestedPath
                };
            }
        }
        // If the type is not imported, the type reference can be converted into an expression as is.
        const expression = typeNodeToValueExpr(typeNode);
        if (expression !== null) {
            return {
                kind: 0 /* LOCAL */,
                expression,
                defaultImportStatement: null,
            };
        }
        else {
            return unsupportedType(typeNode);
        }
    }
    function unsupportedType(typeNode) {
        return {
            kind: 2 /* UNAVAILABLE */,
            reason: { kind: 5 /* UNSUPPORTED */, typeNode },
        };
    }
    function noValueDeclaration(typeNode, decl) {
        return {
            kind: 2 /* UNAVAILABLE */,
            reason: { kind: 1 /* NO_VALUE_DECLARATION */, typeNode, decl },
        };
    }
    function typeOnlyImport(typeNode, importClause) {
        return {
            kind: 2 /* UNAVAILABLE */,
            reason: { kind: 2 /* TYPE_ONLY_IMPORT */, typeNode, importClause },
        };
    }
    function unknownReference(typeNode) {
        return {
            kind: 2 /* UNAVAILABLE */,
            reason: { kind: 3 /* UNKNOWN_REFERENCE */, typeNode },
        };
    }
    function namespaceImport(typeNode, importClause) {
        return {
            kind: 2 /* UNAVAILABLE */,
            reason: { kind: 4 /* NAMESPACE */, typeNode, importClause },
        };
    }
    function missingType() {
        return {
            kind: 2 /* UNAVAILABLE */,
            reason: { kind: 0 /* MISSING_TYPE */ },
        };
    }
    /**
     * Attempt to extract a `ts.Expression` that's equivalent to a `ts.TypeNode`, as the two have
     * different AST shapes but can reference the same symbols.
     *
     * This will return `null` if an equivalent expression cannot be constructed.
     */
    function typeNodeToValueExpr(node) {
        if (ts$1.isTypeReferenceNode(node)) {
            return entityNameToValue(node.typeName);
        }
        else {
            return null;
        }
    }
    /**
     * Resolve a `TypeReference` node to the `ts.Symbol`s for both its declaration and its local source.
     *
     * In the event that the `TypeReference` refers to a locally declared symbol, these will be the
     * same. If the `TypeReference` refers to an imported symbol, then `decl` will be the fully resolved
     * `ts.Symbol` of the referenced symbol. `local` will be the `ts.Symbol` of the `ts.Identifier`
     * which points to the import statement by which the symbol was imported.
     *
     * All symbol names that make up the type reference are returned left-to-right into the
     * `symbolNames` array, which is guaranteed to include at least one entry.
     */
    function resolveTypeSymbols(typeRef, checker) {
        const typeName = typeRef.typeName;
        // typeRefSymbol is the ts.Symbol of the entire type reference.
        const typeRefSymbol = checker.getSymbolAtLocation(typeName);
        if (typeRefSymbol === undefined) {
            return null;
        }
        // `local` is the `ts.Symbol` for the local `ts.Identifier` for the type.
        // If the type is actually locally declared or is imported by name, for example:
        //   import {Foo} from './foo';
        // then it'll be the same as `typeRefSymbol`.
        //
        // If the type is imported via a namespace import, for example:
        //   import * as foo from './foo';
        // and then referenced as:
        //   constructor(f: foo.Foo)
        // then `local` will be the `ts.Symbol` of `foo`, whereas `typeRefSymbol` will be the `ts.Symbol`
        // of `foo.Foo`. This allows tracking of the import behind whatever type reference exists.
        let local = typeRefSymbol;
        // Destructure a name like `foo.X.Y.Z` as follows:
        // - in `leftMost`, the `ts.Identifier` of the left-most name (`foo`) in the qualified name.
        //   This identifier is used to resolve the `ts.Symbol` for `local`.
        // - in `symbolNames`, all names involved in the qualified path, or a single symbol name if the
        //   type is not qualified.
        let leftMost = typeName;
        const symbolNames = [];
        while (ts$1.isQualifiedName(leftMost)) {
            symbolNames.unshift(leftMost.right.text);
            leftMost = leftMost.left;
        }
        symbolNames.unshift(leftMost.text);
        if (leftMost !== typeName) {
            const localTmp = checker.getSymbolAtLocation(leftMost);
            if (localTmp !== undefined) {
                local = localTmp;
            }
        }
        // De-alias the top-level type reference symbol to get the symbol of the actual declaration.
        let decl = typeRefSymbol;
        if (typeRefSymbol.flags & ts$1.SymbolFlags.Alias) {
            decl = checker.getAliasedSymbol(typeRefSymbol);
        }
        return { local, decl, symbolNames };
    }
    function entityNameToValue(node) {
        if (ts$1.isQualifiedName(node)) {
            const left = entityNameToValue(node.left);
            return left !== null ? ts$1.createPropertyAccess(left, node.right) : null;
        }
        else if (ts$1.isIdentifier(node)) {
            return ts$1.getMutableClone(node);
        }
        else {
            return null;
        }
    }
    function extractModuleName(node) {
        if (!ts$1.isStringLiteral(node.moduleSpecifier)) {
            throw new Error('not a module specifier');
        }
        return node.moduleSpecifier.text;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function isNamedClassDeclaration(node) {
        return ts$1.isClassDeclaration(node) && isIdentifier$1(node.name);
    }
    function isIdentifier$1(node) {
        return node !== undefined && ts$1.isIdentifier(node);
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * reflector.ts implements static reflection of declarations using the TypeScript `ts.TypeChecker`.
     */
    class TypeScriptReflectionHost {
        constructor(checker) {
            this.checker = checker;
        }
        getDecoratorsOfDeclaration(declaration) {
            if (declaration.decorators === undefined || declaration.decorators.length === 0) {
                return null;
            }
            return declaration.decorators.map(decorator => this._reflectDecorator(decorator))
                .filter((dec) => dec !== null);
        }
        getMembersOfClass(clazz) {
            const tsClazz = castDeclarationToClassOrDie(clazz);
            return tsClazz.members.map(member => this._reflectMember(member))
                .filter((member) => member !== null);
        }
        getConstructorParameters(clazz) {
            const tsClazz = castDeclarationToClassOrDie(clazz);
            const isDeclaration = tsClazz.getSourceFile().isDeclarationFile;
            // For non-declaration files, we want to find the constructor with a `body`. The constructors
            // without a `body` are overloads whereas we want the implementation since it's the one that'll
            // be executed and which can have decorators. For declaration files, we take the first one that
            // we get.
            const ctor = tsClazz.members.find((member) => ts$1.isConstructorDeclaration(member) && (isDeclaration || member.body !== undefined));
            if (ctor === undefined) {
                return null;
            }
            return ctor.parameters.map(node => {
                // The name of the parameter is easy.
                const name = parameterName(node.name);
                const decorators = this.getDecoratorsOfDeclaration(node);
                // It may or may not be possible to write an expression that refers to the value side of the
                // type named for the parameter.
                let originalTypeNode = node.type || null;
                let typeNode = originalTypeNode;
                // Check if we are dealing with a simple nullable union type e.g. `foo: Foo|null`
                // and extract the type. More complex union types e.g. `foo: Foo|Bar` are not supported.
                // We also don't need to support `foo: Foo|undefined` because Angular's DI injects `null` for
                // optional tokes that don't have providers.
                if (typeNode && ts$1.isUnionTypeNode(typeNode)) {
                    let childTypeNodes = typeNode.types.filter(childTypeNode => !(ts$1.isLiteralTypeNode(childTypeNode) &&
                        childTypeNode.literal.kind === ts$1.SyntaxKind.NullKeyword));
                    if (childTypeNodes.length === 1) {
                        typeNode = childTypeNodes[0];
                    }
                }
                const typeValueReference = typeToValue(typeNode, this.checker);
                return {
                    name,
                    nameNode: node.name,
                    typeValueReference,
                    typeNode: originalTypeNode,
                    decorators,
                };
            });
        }
        getImportOfIdentifier(id) {
            const directImport = this.getDirectImportOfIdentifier(id);
            if (directImport !== null) {
                return directImport;
            }
            else if (ts$1.isQualifiedName(id.parent) && id.parent.right === id) {
                return this.getImportOfNamespacedIdentifier(id, getQualifiedNameRoot(id.parent));
            }
            else if (ts$1.isPropertyAccessExpression(id.parent) && id.parent.name === id) {
                return this.getImportOfNamespacedIdentifier(id, getFarLeftIdentifier(id.parent));
            }
            else {
                return null;
            }
        }
        getExportsOfModule(node) {
            // In TypeScript code, modules are only ts.SourceFiles. Throw if the node isn't a module.
            if (!ts$1.isSourceFile(node)) {
                throw new Error(`getExportsOfModule() called on non-SourceFile in TS code`);
            }
            // Reflect the module to a Symbol, and use getExportsOfModule() to get a list of exported
            // Symbols.
            const symbol = this.checker.getSymbolAtLocation(node);
            if (symbol === undefined) {
                return null;
            }
            const map = new Map();
            this.checker.getExportsOfModule(symbol).forEach(exportSymbol => {
                // Map each exported Symbol to a Declaration and add it to the map.
                const decl = this.getDeclarationOfSymbol(exportSymbol, null);
                if (decl !== null) {
                    map.set(exportSymbol.name, decl);
                }
            });
            return map;
        }
        isClass(node) {
            // For our purposes, classes are "named" ts.ClassDeclarations;
            // (`node.name` can be undefined in unnamed default exports: `default export class { ... }`).
            return isNamedClassDeclaration(node);
        }
        hasBaseClass(clazz) {
            return this.getBaseClassExpression(clazz) !== null;
        }
        getBaseClassExpression(clazz) {
            if (!(ts$1.isClassDeclaration(clazz) || ts$1.isClassExpression(clazz)) ||
                clazz.heritageClauses === undefined) {
                return null;
            }
            const extendsClause = clazz.heritageClauses.find(clause => clause.token === ts$1.SyntaxKind.ExtendsKeyword);
            if (extendsClause === undefined) {
                return null;
            }
            const extendsType = extendsClause.types[0];
            if (extendsType === undefined) {
                return null;
            }
            return extendsType.expression;
        }
        getDeclarationOfIdentifier(id) {
            // Resolve the identifier to a Symbol, and return the declaration of that.
            let symbol = this.checker.getSymbolAtLocation(id);
            if (symbol === undefined) {
                return null;
            }
            return this.getDeclarationOfSymbol(symbol, id);
        }
        getDefinitionOfFunction(node) {
            if (!ts$1.isFunctionDeclaration(node) && !ts$1.isMethodDeclaration(node) &&
                !ts$1.isFunctionExpression(node)) {
                return null;
            }
            return {
                node,
                body: node.body !== undefined ? Array.from(node.body.statements) : null,
                parameters: node.parameters.map(param => {
                    const name = parameterName(param.name);
                    const initializer = param.initializer || null;
                    return { name, node: param, initializer };
                }),
            };
        }
        getGenericArityOfClass(clazz) {
            if (!ts$1.isClassDeclaration(clazz)) {
                return null;
            }
            return clazz.typeParameters !== undefined ? clazz.typeParameters.length : 0;
        }
        getVariableValue(declaration) {
            return declaration.initializer || null;
        }
        getDtsDeclaration(_) {
            return null;
        }
        getInternalNameOfClass(clazz) {
            return clazz.name;
        }
        getAdjacentNameOfClass(clazz) {
            return clazz.name;
        }
        isStaticallyExported(decl) {
            // First check if there's an `export` modifier directly on the declaration.
            let topLevel = decl;
            if (ts$1.isVariableDeclaration(decl) && ts$1.isVariableDeclarationList(decl.parent)) {
                topLevel = decl.parent.parent;
            }
            if (topLevel.modifiers !== undefined &&
                topLevel.modifiers.some(modifier => modifier.kind === ts$1.SyntaxKind.ExportKeyword)) {
                // The node is part of a declaration that's directly exported.
                return true;
            }
            // If `topLevel` is not directly exported via a modifier, then it might be indirectly exported,
            // e.g.:
            //
            // class Foo {}
            // export {Foo};
            //
            // The only way to check this is to look at the module level for exports of the class. As a
            // performance optimization, this check is only performed if the class is actually declared at
            // the top level of the file and thus eligible for exporting in the first place.
            if (topLevel.parent === undefined || !ts$1.isSourceFile(topLevel.parent)) {
                return false;
            }
            const localExports = this.getLocalExportedDeclarationsOfSourceFile(decl.getSourceFile());
            return localExports.has(decl);
        }
        getDirectImportOfIdentifier(id) {
            const symbol = this.checker.getSymbolAtLocation(id);
            if (symbol === undefined || symbol.declarations === undefined ||
                symbol.declarations.length !== 1) {
                return null;
            }
            const decl = symbol.declarations[0];
            const importDecl = getContainingImportDeclaration(decl);
            // Ignore declarations that are defined locally (not imported).
            if (importDecl === null) {
                return null;
            }
            // The module specifier is guaranteed to be a string literal, so this should always pass.
            if (!ts$1.isStringLiteral(importDecl.moduleSpecifier)) {
                // Not allowed to happen in TypeScript ASTs.
                return null;
            }
            return { from: importDecl.moduleSpecifier.text, name: getExportedName(decl, id) };
        }
        /**
         * Try to get the import info for this identifier as though it is a namespaced import.
         *
         * For example, if the identifier is the `Directive` part of a qualified type chain like:
         *
         * ```
         * core.Directive
         * ```
         *
         * then it might be that `core` is a namespace import such as:
         *
         * ```
         * import * as core from 'tslib';
         * ```
         *
         * @param id the TypeScript identifier to find the import info for.
         * @returns The import info if this is a namespaced import or `null`.
         */
        getImportOfNamespacedIdentifier(id, namespaceIdentifier) {
            if (namespaceIdentifier === null) {
                return null;
            }
            const namespaceSymbol = this.checker.getSymbolAtLocation(namespaceIdentifier);
            if (!namespaceSymbol || namespaceSymbol.declarations === undefined) {
                return null;
            }
            const declaration = namespaceSymbol.declarations.length === 1 ? namespaceSymbol.declarations[0] : null;
            if (!declaration) {
                return null;
            }
            const namespaceDeclaration = ts$1.isNamespaceImport(declaration) ? declaration : null;
            if (!namespaceDeclaration) {
                return null;
            }
            const importDeclaration = namespaceDeclaration.parent.parent;
            if (!ts$1.isStringLiteral(importDeclaration.moduleSpecifier)) {
                // Should not happen as this would be invalid TypesScript
                return null;
            }
            return {
                from: importDeclaration.moduleSpecifier.text,
                name: id.text,
            };
        }
        /**
         * Resolve a `ts.Symbol` to its declaration, keeping track of the `viaModule` along the way.
         */
        getDeclarationOfSymbol(symbol, originalId) {
            // If the symbol points to a ShorthandPropertyAssignment, resolve it.
            let valueDeclaration = undefined;
            if (symbol.valueDeclaration !== undefined) {
                valueDeclaration = symbol.valueDeclaration;
            }
            else if (symbol.declarations !== undefined && symbol.declarations.length > 0) {
                valueDeclaration = symbol.declarations[0];
            }
            if (valueDeclaration !== undefined && ts$1.isShorthandPropertyAssignment(valueDeclaration)) {
                const shorthandSymbol = this.checker.getShorthandAssignmentValueSymbol(valueDeclaration);
                if (shorthandSymbol === undefined) {
                    return null;
                }
                return this.getDeclarationOfSymbol(shorthandSymbol, originalId);
            }
            else if (valueDeclaration !== undefined && ts$1.isExportSpecifier(valueDeclaration)) {
                const targetSymbol = this.checker.getExportSpecifierLocalTargetSymbol(valueDeclaration);
                if (targetSymbol === undefined) {
                    return null;
                }
                return this.getDeclarationOfSymbol(targetSymbol, originalId);
            }
            const importInfo = originalId && this.getImportOfIdentifier(originalId);
            const viaModule = importInfo !== null && importInfo.from !== null && !importInfo.from.startsWith('.') ?
                importInfo.from :
                null;
            // Now, resolve the Symbol to its declaration by following any and all aliases.
            while (symbol.flags & ts$1.SymbolFlags.Alias) {
                symbol = this.checker.getAliasedSymbol(symbol);
            }
            // Look at the resolved Symbol's declarations and pick one of them to return. Value declarations
            // are given precedence over type declarations.
            if (symbol.valueDeclaration !== undefined) {
                return {
                    node: symbol.valueDeclaration,
                    known: null,
                    viaModule,
                    identity: null,
                    kind: 0 /* Concrete */,
                };
            }
            else if (symbol.declarations !== undefined && symbol.declarations.length > 0) {
                return {
                    node: symbol.declarations[0],
                    known: null,
                    viaModule,
                    identity: null,
                    kind: 0 /* Concrete */,
                };
            }
            else {
                return null;
            }
        }
        _reflectDecorator(node) {
            // Attempt to resolve the decorator expression into a reference to a concrete Identifier. The
            // expression may contain a call to a function which returns the decorator function, in which
            // case we want to return the arguments.
            let decoratorExpr = node.expression;
            let args = null;
            // Check for call expressions.
            if (ts$1.isCallExpression(decoratorExpr)) {
                args = Array.from(decoratorExpr.arguments);
                decoratorExpr = decoratorExpr.expression;
            }
            // The final resolved decorator should be a `ts.Identifier` - if it's not, then something is
            // wrong and the decorator can't be resolved statically.
            if (!isDecoratorIdentifier(decoratorExpr)) {
                return null;
            }
            const decoratorIdentifier = ts$1.isIdentifier(decoratorExpr) ? decoratorExpr : decoratorExpr.name;
            const importDecl = this.getImportOfIdentifier(decoratorIdentifier);
            return {
                name: decoratorIdentifier.text,
                identifier: decoratorExpr,
                import: importDecl,
                node,
                args,
            };
        }
        _reflectMember(node) {
            let kind = null;
            let value = null;
            let name = null;
            let nameNode = null;
            if (ts$1.isPropertyDeclaration(node)) {
                kind = ClassMemberKind.Property;
                value = node.initializer || null;
            }
            else if (ts$1.isGetAccessorDeclaration(node)) {
                kind = ClassMemberKind.Getter;
            }
            else if (ts$1.isSetAccessorDeclaration(node)) {
                kind = ClassMemberKind.Setter;
            }
            else if (ts$1.isMethodDeclaration(node)) {
                kind = ClassMemberKind.Method;
            }
            else if (ts$1.isConstructorDeclaration(node)) {
                kind = ClassMemberKind.Constructor;
            }
            else {
                return null;
            }
            if (ts$1.isConstructorDeclaration(node)) {
                name = 'constructor';
            }
            else if (ts$1.isIdentifier(node.name)) {
                name = node.name.text;
                nameNode = node.name;
            }
            else if (ts$1.isStringLiteral(node.name)) {
                name = node.name.text;
                nameNode = node.name;
            }
            else {
                return null;
            }
            const decorators = this.getDecoratorsOfDeclaration(node);
            const isStatic = node.modifiers !== undefined &&
                node.modifiers.some(mod => mod.kind === ts$1.SyntaxKind.StaticKeyword);
            return {
                node,
                implementation: node,
                kind,
                type: node.type || null,
                name,
                nameNode,
                decorators,
                value,
                isStatic,
            };
        }
        /**
         * Get the set of declarations declared in `file` which are exported.
         */
        getLocalExportedDeclarationsOfSourceFile(file) {
            const cacheSf = file;
            if (cacheSf[LocalExportedDeclarations] !== undefined) {
                // TS does not currently narrow symbol-keyed fields, hence the non-null assert is needed.
                return cacheSf[LocalExportedDeclarations];
            }
            const exportSet = new Set();
            cacheSf[LocalExportedDeclarations] = exportSet;
            const sfSymbol = this.checker.getSymbolAtLocation(cacheSf);
            if (sfSymbol === undefined || sfSymbol.exports === undefined) {
                return exportSet;
            }
            // Scan the exported symbol of the `ts.SourceFile` for the original `symbol` of the class
            // declaration.
            //
            // Note: when checking multiple classes declared in the same file, this repeats some operations.
            // In theory, this could be expensive if run in the context of a massive input file (like a
            // large FESM in ngcc). If performance does become an issue here, it should be possible to
            // create a `Set<>`
            // Unfortunately, `ts.Iterator` doesn't implement the iterator protocol, so iteration here is
            // done manually.
            const iter = sfSymbol.exports.values();
            let item = iter.next();
            while (item.done !== true) {
                let exportedSymbol = item.value;
                // If this exported symbol comes from an `export {Foo}` statement, then the symbol is actually
                // for the export declaration, not the original declaration. Such a symbol will be an alias,
                // so unwrap aliasing if necessary.
                if (exportedSymbol.flags & ts$1.SymbolFlags.Alias) {
                    exportedSymbol = this.checker.getAliasedSymbol(exportedSymbol);
                }
                if (exportedSymbol.valueDeclaration !== undefined &&
                    exportedSymbol.valueDeclaration.getSourceFile() === file) {
                    exportSet.add(exportedSymbol.valueDeclaration);
                }
                item = iter.next();
            }
            return exportSet;
        }
    }
    function reflectTypeEntityToDeclaration(type, checker) {
        let realSymbol = checker.getSymbolAtLocation(type);
        if (realSymbol === undefined) {
            throw new Error(`Cannot resolve type entity ${type.getText()} to symbol`);
        }
        while (realSymbol.flags & ts$1.SymbolFlags.Alias) {
            realSymbol = checker.getAliasedSymbol(realSymbol);
        }
        let node = null;
        if (realSymbol.valueDeclaration !== undefined) {
            node = realSymbol.valueDeclaration;
        }
        else if (realSymbol.declarations !== undefined && realSymbol.declarations.length === 1) {
            node = realSymbol.declarations[0];
        }
        else {
            throw new Error(`Cannot resolve type entity symbol to declaration`);
        }
        if (ts$1.isQualifiedName(type)) {
            if (!ts$1.isIdentifier(type.left)) {
                throw new Error(`Cannot handle qualified name with non-identifier lhs`);
            }
            const symbol = checker.getSymbolAtLocation(type.left);
            if (symbol === undefined || symbol.declarations === undefined ||
                symbol.declarations.length !== 1) {
                throw new Error(`Cannot resolve qualified type entity lhs to symbol`);
            }
            const decl = symbol.declarations[0];
            if (ts$1.isNamespaceImport(decl)) {
                const clause = decl.parent;
                const importDecl = clause.parent;
                if (!ts$1.isStringLiteral(importDecl.moduleSpecifier)) {
                    throw new Error(`Module specifier is not a string`);
                }
                return { node, from: importDecl.moduleSpecifier.text };
            }
            else if (ts$1.isModuleDeclaration(decl)) {
                return { node, from: null };
            }
            else {
                throw new Error(`Unknown import type?`);
            }
        }
        else {
            return { node, from: null };
        }
    }
    function filterToMembersWithDecorator(members, name, module) {
        return members.filter(member => !member.isStatic)
            .map(member => {
            if (member.decorators === null) {
                return null;
            }
            const decorators = member.decorators.filter(dec => {
                if (dec.import !== null) {
                    return dec.import.name === name && (module === undefined || dec.import.from === module);
                }
                else {
                    return dec.name === name && module === undefined;
                }
            });
            if (decorators.length === 0) {
                return null;
            }
            return { member, decorators };
        })
            .filter((value) => value !== null);
    }
    function reflectObjectLiteral(node) {
        const map = new Map();
        node.properties.forEach(prop => {
            if (ts$1.isPropertyAssignment(prop)) {
                const name = propertyNameToString(prop.name);
                if (name === null) {
                    return;
                }
                map.set(name, prop.initializer);
            }
            else if (ts$1.isShorthandPropertyAssignment(prop)) {
                map.set(prop.name.text, prop.name);
            }
            else {
                return;
            }
        });
        return map;
    }
    function castDeclarationToClassOrDie(declaration) {
        if (!ts$1.isClassDeclaration(declaration)) {
            throw new Error(`Reflecting on a ${ts$1.SyntaxKind[declaration.kind]} instead of a ClassDeclaration.`);
        }
        return declaration;
    }
    function parameterName(name) {
        if (ts$1.isIdentifier(name)) {
            return name.text;
        }
        else {
            return null;
        }
    }
    function propertyNameToString(node) {
        if (ts$1.isIdentifier(node) || ts$1.isStringLiteral(node) || ts$1.isNumericLiteral(node)) {
            return node.text;
        }
        else {
            return null;
        }
    }
    /**
     * Compute the left most identifier in a qualified type chain. E.g. the `a` of `a.b.c.SomeType`.
     * @param qualifiedName The starting property access expression from which we want to compute
     * the left most identifier.
     * @returns the left most identifier in the chain or `null` if it is not an identifier.
     */
    function getQualifiedNameRoot(qualifiedName) {
        while (ts$1.isQualifiedName(qualifiedName.left)) {
            qualifiedName = qualifiedName.left;
        }
        return ts$1.isIdentifier(qualifiedName.left) ? qualifiedName.left : null;
    }
    /**
     * Compute the left most identifier in a property access chain. E.g. the `a` of `a.b.c.d`.
     * @param propertyAccess The starting property access expression from which we want to compute
     * the left most identifier.
     * @returns the left most identifier in the chain or `null` if it is not an identifier.
     */
    function getFarLeftIdentifier(propertyAccess) {
        while (ts$1.isPropertyAccessExpression(propertyAccess.expression)) {
            propertyAccess = propertyAccess.expression;
        }
        return ts$1.isIdentifier(propertyAccess.expression) ? propertyAccess.expression : null;
    }
    /**
     * Return the ImportDeclaration for the given `node` if it is either an `ImportSpecifier` or a
     * `NamespaceImport`. If not return `null`.
     */
    function getContainingImportDeclaration(node) {
        return ts$1.isImportSpecifier(node) ? node.parent.parent.parent :
            ts$1.isNamespaceImport(node) ? node.parent.parent : null;
    }
    /**
     * Compute the name by which the `decl` was exported, not imported.
     * If no such declaration can be found (e.g. it is a namespace import)
     * then fallback to the `originalId`.
     */
    function getExportedName(decl, originalId) {
        return ts$1.isImportSpecifier(decl) ?
            (decl.propertyName !== undefined ? decl.propertyName : decl.name).text :
            originalId.text;
    }
    const LocalExportedDeclarations = Symbol('LocalExportedDeclarations');

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A mapping of component property and template binding property names, for example containing the
     * inputs of a particular directive or component.
     *
     * A single component property has exactly one input/output annotation (and therefore one binding
     * property name) associated with it, but the same binding property name may be shared across many
     * component property names.
     *
     * Allows bidirectional querying of the mapping - looking up all inputs/outputs with a given
     * property name, or mapping from a specific class property to its binding property name.
     */
    class ClassPropertyMapping {
        constructor(forwardMap) {
            this.forwardMap = forwardMap;
            this.reverseMap = reverseMapFromForwardMap(forwardMap);
        }
        /**
         * Construct a `ClassPropertyMapping` with no entries.
         */
        static empty() {
            return new ClassPropertyMapping(new Map());
        }
        /**
         * Construct a `ClassPropertyMapping` from a primitive JS object which maps class property names
         * to either binding property names or an array that contains both names, which is used in on-disk
         * metadata formats (e.g. in .d.ts files).
         */
        static fromMappedObject(obj) {
            const forwardMap = new Map();
            for (const classPropertyName of Object.keys(obj)) {
                const value = obj[classPropertyName];
                const bindingPropertyName = Array.isArray(value) ? value[0] : value;
                const inputOrOutput = { classPropertyName, bindingPropertyName };
                forwardMap.set(classPropertyName, inputOrOutput);
            }
            return new ClassPropertyMapping(forwardMap);
        }
        /**
         * Merge two mappings into one, with class properties from `b` taking precedence over class
         * properties from `a`.
         */
        static merge(a, b) {
            const forwardMap = new Map(a.forwardMap.entries());
            for (const [classPropertyName, inputOrOutput] of b.forwardMap) {
                forwardMap.set(classPropertyName, inputOrOutput);
            }
            return new ClassPropertyMapping(forwardMap);
        }
        /**
         * All class property names mapped in this mapping.
         */
        get classPropertyNames() {
            return Array.from(this.forwardMap.keys());
        }
        /**
         * All binding property names mapped in this mapping.
         */
        get propertyNames() {
            return Array.from(this.reverseMap.keys());
        }
        /**
         * Check whether a mapping for the given property name exists.
         */
        hasBindingPropertyName(propertyName) {
            return this.reverseMap.has(propertyName);
        }
        /**
         * Lookup all `InputOrOutput`s that use this `propertyName`.
         */
        getByBindingPropertyName(propertyName) {
            return this.reverseMap.has(propertyName) ? this.reverseMap.get(propertyName) : null;
        }
        /**
         * Lookup the `InputOrOutput` associated with a `classPropertyName`.
         */
        getByClassPropertyName(classPropertyName) {
            return this.forwardMap.has(classPropertyName) ? this.forwardMap.get(classPropertyName) : null;
        }
        /**
         * Convert this mapping to a primitive JS object which maps each class property directly to the
         * binding property name associated with it.
         */
        toDirectMappedObject() {
            const obj = {};
            for (const [classPropertyName, inputOrOutput] of this.forwardMap) {
                obj[classPropertyName] = inputOrOutput.bindingPropertyName;
            }
            return obj;
        }
        /**
         * Convert this mapping to a primitive JS object which maps each class property either to itself
         * (for cases where the binding property name is the same) or to an array which contains both
         * names if they differ.
         *
         * This object format is used when mappings are serialized (for example into .d.ts files).
         */
        toJointMappedObject() {
            const obj = {};
            for (const [classPropertyName, inputOrOutput] of this.forwardMap) {
                if (inputOrOutput.bindingPropertyName === classPropertyName) {
                    obj[classPropertyName] = inputOrOutput.bindingPropertyName;
                }
                else {
                    obj[classPropertyName] = [inputOrOutput.bindingPropertyName, classPropertyName];
                }
            }
            return obj;
        }
        /**
         * Implement the iterator protocol and return entry objects which contain the class and binding
         * property names (and are useful for destructuring).
         */
        *[Symbol.iterator]() {
            for (const [classPropertyName, inputOrOutput] of this.forwardMap.entries()) {
                yield [classPropertyName, inputOrOutput.bindingPropertyName];
            }
        }
    }
    function reverseMapFromForwardMap(forwardMap) {
        const reverseMap = new Map();
        for (const [_, inputOrOutput] of forwardMap) {
            if (!reverseMap.has(inputOrOutput.bindingPropertyName)) {
                reverseMap.set(inputOrOutput.bindingPropertyName, []);
            }
            reverseMap.get(inputOrOutput.bindingPropertyName).push(inputOrOutput);
        }
        return reverseMap;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function extractReferencesFromType(checker, def, bestGuessOwningModule) {
        if (!ts$1.isTupleTypeNode(def)) {
            return [];
        }
        return def.elements.map(element => {
            if (!ts$1.isTypeQueryNode(element)) {
                throw new Error(`Expected TypeQueryNode: ${nodeDebugInfo(element)}`);
            }
            const type = element.exprName;
            const { node, from } = reflectTypeEntityToDeclaration(type, checker);
            if (!isNamedClassDeclaration(node)) {
                throw new Error(`Expected named ClassDeclaration: ${nodeDebugInfo(node)}`);
            }
            if (from !== null && !from.startsWith('.')) {
                // The symbol was imported using an absolute module specifier so return a reference that
                // uses that absolute module specifier as its best guess owning module.
                return new Reference$1(node, { specifier: from, resolutionContext: def.getSourceFile().fileName });
            }
            else {
                // For local symbols or symbols that were imported using a relative module import it is
                // assumed that the symbol is exported from the provided best guess owning module.
                return new Reference$1(node, bestGuessOwningModule);
            }
        });
    }
    function readStringType(type) {
        if (!ts$1.isLiteralTypeNode(type) || !ts$1.isStringLiteral(type.literal)) {
            return null;
        }
        return type.literal.text;
    }
    function readStringMapType(type) {
        if (!ts$1.isTypeLiteralNode(type)) {
            return {};
        }
        const obj = {};
        type.members.forEach(member => {
            if (!ts$1.isPropertySignature(member) || member.type === undefined || member.name === undefined ||
                !ts$1.isStringLiteral(member.name)) {
                return;
            }
            const value = readStringType(member.type);
            if (value === null) {
                return null;
            }
            obj[member.name.text] = value;
        });
        return obj;
    }
    function readStringArrayType(type) {
        if (!ts$1.isTupleTypeNode(type)) {
            return [];
        }
        const res = [];
        type.elements.forEach(el => {
            if (!ts$1.isLiteralTypeNode(el) || !ts$1.isStringLiteral(el.literal)) {
                return;
            }
            res.push(el.literal.text);
        });
        return res;
    }
    /**
     * Inspects the class' members and extracts the metadata that is used when type-checking templates
     * that use the directive. This metadata does not contain information from a base class, if any,
     * making this metadata invariant to changes of inherited classes.
     */
    function extractDirectiveTypeCheckMeta(node, inputs, reflector) {
        const members = reflector.getMembersOfClass(node);
        const staticMembers = members.filter(member => member.isStatic);
        const ngTemplateGuards = staticMembers.map(extractTemplateGuard)
            .filter((guard) => guard !== null);
        const hasNgTemplateContextGuard = staticMembers.some(member => member.kind === ClassMemberKind.Method && member.name === 'ngTemplateContextGuard');
        const coercedInputFields = new Set(staticMembers.map(extractCoercedInput)
            .filter((inputName) => inputName !== null));
        const restrictedInputFields = new Set();
        const stringLiteralInputFields = new Set();
        const undeclaredInputFields = new Set();
        for (const classPropertyName of inputs.classPropertyNames) {
            const field = members.find(member => member.name === classPropertyName);
            if (field === undefined || field.node === null) {
                undeclaredInputFields.add(classPropertyName);
                continue;
            }
            if (isRestricted(field.node)) {
                restrictedInputFields.add(classPropertyName);
            }
            if (field.nameNode !== null && ts$1.isStringLiteral(field.nameNode)) {
                stringLiteralInputFields.add(classPropertyName);
            }
        }
        const arity = reflector.getGenericArityOfClass(node);
        return {
            hasNgTemplateContextGuard,
            ngTemplateGuards,
            coercedInputFields,
            restrictedInputFields,
            stringLiteralInputFields,
            undeclaredInputFields,
            isGeneric: arity !== null && arity > 0,
        };
    }
    function isRestricted(node) {
        if (node.modifiers === undefined) {
            return false;
        }
        return node.modifiers.some(modifier => modifier.kind === ts$1.SyntaxKind.PrivateKeyword ||
            modifier.kind === ts$1.SyntaxKind.ProtectedKeyword ||
            modifier.kind === ts$1.SyntaxKind.ReadonlyKeyword);
    }
    function extractTemplateGuard(member) {
        if (!member.name.startsWith('ngTemplateGuard_')) {
            return null;
        }
        const inputName = afterUnderscore(member.name);
        if (member.kind === ClassMemberKind.Property) {
            let type = null;
            if (member.type !== null && ts$1.isLiteralTypeNode(member.type) &&
                ts$1.isStringLiteral(member.type.literal)) {
                type = member.type.literal.text;
            }
            // Only property members with string literal type 'binding' are considered as template guard.
            if (type !== 'binding') {
                return null;
            }
            return { inputName, type };
        }
        else if (member.kind === ClassMemberKind.Method) {
            return { inputName, type: 'invocation' };
        }
        else {
            return null;
        }
    }
    function extractCoercedInput(member) {
        if (member.kind !== ClassMemberKind.Property || !member.name.startsWith('ngAcceptInputType_')) {
            return null;
        }
        return afterUnderscore(member.name);
    }
    /**
     * A `MetadataReader` that reads from an ordered set of child readers until it obtains the requested
     * metadata.
     *
     * This is used to combine `MetadataReader`s that read from different sources (e.g. from a registry
     * and from .d.ts files).
     */
    class CompoundMetadataReader {
        constructor(readers) {
            this.readers = readers;
        }
        getDirectiveMetadata(node) {
            for (const reader of this.readers) {
                const meta = reader.getDirectiveMetadata(node);
                if (meta !== null) {
                    return meta;
                }
            }
            return null;
        }
        getNgModuleMetadata(node) {
            for (const reader of this.readers) {
                const meta = reader.getNgModuleMetadata(node);
                if (meta !== null) {
                    return meta;
                }
            }
            return null;
        }
        getPipeMetadata(node) {
            for (const reader of this.readers) {
                const meta = reader.getPipeMetadata(node);
                if (meta !== null) {
                    return meta;
                }
            }
            return null;
        }
    }
    function afterUnderscore(str) {
        const pos = str.indexOf('_');
        if (pos === -1) {
            throw new Error(`Expected '${str}' to contain '_'`);
        }
        return str.substr(pos + 1);
    }
    /** Returns whether a class declaration has the necessary class fields to make it injectable. */
    function hasInjectableFields(clazz, host) {
        const members = host.getMembersOfClass(clazz);
        return members.some(({ isStatic, name }) => isStatic && (name === 'prov' || name === 'fac'));
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A `MetadataReader` that can read metadata from `.d.ts` files, which have static Ivy properties
     * from an upstream compilation already.
     */
    class DtsMetadataReader {
        constructor(checker, reflector) {
            this.checker = checker;
            this.reflector = reflector;
        }
        /**
         * Read the metadata from a class that has already been compiled somehow (either it's in a .d.ts
         * file, or in a .ts file with a handwritten definition).
         *
         * @param ref `Reference` to the class of interest, with the context of how it was obtained.
         */
        getNgModuleMetadata(ref) {
            const clazz = ref.node;
            // This operation is explicitly not memoized, as it depends on `ref.ownedByModuleGuess`.
            // TODO(alxhub): investigate caching of .d.ts module metadata.
            const ngModuleDef = this.reflector.getMembersOfClass(clazz).find(member => member.name === 'mod' && member.isStatic);
            if (ngModuleDef === undefined) {
                return null;
            }
            else if (
            // Validate that the shape of the ngModuleDef type is correct.
            ngModuleDef.type === null || !ts$1.isTypeReferenceNode(ngModuleDef.type) ||
                ngModuleDef.type.typeArguments === undefined ||
                ngModuleDef.type.typeArguments.length !== 4) {
                return null;
            }
            // Read the ModuleData out of the type arguments.
            const [_, declarationMetadata, importMetadata, exportMetadata] = ngModuleDef.type.typeArguments;
            return {
                ref,
                declarations: extractReferencesFromType(this.checker, declarationMetadata, ref.bestGuessOwningModule),
                exports: extractReferencesFromType(this.checker, exportMetadata, ref.bestGuessOwningModule),
                imports: extractReferencesFromType(this.checker, importMetadata, ref.bestGuessOwningModule),
                schemas: [],
                rawDeclarations: null,
            };
        }
        /**
         * Read directive (or component) metadata from a referenced class in a .d.ts file.
         */
        getDirectiveMetadata(ref) {
            const clazz = ref.node;
            const def = this.reflector.getMembersOfClass(clazz).find(field => field.isStatic && (field.name === 'cmp' || field.name === 'dir'));
            if (def === undefined) {
                // No definition could be found.
                return null;
            }
            else if (def.type === null || !ts$1.isTypeReferenceNode(def.type) ||
                def.type.typeArguments === undefined || def.type.typeArguments.length < 2) {
                // The type metadata was the wrong shape.
                return null;
            }
            const isComponent = def.name === 'cmp';
            const ctorParams = this.reflector.getConstructorParameters(clazz);
            // A directive is considered to be structural if:
            // 1) it's a directive, not a component, and
            // 2) it injects `TemplateRef`
            const isStructural = !isComponent && ctorParams !== null && ctorParams.some(param => {
                return param.typeValueReference.kind === 1 /* IMPORTED */ &&
                    param.typeValueReference.moduleName === '@angular/core' &&
                    param.typeValueReference.importedName === 'TemplateRef';
            });
            const inputs = ClassPropertyMapping.fromMappedObject(readStringMapType(def.type.typeArguments[3]));
            const outputs = ClassPropertyMapping.fromMappedObject(readStringMapType(def.type.typeArguments[4]));
            return Object.assign(Object.assign({ type: MetaType.Directive, ref, name: clazz.name.text, isComponent, selector: readStringType(def.type.typeArguments[1]), exportAs: readStringArrayType(def.type.typeArguments[2]), inputs,
                outputs, queries: readStringArrayType(def.type.typeArguments[5]) }, extractDirectiveTypeCheckMeta(clazz, inputs, this.reflector)), { baseClass: readBaseClass(clazz, this.checker, this.reflector), isPoisoned: false, isStructural });
        }
        /**
         * Read pipe metadata from a referenced class in a .d.ts file.
         */
        getPipeMetadata(ref) {
            const def = this.reflector.getMembersOfClass(ref.node).find(field => field.isStatic && field.name === 'pipe');
            if (def === undefined) {
                // No definition could be found.
                return null;
            }
            else if (def.type === null || !ts$1.isTypeReferenceNode(def.type) ||
                def.type.typeArguments === undefined || def.type.typeArguments.length < 2) {
                // The type metadata was the wrong shape.
                return null;
            }
            const type = def.type.typeArguments[1];
            if (!ts$1.isLiteralTypeNode(type) || !ts$1.isStringLiteral(type.literal)) {
                // The type metadata was the wrong type.
                return null;
            }
            const name = type.literal.text;
            return {
                type: MetaType.Pipe,
                ref,
                name,
                nameExpr: null,
            };
        }
    }
    function readBaseClass(clazz, checker, reflector) {
        if (!isNamedClassDeclaration(clazz)) {
            // Technically this is an error in a .d.ts file, but for the purposes of finding the base class
            // it's ignored.
            return reflector.hasBaseClass(clazz) ? 'dynamic' : null;
        }
        if (clazz.heritageClauses !== undefined) {
            for (const clause of clazz.heritageClauses) {
                if (clause.token === ts$1.SyntaxKind.ExtendsKeyword) {
                    const baseExpr = clause.types[0].expression;
                    let symbol = checker.getSymbolAtLocation(baseExpr);
                    if (symbol === undefined) {
                        return 'dynamic';
                    }
                    else if (symbol.flags & ts$1.SymbolFlags.Alias) {
                        symbol = checker.getAliasedSymbol(symbol);
                    }
                    if (symbol.valueDeclaration !== undefined &&
                        isNamedClassDeclaration(symbol.valueDeclaration)) {
                        return new Reference$1(symbol.valueDeclaration);
                    }
                    else {
                        return 'dynamic';
                    }
                }
            }
        }
        return null;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Given a reference to a directive, return a flattened version of its `DirectiveMeta` metadata
     * which includes metadata from its entire inheritance chain.
     *
     * The returned `DirectiveMeta` will either have `baseClass: null` if the inheritance chain could be
     * fully resolved, or `baseClass: 'dynamic'` if the inheritance chain could not be completely
     * followed.
     */
    function flattenInheritedDirectiveMetadata(reader, dir) {
        const topMeta = reader.getDirectiveMetadata(dir);
        if (topMeta === null) {
            throw new Error(`Metadata not found for directive: ${dir.debugName}`);
        }
        if (topMeta.baseClass === null) {
            return topMeta;
        }
        const coercedInputFields = new Set();
        const undeclaredInputFields = new Set();
        const restrictedInputFields = new Set();
        const stringLiteralInputFields = new Set();
        let isDynamic = false;
        let inputs = ClassPropertyMapping.empty();
        let outputs = ClassPropertyMapping.empty();
        let isStructural = false;
        const addMetadata = (meta) => {
            if (meta.baseClass === 'dynamic') {
                isDynamic = true;
            }
            else if (meta.baseClass !== null) {
                const baseMeta = reader.getDirectiveMetadata(meta.baseClass);
                if (baseMeta !== null) {
                    addMetadata(baseMeta);
                }
                else {
                    // Missing metadata for the base class means it's effectively dynamic.
                    isDynamic = true;
                }
            }
            isStructural = isStructural || meta.isStructural;
            inputs = ClassPropertyMapping.merge(inputs, meta.inputs);
            outputs = ClassPropertyMapping.merge(outputs, meta.outputs);
            for (const coercedInputField of meta.coercedInputFields) {
                coercedInputFields.add(coercedInputField);
            }
            for (const undeclaredInputField of meta.undeclaredInputFields) {
                undeclaredInputFields.add(undeclaredInputField);
            }
            for (const restrictedInputField of meta.restrictedInputFields) {
                restrictedInputFields.add(restrictedInputField);
            }
            for (const field of meta.stringLiteralInputFields) {
                stringLiteralInputFields.add(field);
            }
        };
        addMetadata(topMeta);
        return Object.assign(Object.assign({}, topMeta), { inputs,
            outputs,
            coercedInputFields,
            undeclaredInputFields,
            restrictedInputFields,
            stringLiteralInputFields, baseClass: isDynamic ? 'dynamic' : null, isStructural });
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A registry of directive, pipe, and module metadata for types defined in the current compilation
     * unit, which supports both reading and registering.
     */
    class LocalMetadataRegistry {
        constructor() {
            this.directives = new Map();
            this.ngModules = new Map();
            this.pipes = new Map();
        }
        getDirectiveMetadata(ref) {
            return this.directives.has(ref.node) ? this.directives.get(ref.node) : null;
        }
        getNgModuleMetadata(ref) {
            return this.ngModules.has(ref.node) ? this.ngModules.get(ref.node) : null;
        }
        getPipeMetadata(ref) {
            return this.pipes.has(ref.node) ? this.pipes.get(ref.node) : null;
        }
        registerDirectiveMetadata(meta) {
            this.directives.set(meta.ref.node, meta);
        }
        registerNgModuleMetadata(meta) {
            this.ngModules.set(meta.ref.node, meta);
        }
        registerPipeMetadata(meta) {
            this.pipes.set(meta.ref.node, meta);
        }
    }
    /**
     * A `MetadataRegistry` which registers metdata with multiple delegate `MetadataRegistry` instances.
     */
    class CompoundMetadataRegistry {
        constructor(registries) {
            this.registries = registries;
        }
        registerDirectiveMetadata(meta) {
            for (const registry of this.registries) {
                registry.registerDirectiveMetadata(meta);
            }
        }
        registerNgModuleMetadata(meta) {
            for (const registry of this.registries) {
                registry.registerNgModuleMetadata(meta);
            }
        }
        registerPipeMetadata(meta) {
            for (const registry of this.registries) {
                registry.registerPipeMetadata(meta);
            }
        }
    }
    /**
     * Registry that keeps track of classes that can be constructed via dependency injection (e.g.
     * injectables, directives, pipes).
     */
    class InjectableClassRegistry {
        constructor(host) {
            this.host = host;
            this.classes = new Set();
        }
        registerInjectable(declaration) {
            this.classes.add(declaration);
        }
        isInjectable(declaration) {
            // Figure out whether the class is injectable based on the registered classes, otherwise
            // fall back to looking at its members since we might not have been able register the class
            // if it was compiled already.
            return this.classes.has(declaration) || hasInjectableFields(declaration, this.host);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function isExternalResource(resource) {
        return resource.path !== null;
    }
    /**
     * Tracks the mapping between external template/style files and the component(s) which use them.
     *
     * This information is produced during analysis of the program and is used mainly to support
     * external tooling, for which such a mapping is challenging to determine without compiler
     * assistance.
     */
    class ResourceRegistry {
        constructor() {
            this.externalTemplateToComponentsMap = new Map();
            this.componentToTemplateMap = new Map();
            this.componentToStylesMap = new Map();
            this.externalStyleToComponentsMap = new Map();
        }
        getComponentsWithTemplate(template) {
            if (!this.externalTemplateToComponentsMap.has(template)) {
                return new Set();
            }
            return this.externalTemplateToComponentsMap.get(template);
        }
        registerResources(resources, component) {
            if (resources.template !== null) {
                this.registerTemplate(resources.template, component);
            }
            for (const style of resources.styles) {
                this.registerStyle(style, component);
            }
        }
        registerTemplate(templateResource, component) {
            const { path } = templateResource;
            if (path !== null) {
                if (!this.externalTemplateToComponentsMap.has(path)) {
                    this.externalTemplateToComponentsMap.set(path, new Set());
                }
                this.externalTemplateToComponentsMap.get(path).add(component);
            }
            this.componentToTemplateMap.set(component, templateResource);
        }
        getTemplate(component) {
            if (!this.componentToTemplateMap.has(component)) {
                return null;
            }
            return this.componentToTemplateMap.get(component);
        }
        registerStyle(styleResource, component) {
            const { path } = styleResource;
            if (!this.componentToStylesMap.has(component)) {
                this.componentToStylesMap.set(component, new Set());
            }
            if (path !== null) {
                if (!this.externalStyleToComponentsMap.has(path)) {
                    this.externalStyleToComponentsMap.set(path, new Set());
                }
                this.externalStyleToComponentsMap.get(path).add(component);
            }
            this.componentToStylesMap.get(component).add(styleResource);
        }
        getStyles(component) {
            if (!this.componentToStylesMap.has(component)) {
                return new Set();
            }
            return this.componentToStylesMap.get(component);
        }
        getComponentsWithStyle(styleUrl) {
            if (!this.externalStyleToComponentsMap.has(styleUrl)) {
                return new Set();
            }
            return this.externalStyleToComponentsMap.get(styleUrl);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Represents a value which cannot be determined statically.
     */
    class DynamicValue {
        constructor(node, reason, code) {
            this.node = node;
            this.reason = reason;
            this.code = code;
        }
        static fromDynamicInput(node, input) {
            return new DynamicValue(node, input, 0 /* DYNAMIC_INPUT */);
        }
        static fromDynamicString(node) {
            return new DynamicValue(node, undefined, 1 /* DYNAMIC_STRING */);
        }
        static fromExternalReference(node, ref) {
            return new DynamicValue(node, ref, 2 /* EXTERNAL_REFERENCE */);
        }
        static fromUnsupportedSyntax(node) {
            return new DynamicValue(node, undefined, 3 /* UNSUPPORTED_SYNTAX */);
        }
        static fromUnknownIdentifier(node) {
            return new DynamicValue(node, undefined, 4 /* UNKNOWN_IDENTIFIER */);
        }
        static fromInvalidExpressionType(node, value) {
            return new DynamicValue(node, value, 5 /* INVALID_EXPRESSION_TYPE */);
        }
        static fromComplexFunctionCall(node, fn) {
            return new DynamicValue(node, fn, 6 /* COMPLEX_FUNCTION_CALL */);
        }
        static fromDynamicType(node) {
            return new DynamicValue(node, undefined, 7 /* DYNAMIC_TYPE */);
        }
        static fromUnknown(node) {
            return new DynamicValue(node, undefined, 8 /* UNKNOWN */);
        }
        isFromDynamicInput() {
            return this.code === 0 /* DYNAMIC_INPUT */;
        }
        isFromDynamicString() {
            return this.code === 1 /* DYNAMIC_STRING */;
        }
        isFromExternalReference() {
            return this.code === 2 /* EXTERNAL_REFERENCE */;
        }
        isFromUnsupportedSyntax() {
            return this.code === 3 /* UNSUPPORTED_SYNTAX */;
        }
        isFromUnknownIdentifier() {
            return this.code === 4 /* UNKNOWN_IDENTIFIER */;
        }
        isFromInvalidExpressionType() {
            return this.code === 5 /* INVALID_EXPRESSION_TYPE */;
        }
        isFromComplexFunctionCall() {
            return this.code === 6 /* COMPLEX_FUNCTION_CALL */;
        }
        isFromDynamicType() {
            return this.code === 7 /* DYNAMIC_TYPE */;
        }
        isFromUnknown() {
            return this.code === 8 /* UNKNOWN */;
        }
        accept(visitor) {
            switch (this.code) {
                case 0 /* DYNAMIC_INPUT */:
                    return visitor.visitDynamicInput(this);
                case 1 /* DYNAMIC_STRING */:
                    return visitor.visitDynamicString(this);
                case 2 /* EXTERNAL_REFERENCE */:
                    return visitor.visitExternalReference(this);
                case 3 /* UNSUPPORTED_SYNTAX */:
                    return visitor.visitUnsupportedSyntax(this);
                case 4 /* UNKNOWN_IDENTIFIER */:
                    return visitor.visitUnknownIdentifier(this);
                case 5 /* INVALID_EXPRESSION_TYPE */:
                    return visitor.visitInvalidExpressionType(this);
                case 6 /* COMPLEX_FUNCTION_CALL */:
                    return visitor.visitComplexFunctionCall(this);
                case 7 /* DYNAMIC_TYPE */:
                    return visitor.visitDynamicType(this);
                case 8 /* UNKNOWN */:
                    return visitor.visitUnknown(this);
            }
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A collection of publicly exported declarations from a module. Each declaration is evaluated
     * lazily upon request.
     */
    class ResolvedModule {
        constructor(exports, evaluate) {
            this.exports = exports;
            this.evaluate = evaluate;
        }
        getExport(name) {
            if (!this.exports.has(name)) {
                return undefined;
            }
            return this.evaluate(this.exports.get(name));
        }
        getExports() {
            const map = new Map();
            this.exports.forEach((decl, name) => {
                map.set(name, this.evaluate(decl));
            });
            return map;
        }
    }
    /**
     * A value member of an enumeration.
     *
     * Contains a `Reference` to the enumeration itself, and the name of the referenced member.
     */
    class EnumValue {
        constructor(enumRef, name, resolved) {
            this.enumRef = enumRef;
            this.name = name;
            this.resolved = resolved;
        }
    }
    /**
     * An implementation of a known function that can be statically evaluated.
     * It could be a built-in function or method (such as `Array.prototype.slice`) or a TypeScript
     * helper (such as `__spread`).
     */
    class KnownFn {
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Derives a type representation from a resolved value to be reported in a diagnostic.
     *
     * @param value The resolved value for which a type representation should be derived.
     * @param maxDepth The maximum nesting depth of objects and arrays, defaults to 1 level.
     */
    function describeResolvedType(value, maxDepth = 1) {
        var _a, _b;
        if (value === null) {
            return 'null';
        }
        else if (value === undefined) {
            return 'undefined';
        }
        else if (typeof value === 'number' || typeof value === 'boolean' || typeof value === 'string') {
            return typeof value;
        }
        else if (value instanceof Map) {
            if (maxDepth === 0) {
                return 'object';
            }
            const entries = Array.from(value.entries()).map(([key, v]) => {
                return `${quoteKey(key)}: ${describeResolvedType(v, maxDepth - 1)}`;
            });
            return entries.length > 0 ? `{ ${entries.join('; ')} }` : '{}';
        }
        else if (value instanceof ResolvedModule) {
            return '(module)';
        }
        else if (value instanceof EnumValue) {
            return (_a = value.enumRef.debugName) !== null && _a !== void 0 ? _a : '(anonymous)';
        }
        else if (value instanceof Reference$1) {
            return (_b = value.debugName) !== null && _b !== void 0 ? _b : '(anonymous)';
        }
        else if (Array.isArray(value)) {
            if (maxDepth === 0) {
                return 'Array';
            }
            return `[${value.map(v => describeResolvedType(v, maxDepth - 1)).join(', ')}]`;
        }
        else if (value instanceof DynamicValue) {
            return '(not statically analyzable)';
        }
        else if (value instanceof KnownFn) {
            return 'Function';
        }
        else {
            return 'unknown';
        }
    }
    function quoteKey(key) {
        if (/^[a-z0-9_]+$/i.test(key)) {
            return key;
        }
        else {
            return `'${key.replace(/'/g, '\\\'')}'`;
        }
    }
    /**
     * Creates an array of related information diagnostics for a `DynamicValue` that describe the trace
     * of why an expression was evaluated as dynamic.
     *
     * @param node The node for which a `ts.Diagnostic` is to be created with the trace.
     * @param value The dynamic value for which a trace should be created.
     */
    function traceDynamicValue(node, value) {
        return value.accept(new TraceDynamicValueVisitor(node));
    }
    class TraceDynamicValueVisitor {
        constructor(node) {
            this.node = node;
            this.currentContainerNode = null;
        }
        visitDynamicInput(value) {
            const trace = value.reason.accept(this);
            if (this.shouldTrace(value.node)) {
                const info = makeRelatedInformation(value.node, 'Unable to evaluate this expression statically.');
                trace.unshift(info);
            }
            return trace;
        }
        visitDynamicString(value) {
            return [makeRelatedInformation(value.node, 'A string value could not be determined statically.')];
        }
        visitExternalReference(value) {
            const name = value.reason.debugName;
            const description = name !== null ? `'${name}'` : 'an anonymous declaration';
            return [makeRelatedInformation(value.node, `A value for ${description} cannot be determined statically, as it is an external declaration.`)];
        }
        visitComplexFunctionCall(value) {
            return [
                makeRelatedInformation(value.node, 'Unable to evaluate function call of complex function. A function must have exactly one return statement.'),
                makeRelatedInformation(value.reason.node, 'Function is declared here.')
            ];
        }
        visitInvalidExpressionType(value) {
            return [makeRelatedInformation(value.node, 'Unable to evaluate an invalid expression.')];
        }
        visitUnknown(value) {
            return [makeRelatedInformation(value.node, 'Unable to evaluate statically.')];
        }
        visitUnknownIdentifier(value) {
            return [makeRelatedInformation(value.node, 'Unknown reference.')];
        }
        visitDynamicType(value) {
            return [makeRelatedInformation(value.node, 'Dynamic type.')];
        }
        visitUnsupportedSyntax(value) {
            return [makeRelatedInformation(value.node, 'This syntax is not supported.')];
        }
        /**
         * Determines whether the dynamic value reported for the node should be traced, i.e. if it is not
         * part of the container for which the most recent trace was created.
         */
        shouldTrace(node) {
            if (node === this.node) {
                // Do not include a dynamic value for the origin node, as the main diagnostic is already
                // reported on that node.
                return false;
            }
            const container = getContainerNode(node);
            if (container === this.currentContainerNode) {
                // The node is part of the same container as the previous trace entry, so this dynamic value
                // should not become part of the trace.
                return false;
            }
            this.currentContainerNode = container;
            return true;
        }
    }
    /**
     * Determines the closest parent node that is to be considered as container, which is used to reduce
     * the granularity of tracing the dynamic values to a single entry per container. Currently, full
     * statements and destructuring patterns are considered as container.
     */
    function getContainerNode(node) {
        let currentNode = node;
        while (currentNode !== undefined) {
            switch (currentNode.kind) {
                case ts$1.SyntaxKind.ExpressionStatement:
                case ts$1.SyntaxKind.VariableStatement:
                case ts$1.SyntaxKind.ReturnStatement:
                case ts$1.SyntaxKind.IfStatement:
                case ts$1.SyntaxKind.SwitchStatement:
                case ts$1.SyntaxKind.DoStatement:
                case ts$1.SyntaxKind.WhileStatement:
                case ts$1.SyntaxKind.ForStatement:
                case ts$1.SyntaxKind.ForInStatement:
                case ts$1.SyntaxKind.ForOfStatement:
                case ts$1.SyntaxKind.ContinueStatement:
                case ts$1.SyntaxKind.BreakStatement:
                case ts$1.SyntaxKind.ThrowStatement:
                case ts$1.SyntaxKind.ObjectBindingPattern:
                case ts$1.SyntaxKind.ArrayBindingPattern:
                    return currentNode;
            }
            currentNode = currentNode.parent;
        }
        return node.getSourceFile();
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class ArraySliceBuiltinFn extends KnownFn {
        constructor(lhs) {
            super();
            this.lhs = lhs;
        }
        evaluate(node, args) {
            if (args.length === 0) {
                return this.lhs;
            }
            else {
                return DynamicValue.fromUnknown(node);
            }
        }
    }
    class ArrayConcatBuiltinFn extends KnownFn {
        constructor(lhs) {
            super();
            this.lhs = lhs;
        }
        evaluate(node, args) {
            const result = [...this.lhs];
            for (const arg of args) {
                if (arg instanceof DynamicValue) {
                    result.push(DynamicValue.fromDynamicInput(node, arg));
                }
                else if (Array.isArray(arg)) {
                    result.push(...arg);
                }
                else {
                    result.push(arg);
                }
            }
            return result;
        }
    }
    class ObjectAssignBuiltinFn extends KnownFn {
        evaluate(node, args) {
            if (args.length === 0) {
                return DynamicValue.fromUnsupportedSyntax(node);
            }
            for (const arg of args) {
                if (arg instanceof DynamicValue) {
                    return DynamicValue.fromDynamicInput(node, arg);
                }
                else if (!(arg instanceof Map)) {
                    return DynamicValue.fromUnsupportedSyntax(node);
                }
            }
            const [target, ...sources] = args;
            for (const source of sources) {
                source.forEach((value, key) => target.set(key, value));
            }
            return target;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    // Use the same implementation we use for `Object.assign()`. Semantically these functions are the
    // same, so they can also share the same evaluation code.
    class AssignHelperFn extends ObjectAssignBuiltinFn {
    }
    // Used for both `__spread()` and `__spreadArrays()` TypeScript helper functions.
    class SpreadHelperFn extends KnownFn {
        evaluate(node, args) {
            const result = [];
            for (const arg of args) {
                if (arg instanceof DynamicValue) {
                    result.push(DynamicValue.fromDynamicInput(node, arg));
                }
                else if (Array.isArray(arg)) {
                    result.push(...arg);
                }
                else {
                    result.push(arg);
                }
            }
            return result;
        }
    }
    // Used for `__spreadArray` TypeScript helper function.
    class SpreadArrayHelperFn extends KnownFn {
        evaluate(node, args) {
            if (args.length !== 2) {
                return DynamicValue.fromUnknown(node);
            }
            const [to, from] = args;
            if (to instanceof DynamicValue) {
                return DynamicValue.fromDynamicInput(node, to);
            }
            else if (from instanceof DynamicValue) {
                return DynamicValue.fromDynamicInput(node, from);
            }
            if (!Array.isArray(to)) {
                return DynamicValue.fromInvalidExpressionType(node, to);
            }
            else if (!Array.isArray(from)) {
                return DynamicValue.fromInvalidExpressionType(node, from);
            }
            return to.concat(from);
        }
    }
    // Used for `__read` TypeScript helper function.
    class ReadHelperFn extends KnownFn {
        evaluate(node, args) {
            if (args.length !== 1) {
                // The `__read` helper accepts a second argument `n` but that case is not supported.
                return DynamicValue.fromUnknown(node);
            }
            const [value] = args;
            if (value instanceof DynamicValue) {
                return DynamicValue.fromDynamicInput(node, value);
            }
            if (!Array.isArray(value)) {
                return DynamicValue.fromInvalidExpressionType(node, value);
            }
            return value;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /** Resolved value for the JavaScript global `Object` declaration. */
    const jsGlobalObjectValue = new Map([['assign', new ObjectAssignBuiltinFn()]]);
    /** Resolved value for the `__assign()` TypeScript helper declaration. */
    const assignTsHelperFn = new AssignHelperFn();
    /** Resolved value for the `__spread()` and `__spreadArrays()` TypeScript helper declarations. */
    const spreadTsHelperFn = new SpreadHelperFn();
    /** Resolved value for the `__spreadArray()` TypeScript helper declarations. */
    const spreadArrayTsHelperFn = new SpreadArrayHelperFn();
    /** Resolved value for the `__read()` TypeScript helper declarations. */
    const readTsHelperFn = new ReadHelperFn();
    /**
     * Resolves the specified known declaration to a resolved value. For example,
     * the known JavaScript global `Object` will resolve to a `Map` that provides the
     * `assign` method with a built-in function. This enables evaluation of `Object.assign`.
     */
    function resolveKnownDeclaration(decl) {
        switch (decl) {
            case KnownDeclaration.JsGlobalObject:
                return jsGlobalObjectValue;
            case KnownDeclaration.TsHelperAssign:
                return assignTsHelperFn;
            case KnownDeclaration.TsHelperSpread:
            case KnownDeclaration.TsHelperSpreadArrays:
                return spreadTsHelperFn;
            case KnownDeclaration.TsHelperSpreadArray:
                return spreadArrayTsHelperFn;
            case KnownDeclaration.TsHelperRead:
                return readTsHelperFn;
            default:
                throw new Error(`Cannot resolve known declaration. Received: ${KnownDeclaration[decl]}.`);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function literalBinaryOp(op) {
        return { op, literal: true };
    }
    function referenceBinaryOp(op) {
        return { op, literal: false };
    }
    const BINARY_OPERATORS = new Map([
        [ts$1.SyntaxKind.PlusToken, literalBinaryOp((a, b) => a + b)],
        [ts$1.SyntaxKind.MinusToken, literalBinaryOp((a, b) => a - b)],
        [ts$1.SyntaxKind.AsteriskToken, literalBinaryOp((a, b) => a * b)],
        [ts$1.SyntaxKind.SlashToken, literalBinaryOp((a, b) => a / b)],
        [ts$1.SyntaxKind.PercentToken, literalBinaryOp((a, b) => a % b)],
        [ts$1.SyntaxKind.AmpersandToken, literalBinaryOp((a, b) => a & b)],
        [ts$1.SyntaxKind.BarToken, literalBinaryOp((a, b) => a | b)],
        [ts$1.SyntaxKind.CaretToken, literalBinaryOp((a, b) => a ^ b)],
        [ts$1.SyntaxKind.LessThanToken, literalBinaryOp((a, b) => a < b)],
        [ts$1.SyntaxKind.LessThanEqualsToken, literalBinaryOp((a, b) => a <= b)],
        [ts$1.SyntaxKind.GreaterThanToken, literalBinaryOp((a, b) => a > b)],
        [ts$1.SyntaxKind.GreaterThanEqualsToken, literalBinaryOp((a, b) => a >= b)],
        [ts$1.SyntaxKind.EqualsEqualsToken, literalBinaryOp((a, b) => a == b)],
        [ts$1.SyntaxKind.EqualsEqualsEqualsToken, literalBinaryOp((a, b) => a === b)],
        [ts$1.SyntaxKind.ExclamationEqualsToken, literalBinaryOp((a, b) => a != b)],
        [ts$1.SyntaxKind.ExclamationEqualsEqualsToken, literalBinaryOp((a, b) => a !== b)],
        [ts$1.SyntaxKind.LessThanLessThanToken, literalBinaryOp((a, b) => a << b)],
        [ts$1.SyntaxKind.GreaterThanGreaterThanToken, literalBinaryOp((a, b) => a >> b)],
        [ts$1.SyntaxKind.GreaterThanGreaterThanGreaterThanToken, literalBinaryOp((a, b) => a >>> b)],
        [ts$1.SyntaxKind.AsteriskAsteriskToken, literalBinaryOp((a, b) => Math.pow(a, b))],
        [ts$1.SyntaxKind.AmpersandAmpersandToken, referenceBinaryOp((a, b) => a && b)],
        [ts$1.SyntaxKind.BarBarToken, referenceBinaryOp((a, b) => a || b)]
    ]);
    const UNARY_OPERATORS = new Map([
        [ts$1.SyntaxKind.TildeToken, a => ~a], [ts$1.SyntaxKind.MinusToken, a => -a],
        [ts$1.SyntaxKind.PlusToken, a => +a], [ts$1.SyntaxKind.ExclamationToken, a => !a]
    ]);
    class StaticInterpreter {
        constructor(host, checker, dependencyTracker) {
            this.host = host;
            this.checker = checker;
            this.dependencyTracker = dependencyTracker;
        }
        visit(node, context) {
            return this.visitExpression(node, context);
        }
        visitExpression(node, context) {
            let result;
            if (node.kind === ts$1.SyntaxKind.TrueKeyword) {
                return true;
            }
            else if (node.kind === ts$1.SyntaxKind.FalseKeyword) {
                return false;
            }
            else if (node.kind === ts$1.SyntaxKind.NullKeyword) {
                return null;
            }
            else if (ts$1.isStringLiteral(node)) {
                return node.text;
            }
            else if (ts$1.isNoSubstitutionTemplateLiteral(node)) {
                return node.text;
            }
            else if (ts$1.isTemplateExpression(node)) {
                result = this.visitTemplateExpression(node, context);
            }
            else if (ts$1.isNumericLiteral(node)) {
                return parseFloat(node.text);
            }
            else if (ts$1.isObjectLiteralExpression(node)) {
                result = this.visitObjectLiteralExpression(node, context);
            }
            else if (ts$1.isIdentifier(node)) {
                result = this.visitIdentifier(node, context);
            }
            else if (ts$1.isPropertyAccessExpression(node)) {
                result = this.visitPropertyAccessExpression(node, context);
            }
            else if (ts$1.isCallExpression(node)) {
                result = this.visitCallExpression(node, context);
            }
            else if (ts$1.isConditionalExpression(node)) {
                result = this.visitConditionalExpression(node, context);
            }
            else if (ts$1.isPrefixUnaryExpression(node)) {
                result = this.visitPrefixUnaryExpression(node, context);
            }
            else if (ts$1.isBinaryExpression(node)) {
                result = this.visitBinaryExpression(node, context);
            }
            else if (ts$1.isArrayLiteralExpression(node)) {
                result = this.visitArrayLiteralExpression(node, context);
            }
            else if (ts$1.isParenthesizedExpression(node)) {
                result = this.visitParenthesizedExpression(node, context);
            }
            else if (ts$1.isElementAccessExpression(node)) {
                result = this.visitElementAccessExpression(node, context);
            }
            else if (ts$1.isAsExpression(node)) {
                result = this.visitExpression(node.expression, context);
            }
            else if (ts$1.isNonNullExpression(node)) {
                result = this.visitExpression(node.expression, context);
            }
            else if (this.host.isClass(node)) {
                result = this.visitDeclaration(node, context);
            }
            else {
                return DynamicValue.fromUnsupportedSyntax(node);
            }
            if (result instanceof DynamicValue && result.node !== node) {
                return DynamicValue.fromDynamicInput(node, result);
            }
            return result;
        }
        visitArrayLiteralExpression(node, context) {
            const array = [];
            for (let i = 0; i < node.elements.length; i++) {
                const element = node.elements[i];
                if (ts$1.isSpreadElement(element)) {
                    array.push(...this.visitSpreadElement(element, context));
                }
                else {
                    array.push(this.visitExpression(element, context));
                }
            }
            return array;
        }
        visitObjectLiteralExpression(node, context) {
            const map = new Map();
            for (let i = 0; i < node.properties.length; i++) {
                const property = node.properties[i];
                if (ts$1.isPropertyAssignment(property)) {
                    const name = this.stringNameFromPropertyName(property.name, context);
                    // Check whether the name can be determined statically.
                    if (name === undefined) {
                        return DynamicValue.fromDynamicInput(node, DynamicValue.fromDynamicString(property.name));
                    }
                    map.set(name, this.visitExpression(property.initializer, context));
                }
                else if (ts$1.isShorthandPropertyAssignment(property)) {
                    const symbol = this.checker.getShorthandAssignmentValueSymbol(property);
                    if (symbol === undefined || symbol.valueDeclaration === undefined) {
                        map.set(property.name.text, DynamicValue.fromUnknown(property));
                    }
                    else {
                        map.set(property.name.text, this.visitDeclaration(symbol.valueDeclaration, context));
                    }
                }
                else if (ts$1.isSpreadAssignment(property)) {
                    const spread = this.visitExpression(property.expression, context);
                    if (spread instanceof DynamicValue) {
                        return DynamicValue.fromDynamicInput(node, spread);
                    }
                    else if (spread instanceof Map) {
                        spread.forEach((value, key) => map.set(key, value));
                    }
                    else if (spread instanceof ResolvedModule) {
                        spread.getExports().forEach((value, key) => map.set(key, value));
                    }
                    else {
                        return DynamicValue.fromDynamicInput(node, DynamicValue.fromInvalidExpressionType(property, spread));
                    }
                }
                else {
                    return DynamicValue.fromUnknown(node);
                }
            }
            return map;
        }
        visitTemplateExpression(node, context) {
            const pieces = [node.head.text];
            for (let i = 0; i < node.templateSpans.length; i++) {
                const span = node.templateSpans[i];
                const value = literal$1(this.visit(span.expression, context), () => DynamicValue.fromDynamicString(span.expression));
                if (value instanceof DynamicValue) {
                    return DynamicValue.fromDynamicInput(node, value);
                }
                pieces.push(`${value}`, span.literal.text);
            }
            return pieces.join('');
        }
        visitIdentifier(node, context) {
            const decl = this.host.getDeclarationOfIdentifier(node);
            if (decl === null) {
                if (node.originalKeywordKind === ts$1.SyntaxKind.UndefinedKeyword) {
                    return undefined;
                }
                else {
                    // Check if the symbol here is imported.
                    if (this.dependencyTracker !== null && this.host.getImportOfIdentifier(node) !== null) {
                        // It was, but no declaration for the node could be found. This means that the dependency
                        // graph for the current file cannot be properly updated to account for this (broken)
                        // import. Instead, the originating file is reported as failing dependency analysis,
                        // ensuring that future compilations will always attempt to re-resolve the previously
                        // broken identifier.
                        this.dependencyTracker.recordDependencyAnalysisFailure(context.originatingFile);
                    }
                    return DynamicValue.fromUnknownIdentifier(node);
                }
            }
            if (decl.known !== null) {
                return resolveKnownDeclaration(decl.known);
            }
            else if (isConcreteDeclaration(decl) && decl.identity !== null &&
                decl.identity.kind === 0 /* DownleveledEnum */) {
                return this.getResolvedEnum(decl.node, decl.identity.enumMembers, context);
            }
            const declContext = Object.assign(Object.assign({}, context), joinModuleContext(context, node, decl));
            const result = this.visitAmbiguousDeclaration(decl, declContext);
            if (result instanceof Reference$1) {
                // Only record identifiers to non-synthetic references. Synthetic references may not have the
                // same value at runtime as they do at compile time, so it's not legal to refer to them by the
                // identifier here.
                if (!result.synthetic) {
                    result.addIdentifier(node);
                }
            }
            else if (result instanceof DynamicValue) {
                return DynamicValue.fromDynamicInput(node, result);
            }
            return result;
        }
        visitDeclaration(node, context) {
            if (this.dependencyTracker !== null) {
                this.dependencyTracker.addDependency(context.originatingFile, node.getSourceFile());
            }
            if (this.host.isClass(node)) {
                return this.getReference(node, context);
            }
            else if (ts$1.isVariableDeclaration(node)) {
                return this.visitVariableDeclaration(node, context);
            }
            else if (ts$1.isParameter(node) && context.scope.has(node)) {
                return context.scope.get(node);
            }
            else if (ts$1.isExportAssignment(node)) {
                return this.visitExpression(node.expression, context);
            }
            else if (ts$1.isEnumDeclaration(node)) {
                return this.visitEnumDeclaration(node, context);
            }
            else if (ts$1.isSourceFile(node)) {
                return this.visitSourceFile(node, context);
            }
            else if (ts$1.isBindingElement(node)) {
                return this.visitBindingElement(node, context);
            }
            else {
                return this.getReference(node, context);
            }
        }
        visitVariableDeclaration(node, context) {
            const value = this.host.getVariableValue(node);
            if (value !== null) {
                return this.visitExpression(value, context);
            }
            else if (isVariableDeclarationDeclared(node)) {
                // If the declaration has a literal type that can be statically reduced to a value, resolve to
                // that value. If not, the historical behavior for variable declarations is to return a
                // `Reference` to the variable, as the consumer could use it in a context where knowing its
                // static value is not necessary.
                //
                // Arguably, since the value cannot be statically determined, we should return a
                // `DynamicValue`. This returns a `Reference` because it's the same behavior as before
                // `visitType` was introduced.
                //
                // TODO(zarend): investigate switching to a `DynamicValue` and verify this won't break any
                // use cases, especially in ngcc
                if (node.type !== undefined) {
                    const evaluatedType = this.visitType(node.type, context);
                    if (!(evaluatedType instanceof DynamicValue)) {
                        return evaluatedType;
                    }
                }
                return this.getReference(node, context);
            }
            else {
                return undefined;
            }
        }
        visitEnumDeclaration(node, context) {
            const enumRef = this.getReference(node, context);
            const map = new Map();
            node.members.forEach(member => {
                const name = this.stringNameFromPropertyName(member.name, context);
                if (name !== undefined) {
                    const resolved = member.initializer && this.visit(member.initializer, context);
                    map.set(name, new EnumValue(enumRef, name, resolved));
                }
            });
            return map;
        }
        visitElementAccessExpression(node, context) {
            const lhs = this.visitExpression(node.expression, context);
            if (lhs instanceof DynamicValue) {
                return DynamicValue.fromDynamicInput(node, lhs);
            }
            const rhs = this.visitExpression(node.argumentExpression, context);
            if (rhs instanceof DynamicValue) {
                return DynamicValue.fromDynamicInput(node, rhs);
            }
            if (typeof rhs !== 'string' && typeof rhs !== 'number') {
                return DynamicValue.fromInvalidExpressionType(node, rhs);
            }
            return this.accessHelper(node, lhs, rhs, context);
        }
        visitPropertyAccessExpression(node, context) {
            const lhs = this.visitExpression(node.expression, context);
            const rhs = node.name.text;
            // TODO: handle reference to class declaration.
            if (lhs instanceof DynamicValue) {
                return DynamicValue.fromDynamicInput(node, lhs);
            }
            return this.accessHelper(node, lhs, rhs, context);
        }
        visitSourceFile(node, context) {
            const declarations = this.host.getExportsOfModule(node);
            if (declarations === null) {
                return DynamicValue.fromUnknown(node);
            }
            return new ResolvedModule(declarations, decl => {
                if (decl.known !== null) {
                    return resolveKnownDeclaration(decl.known);
                }
                const declContext = Object.assign(Object.assign({}, context), joinModuleContext(context, node, decl));
                // Visit both concrete and inline declarations.
                return this.visitAmbiguousDeclaration(decl, declContext);
            });
        }
        visitAmbiguousDeclaration(decl, declContext) {
            return decl.kind === 1 /* Inline */ && decl.implementation !== undefined &&
                !isDeclaration(decl.implementation) ?
                // Inline declarations whose `implementation` is a `ts.Expression` should be visited as
                // an expression.
                this.visitExpression(decl.implementation, declContext) :
                // Otherwise just visit the `node` as a declaration.
                this.visitDeclaration(decl.node, declContext);
        }
        accessHelper(node, lhs, rhs, context) {
            const strIndex = `${rhs}`;
            if (lhs instanceof Map) {
                if (lhs.has(strIndex)) {
                    return lhs.get(strIndex);
                }
                else {
                    return undefined;
                }
            }
            else if (lhs instanceof ResolvedModule) {
                return lhs.getExport(strIndex);
            }
            else if (Array.isArray(lhs)) {
                if (rhs === 'length') {
                    return lhs.length;
                }
                else if (rhs === 'slice') {
                    return new ArraySliceBuiltinFn(lhs);
                }
                else if (rhs === 'concat') {
                    return new ArrayConcatBuiltinFn(lhs);
                }
                if (typeof rhs !== 'number' || !Number.isInteger(rhs)) {
                    return DynamicValue.fromInvalidExpressionType(node, rhs);
                }
                return lhs[rhs];
            }
            else if (lhs instanceof Reference$1) {
                const ref = lhs.node;
                if (this.host.isClass(ref)) {
                    const module = owningModule(context, lhs.bestGuessOwningModule);
                    let value = undefined;
                    const member = this.host.getMembersOfClass(ref).find(member => member.isStatic && member.name === strIndex);
                    if (member !== undefined) {
                        if (member.value !== null) {
                            value = this.visitExpression(member.value, context);
                        }
                        else if (member.implementation !== null) {
                            value = new Reference$1(member.implementation, module);
                        }
                        else if (member.node) {
                            value = new Reference$1(member.node, module);
                        }
                    }
                    return value;
                }
                else if (isDeclaration(ref)) {
                    return DynamicValue.fromDynamicInput(node, DynamicValue.fromExternalReference(ref, lhs));
                }
            }
            else if (lhs instanceof DynamicValue) {
                return DynamicValue.fromDynamicInput(node, lhs);
            }
            return DynamicValue.fromUnknown(node);
        }
        visitCallExpression(node, context) {
            const lhs = this.visitExpression(node.expression, context);
            if (lhs instanceof DynamicValue) {
                return DynamicValue.fromDynamicInput(node, lhs);
            }
            // If the call refers to a builtin function, attempt to evaluate the function.
            if (lhs instanceof KnownFn) {
                return lhs.evaluate(node, this.evaluateFunctionArguments(node, context));
            }
            if (!(lhs instanceof Reference$1)) {
                return DynamicValue.fromInvalidExpressionType(node.expression, lhs);
            }
            const fn = this.host.getDefinitionOfFunction(lhs.node);
            if (fn === null) {
                return DynamicValue.fromInvalidExpressionType(node.expression, lhs);
            }
            if (!isFunctionOrMethodReference(lhs)) {
                return DynamicValue.fromInvalidExpressionType(node.expression, lhs);
            }
            // If the function is foreign (declared through a d.ts file), attempt to resolve it with the
            // foreignFunctionResolver, if one is specified.
            if (fn.body === null) {
                let expr = null;
                if (context.foreignFunctionResolver) {
                    expr = context.foreignFunctionResolver(lhs, node.arguments);
                }
                if (expr === null) {
                    return DynamicValue.fromDynamicInput(node, DynamicValue.fromExternalReference(node.expression, lhs));
                }
                // If the foreign expression occurs in a different file, then assume that the owning module
                // of the call expression should also be used for the resolved foreign expression.
                if (expr.getSourceFile() !== node.expression.getSourceFile() &&
                    lhs.bestGuessOwningModule !== null) {
                    context = Object.assign(Object.assign({}, context), { absoluteModuleName: lhs.bestGuessOwningModule.specifier, resolutionContext: lhs.bestGuessOwningModule.resolutionContext });
                }
                return this.visitFfrExpression(expr, context);
            }
            let res = this.visitFunctionBody(node, fn, context);
            // If the result of attempting to resolve the function body was a DynamicValue, attempt to use
            // the foreignFunctionResolver if one is present. This could still potentially yield a usable
            // value.
            if (res instanceof DynamicValue && context.foreignFunctionResolver !== undefined) {
                const ffrExpr = context.foreignFunctionResolver(lhs, node.arguments);
                if (ffrExpr !== null) {
                    // The foreign function resolver was able to extract an expression from this function. See
                    // if that expression leads to a non-dynamic result.
                    const ffrRes = this.visitFfrExpression(ffrExpr, context);
                    if (!(ffrRes instanceof DynamicValue)) {
                        // FFR yielded an actual result that's not dynamic, so use that instead of the original
                        // resolution.
                        res = ffrRes;
                    }
                }
            }
            return res;
        }
        /**
         * Visit an expression which was extracted from a foreign-function resolver.
         *
         * This will process the result and ensure it's correct for FFR-resolved values, including marking
         * `Reference`s as synthetic.
         */
        visitFfrExpression(expr, context) {
            const res = this.visitExpression(expr, context);
            if (res instanceof Reference$1) {
                // This Reference was created synthetically, via a foreign function resolver. The real
                // runtime value of the function expression may be different than the foreign function
                // resolved value, so mark the Reference as synthetic to avoid it being misinterpreted.
                res.synthetic = true;
            }
            return res;
        }
        visitFunctionBody(node, fn, context) {
            if (fn.body === null) {
                return DynamicValue.fromUnknown(node);
            }
            else if (fn.body.length !== 1 || !ts$1.isReturnStatement(fn.body[0])) {
                return DynamicValue.fromComplexFunctionCall(node, fn);
            }
            const ret = fn.body[0];
            const args = this.evaluateFunctionArguments(node, context);
            const newScope = new Map();
            const calleeContext = Object.assign(Object.assign({}, context), { scope: newScope });
            fn.parameters.forEach((param, index) => {
                let arg = args[index];
                if (param.node.dotDotDotToken !== undefined) {
                    arg = args.slice(index);
                }
                if (arg === undefined && param.initializer !== null) {
                    arg = this.visitExpression(param.initializer, calleeContext);
                }
                newScope.set(param.node, arg);
            });
            return ret.expression !== undefined ? this.visitExpression(ret.expression, calleeContext) :
                undefined;
        }
        visitConditionalExpression(node, context) {
            const condition = this.visitExpression(node.condition, context);
            if (condition instanceof DynamicValue) {
                return DynamicValue.fromDynamicInput(node, condition);
            }
            if (condition) {
                return this.visitExpression(node.whenTrue, context);
            }
            else {
                return this.visitExpression(node.whenFalse, context);
            }
        }
        visitPrefixUnaryExpression(node, context) {
            const operatorKind = node.operator;
            if (!UNARY_OPERATORS.has(operatorKind)) {
                return DynamicValue.fromUnsupportedSyntax(node);
            }
            const op = UNARY_OPERATORS.get(operatorKind);
            const value = this.visitExpression(node.operand, context);
            if (value instanceof DynamicValue) {
                return DynamicValue.fromDynamicInput(node, value);
            }
            else {
                return op(value);
            }
        }
        visitBinaryExpression(node, context) {
            const tokenKind = node.operatorToken.kind;
            if (!BINARY_OPERATORS.has(tokenKind)) {
                return DynamicValue.fromUnsupportedSyntax(node);
            }
            const opRecord = BINARY_OPERATORS.get(tokenKind);
            let lhs, rhs;
            if (opRecord.literal) {
                lhs = literal$1(this.visitExpression(node.left, context), value => DynamicValue.fromInvalidExpressionType(node.left, value));
                rhs = literal$1(this.visitExpression(node.right, context), value => DynamicValue.fromInvalidExpressionType(node.right, value));
            }
            else {
                lhs = this.visitExpression(node.left, context);
                rhs = this.visitExpression(node.right, context);
            }
            if (lhs instanceof DynamicValue) {
                return DynamicValue.fromDynamicInput(node, lhs);
            }
            else if (rhs instanceof DynamicValue) {
                return DynamicValue.fromDynamicInput(node, rhs);
            }
            else {
                return opRecord.op(lhs, rhs);
            }
        }
        visitParenthesizedExpression(node, context) {
            return this.visitExpression(node.expression, context);
        }
        evaluateFunctionArguments(node, context) {
            const args = [];
            for (const arg of node.arguments) {
                if (ts$1.isSpreadElement(arg)) {
                    args.push(...this.visitSpreadElement(arg, context));
                }
                else {
                    args.push(this.visitExpression(arg, context));
                }
            }
            return args;
        }
        visitSpreadElement(node, context) {
            const spread = this.visitExpression(node.expression, context);
            if (spread instanceof DynamicValue) {
                return [DynamicValue.fromDynamicInput(node, spread)];
            }
            else if (!Array.isArray(spread)) {
                return [DynamicValue.fromInvalidExpressionType(node, spread)];
            }
            else {
                return spread;
            }
        }
        visitBindingElement(node, context) {
            const path = [];
            let closestDeclaration = node;
            while (ts$1.isBindingElement(closestDeclaration) ||
                ts$1.isArrayBindingPattern(closestDeclaration) ||
                ts$1.isObjectBindingPattern(closestDeclaration)) {
                if (ts$1.isBindingElement(closestDeclaration)) {
                    path.unshift(closestDeclaration);
                }
                closestDeclaration = closestDeclaration.parent;
            }
            if (!ts$1.isVariableDeclaration(closestDeclaration) ||
                closestDeclaration.initializer === undefined) {
                return DynamicValue.fromUnknown(node);
            }
            let value = this.visit(closestDeclaration.initializer, context);
            for (const element of path) {
                let key;
                if (ts$1.isArrayBindingPattern(element.parent)) {
                    key = element.parent.elements.indexOf(element);
                }
                else {
                    const name = element.propertyName || element.name;
                    if (ts$1.isIdentifier(name)) {
                        key = name.text;
                    }
                    else {
                        return DynamicValue.fromUnknown(element);
                    }
                }
                value = this.accessHelper(element, value, key, context);
                if (value instanceof DynamicValue) {
                    return value;
                }
            }
            return value;
        }
        stringNameFromPropertyName(node, context) {
            if (ts$1.isIdentifier(node) || ts$1.isStringLiteral(node) || ts$1.isNumericLiteral(node)) {
                return node.text;
            }
            else if (ts$1.isComputedPropertyName(node)) {
                const literal = this.visitExpression(node.expression, context);
                return typeof literal === 'string' ? literal : undefined;
            }
            else {
                return undefined;
            }
        }
        getResolvedEnum(node, enumMembers, context) {
            const enumRef = this.getReference(node, context);
            const map = new Map();
            enumMembers.forEach(member => {
                const name = this.stringNameFromPropertyName(member.name, context);
                if (name !== undefined) {
                    const resolved = this.visit(member.initializer, context);
                    map.set(name, new EnumValue(enumRef, name, resolved));
                }
            });
            return map;
        }
        getReference(node, context) {
            return new Reference$1(node, owningModule(context));
        }
        visitType(node, context) {
            if (ts$1.isLiteralTypeNode(node)) {
                return this.visitExpression(node.literal, context);
            }
            else if (ts$1.isTupleTypeNode(node)) {
                return this.visitTupleType(node, context);
            }
            else if (ts$1.isNamedTupleMember(node)) {
                return this.visitType(node.type, context);
            }
            return DynamicValue.fromDynamicType(node);
        }
        visitTupleType(node, context) {
            const res = [];
            for (const elem of node.elements) {
                res.push(this.visitType(elem, context));
            }
            return res;
        }
    }
    function isFunctionOrMethodReference(ref) {
        return ts$1.isFunctionDeclaration(ref.node) || ts$1.isMethodDeclaration(ref.node) ||
            ts$1.isFunctionExpression(ref.node);
    }
    function literal$1(value, reject) {
        if (value instanceof EnumValue) {
            value = value.resolved;
        }
        if (value instanceof DynamicValue || value === null || value === undefined ||
            typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
            return value;
        }
        return reject(value);
    }
    function isVariableDeclarationDeclared(node) {
        if (node.parent === undefined || !ts$1.isVariableDeclarationList(node.parent)) {
            return false;
        }
        const declList = node.parent;
        if (declList.parent === undefined || !ts$1.isVariableStatement(declList.parent)) {
            return false;
        }
        const varStmt = declList.parent;
        return varStmt.modifiers !== undefined &&
            varStmt.modifiers.some(mod => mod.kind === ts$1.SyntaxKind.DeclareKeyword);
    }
    const EMPTY = {};
    function joinModuleContext(existing, node, decl) {
        if (decl.viaModule !== null && decl.viaModule !== existing.absoluteModuleName) {
            return {
                absoluteModuleName: decl.viaModule,
                resolutionContext: node.getSourceFile().fileName,
            };
        }
        else {
            return EMPTY;
        }
    }
    function owningModule(context, override = null) {
        let specifier = context.absoluteModuleName;
        if (override !== null) {
            specifier = override.specifier;
        }
        if (specifier !== null) {
            return {
                specifier,
                resolutionContext: context.resolutionContext,
            };
        }
        else {
            return null;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class PartialEvaluator {
        constructor(host, checker, dependencyTracker) {
            this.host = host;
            this.checker = checker;
            this.dependencyTracker = dependencyTracker;
        }
        evaluate(expr, foreignFunctionResolver) {
            const interpreter = new StaticInterpreter(this.host, this.checker, this.dependencyTracker);
            const sourceFile = expr.getSourceFile();
            return interpreter.visit(expr, {
                originatingFile: sourceFile,
                absoluteModuleName: null,
                resolutionContext: sourceFile.fileName,
                scope: new Map(),
                foreignFunctionResolver,
            });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A phase of compilation for which time is tracked in a distinct bucket.
     */
    var PerfPhase;
    (function (PerfPhase) {
        /**
         * The "default" phase which tracks time not spent in any other phase.
         */
        PerfPhase[PerfPhase["Unaccounted"] = 0] = "Unaccounted";
        /**
         * Time spent setting up the compiler, before a TypeScript program is created.
         *
         * This includes operations like configuring the `ts.CompilerHost` and any wrappers.
         */
        PerfPhase[PerfPhase["Setup"] = 1] = "Setup";
        /**
         * Time spent in `ts.createProgram`, including reading and parsing `ts.SourceFile`s in the
         * `ts.CompilerHost`.
         *
         * This might be an incremental program creation operation.
         */
        PerfPhase[PerfPhase["TypeScriptProgramCreate"] = 2] = "TypeScriptProgramCreate";
        /**
         * Time spent reconciling the contents of an old `ts.Program` with the new incremental one.
         *
         * Only present in incremental compilations.
         */
        PerfPhase[PerfPhase["Reconciliation"] = 3] = "Reconciliation";
        /**
         * Time spent updating an `NgCompiler` instance with a resource-only change.
         *
         * Only present in incremental compilations where the change was resource-only.
         */
        PerfPhase[PerfPhase["ResourceUpdate"] = 4] = "ResourceUpdate";
        /**
         * Time spent calculating the plain TypeScript diagnostics (structural and semantic).
         */
        PerfPhase[PerfPhase["TypeScriptDiagnostics"] = 5] = "TypeScriptDiagnostics";
        /**
         * Time spent in Angular analysis of individual classes in the program.
         */
        PerfPhase[PerfPhase["Analysis"] = 6] = "Analysis";
        /**
         * Time spent in Angular global analysis (synthesis of analysis information into a complete
         * understanding of the program).
         */
        PerfPhase[PerfPhase["Resolve"] = 7] = "Resolve";
        /**
         * Time spent building the import graph of the program in order to perform cycle detection.
         */
        PerfPhase[PerfPhase["CycleDetection"] = 8] = "CycleDetection";
        /**
         * Time spent generating the text of Type Check Blocks in order to perform template type checking.
         */
        PerfPhase[PerfPhase["TcbGeneration"] = 9] = "TcbGeneration";
        /**
         * Time spent updating the `ts.Program` with new Type Check Block code.
         */
        PerfPhase[PerfPhase["TcbUpdateProgram"] = 10] = "TcbUpdateProgram";
        /**
         * Time spent by TypeScript performing its emit operations, including downleveling and writing
         * output files.
         */
        PerfPhase[PerfPhase["TypeScriptEmit"] = 11] = "TypeScriptEmit";
        /**
         * Time spent by Angular performing code transformations of ASTs as they're about to be emitted.
         *
         * This includes the actual code generation step for templates, and occurs during the emit phase
         * (but is tracked separately from `TypeScriptEmit` time).
         */
        PerfPhase[PerfPhase["Compile"] = 12] = "Compile";
        /**
         * Time spent performing a `TemplateTypeChecker` autocompletion operation.
         */
        PerfPhase[PerfPhase["TtcAutocompletion"] = 13] = "TtcAutocompletion";
        /**
         * Time spent computing template type-checking diagnostics.
         */
        PerfPhase[PerfPhase["TtcDiagnostics"] = 14] = "TtcDiagnostics";
        /**
         * Time spent getting a `Symbol` from the `TemplateTypeChecker`.
         */
        PerfPhase[PerfPhase["TtcSymbol"] = 15] = "TtcSymbol";
        /**
         * Time spent by the Angular Language Service calculating a "get references" or a renaming
         * operation.
         */
        PerfPhase[PerfPhase["LsReferencesAndRenames"] = 16] = "LsReferencesAndRenames";
        /**
         * Time spent by the Angular Language Service calculating a "quick info" operation.
         */
        PerfPhase[PerfPhase["LsQuickInfo"] = 17] = "LsQuickInfo";
        /**
         * Time spent by the Angular Language Service calculating a "get type definition" or "get
         * definition" operation.
         */
        PerfPhase[PerfPhase["LsDefinition"] = 18] = "LsDefinition";
        /**
         * Time spent by the Angular Language Service calculating a "get completions" (AKA autocomplete)
         * operation.
         */
        PerfPhase[PerfPhase["LsCompletions"] = 19] = "LsCompletions";
        /**
         * Time spent by the Angular Language Service calculating a "view template typecheck block"
         * operation.
         */
        PerfPhase[PerfPhase["LsTcb"] = 20] = "LsTcb";
        /**
         * Time spent by the Angular Language Service calculating diagnostics.
         */
        PerfPhase[PerfPhase["LsDiagnostics"] = 21] = "LsDiagnostics";
        /**
         * Time spent by the Angular Language Service calculating a "get component locations for template"
         * operation.
         */
        PerfPhase[PerfPhase["LsComponentLocations"] = 22] = "LsComponentLocations";
        /**
         * Time spent by the Angular Language Service calculating signature help.
         */
        PerfPhase[PerfPhase["LsSignatureHelp"] = 23] = "LsSignatureHelp";
        /**
         * Tracks the number of `PerfPhase`s, and must appear at the end of the list.
         */
        PerfPhase[PerfPhase["LAST"] = 24] = "LAST";
    })(PerfPhase || (PerfPhase = {}));
    /**
     * Represents some occurrence during compilation, and is tracked with a counter.
     */
    var PerfEvent;
    (function (PerfEvent) {
        /**
         * Counts the number of `.d.ts` files in the program.
         */
        PerfEvent[PerfEvent["InputDtsFile"] = 0] = "InputDtsFile";
        /**
         * Counts the number of non-`.d.ts` files in the program.
         */
        PerfEvent[PerfEvent["InputTsFile"] = 1] = "InputTsFile";
        /**
         * An `@Component` class was analyzed.
         */
        PerfEvent[PerfEvent["AnalyzeComponent"] = 2] = "AnalyzeComponent";
        /**
         * An `@Directive` class was analyzed.
         */
        PerfEvent[PerfEvent["AnalyzeDirective"] = 3] = "AnalyzeDirective";
        /**
         * An `@Injectable` class was analyzed.
         */
        PerfEvent[PerfEvent["AnalyzeInjectable"] = 4] = "AnalyzeInjectable";
        /**
         * An `@NgModule` class was analyzed.
         */
        PerfEvent[PerfEvent["AnalyzeNgModule"] = 5] = "AnalyzeNgModule";
        /**
         * An `@Pipe` class was analyzed.
         */
        PerfEvent[PerfEvent["AnalyzePipe"] = 6] = "AnalyzePipe";
        /**
         * A trait was analyzed.
         *
         * In theory, this should be the sum of the `Analyze` counters for each decorator type.
         */
        PerfEvent[PerfEvent["TraitAnalyze"] = 7] = "TraitAnalyze";
        /**
         * A trait had a prior analysis available from an incremental program, and did not need to be
         * re-analyzed.
         */
        PerfEvent[PerfEvent["TraitReuseAnalysis"] = 8] = "TraitReuseAnalysis";
        /**
         * A `ts.SourceFile` directly changed between the prior program and a new incremental compilation.
         */
        PerfEvent[PerfEvent["SourceFilePhysicalChange"] = 9] = "SourceFilePhysicalChange";
        /**
         * A `ts.SourceFile` did not physically changed, but according to the file dependency graph, has
         * logically changed between the prior program and a new incremental compilation.
         */
        PerfEvent[PerfEvent["SourceFileLogicalChange"] = 10] = "SourceFileLogicalChange";
        /**
         * A `ts.SourceFile` has not logically changed and all of its analysis results were thus available
         * for reuse.
         */
        PerfEvent[PerfEvent["SourceFileReuseAnalysis"] = 11] = "SourceFileReuseAnalysis";
        /**
         * A Type Check Block (TCB) was generated.
         */
        PerfEvent[PerfEvent["GenerateTcb"] = 12] = "GenerateTcb";
        /**
         * A Type Check Block (TCB) could not be generated because inlining was disabled, and the block
         * would've required inlining.
         */
        PerfEvent[PerfEvent["SkipGenerateTcbNoInline"] = 13] = "SkipGenerateTcbNoInline";
        /**
         * A `.ngtypecheck.ts` file could be reused from the previous program and did not need to be
         * regenerated.
         */
        PerfEvent[PerfEvent["ReuseTypeCheckFile"] = 14] = "ReuseTypeCheckFile";
        /**
         * The template type-checking program required changes and had to be updated in an incremental
         * step.
         */
        PerfEvent[PerfEvent["UpdateTypeCheckProgram"] = 15] = "UpdateTypeCheckProgram";
        /**
         * The compiler was able to prove that a `ts.SourceFile` did not need to be re-emitted.
         */
        PerfEvent[PerfEvent["EmitSkipSourceFile"] = 16] = "EmitSkipSourceFile";
        /**
         * A `ts.SourceFile` was emitted.
         */
        PerfEvent[PerfEvent["EmitSourceFile"] = 17] = "EmitSourceFile";
        /**
         * Tracks the number of `PrefEvent`s, and must appear at the end of the list.
         */
        PerfEvent[PerfEvent["LAST"] = 18] = "LAST";
    })(PerfEvent || (PerfEvent = {}));
    /**
     * Represents a checkpoint during compilation at which the memory usage of the compiler should be
     * recorded.
     */
    var PerfCheckpoint;
    (function (PerfCheckpoint) {
        /**
         * The point at which the `PerfRecorder` was created, and ideally tracks memory used before any
         * compilation structures are created.
         */
        PerfCheckpoint[PerfCheckpoint["Initial"] = 0] = "Initial";
        /**
         * The point just after the `ts.Program` has been created.
         */
        PerfCheckpoint[PerfCheckpoint["TypeScriptProgramCreate"] = 1] = "TypeScriptProgramCreate";
        /**
         * The point just before Angular analysis starts.
         *
         * In the main usage pattern for the compiler, TypeScript diagnostics have been calculated at this
         * point, so the `ts.TypeChecker` has fully ingested the current program, all `ts.Type` structures
         * and `ts.Symbol`s have been created.
         */
        PerfCheckpoint[PerfCheckpoint["PreAnalysis"] = 2] = "PreAnalysis";
        /**
         * The point just after Angular analysis completes.
         */
        PerfCheckpoint[PerfCheckpoint["Analysis"] = 3] = "Analysis";
        /**
         * The point just after Angular resolution is complete.
         */
        PerfCheckpoint[PerfCheckpoint["Resolve"] = 4] = "Resolve";
        /**
         * The point just after Type Check Blocks (TCBs) have been generated.
         */
        PerfCheckpoint[PerfCheckpoint["TtcGeneration"] = 5] = "TtcGeneration";
        /**
         * The point just after the template type-checking program has been updated with any new TCBs.
         */
        PerfCheckpoint[PerfCheckpoint["TtcUpdateProgram"] = 6] = "TtcUpdateProgram";
        /**
         * The point just before emit begins.
         *
         * In the main usage pattern for the compiler, all template type-checking diagnostics have been
         * requested at this point.
         */
        PerfCheckpoint[PerfCheckpoint["PreEmit"] = 7] = "PreEmit";
        /**
         * The point just after the program has been fully emitted.
         */
        PerfCheckpoint[PerfCheckpoint["Emit"] = 8] = "Emit";
        /**
         * Tracks the number of `PerfCheckpoint`s, and must appear at the end of the list.
         */
        PerfCheckpoint[PerfCheckpoint["LAST"] = 9] = "LAST";
    })(PerfCheckpoint || (PerfCheckpoint = {}));

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function mark() {
        return process.hrtime();
    }
    function timeSinceInMicros(mark) {
        const delta = process.hrtime(mark);
        return (delta[0] * 1000000) + Math.floor(delta[1] / 1000);
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A `PerfRecorder` that actively tracks performance statistics.
     */
    class ActivePerfRecorder {
        constructor(zeroTime) {
            this.zeroTime = zeroTime;
            this.currentPhase = PerfPhase.Unaccounted;
            this.currentPhaseEntered = this.zeroTime;
            this.counters = Array(PerfEvent.LAST).fill(0);
            this.phaseTime = Array(PerfPhase.LAST).fill(0);
            this.bytes = Array(PerfCheckpoint.LAST).fill(0);
            // Take an initial memory snapshot before any other compilation work begins.
            this.memory(PerfCheckpoint.Initial);
        }
        /**
         * Creates an `ActivePerfRecoder` with its zero point set to the current time.
         */
        static zeroedToNow() {
            return new ActivePerfRecorder(mark());
        }
        reset() {
            this.counters = Array(PerfEvent.LAST).fill(0);
            this.phaseTime = Array(PerfPhase.LAST).fill(0);
            this.bytes = Array(PerfCheckpoint.LAST).fill(0);
            this.zeroTime = mark();
            this.currentPhase = PerfPhase.Unaccounted;
            this.currentPhaseEntered = this.zeroTime;
        }
        memory(after) {
            this.bytes[after] = process.memoryUsage().heapUsed;
        }
        phase(phase) {
            const previous = this.currentPhase;
            this.phaseTime[this.currentPhase] += timeSinceInMicros(this.currentPhaseEntered);
            this.currentPhase = phase;
            this.currentPhaseEntered = mark();
            return previous;
        }
        inPhase(phase, fn) {
            const previousPhase = this.phase(phase);
            try {
                return fn();
            }
            finally {
                this.phase(previousPhase);
            }
        }
        eventCount(counter, incrementBy = 1) {
            this.counters[counter] += incrementBy;
        }
        /**
         * Return the current performance metrics as a serializable object.
         */
        finalize() {
            // Track the last segment of time spent in `this.currentPhase` in the time array.
            this.phase(PerfPhase.Unaccounted);
            const results = {
                events: {},
                phases: {},
                memory: {},
            };
            for (let i = 0; i < this.phaseTime.length; i++) {
                if (this.phaseTime[i] > 0) {
                    results.phases[PerfPhase[i]] = this.phaseTime[i];
                }
            }
            for (let i = 0; i < this.phaseTime.length; i++) {
                if (this.counters[i] > 0) {
                    results.events[PerfEvent[i]] = this.counters[i];
                }
            }
            for (let i = 0; i < this.bytes.length; i++) {
                if (this.bytes[i] > 0) {
                    results.memory[PerfCheckpoint[i]] = this.bytes[i];
                }
            }
            return results;
        }
    }
    /**
     * A `PerfRecorder` that delegates to a target `PerfRecorder` which can be updated later.
     *
     * `DelegatingPerfRecorder` is useful when a compiler class that needs a `PerfRecorder` can outlive
     * the current compilation. This is true for most compiler classes as resource-only changes reuse
     * the same `NgCompiler` for a new compilation.
     */
    class DelegatingPerfRecorder {
        constructor(target) {
            this.target = target;
        }
        eventCount(counter, incrementBy) {
            this.target.eventCount(counter, incrementBy);
        }
        phase(phase) {
            return this.target.phase(phase);
        }
        inPhase(phase, fn) {
            // Note: this doesn't delegate to `this.target.inPhase` but instead is implemented manually here
            // to avoid adding an additional frame of noise to the stack when debugging.
            const previousPhase = this.target.phase(phase);
            try {
                return fn();
            }
            finally {
                this.target.phase(previousPhase);
            }
        }
        memory(after) {
            this.target.memory(after);
        }
        reset() {
            this.target.reset();
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Specifies the compilation mode that is used for the compilation.
     */
    var CompilationMode;
    (function (CompilationMode) {
        /**
         * Generates fully AOT compiled code using Ivy instructions.
         */
        CompilationMode[CompilationMode["FULL"] = 0] = "FULL";
        /**
         * Generates code using a stable, but intermediate format suitable to be published to NPM.
         */
        CompilationMode[CompilationMode["PARTIAL"] = 1] = "PARTIAL";
    })(CompilationMode || (CompilationMode = {}));
    var HandlerPrecedence;
    (function (HandlerPrecedence) {
        /**
         * Handler with PRIMARY precedence cannot overlap - there can only be one on a given class.
         *
         * If more than one PRIMARY handler matches a class, an error is produced.
         */
        HandlerPrecedence[HandlerPrecedence["PRIMARY"] = 0] = "PRIMARY";
        /**
         * Handlers with SHARED precedence can match any class, possibly in addition to a single PRIMARY
         * handler.
         *
         * It is not an error for a class to have any number of SHARED handlers.
         */
        HandlerPrecedence[HandlerPrecedence["SHARED"] = 1] = "SHARED";
        /**
         * Handlers with WEAK precedence that match a class are ignored if any handlers with stronger
         * precedence match a class.
         */
        HandlerPrecedence[HandlerPrecedence["WEAK"] = 2] = "WEAK";
    })(HandlerPrecedence || (HandlerPrecedence = {}));
    /**
     * A set of options which can be passed to a `DecoratorHandler` by a consumer, to tailor the output
     * of compilation beyond the decorators themselves.
     */
    var HandlerFlags;
    (function (HandlerFlags) {
        /**
         * No flags set.
         */
        HandlerFlags[HandlerFlags["NONE"] = 0] = "NONE";
        /**
         * Indicates that this decorator is fully inherited from its parent at runtime. In addition to
         * normally inherited aspects such as inputs and queries, full inheritance applies to every aspect
         * of the component or directive, such as the template function itself.
         *
         * Its primary effect is to cause the `CopyDefinitionFeature` to be applied to the definition
         * being compiled. See that class for more information.
         */
        HandlerFlags[HandlerFlags["FULL_INHERITANCE"] = 1] = "FULL_INHERITANCE";
    })(HandlerFlags || (HandlerFlags = {}));

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function aliasTransformFactory(exportStatements) {
        return (context) => {
            return (file) => {
                if (ts$1.isBundle(file) || !exportStatements.has(file.fileName)) {
                    return file;
                }
                const statements = [...file.statements];
                exportStatements.get(file.fileName).forEach(([moduleName, symbolName], aliasName) => {
                    const stmt = ts$1.createExportDeclaration(
                    /* decorators */ undefined, 
                    /* modifiers */ undefined, 
                    /* exportClause */ ts$1.createNamedExports([ts$1.createExportSpecifier(
                        /* propertyName */ symbolName, 
                        /* name */ aliasName)]), 
                    /* moduleSpecifier */ ts$1.createStringLiteral(moduleName));
                    statements.push(stmt);
                });
                return ts$1.updateSourceFileNode(file, statements);
            };
        };
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var TraitState;
    (function (TraitState) {
        /**
         * Pending traits are freshly created and have never been analyzed.
         */
        TraitState[TraitState["Pending"] = 0] = "Pending";
        /**
         * Analyzed traits have successfully been analyzed, but are pending resolution.
         */
        TraitState[TraitState["Analyzed"] = 1] = "Analyzed";
        /**
         * Resolved traits have successfully been analyzed and resolved and are ready for compilation.
         */
        TraitState[TraitState["Resolved"] = 2] = "Resolved";
        /**
         * Skipped traits are no longer considered for compilation.
         */
        TraitState[TraitState["Skipped"] = 3] = "Skipped";
    })(TraitState || (TraitState = {}));
    /**
     * The value side of `Trait` exposes a helper to create a `Trait` in a pending state (by delegating
     * to `TraitImpl`).
     */
    const Trait = {
        pending: (handler, detected) => TraitImpl.pending(handler, detected),
    };
    /**
     * An implementation of the `Trait` type which transitions safely between the various
     * `TraitState`s.
     */
    class TraitImpl {
        constructor(handler, detected) {
            this.state = TraitState.Pending;
            this.analysis = null;
            this.symbol = null;
            this.resolution = null;
            this.analysisDiagnostics = null;
            this.resolveDiagnostics = null;
            this.handler = handler;
            this.detected = detected;
        }
        toAnalyzed(analysis, diagnostics, symbol) {
            // Only pending traits can be analyzed.
            this.assertTransitionLegal(TraitState.Pending, TraitState.Analyzed);
            this.analysis = analysis;
            this.analysisDiagnostics = diagnostics;
            this.symbol = symbol;
            this.state = TraitState.Analyzed;
            return this;
        }
        toResolved(resolution, diagnostics) {
            // Only analyzed traits can be resolved.
            this.assertTransitionLegal(TraitState.Analyzed, TraitState.Resolved);
            if (this.analysis === null) {
                throw new Error(`Cannot transition an Analyzed trait with a null analysis to Resolved`);
            }
            this.resolution = resolution;
            this.state = TraitState.Resolved;
            this.resolveDiagnostics = diagnostics;
            return this;
        }
        toSkipped() {
            // Only pending traits can be skipped.
            this.assertTransitionLegal(TraitState.Pending, TraitState.Skipped);
            this.state = TraitState.Skipped;
            return this;
        }
        /**
         * Verifies that the trait is currently in one of the `allowedState`s.
         *
         * If correctly used, the `Trait` type and transition methods prevent illegal transitions from
         * occurring. However, if a reference to the `TraitImpl` instance typed with the previous
         * interface is retained after calling one of its transition methods, it will allow for illegal
         * transitions to take place. Hence, this assertion provides a little extra runtime protection.
         */
        assertTransitionLegal(allowedState, transitionTo) {
            if (!(this.state === allowedState)) {
                throw new Error(`Assertion failure: cannot transition from ${TraitState[this.state]} to ${TraitState[transitionTo]}.`);
            }
        }
        /**
         * Construct a new `TraitImpl` in the pending state.
         */
        static pending(handler, detected) {
            return new TraitImpl(handler, detected);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * The heart of Angular compilation.
     *
     * The `TraitCompiler` is responsible for processing all classes in the program. Any time a
     * `DecoratorHandler` matches a class, a "trait" is created to represent that Angular aspect of the
     * class (such as the class having a component definition).
     *
     * The `TraitCompiler` transitions each trait through the various phases of compilation, culminating
     * in the production of `CompileResult`s instructing the compiler to apply various mutations to the
     * class (like adding fields or type declarations).
     */
    class TraitCompiler {
        constructor(handlers, reflector, perf, incrementalBuild, compileNonExportedClasses, compilationMode, dtsTransforms, semanticDepGraphUpdater) {
            this.handlers = handlers;
            this.reflector = reflector;
            this.perf = perf;
            this.incrementalBuild = incrementalBuild;
            this.compileNonExportedClasses = compileNonExportedClasses;
            this.compilationMode = compilationMode;
            this.dtsTransforms = dtsTransforms;
            this.semanticDepGraphUpdater = semanticDepGraphUpdater;
            /**
             * Maps class declarations to their `ClassRecord`, which tracks the Ivy traits being applied to
             * those classes.
             */
            this.classes = new Map();
            /**
             * Maps source files to any class declaration(s) within them which have been discovered to contain
             * Ivy traits.
             */
            this.fileToClasses = new Map();
            /**
             * Tracks which source files have been analyzed but did not contain any traits. This set allows
             * the compiler to skip analyzing these files in an incremental rebuild.
             */
            this.filesWithoutTraits = new Set();
            this.reexportMap = new Map();
            this.handlersByName = new Map();
            for (const handler of handlers) {
                this.handlersByName.set(handler.name, handler);
            }
        }
        analyzeSync(sf) {
            this.analyze(sf, false);
        }
        analyzeAsync(sf) {
            return this.analyze(sf, true);
        }
        analyze(sf, preanalyze) {
            // We shouldn't analyze declaration files.
            if (sf.isDeclarationFile) {
                return undefined;
            }
            // analyze() really wants to return `Promise<void>|void`, but TypeScript cannot narrow a return
            // type of 'void', so `undefined` is used instead.
            const promises = [];
            const priorWork = this.incrementalBuild.priorAnalysisFor(sf);
            if (priorWork !== null) {
                this.perf.eventCount(PerfEvent.SourceFileReuseAnalysis);
                if (priorWork.length > 0) {
                    for (const priorRecord of priorWork) {
                        this.adopt(priorRecord);
                    }
                    this.perf.eventCount(PerfEvent.TraitReuseAnalysis, priorWork.length);
                }
                else {
                    this.filesWithoutTraits.add(sf);
                }
                // Skip the rest of analysis, as this file's prior traits are being reused.
                return;
            }
            const visit = (node) => {
                if (this.reflector.isClass(node)) {
                    this.analyzeClass(node, preanalyze ? promises : null);
                }
                ts$1.forEachChild(node, visit);
            };
            visit(sf);
            if (preanalyze && promises.length > 0) {
                return Promise.all(promises).then(() => undefined);
            }
            else {
                return undefined;
            }
        }
        recordFor(clazz) {
            if (this.classes.has(clazz)) {
                return this.classes.get(clazz);
            }
            else {
                return null;
            }
        }
        recordsFor(sf) {
            if (!this.fileToClasses.has(sf)) {
                return null;
            }
            const records = [];
            for (const clazz of this.fileToClasses.get(sf)) {
                records.push(this.classes.get(clazz));
            }
            return records;
        }
        getAnalyzedRecords() {
            const result = new Map();
            for (const [sf, classes] of this.fileToClasses) {
                const records = [];
                for (const clazz of classes) {
                    records.push(this.classes.get(clazz));
                }
                result.set(sf, records);
            }
            for (const sf of this.filesWithoutTraits) {
                result.set(sf, []);
            }
            return result;
        }
        /**
         * Import a `ClassRecord` from a previous compilation.
         *
         * Traits from the `ClassRecord` have accurate metadata, but the `handler` is from the old program
         * and needs to be updated (matching is done by name). A new pending trait is created and then
         * transitioned to analyzed using the previous analysis. If the trait is in the errored state,
         * instead the errors are copied over.
         */
        adopt(priorRecord) {
            const record = {
                hasPrimaryHandler: priorRecord.hasPrimaryHandler,
                hasWeakHandlers: priorRecord.hasWeakHandlers,
                metaDiagnostics: priorRecord.metaDiagnostics,
                node: priorRecord.node,
                traits: [],
            };
            for (const priorTrait of priorRecord.traits) {
                const handler = this.handlersByName.get(priorTrait.handler.name);
                let trait = Trait.pending(handler, priorTrait.detected);
                if (priorTrait.state === TraitState.Analyzed || priorTrait.state === TraitState.Resolved) {
                    const symbol = this.makeSymbolForTrait(handler, record.node, priorTrait.analysis);
                    trait = trait.toAnalyzed(priorTrait.analysis, priorTrait.analysisDiagnostics, symbol);
                    if (trait.analysis !== null && trait.handler.register !== undefined) {
                        trait.handler.register(record.node, trait.analysis);
                    }
                }
                else if (priorTrait.state === TraitState.Skipped) {
                    trait = trait.toSkipped();
                }
                record.traits.push(trait);
            }
            this.classes.set(record.node, record);
            const sf = record.node.getSourceFile();
            if (!this.fileToClasses.has(sf)) {
                this.fileToClasses.set(sf, new Set());
            }
            this.fileToClasses.get(sf).add(record.node);
        }
        scanClassForTraits(clazz) {
            if (!this.compileNonExportedClasses && !this.reflector.isStaticallyExported(clazz)) {
                return null;
            }
            const decorators = this.reflector.getDecoratorsOfDeclaration(clazz);
            return this.detectTraits(clazz, decorators);
        }
        detectTraits(clazz, decorators) {
            let record = this.recordFor(clazz);
            let foundTraits = [];
            for (const handler of this.handlers) {
                const result = handler.detect(clazz, decorators);
                if (result === undefined) {
                    continue;
                }
                const isPrimaryHandler = handler.precedence === HandlerPrecedence.PRIMARY;
                const isWeakHandler = handler.precedence === HandlerPrecedence.WEAK;
                const trait = Trait.pending(handler, result);
                foundTraits.push(trait);
                if (record === null) {
                    // This is the first handler to match this class. This path is a fast path through which
                    // most classes will flow.
                    record = {
                        node: clazz,
                        traits: [trait],
                        metaDiagnostics: null,
                        hasPrimaryHandler: isPrimaryHandler,
                        hasWeakHandlers: isWeakHandler,
                    };
                    this.classes.set(clazz, record);
                    const sf = clazz.getSourceFile();
                    if (!this.fileToClasses.has(sf)) {
                        this.fileToClasses.set(sf, new Set());
                    }
                    this.fileToClasses.get(sf).add(clazz);
                }
                else {
                    // This is at least the second handler to match this class. This is a slower path that some
                    // classes will go through, which validates that the set of decorators applied to the class
                    // is valid.
                    // Validate according to rules as follows:
                    //
                    // * WEAK handlers are removed if a non-WEAK handler matches.
                    // * Only one PRIMARY handler can match at a time. Any other PRIMARY handler matching a
                    //   class with an existing PRIMARY handler is an error.
                    if (!isWeakHandler && record.hasWeakHandlers) {
                        // The current handler is not a WEAK handler, but the class has other WEAK handlers.
                        // Remove them.
                        record.traits =
                            record.traits.filter(field => field.handler.precedence !== HandlerPrecedence.WEAK);
                        record.hasWeakHandlers = false;
                    }
                    else if (isWeakHandler && !record.hasWeakHandlers) {
                        // The current handler is a WEAK handler, but the class has non-WEAK handlers already.
                        // Drop the current one.
                        continue;
                    }
                    if (isPrimaryHandler && record.hasPrimaryHandler) {
                        // The class already has a PRIMARY handler, and another one just matched.
                        record.metaDiagnostics = [{
                                category: ts$1.DiagnosticCategory.Error,
                                code: Number('-99' + ErrorCode.DECORATOR_COLLISION),
                                file: getSourceFile(clazz),
                                start: clazz.getStart(undefined, false),
                                length: clazz.getWidth(),
                                messageText: 'Two incompatible decorators on class',
                            }];
                        record.traits = foundTraits = [];
                        break;
                    }
                    // Otherwise, it's safe to accept the multiple decorators here. Update some of the metadata
                    // regarding this class.
                    record.traits.push(trait);
                    record.hasPrimaryHandler = record.hasPrimaryHandler || isPrimaryHandler;
                }
            }
            return foundTraits.length > 0 ? foundTraits : null;
        }
        makeSymbolForTrait(handler, decl, analysis) {
            if (analysis === null) {
                return null;
            }
            const symbol = handler.symbol(decl, analysis);
            if (symbol !== null && this.semanticDepGraphUpdater !== null) {
                const isPrimary = handler.precedence === HandlerPrecedence.PRIMARY;
                if (!isPrimary) {
                    throw new Error(`AssertionError: ${handler.name} returned a symbol but is not a primary handler.`);
                }
                this.semanticDepGraphUpdater.registerSymbol(symbol);
            }
            return symbol;
        }
        analyzeClass(clazz, preanalyzeQueue) {
            const traits = this.scanClassForTraits(clazz);
            if (traits === null) {
                // There are no Ivy traits on the class, so it can safely be skipped.
                return;
            }
            for (const trait of traits) {
                const analyze = () => this.analyzeTrait(clazz, trait);
                let preanalysis = null;
                if (preanalyzeQueue !== null && trait.handler.preanalyze !== undefined) {
                    // Attempt to run preanalysis. This could fail with a `FatalDiagnosticError`; catch it if it
                    // does.
                    try {
                        preanalysis = trait.handler.preanalyze(clazz, trait.detected.metadata) || null;
                    }
                    catch (err) {
                        if (err instanceof FatalDiagnosticError) {
                            trait.toAnalyzed(null, [err.toDiagnostic()], null);
                            return;
                        }
                        else {
                            throw err;
                        }
                    }
                }
                if (preanalysis !== null) {
                    preanalyzeQueue.push(preanalysis.then(analyze));
                }
                else {
                    analyze();
                }
            }
        }
        analyzeTrait(clazz, trait, flags) {
            var _a, _b, _c;
            if (trait.state !== TraitState.Pending) {
                throw new Error(`Attempt to analyze trait of ${clazz.name.text} in state ${TraitState[trait.state]} (expected DETECTED)`);
            }
            this.perf.eventCount(PerfEvent.TraitAnalyze);
            // Attempt analysis. This could fail with a `FatalDiagnosticError`; catch it if it does.
            let result;
            try {
                result = trait.handler.analyze(clazz, trait.detected.metadata, flags);
            }
            catch (err) {
                if (err instanceof FatalDiagnosticError) {
                    trait.toAnalyzed(null, [err.toDiagnostic()], null);
                    return;
                }
                else {
                    throw err;
                }
            }
            const symbol = this.makeSymbolForTrait(trait.handler, clazz, (_a = result.analysis) !== null && _a !== void 0 ? _a : null);
            if (result.analysis !== undefined && trait.handler.register !== undefined) {
                trait.handler.register(clazz, result.analysis);
            }
            trait = trait.toAnalyzed((_b = result.analysis) !== null && _b !== void 0 ? _b : null, (_c = result.diagnostics) !== null && _c !== void 0 ? _c : null, symbol);
        }
        resolve() {
            var _a, _b;
            const classes = Array.from(this.classes.keys());
            for (const clazz of classes) {
                const record = this.classes.get(clazz);
                for (let trait of record.traits) {
                    const handler = trait.handler;
                    switch (trait.state) {
                        case TraitState.Skipped:
                            continue;
                        case TraitState.Pending:
                            throw new Error(`Resolving a trait that hasn't been analyzed: ${clazz.name.text} / ${Object.getPrototypeOf(trait.handler).constructor.name}`);
                        case TraitState.Resolved:
                            throw new Error(`Resolving an already resolved trait`);
                    }
                    if (trait.analysis === null) {
                        // No analysis results, cannot further process this trait.
                        continue;
                    }
                    if (handler.resolve === undefined) {
                        // No resolution of this trait needed - it's considered successful by default.
                        trait = trait.toResolved(null, null);
                        continue;
                    }
                    let result;
                    try {
                        result = handler.resolve(clazz, trait.analysis, trait.symbol);
                    }
                    catch (err) {
                        if (err instanceof FatalDiagnosticError) {
                            trait = trait.toResolved(null, [err.toDiagnostic()]);
                            continue;
                        }
                        else {
                            throw err;
                        }
                    }
                    trait = trait.toResolved((_a = result.data) !== null && _a !== void 0 ? _a : null, (_b = result.diagnostics) !== null && _b !== void 0 ? _b : null);
                    if (result.reexports !== undefined) {
                        const fileName = clazz.getSourceFile().fileName;
                        if (!this.reexportMap.has(fileName)) {
                            this.reexportMap.set(fileName, new Map());
                        }
                        const fileReexports = this.reexportMap.get(fileName);
                        for (const reexport of result.reexports) {
                            fileReexports.set(reexport.asAlias, [reexport.fromModule, reexport.symbolName]);
                        }
                    }
                }
            }
        }
        /**
         * Generate type-checking code into the `TypeCheckContext` for any components within the given
         * `ts.SourceFile`.
         */
        typeCheck(sf, ctx) {
            if (!this.fileToClasses.has(sf)) {
                return;
            }
            for (const clazz of this.fileToClasses.get(sf)) {
                const record = this.classes.get(clazz);
                for (const trait of record.traits) {
                    if (trait.state !== TraitState.Resolved) {
                        continue;
                    }
                    else if (trait.handler.typeCheck === undefined) {
                        continue;
                    }
                    if (trait.resolution !== null) {
                        trait.handler.typeCheck(ctx, clazz, trait.analysis, trait.resolution);
                    }
                }
            }
        }
        extendedTemplateCheck(sf, extendedTemplateChecker) {
            const classes = this.fileToClasses.get(sf);
            if (classes === undefined) {
                return [];
            }
            const diagnostics = [];
            for (const clazz of classes) {
                if (!isNamedClassDeclaration(clazz)) {
                    continue;
                }
                const record = this.classes.get(clazz);
                for (const trait of record.traits) {
                    if (trait.handler.extendedTemplateCheck === undefined) {
                        continue;
                    }
                    diagnostics.push(...trait.handler.extendedTemplateCheck(clazz, extendedTemplateChecker));
                }
            }
            return diagnostics;
        }
        index(ctx) {
            for (const clazz of this.classes.keys()) {
                const record = this.classes.get(clazz);
                for (const trait of record.traits) {
                    if (trait.state !== TraitState.Resolved) {
                        // Skip traits that haven't been resolved successfully.
                        continue;
                    }
                    else if (trait.handler.index === undefined) {
                        // Skip traits that don't affect indexing.
                        continue;
                    }
                    if (trait.resolution !== null) {
                        trait.handler.index(ctx, clazz, trait.analysis, trait.resolution);
                    }
                }
            }
        }
        xi18n(bundle) {
            for (const clazz of this.classes.keys()) {
                const record = this.classes.get(clazz);
                for (const trait of record.traits) {
                    if (trait.state !== TraitState.Analyzed && trait.state !== TraitState.Resolved) {
                        // Skip traits that haven't been analyzed successfully.
                        continue;
                    }
                    else if (trait.handler.xi18n === undefined) {
                        // Skip traits that don't support xi18n.
                        continue;
                    }
                    if (trait.analysis !== null) {
                        trait.handler.xi18n(bundle, clazz, trait.analysis);
                    }
                }
            }
        }
        updateResources(clazz) {
            if (!this.reflector.isClass(clazz) || !this.classes.has(clazz)) {
                return;
            }
            const record = this.classes.get(clazz);
            for (const trait of record.traits) {
                if (trait.state !== TraitState.Resolved || trait.handler.updateResources === undefined) {
                    continue;
                }
                trait.handler.updateResources(clazz, trait.analysis, trait.resolution);
            }
        }
        compile(clazz, constantPool) {
            const original = ts$1.getOriginalNode(clazz);
            if (!this.reflector.isClass(clazz) || !this.reflector.isClass(original) ||
                !this.classes.has(original)) {
                return null;
            }
            const record = this.classes.get(original);
            let res = [];
            for (const trait of record.traits) {
                if (trait.state !== TraitState.Resolved || trait.analysisDiagnostics !== null ||
                    trait.resolveDiagnostics !== null) {
                    // Cannot compile a trait that is not resolved, or had any errors in its declaration.
                    continue;
                }
                // `trait.resolution` is non-null asserted here because TypeScript does not recognize that
                // `Readonly<unknown>` is nullable (as `unknown` itself is nullable) due to the way that
                // `Readonly` works.
                let compileRes;
                if (this.compilationMode === CompilationMode.PARTIAL &&
                    trait.handler.compilePartial !== undefined) {
                    compileRes = trait.handler.compilePartial(clazz, trait.analysis, trait.resolution);
                }
                else {
                    compileRes =
                        trait.handler.compileFull(clazz, trait.analysis, trait.resolution, constantPool);
                }
                const compileMatchRes = compileRes;
                if (Array.isArray(compileMatchRes)) {
                    for (const result of compileMatchRes) {
                        if (!res.some(r => r.name === result.name)) {
                            res.push(result);
                        }
                    }
                }
                else if (!res.some(result => result.name === compileMatchRes.name)) {
                    res.push(compileMatchRes);
                }
            }
            // Look up the .d.ts transformer for the input file and record that at least one field was
            // generated, which will allow the .d.ts to be transformed later.
            this.dtsTransforms.getIvyDeclarationTransform(original.getSourceFile())
                .addFields(original, res);
            // Return the instruction to the transformer so the fields will be added.
            return res.length > 0 ? res : null;
        }
        decoratorsFor(node) {
            const original = ts$1.getOriginalNode(node);
            if (!this.reflector.isClass(original) || !this.classes.has(original)) {
                return [];
            }
            const record = this.classes.get(original);
            const decorators = [];
            for (const trait of record.traits) {
                if (trait.state !== TraitState.Resolved) {
                    continue;
                }
                if (trait.detected.trigger !== null && ts$1.isDecorator(trait.detected.trigger)) {
                    decorators.push(trait.detected.trigger);
                }
            }
            return decorators;
        }
        get diagnostics() {
            const diagnostics = [];
            for (const clazz of this.classes.keys()) {
                const record = this.classes.get(clazz);
                if (record.metaDiagnostics !== null) {
                    diagnostics.push(...record.metaDiagnostics);
                }
                for (const trait of record.traits) {
                    if ((trait.state === TraitState.Analyzed || trait.state === TraitState.Resolved) &&
                        trait.analysisDiagnostics !== null) {
                        diagnostics.push(...trait.analysisDiagnostics);
                    }
                    if (trait.state === TraitState.Resolved && trait.resolveDiagnostics !== null) {
                        diagnostics.push(...trait.resolveDiagnostics);
                    }
                }
            }
            return diagnostics;
        }
        get exportStatements() {
            return this.reexportMap;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * The current context of a translator visitor as it traverses the AST tree.
     *
     * It tracks whether we are in the process of outputting a statement or an expression.
     */
    class Context {
        constructor(isStatement) {
            this.isStatement = isStatement;
        }
        get withExpressionMode() {
            return this.isStatement ? new Context(false) : this;
        }
        get withStatementMode() {
            return !this.isStatement ? new Context(true) : this;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class ImportManager {
        constructor(rewriter = new NoopImportRewriter(), prefix = 'i') {
            this.rewriter = rewriter;
            this.prefix = prefix;
            this.specifierToIdentifier = new Map();
            this.nextIndex = 0;
        }
        generateNamespaceImport(moduleName) {
            if (!this.specifierToIdentifier.has(moduleName)) {
                this.specifierToIdentifier.set(moduleName, ts$1.createIdentifier(`${this.prefix}${this.nextIndex++}`));
            }
            return this.specifierToIdentifier.get(moduleName);
        }
        generateNamedImport(moduleName, originalSymbol) {
            // First, rewrite the symbol name.
            const symbol = this.rewriter.rewriteSymbol(originalSymbol, moduleName);
            // Ask the rewriter if this symbol should be imported at all. If not, it can be referenced
            // directly (moduleImport: null).
            if (!this.rewriter.shouldImportSymbol(symbol, moduleName)) {
                // The symbol should be referenced directly.
                return { moduleImport: null, symbol };
            }
            // If not, this symbol will be imported using a generated namespace import.
            const moduleImport = this.generateNamespaceImport(moduleName);
            return { moduleImport, symbol };
        }
        getAllImports(contextPath) {
            const imports = [];
            for (const [originalSpecifier, qualifier] of this.specifierToIdentifier) {
                const specifier = this.rewriter.rewriteSpecifier(originalSpecifier, contextPath);
                imports.push({
                    specifier,
                    qualifier,
                });
            }
            return imports;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const UNARY_OPERATORS$1 = new Map([
        [UnaryOperator.Minus, '-'],
        [UnaryOperator.Plus, '+'],
    ]);
    const BINARY_OPERATORS$1 = new Map([
        [BinaryOperator.And, '&&'],
        [BinaryOperator.Bigger, '>'],
        [BinaryOperator.BiggerEquals, '>='],
        [BinaryOperator.BitwiseAnd, '&'],
        [BinaryOperator.Divide, '/'],
        [BinaryOperator.Equals, '=='],
        [BinaryOperator.Identical, '==='],
        [BinaryOperator.Lower, '<'],
        [BinaryOperator.LowerEquals, '<='],
        [BinaryOperator.Minus, '-'],
        [BinaryOperator.Modulo, '%'],
        [BinaryOperator.Multiply, '*'],
        [BinaryOperator.NotEquals, '!='],
        [BinaryOperator.NotIdentical, '!=='],
        [BinaryOperator.Or, '||'],
        [BinaryOperator.Plus, '+'],
        [BinaryOperator.NullishCoalesce, '??'],
    ]);
    class ExpressionTranslatorVisitor {
        constructor(factory, imports, options) {
            this.factory = factory;
            this.imports = imports;
            this.downlevelTaggedTemplates = options.downlevelTaggedTemplates === true;
            this.downlevelVariableDeclarations = options.downlevelVariableDeclarations === true;
            this.recordWrappedNode = options.recordWrappedNode || (() => { });
        }
        visitDeclareVarStmt(stmt, context) {
            var _a;
            const varType = this.downlevelVariableDeclarations ?
                'var' :
                stmt.hasModifier(StmtModifier.Final) ? 'const' : 'let';
            return this.attachComments(this.factory.createVariableDeclaration(stmt.name, (_a = stmt.value) === null || _a === void 0 ? void 0 : _a.visitExpression(this, context.withExpressionMode), varType), stmt.leadingComments);
        }
        visitDeclareFunctionStmt(stmt, context) {
            return this.attachComments(this.factory.createFunctionDeclaration(stmt.name, stmt.params.map(param => param.name), this.factory.createBlock(this.visitStatements(stmt.statements, context.withStatementMode))), stmt.leadingComments);
        }
        visitExpressionStmt(stmt, context) {
            return this.attachComments(this.factory.createExpressionStatement(stmt.expr.visitExpression(this, context.withStatementMode)), stmt.leadingComments);
        }
        visitReturnStmt(stmt, context) {
            return this.attachComments(this.factory.createReturnStatement(stmt.value.visitExpression(this, context.withExpressionMode)), stmt.leadingComments);
        }
        visitDeclareClassStmt(_stmt, _context) {
            throw new Error('Method not implemented.');
        }
        visitIfStmt(stmt, context) {
            return this.attachComments(this.factory.createIfStatement(stmt.condition.visitExpression(this, context), this.factory.createBlock(this.visitStatements(stmt.trueCase, context.withStatementMode)), stmt.falseCase.length > 0 ? this.factory.createBlock(this.visitStatements(stmt.falseCase, context.withStatementMode)) :
                null), stmt.leadingComments);
        }
        visitTryCatchStmt(_stmt, _context) {
            throw new Error('Method not implemented.');
        }
        visitThrowStmt(stmt, context) {
            return this.attachComments(this.factory.createThrowStatement(stmt.error.visitExpression(this, context.withExpressionMode)), stmt.leadingComments);
        }
        visitReadVarExpr(ast, _context) {
            const identifier = this.factory.createIdentifier(ast.name);
            this.setSourceMapRange(identifier, ast.sourceSpan);
            return identifier;
        }
        visitWriteVarExpr(expr, context) {
            const assignment = this.factory.createAssignment(this.setSourceMapRange(this.factory.createIdentifier(expr.name), expr.sourceSpan), expr.value.visitExpression(this, context));
            return context.isStatement ? assignment :
                this.factory.createParenthesizedExpression(assignment);
        }
        visitWriteKeyExpr(expr, context) {
            const exprContext = context.withExpressionMode;
            const target = this.factory.createElementAccess(expr.receiver.visitExpression(this, exprContext), expr.index.visitExpression(this, exprContext));
            const assignment = this.factory.createAssignment(target, expr.value.visitExpression(this, exprContext));
            return context.isStatement ? assignment :
                this.factory.createParenthesizedExpression(assignment);
        }
        visitWritePropExpr(expr, context) {
            const target = this.factory.createPropertyAccess(expr.receiver.visitExpression(this, context), expr.name);
            return this.factory.createAssignment(target, expr.value.visitExpression(this, context));
        }
        visitInvokeMethodExpr(ast, context) {
            const target = ast.receiver.visitExpression(this, context);
            return this.setSourceMapRange(this.factory.createCallExpression(ast.name !== null ? this.factory.createPropertyAccess(target, ast.name) : target, ast.args.map(arg => arg.visitExpression(this, context)), 
            /* pure */ false), ast.sourceSpan);
        }
        visitInvokeFunctionExpr(ast, context) {
            return this.setSourceMapRange(this.factory.createCallExpression(ast.fn.visitExpression(this, context), ast.args.map(arg => arg.visitExpression(this, context)), ast.pure), ast.sourceSpan);
        }
        visitTaggedTemplateExpr(ast, context) {
            return this.setSourceMapRange(this.createTaggedTemplateExpression(ast.tag.visitExpression(this, context), {
                elements: ast.template.elements.map(e => {
                    var _a;
                    return createTemplateElement({
                        cooked: e.text,
                        raw: e.rawText,
                        range: (_a = e.sourceSpan) !== null && _a !== void 0 ? _a : ast.sourceSpan,
                    });
                }),
                expressions: ast.template.expressions.map(e => e.visitExpression(this, context))
            }), ast.sourceSpan);
        }
        visitInstantiateExpr(ast, context) {
            return this.factory.createNewExpression(ast.classExpr.visitExpression(this, context), ast.args.map(arg => arg.visitExpression(this, context)));
        }
        visitLiteralExpr(ast, _context) {
            return this.setSourceMapRange(this.factory.createLiteral(ast.value), ast.sourceSpan);
        }
        visitLocalizedString(ast, context) {
            // A `$localize` message consists of `messageParts` and `expressions`, which get interleaved
            // together. The interleaved pieces look like:
            // `[messagePart0, expression0, messagePart1, expression1, messagePart2]`
            //
            // Note that there is always a message part at the start and end, and so therefore
            // `messageParts.length === expressions.length + 1`.
            //
            // Each message part may be prefixed with "metadata", which is wrapped in colons (:) delimiters.
            // The metadata is attached to the first and subsequent message parts by calls to
            // `serializeI18nHead()` and `serializeI18nTemplatePart()` respectively.
            //
            // The first message part (i.e. `ast.messageParts[0]`) is used to initialize `messageParts`
            // array.
            const elements = [createTemplateElement(ast.serializeI18nHead())];
            const expressions = [];
            for (let i = 0; i < ast.expressions.length; i++) {
                const placeholder = this.setSourceMapRange(ast.expressions[i].visitExpression(this, context), ast.getPlaceholderSourceSpan(i));
                expressions.push(placeholder);
                elements.push(createTemplateElement(ast.serializeI18nTemplatePart(i + 1)));
            }
            const localizeTag = this.factory.createIdentifier('$localize');
            return this.setSourceMapRange(this.createTaggedTemplateExpression(localizeTag, { elements, expressions }), ast.sourceSpan);
        }
        createTaggedTemplateExpression(tag, template) {
            return this.downlevelTaggedTemplates ? this.createES5TaggedTemplateFunctionCall(tag, template) :
                this.factory.createTaggedTemplate(tag, template);
        }
        /**
         * Translate the tagged template literal into a call that is compatible with ES5, using the
         * imported `__makeTemplateObject` helper for ES5 formatted output.
         */
        createES5TaggedTemplateFunctionCall(tagHandler, { elements, expressions }) {
            // Ensure that the `__makeTemplateObject()` helper has been imported.
            const { moduleImport, symbol } = this.imports.generateNamedImport('tslib', '__makeTemplateObject');
            const __makeTemplateObjectHelper = (moduleImport === null) ?
                this.factory.createIdentifier(symbol) :
                this.factory.createPropertyAccess(moduleImport, symbol);
            // Collect up the cooked and raw strings into two separate arrays.
            const cooked = [];
            const raw = [];
            for (const element of elements) {
                cooked.push(this.factory.setSourceMapRange(this.factory.createLiteral(element.cooked), element.range));
                raw.push(this.factory.setSourceMapRange(this.factory.createLiteral(element.raw), element.range));
            }
            // Generate the helper call in the form: `__makeTemplateObject([cooked], [raw]);`
            const templateHelperCall = this.factory.createCallExpression(__makeTemplateObjectHelper, [this.factory.createArrayLiteral(cooked), this.factory.createArrayLiteral(raw)], 
            /* pure */ false);
            // Finally create the tagged handler call in the form:
            // `tag(__makeTemplateObject([cooked], [raw]), ...expressions);`
            return this.factory.createCallExpression(tagHandler, [templateHelperCall, ...expressions], 
            /* pure */ false);
        }
        visitExternalExpr(ast, _context) {
            if (ast.value.name === null) {
                if (ast.value.moduleName === null) {
                    throw new Error('Invalid import without name nor moduleName');
                }
                return this.imports.generateNamespaceImport(ast.value.moduleName);
            }
            // If a moduleName is specified, this is a normal import. If there's no module name, it's a
            // reference to a global/ambient symbol.
            if (ast.value.moduleName !== null) {
                // This is a normal import. Find the imported module.
                const { moduleImport, symbol } = this.imports.generateNamedImport(ast.value.moduleName, ast.value.name);
                if (moduleImport === null) {
                    // The symbol was ambient after all.
                    return this.factory.createIdentifier(symbol);
                }
                else {
                    return this.factory.createPropertyAccess(moduleImport, symbol);
                }
            }
            else {
                // The symbol is ambient, so just reference it.
                return this.factory.createIdentifier(ast.value.name);
            }
        }
        visitConditionalExpr(ast, context) {
            let cond = ast.condition.visitExpression(this, context);
            // Ordinarily the ternary operator is right-associative. The following are equivalent:
            //   `a ? b : c ? d : e` => `a ? b : (c ? d : e)`
            //
            // However, occasionally Angular needs to produce a left-associative conditional, such as in
            // the case of a null-safe navigation production: `{{a?.b ? c : d}}`. This template produces
            // a ternary of the form:
            //   `a == null ? null : rest of expression`
            // If the rest of the expression is also a ternary though, this would produce the form:
            //   `a == null ? null : a.b ? c : d`
            // which, if left as right-associative, would be incorrectly associated as:
            //   `a == null ? null : (a.b ? c : d)`
            //
            // In such cases, the left-associativity needs to be enforced with parentheses:
            //   `(a == null ? null : a.b) ? c : d`
            //
            // Such parentheses could always be included in the condition (guaranteeing correct behavior) in
            // all cases, but this has a code size cost. Instead, parentheses are added only when a
            // conditional expression is directly used as the condition of another.
            //
            // TODO(alxhub): investigate better logic for precendence of conditional operators
            if (ast.condition instanceof ConditionalExpr) {
                // The condition of this ternary needs to be wrapped in parentheses to maintain
                // left-associativity.
                cond = this.factory.createParenthesizedExpression(cond);
            }
            return this.factory.createConditional(cond, ast.trueCase.visitExpression(this, context), ast.falseCase.visitExpression(this, context));
        }
        visitNotExpr(ast, context) {
            return this.factory.createUnaryExpression('!', ast.condition.visitExpression(this, context));
        }
        visitAssertNotNullExpr(ast, context) {
            return ast.condition.visitExpression(this, context);
        }
        visitCastExpr(ast, context) {
            return ast.value.visitExpression(this, context);
        }
        visitFunctionExpr(ast, context) {
            var _a;
            return this.factory.createFunctionExpression((_a = ast.name) !== null && _a !== void 0 ? _a : null, ast.params.map(param => param.name), this.factory.createBlock(this.visitStatements(ast.statements, context)));
        }
        visitBinaryOperatorExpr(ast, context) {
            if (!BINARY_OPERATORS$1.has(ast.operator)) {
                throw new Error(`Unknown binary operator: ${BinaryOperator[ast.operator]}`);
            }
            return this.factory.createBinaryExpression(ast.lhs.visitExpression(this, context), BINARY_OPERATORS$1.get(ast.operator), ast.rhs.visitExpression(this, context));
        }
        visitReadPropExpr(ast, context) {
            return this.factory.createPropertyAccess(ast.receiver.visitExpression(this, context), ast.name);
        }
        visitReadKeyExpr(ast, context) {
            return this.factory.createElementAccess(ast.receiver.visitExpression(this, context), ast.index.visitExpression(this, context));
        }
        visitLiteralArrayExpr(ast, context) {
            return this.factory.createArrayLiteral(ast.entries.map(expr => this.setSourceMapRange(expr.visitExpression(this, context), ast.sourceSpan)));
        }
        visitLiteralMapExpr(ast, context) {
            const properties = ast.entries.map(entry => {
                return {
                    propertyName: entry.key,
                    quoted: entry.quoted,
                    value: entry.value.visitExpression(this, context)
                };
            });
            return this.setSourceMapRange(this.factory.createObjectLiteral(properties), ast.sourceSpan);
        }
        visitCommaExpr(ast, context) {
            throw new Error('Method not implemented.');
        }
        visitWrappedNodeExpr(ast, _context) {
            this.recordWrappedNode(ast);
            return ast.node;
        }
        visitTypeofExpr(ast, context) {
            return this.factory.createTypeOfExpression(ast.expr.visitExpression(this, context));
        }
        visitUnaryOperatorExpr(ast, context) {
            if (!UNARY_OPERATORS$1.has(ast.operator)) {
                throw new Error(`Unknown unary operator: ${UnaryOperator[ast.operator]}`);
            }
            return this.factory.createUnaryExpression(UNARY_OPERATORS$1.get(ast.operator), ast.expr.visitExpression(this, context));
        }
        visitStatements(statements, context) {
            return statements.map(stmt => stmt.visitStatement(this, context))
                .filter(stmt => stmt !== undefined);
        }
        setSourceMapRange(ast, span) {
            return this.factory.setSourceMapRange(ast, createRange(span));
        }
        attachComments(statement, leadingComments) {
            if (leadingComments !== undefined) {
                this.factory.attachComments(statement, leadingComments);
            }
            return statement;
        }
    }
    /**
     * Convert a cooked-raw string object into one that can be used by the AST factories.
     */
    function createTemplateElement({ cooked, raw, range }) {
        return { cooked, raw, range: createRange(range) };
    }
    /**
     * Convert an OutputAST source-span into a range that can be used by the AST factories.
     */
    function createRange(span) {
        if (span === null) {
            return null;
        }
        const { start, end } = span;
        const { url, content } = start.file;
        if (!url) {
            return null;
        }
        return {
            url,
            content,
            start: { offset: start.offset, line: start.line, column: start.col },
            end: { offset: end.offset, line: end.line, column: end.col },
        };
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function translateType(type, imports) {
        return type.visitType(new TypeTranslatorVisitor(imports), new Context(false));
    }
    class TypeTranslatorVisitor {
        constructor(imports) {
            this.imports = imports;
        }
        visitBuiltinType(type, context) {
            switch (type.name) {
                case BuiltinTypeName.Bool:
                    return ts$1.createKeywordTypeNode(ts$1.SyntaxKind.BooleanKeyword);
                case BuiltinTypeName.Dynamic:
                    return ts$1.createKeywordTypeNode(ts$1.SyntaxKind.AnyKeyword);
                case BuiltinTypeName.Int:
                case BuiltinTypeName.Number:
                    return ts$1.createKeywordTypeNode(ts$1.SyntaxKind.NumberKeyword);
                case BuiltinTypeName.String:
                    return ts$1.createKeywordTypeNode(ts$1.SyntaxKind.StringKeyword);
                case BuiltinTypeName.None:
                    return ts$1.createKeywordTypeNode(ts$1.SyntaxKind.NeverKeyword);
                default:
                    throw new Error(`Unsupported builtin type: ${BuiltinTypeName[type.name]}`);
            }
        }
        visitExpressionType(type, context) {
            const typeNode = this.translateExpression(type.value, context);
            if (type.typeParams === null) {
                return typeNode;
            }
            if (!ts$1.isTypeReferenceNode(typeNode)) {
                throw new Error('An ExpressionType with type arguments must translate into a TypeReferenceNode');
            }
            else if (typeNode.typeArguments !== undefined) {
                throw new Error(`An ExpressionType with type arguments cannot have multiple levels of type arguments`);
            }
            const typeArgs = type.typeParams.map(param => this.translateType(param, context));
            return ts$1.createTypeReferenceNode(typeNode.typeName, typeArgs);
        }
        visitArrayType(type, context) {
            return ts$1.createArrayTypeNode(this.translateType(type.of, context));
        }
        visitMapType(type, context) {
            const parameter = ts$1.createParameter(undefined, undefined, undefined, 'key', undefined, ts$1.createKeywordTypeNode(ts$1.SyntaxKind.StringKeyword));
            const typeArgs = type.valueType !== null ?
                this.translateType(type.valueType, context) :
                ts$1.createKeywordTypeNode(ts$1.SyntaxKind.UnknownKeyword);
            const indexSignature = ts$1.createIndexSignature(undefined, undefined, [parameter], typeArgs);
            return ts$1.createTypeLiteralNode([indexSignature]);
        }
        visitReadVarExpr(ast, context) {
            if (ast.name === null) {
                throw new Error(`ReadVarExpr with no variable name in type`);
            }
            return ts$1.createTypeQueryNode(ts$1.createIdentifier(ast.name));
        }
        visitWriteVarExpr(expr, context) {
            throw new Error('Method not implemented.');
        }
        visitWriteKeyExpr(expr, context) {
            throw new Error('Method not implemented.');
        }
        visitWritePropExpr(expr, context) {
            throw new Error('Method not implemented.');
        }
        visitInvokeMethodExpr(ast, context) {
            throw new Error('Method not implemented.');
        }
        visitInvokeFunctionExpr(ast, context) {
            throw new Error('Method not implemented.');
        }
        visitTaggedTemplateExpr(ast, context) {
            throw new Error('Method not implemented.');
        }
        visitInstantiateExpr(ast, context) {
            throw new Error('Method not implemented.');
        }
        visitLiteralExpr(ast, context) {
            if (ast.value === null) {
                return ts$1.createLiteralTypeNode(ts$1.createNull());
            }
            else if (ast.value === undefined) {
                return ts$1.createKeywordTypeNode(ts$1.SyntaxKind.UndefinedKeyword);
            }
            else if (typeof ast.value === 'boolean') {
                return ts$1.createLiteralTypeNode(ts$1.createLiteral(ast.value));
            }
            else if (typeof ast.value === 'number') {
                return ts$1.createLiteralTypeNode(ts$1.createLiteral(ast.value));
            }
            else {
                return ts$1.createLiteralTypeNode(ts$1.createLiteral(ast.value));
            }
        }
        visitLocalizedString(ast, context) {
            throw new Error('Method not implemented.');
        }
        visitExternalExpr(ast, context) {
            if (ast.value.moduleName === null || ast.value.name === null) {
                throw new Error(`Import unknown module or symbol`);
            }
            const { moduleImport, symbol } = this.imports.generateNamedImport(ast.value.moduleName, ast.value.name);
            const symbolIdentifier = ts$1.createIdentifier(symbol);
            const typeName = moduleImport ? ts$1.createQualifiedName(moduleImport, symbolIdentifier) : symbolIdentifier;
            const typeArguments = ast.typeParams !== null ?
                ast.typeParams.map(type => this.translateType(type, context)) :
                undefined;
            return ts$1.createTypeReferenceNode(typeName, typeArguments);
        }
        visitConditionalExpr(ast, context) {
            throw new Error('Method not implemented.');
        }
        visitNotExpr(ast, context) {
            throw new Error('Method not implemented.');
        }
        visitAssertNotNullExpr(ast, context) {
            throw new Error('Method not implemented.');
        }
        visitCastExpr(ast, context) {
            throw new Error('Method not implemented.');
        }
        visitFunctionExpr(ast, context) {
            throw new Error('Method not implemented.');
        }
        visitUnaryOperatorExpr(ast, context) {
            throw new Error('Method not implemented.');
        }
        visitBinaryOperatorExpr(ast, context) {
            throw new Error('Method not implemented.');
        }
        visitReadPropExpr(ast, context) {
            throw new Error('Method not implemented.');
        }
        visitReadKeyExpr(ast, context) {
            throw new Error('Method not implemented.');
        }
        visitLiteralArrayExpr(ast, context) {
            const values = ast.entries.map(expr => this.translateExpression(expr, context));
            return ts$1.createTupleTypeNode(values);
        }
        visitLiteralMapExpr(ast, context) {
            const entries = ast.entries.map(entry => {
                const { key, quoted } = entry;
                const type = this.translateExpression(entry.value, context);
                return ts$1.createPropertySignature(
                /* modifiers */ undefined, 
                /* name */ quoted ? ts$1.createStringLiteral(key) : key, 
                /* questionToken */ undefined, 
                /* type */ type, 
                /* initializer */ undefined);
            });
            return ts$1.createTypeLiteralNode(entries);
        }
        visitCommaExpr(ast, context) {
            throw new Error('Method not implemented.');
        }
        visitWrappedNodeExpr(ast, context) {
            const node = ast.node;
            if (ts$1.isEntityName(node)) {
                return ts$1.createTypeReferenceNode(node, /* typeArguments */ undefined);
            }
            else if (ts$1.isTypeNode(node)) {
                return node;
            }
            else if (ts$1.isLiteralExpression(node)) {
                return ts$1.createLiteralTypeNode(node);
            }
            else {
                throw new Error(`Unsupported WrappedNodeExpr in TypeTranslatorVisitor: ${ts$1.SyntaxKind[node.kind]}`);
            }
        }
        visitTypeofExpr(ast, context) {
            const typeNode = this.translateExpression(ast.expr, context);
            if (!ts$1.isTypeReferenceNode(typeNode)) {
                throw new Error(`The target of a typeof expression must be a type reference, but it was
          ${ts$1.SyntaxKind[typeNode.kind]}`);
            }
            return ts$1.createTypeQueryNode(typeNode.typeName);
        }
        translateType(type, context) {
            const typeNode = type.visitType(this, context);
            if (!ts$1.isTypeNode(typeNode)) {
                throw new Error(`A Type must translate to a TypeNode, but was ${ts$1.SyntaxKind[typeNode.kind]}`);
            }
            return typeNode;
        }
        translateExpression(expr, context) {
            const typeNode = expr.visitExpression(this, context);
            if (!ts$1.isTypeNode(typeNode)) {
                throw new Error(`An Expression must translate to a TypeNode, but was ${ts$1.SyntaxKind[typeNode.kind]}`);
            }
            return typeNode;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Different optimizers use different annotations on a function or method call to indicate its pure
     * status.
     */
    var PureAnnotation;
    (function (PureAnnotation) {
        /**
         * Closure's annotation for purity is `@pureOrBreakMyCode`, but this needs to be in a semantic
         * (jsdoc) enabled comment. Thus, the actual comment text for Closure must include the `*` that
         * turns a `/*` comment into a `/**` comment, as well as surrounding whitespace.
         */
        PureAnnotation["CLOSURE"] = "* @pureOrBreakMyCode ";
        PureAnnotation["TERSER"] = "@__PURE__";
    })(PureAnnotation || (PureAnnotation = {}));
    const UNARY_OPERATORS$2 = {
        '+': ts$1.SyntaxKind.PlusToken,
        '-': ts$1.SyntaxKind.MinusToken,
        '!': ts$1.SyntaxKind.ExclamationToken,
    };
    const BINARY_OPERATORS$2 = {
        '&&': ts$1.SyntaxKind.AmpersandAmpersandToken,
        '>': ts$1.SyntaxKind.GreaterThanToken,
        '>=': ts$1.SyntaxKind.GreaterThanEqualsToken,
        '&': ts$1.SyntaxKind.AmpersandToken,
        '/': ts$1.SyntaxKind.SlashToken,
        '==': ts$1.SyntaxKind.EqualsEqualsToken,
        '===': ts$1.SyntaxKind.EqualsEqualsEqualsToken,
        '<': ts$1.SyntaxKind.LessThanToken,
        '<=': ts$1.SyntaxKind.LessThanEqualsToken,
        '-': ts$1.SyntaxKind.MinusToken,
        '%': ts$1.SyntaxKind.PercentToken,
        '*': ts$1.SyntaxKind.AsteriskToken,
        '!=': ts$1.SyntaxKind.ExclamationEqualsToken,
        '!==': ts$1.SyntaxKind.ExclamationEqualsEqualsToken,
        '||': ts$1.SyntaxKind.BarBarToken,
        '+': ts$1.SyntaxKind.PlusToken,
        '??': ts$1.SyntaxKind.QuestionQuestionToken,
    };
    const VAR_TYPES = {
        'const': ts$1.NodeFlags.Const,
        'let': ts$1.NodeFlags.Let,
        'var': ts$1.NodeFlags.None,
    };
    /**
     * A TypeScript flavoured implementation of the AstFactory.
     */
    class TypeScriptAstFactory {
        constructor(annotateForClosureCompiler) {
            this.annotateForClosureCompiler = annotateForClosureCompiler;
            this.externalSourceFiles = new Map();
            this.attachComments = attachComments;
            this.createArrayLiteral = ts$1.createArrayLiteral;
            this.createConditional = ts$1.createConditional;
            this.createElementAccess = ts$1.createElementAccess;
            this.createExpressionStatement = ts$1.createExpressionStatement;
            this.createIdentifier = ts$1.createIdentifier;
            this.createParenthesizedExpression = ts$1.createParen;
            this.createPropertyAccess = ts$1.createPropertyAccess;
            this.createThrowStatement = ts$1.createThrow;
            this.createTypeOfExpression = ts$1.createTypeOf;
        }
        createAssignment(target, value) {
            return ts$1.createBinary(target, ts$1.SyntaxKind.EqualsToken, value);
        }
        createBinaryExpression(leftOperand, operator, rightOperand) {
            return ts$1.createBinary(leftOperand, BINARY_OPERATORS$2[operator], rightOperand);
        }
        createBlock(body) {
            return ts$1.createBlock(body);
        }
        createCallExpression(callee, args, pure) {
            const call = ts$1.createCall(callee, undefined, args);
            if (pure) {
                ts$1.addSyntheticLeadingComment(call, ts$1.SyntaxKind.MultiLineCommentTrivia, this.annotateForClosureCompiler ? PureAnnotation.CLOSURE : PureAnnotation.TERSER, 
                /* trailing newline */ false);
            }
            return call;
        }
        createFunctionDeclaration(functionName, parameters, body) {
            if (!ts$1.isBlock(body)) {
                throw new Error(`Invalid syntax, expected a block, but got ${ts$1.SyntaxKind[body.kind]}.`);
            }
            return ts$1.createFunctionDeclaration(undefined, undefined, undefined, functionName, undefined, parameters.map(param => ts$1.createParameter(undefined, undefined, undefined, param)), undefined, body);
        }
        createFunctionExpression(functionName, parameters, body) {
            if (!ts$1.isBlock(body)) {
                throw new Error(`Invalid syntax, expected a block, but got ${ts$1.SyntaxKind[body.kind]}.`);
            }
            return ts$1.createFunctionExpression(undefined, undefined, functionName !== null && functionName !== void 0 ? functionName : undefined, undefined, parameters.map(param => ts$1.createParameter(undefined, undefined, undefined, param)), undefined, body);
        }
        createIfStatement(condition, thenStatement, elseStatement) {
            return ts$1.createIf(condition, thenStatement, elseStatement !== null && elseStatement !== void 0 ? elseStatement : undefined);
        }
        createLiteral(value) {
            if (value === undefined) {
                return ts$1.createIdentifier('undefined');
            }
            else if (value === null) {
                return ts$1.createNull();
            }
            else {
                return ts$1.createLiteral(value);
            }
        }
        createNewExpression(expression, args) {
            return ts$1.createNew(expression, undefined, args);
        }
        createObjectLiteral(properties) {
            return ts$1.createObjectLiteral(properties.map(prop => ts$1.createPropertyAssignment(prop.quoted ? ts$1.createLiteral(prop.propertyName) :
                ts$1.createIdentifier(prop.propertyName), prop.value)));
        }
        createReturnStatement(expression) {
            return ts$1.createReturn(expression !== null && expression !== void 0 ? expression : undefined);
        }
        createTaggedTemplate(tag, template) {
            let templateLiteral;
            const length = template.elements.length;
            const head = template.elements[0];
            if (length === 1) {
                templateLiteral = ts$1.createNoSubstitutionTemplateLiteral(head.cooked, head.raw);
            }
            else {
                const spans = [];
                // Create the middle parts
                for (let i = 1; i < length - 1; i++) {
                    const { cooked, raw, range } = template.elements[i];
                    const middle = createTemplateMiddle(cooked, raw);
                    if (range !== null) {
                        this.setSourceMapRange(middle, range);
                    }
                    spans.push(ts$1.createTemplateSpan(template.expressions[i - 1], middle));
                }
                // Create the tail part
                const resolvedExpression = template.expressions[length - 2];
                const templatePart = template.elements[length - 1];
                const templateTail = createTemplateTail(templatePart.cooked, templatePart.raw);
                if (templatePart.range !== null) {
                    this.setSourceMapRange(templateTail, templatePart.range);
                }
                spans.push(ts$1.createTemplateSpan(resolvedExpression, templateTail));
                // Put it all together
                templateLiteral =
                    ts$1.createTemplateExpression(ts$1.createTemplateHead(head.cooked, head.raw), spans);
            }
            if (head.range !== null) {
                this.setSourceMapRange(templateLiteral, head.range);
            }
            return ts$1.createTaggedTemplate(tag, templateLiteral);
        }
        createUnaryExpression(operator, operand) {
            return ts$1.createPrefix(UNARY_OPERATORS$2[operator], operand);
        }
        createVariableDeclaration(variableName, initializer, type) {
            return ts$1.createVariableStatement(undefined, ts$1.createVariableDeclarationList([ts$1.createVariableDeclaration(variableName, undefined, initializer !== null && initializer !== void 0 ? initializer : undefined)], VAR_TYPES[type]));
        }
        setSourceMapRange(node, sourceMapRange) {
            if (sourceMapRange === null) {
                return node;
            }
            const url = sourceMapRange.url;
            if (!this.externalSourceFiles.has(url)) {
                this.externalSourceFiles.set(url, ts$1.createSourceMapSource(url, sourceMapRange.content, pos => pos));
            }
            const source = this.externalSourceFiles.get(url);
            ts$1.setSourceMapRange(node, { pos: sourceMapRange.start.offset, end: sourceMapRange.end.offset, source });
            return node;
        }
    }
    // HACK: Use this in place of `ts.createTemplateMiddle()`.
    // Revert once https://github.com/microsoft/TypeScript/issues/35374 is fixed.
    function createTemplateMiddle(cooked, raw) {
        const node = ts$1.createTemplateHead(cooked, raw);
        node.kind = ts$1.SyntaxKind.TemplateMiddle;
        return node;
    }
    // HACK: Use this in place of `ts.createTemplateTail()`.
    // Revert once https://github.com/microsoft/TypeScript/issues/35374 is fixed.
    function createTemplateTail(cooked, raw) {
        const node = ts$1.createTemplateHead(cooked, raw);
        node.kind = ts$1.SyntaxKind.TemplateTail;
        return node;
    }
    /**
     * Attach the given `leadingComments` to the `statement` node.
     *
     * @param statement The statement that will have comments attached.
     * @param leadingComments The comments to attach to the statement.
     */
    function attachComments(statement, leadingComments) {
        for (const comment of leadingComments) {
            const commentKind = comment.multiline ? ts$1.SyntaxKind.MultiLineCommentTrivia :
                ts$1.SyntaxKind.SingleLineCommentTrivia;
            if (comment.multiline) {
                ts$1.addSyntheticLeadingComment(statement, commentKind, comment.toString(), comment.trailingNewline);
            }
            else {
                for (const line of comment.toString().split('\n')) {
                    ts$1.addSyntheticLeadingComment(statement, commentKind, line, comment.trailingNewline);
                }
            }
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function translateExpression(expression, imports, options = {}) {
        return expression.visitExpression(new ExpressionTranslatorVisitor(new TypeScriptAstFactory(options.annotateForClosureCompiler === true), imports, options), new Context(false));
    }
    function translateStatement(statement, imports, options = {}) {
        return statement.visitStatement(new ExpressionTranslatorVisitor(new TypeScriptAstFactory(options.annotateForClosureCompiler === true), imports, options), new Context(true));
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Adds extra imports in the import manage for this source file, after the existing imports
     * and before the module body.
     * Can optionally add extra statements (e.g. new constants) before the body as well.
     */
    function addImports(importManager, sf, extraStatements = []) {
        // Generate the import statements to prepend.
        const addedImports = importManager.getAllImports(sf.fileName).map(i => {
            const qualifier = ts$1.createIdentifier(i.qualifier.text);
            const importClause = ts$1.createImportClause(
            /* name */ undefined, 
            /* namedBindings */ ts$1.createNamespaceImport(qualifier));
            const decl = ts$1.createImportDeclaration(
            /* decorators */ undefined, 
            /* modifiers */ undefined, 
            /* importClause */ importClause, 
            /* moduleSpecifier */ ts$1.createLiteral(i.specifier));
            // Set the qualifier's original TS node to the `ts.ImportDeclaration`. This allows downstream
            // transforms such as tsickle to properly process references to this import.
            //
            // This operation is load-bearing in g3 as some imported modules contain special metadata
            // generated by clutz, which tsickle uses to transform imports and references to those imports.
            //
            // TODO(alxhub): add a test for this when tsickle is updated externally to depend on this
            // behavior.
            ts$1.setOriginalNode(i.qualifier, decl);
            return decl;
        });
        // Filter out the existing imports and the source file body. All new statements
        // will be inserted between them.
        const existingImports = sf.statements.filter(stmt => isImportStatement(stmt));
        const body = sf.statements.filter(stmt => !isImportStatement(stmt));
        // Prepend imports if needed.
        if (addedImports.length > 0) {
            // If we prepend imports, we also prepend NotEmittedStatement to use it as an anchor
            // for @fileoverview Closure annotation. If there is no @fileoverview annotations, this
            // statement would be a noop.
            const fileoverviewAnchorStmt = ts$1.createNotEmittedStatement(sf);
            return ts$1.updateSourceFileNode(sf, ts$1.createNodeArray([
                fileoverviewAnchorStmt, ...existingImports, ...addedImports, ...extraStatements, ...body
            ]));
        }
        return sf;
    }
    function isImportStatement(stmt) {
        return ts$1.isImportDeclaration(stmt) || ts$1.isImportEqualsDeclaration(stmt) ||
            ts$1.isNamespaceImport(stmt);
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Keeps track of `DtsTransform`s per source file, so that it is known which source files need to
     * have their declaration file transformed.
     */
    class DtsTransformRegistry {
        constructor() {
            this.ivyDeclarationTransforms = new Map();
        }
        getIvyDeclarationTransform(sf) {
            if (!this.ivyDeclarationTransforms.has(sf)) {
                this.ivyDeclarationTransforms.set(sf, new IvyDeclarationDtsTransform());
            }
            return this.ivyDeclarationTransforms.get(sf);
        }
        /**
         * Gets the dts transforms to be applied for the given source file, or `null` if no transform is
         * necessary.
         */
        getAllTransforms(sf) {
            // No need to transform if it's not a declarations file, or if no changes have been requested
            // to the input file. Due to the way TypeScript afterDeclarations transformers work, the
            // `ts.SourceFile` path is the same as the original .ts. The only way we know it's actually a
            // declaration file is via the `isDeclarationFile` property.
            if (!sf.isDeclarationFile) {
                return null;
            }
            const originalSf = ts$1.getOriginalNode(sf);
            let transforms = null;
            if (this.ivyDeclarationTransforms.has(originalSf)) {
                transforms = [];
                transforms.push(this.ivyDeclarationTransforms.get(originalSf));
            }
            return transforms;
        }
    }
    function declarationTransformFactory(transformRegistry, importRewriter, importPrefix) {
        return (context) => {
            const transformer = new DtsTransformer(context, importRewriter, importPrefix);
            return (fileOrBundle) => {
                if (ts$1.isBundle(fileOrBundle)) {
                    // Only attempt to transform source files.
                    return fileOrBundle;
                }
                const transforms = transformRegistry.getAllTransforms(fileOrBundle);
                if (transforms === null) {
                    return fileOrBundle;
                }
                return transformer.transform(fileOrBundle, transforms);
            };
        };
    }
    /**
     * Processes .d.ts file text and adds static field declarations, with types.
     */
    class DtsTransformer {
        constructor(ctx, importRewriter, importPrefix) {
            this.ctx = ctx;
            this.importRewriter = importRewriter;
            this.importPrefix = importPrefix;
        }
        /**
         * Transform the declaration file and add any declarations which were recorded.
         */
        transform(sf, transforms) {
            const imports = new ImportManager(this.importRewriter, this.importPrefix);
            const visitor = (node) => {
                if (ts$1.isClassDeclaration(node)) {
                    return this.transformClassDeclaration(node, transforms, imports);
                }
                else if (ts$1.isFunctionDeclaration(node)) {
                    return this.transformFunctionDeclaration(node, transforms, imports);
                }
                else {
                    // Otherwise return node as is.
                    return ts$1.visitEachChild(node, visitor, this.ctx);
                }
            };
            // Recursively scan through the AST and process all nodes as desired.
            sf = ts$1.visitNode(sf, visitor);
            // Add new imports for this file.
            return addImports(imports, sf);
        }
        transformClassDeclaration(clazz, transforms, imports) {
            let elements = clazz.members;
            let elementsChanged = false;
            for (const transform of transforms) {
                if (transform.transformClassElement !== undefined) {
                    for (let i = 0; i < elements.length; i++) {
                        const res = transform.transformClassElement(elements[i], imports);
                        if (res !== elements[i]) {
                            if (!elementsChanged) {
                                elements = [...elements];
                                elementsChanged = true;
                            }
                            elements[i] = res;
                        }
                    }
                }
            }
            let newClazz = clazz;
            for (const transform of transforms) {
                if (transform.transformClass !== undefined) {
                    // If no DtsTransform has changed the class yet, then the (possibly mutated) elements have
                    // not yet been incorporated. Otherwise, `newClazz.members` holds the latest class members.
                    const inputMembers = (clazz === newClazz ? elements : newClazz.members);
                    newClazz = transform.transformClass(newClazz, inputMembers, imports);
                }
            }
            // If some elements have been transformed but the class itself has not been transformed, create
            // an updated class declaration with the updated elements.
            if (elementsChanged && clazz === newClazz) {
                newClazz = ts$1.updateClassDeclaration(
                /* node */ clazz, 
                /* decorators */ clazz.decorators, 
                /* modifiers */ clazz.modifiers, 
                /* name */ clazz.name, 
                /* typeParameters */ clazz.typeParameters, 
                /* heritageClauses */ clazz.heritageClauses, 
                /* members */ elements);
            }
            return newClazz;
        }
        transformFunctionDeclaration(declaration, transforms, imports) {
            let newDecl = declaration;
            for (const transform of transforms) {
                if (transform.transformFunctionDeclaration !== undefined) {
                    newDecl = transform.transformFunctionDeclaration(newDecl, imports);
                }
            }
            return newDecl;
        }
    }
    class IvyDeclarationDtsTransform {
        constructor() {
            this.declarationFields = new Map();
        }
        addFields(decl, fields) {
            this.declarationFields.set(decl, fields);
        }
        transformClass(clazz, members, imports) {
            const original = ts$1.getOriginalNode(clazz);
            if (!this.declarationFields.has(original)) {
                return clazz;
            }
            const fields = this.declarationFields.get(original);
            const newMembers = fields.map(decl => {
                const modifiers = [ts$1.createModifier(ts$1.SyntaxKind.StaticKeyword)];
                const typeRef = translateType(decl.type, imports);
                markForEmitAsSingleLine(typeRef);
                return ts$1.createProperty(
                /* decorators */ undefined, 
                /* modifiers */ modifiers, 
                /* name */ decl.name, 
                /* questionOrExclamationToken */ undefined, 
                /* type */ typeRef, 
                /* initializer */ undefined);
            });
            return ts$1.updateClassDeclaration(
            /* node */ clazz, 
            /* decorators */ clazz.decorators, 
            /* modifiers */ clazz.modifiers, 
            /* name */ clazz.name, 
            /* typeParameters */ clazz.typeParameters, 
            /* heritageClauses */ clazz.heritageClauses, 
            /* members */ [...members, ...newMembers]);
        }
    }
    function markForEmitAsSingleLine(node) {
        ts$1.setEmitFlags(node, ts$1.EmitFlags.SingleLine);
        ts$1.forEachChild(node, markForEmitAsSingleLine);
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Visit a node with the given visitor and return a transformed copy.
     */
    function visit(node, visitor, context) {
        return visitor._visit(node, context);
    }
    /**
     * Abstract base class for visitors, which processes certain nodes specially to allow insertion
     * of other nodes before them.
     */
    class Visitor {
        constructor() {
            /**
             * Maps statements to an array of statements that should be inserted before them.
             */
            this._before = new Map();
            /**
             * Maps statements to an array of statements that should be inserted after them.
             */
            this._after = new Map();
        }
        _visitListEntryNode(node, visitor) {
            const result = visitor(node);
            if (result.before !== undefined) {
                // Record that some nodes should be inserted before the given declaration. The declaration's
                // parent's _visit call is responsible for performing this insertion.
                this._before.set(result.node, result.before);
            }
            if (result.after !== undefined) {
                // Same with nodes that should be inserted after.
                this._after.set(result.node, result.after);
            }
            return result.node;
        }
        /**
         * Visit types of nodes which don't have their own explicit visitor.
         */
        visitOtherNode(node) {
            return node;
        }
        /**
         * @internal
         */
        _visit(node, context) {
            // First, visit the node. visitedNode starts off as `null` but should be set after visiting
            // is completed.
            let visitedNode = null;
            node = ts$1.visitEachChild(node, child => this._visit(child, context), context);
            if (ts$1.isClassDeclaration(node)) {
                visitedNode =
                    this._visitListEntryNode(node, (node) => this.visitClassDeclaration(node));
            }
            else {
                visitedNode = this.visitOtherNode(node);
            }
            // If the visited node has a `statements` array then process them, maybe replacing the visited
            // node and adding additional statements.
            if (hasStatements(visitedNode)) {
                visitedNode = this._maybeProcessStatements(visitedNode);
            }
            return visitedNode;
        }
        _maybeProcessStatements(node) {
            // Shortcut - if every statement doesn't require nodes to be prepended or appended,
            // this is a no-op.
            if (node.statements.every(stmt => !this._before.has(stmt) && !this._after.has(stmt))) {
                return node;
            }
            // There are statements to prepend, so clone the original node.
            const clone = ts$1.getMutableClone(node);
            // Build a new list of statements and patch it onto the clone.
            const newStatements = [];
            clone.statements.forEach(stmt => {
                if (this._before.has(stmt)) {
                    newStatements.push(...this._before.get(stmt));
                    this._before.delete(stmt);
                }
                newStatements.push(stmt);
                if (this._after.has(stmt)) {
                    newStatements.push(...this._after.get(stmt));
                    this._after.delete(stmt);
                }
            });
            clone.statements = ts$1.createNodeArray(newStatements, node.statements.hasTrailingComma);
            return clone;
        }
    }
    function hasStatements(node) {
        const block = node;
        return block.statements !== undefined && Array.isArray(block.statements);
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const NO_DECORATORS = new Set();
    const CLOSURE_FILE_OVERVIEW_REGEXP = /\s+@fileoverview\s+/i;
    function ivyTransformFactory(compilation, reflector, importRewriter, defaultImportTracker, perf, isCore, isClosureCompilerEnabled) {
        const recordWrappedNode = createRecorderFn(defaultImportTracker);
        return (context) => {
            return (file) => {
                return perf.inPhase(PerfPhase.Compile, () => transformIvySourceFile(compilation, context, reflector, importRewriter, file, isCore, isClosureCompilerEnabled, recordWrappedNode));
            };
        };
    }
    /**
     * Visits all classes, performs Ivy compilation where Angular decorators are present and collects
     * result in a Map that associates a ts.ClassDeclaration with Ivy compilation results. This visitor
     * does NOT perform any TS transformations.
     */
    class IvyCompilationVisitor extends Visitor {
        constructor(compilation, constantPool) {
            super();
            this.compilation = compilation;
            this.constantPool = constantPool;
            this.classCompilationMap = new Map();
        }
        visitClassDeclaration(node) {
            // Determine if this class has an Ivy field that needs to be added, and compile the field
            // to an expression if so.
            const result = this.compilation.compile(node, this.constantPool);
            if (result !== null) {
                this.classCompilationMap.set(node, result);
            }
            return { node };
        }
    }
    /**
     * Visits all classes and performs transformation of corresponding TS nodes based on the Ivy
     * compilation results (provided as an argument).
     */
    class IvyTransformationVisitor extends Visitor {
        constructor(compilation, classCompilationMap, reflector, importManager, recordWrappedNodeExpr, isClosureCompilerEnabled, isCore) {
            super();
            this.compilation = compilation;
            this.classCompilationMap = classCompilationMap;
            this.reflector = reflector;
            this.importManager = importManager;
            this.recordWrappedNodeExpr = recordWrappedNodeExpr;
            this.isClosureCompilerEnabled = isClosureCompilerEnabled;
            this.isCore = isCore;
        }
        visitClassDeclaration(node) {
            // If this class is not registered in the map, it means that it doesn't have Angular decorators,
            // thus no further processing is required.
            if (!this.classCompilationMap.has(node)) {
                return { node };
            }
            const translateOptions = {
                recordWrappedNode: this.recordWrappedNodeExpr,
                annotateForClosureCompiler: this.isClosureCompilerEnabled,
            };
            // There is at least one field to add.
            const statements = [];
            const members = [...node.members];
            for (const field of this.classCompilationMap.get(node)) {
                // Translate the initializer for the field into TS nodes.
                const exprNode = translateExpression(field.initializer, this.importManager, translateOptions);
                // Create a static property declaration for the new field.
                const property = ts$1.createProperty(undefined, [ts$1.createToken(ts$1.SyntaxKind.StaticKeyword)], field.name, undefined, undefined, exprNode);
                if (this.isClosureCompilerEnabled) {
                    // Closure compiler transforms the form `Service.prov = X` into `Service$prov = X`. To
                    // prevent this transformation, such assignments need to be annotated with @nocollapse.
                    // Note that tsickle is typically responsible for adding such annotations, however it
                    // doesn't yet handle synthetic fields added during other transformations.
                    ts$1.addSyntheticLeadingComment(property, ts$1.SyntaxKind.MultiLineCommentTrivia, '* @nocollapse ', 
                    /* hasTrailingNewLine */ false);
                }
                field.statements.map(stmt => translateStatement(stmt, this.importManager, translateOptions))
                    .forEach(stmt => statements.push(stmt));
                members.push(property);
            }
            // Replace the class declaration with an updated version.
            node = ts$1.updateClassDeclaration(node, 
            // Remove the decorator which triggered this compilation, leaving the others alone.
            maybeFilterDecorator(node.decorators, this.compilation.decoratorsFor(node)), node.modifiers, node.name, node.typeParameters, node.heritageClauses || [], 
            // Map over the class members and remove any Angular decorators from them.
            members.map(member => this._stripAngularDecorators(member)));
            return { node, after: statements };
        }
        /**
         * Return all decorators on a `Declaration` which are from @angular/core, or an empty set if none
         * are.
         */
        _angularCoreDecorators(decl) {
            const decorators = this.reflector.getDecoratorsOfDeclaration(decl);
            if (decorators === null) {
                return NO_DECORATORS;
            }
            const coreDecorators = decorators.filter(dec => this.isCore || isFromAngularCore(dec))
                .map(dec => dec.node);
            if (coreDecorators.length > 0) {
                return new Set(coreDecorators);
            }
            else {
                return NO_DECORATORS;
            }
        }
        /**
         * Given a `ts.Node`, filter the decorators array and return a version containing only non-Angular
         * decorators.
         *
         * If all decorators are removed (or none existed in the first place), this method returns
         * `undefined`.
         */
        _nonCoreDecoratorsOnly(node) {
            // Shortcut if the node has no decorators.
            if (node.decorators === undefined) {
                return undefined;
            }
            // Build a Set of the decorators on this node from @angular/core.
            const coreDecorators = this._angularCoreDecorators(node);
            if (coreDecorators.size === node.decorators.length) {
                // If all decorators are to be removed, return `undefined`.
                return undefined;
            }
            else if (coreDecorators.size === 0) {
                // If no decorators need to be removed, return the original decorators array.
                return node.decorators;
            }
            // Filter out the core decorators.
            const filtered = node.decorators.filter(dec => !coreDecorators.has(dec));
            // If no decorators survive, return `undefined`. This can only happen if a core decorator is
            // repeated on the node.
            if (filtered.length === 0) {
                return undefined;
            }
            // Create a new `NodeArray` with the filtered decorators that sourcemaps back to the original.
            const array = ts$1.createNodeArray(filtered);
            array.pos = node.decorators.pos;
            array.end = node.decorators.end;
            return array;
        }
        /**
         * Remove Angular decorators from a `ts.Node` in a shallow manner.
         *
         * This will remove decorators from class elements (getters, setters, properties, methods) as well
         * as parameters of constructors.
         */
        _stripAngularDecorators(node) {
            if (ts$1.isParameter(node)) {
                // Strip decorators from parameters (probably of the constructor).
                node = ts$1.updateParameter(node, this._nonCoreDecoratorsOnly(node), node.modifiers, node.dotDotDotToken, node.name, node.questionToken, node.type, node.initializer);
            }
            else if (ts$1.isMethodDeclaration(node) && node.decorators !== undefined) {
                // Strip decorators of methods.
                node = ts$1.updateMethod(node, this._nonCoreDecoratorsOnly(node), node.modifiers, node.asteriskToken, node.name, node.questionToken, node.typeParameters, node.parameters, node.type, node.body);
            }
            else if (ts$1.isPropertyDeclaration(node) && node.decorators !== undefined) {
                // Strip decorators of properties.
                node = ts$1.updateProperty(node, this._nonCoreDecoratorsOnly(node), node.modifiers, node.name, node.questionToken, node.type, node.initializer);
            }
            else if (ts$1.isGetAccessor(node)) {
                // Strip decorators of getters.
                node = ts$1.updateGetAccessor(node, this._nonCoreDecoratorsOnly(node), node.modifiers, node.name, node.parameters, node.type, node.body);
            }
            else if (ts$1.isSetAccessor(node)) {
                // Strip decorators of setters.
                node = ts$1.updateSetAccessor(node, this._nonCoreDecoratorsOnly(node), node.modifiers, node.name, node.parameters, node.body);
            }
            else if (ts$1.isConstructorDeclaration(node)) {
                // For constructors, strip decorators of the parameters.
                const parameters = node.parameters.map(param => this._stripAngularDecorators(param));
                node =
                    ts$1.updateConstructor(node, node.decorators, node.modifiers, parameters, node.body);
            }
            return node;
        }
    }
    /**
     * A transformer which operates on ts.SourceFiles and applies changes from an `IvyCompilation`.
     */
    function transformIvySourceFile(compilation, context, reflector, importRewriter, file, isCore, isClosureCompilerEnabled, recordWrappedNode) {
        const constantPool = new ConstantPool(isClosureCompilerEnabled);
        const importManager = new ImportManager(importRewriter);
        // The transformation process consists of 2 steps:
        //
        //  1. Visit all classes, perform compilation and collect the results.
        //  2. Perform actual transformation of required TS nodes using compilation results from the first
        //     step.
        //
        // This is needed to have all `o.Expression`s generated before any TS transforms happen. This
        // allows `ConstantPool` to properly identify expressions that can be shared across multiple
        // components declared in the same file.
        // Step 1. Go though all classes in AST, perform compilation and collect the results.
        const compilationVisitor = new IvyCompilationVisitor(compilation, constantPool);
        visit(file, compilationVisitor, context);
        // Step 2. Scan through the AST again and perform transformations based on Ivy compilation
        // results obtained at Step 1.
        const transformationVisitor = new IvyTransformationVisitor(compilation, compilationVisitor.classCompilationMap, reflector, importManager, recordWrappedNode, isClosureCompilerEnabled, isCore);
        let sf = visit(file, transformationVisitor, context);
        // Generate the constant statements first, as they may involve adding additional imports
        // to the ImportManager.
        const downlevelTranslatedCode = getLocalizeCompileTarget(context) < ts$1.ScriptTarget.ES2015;
        const constants = constantPool.statements.map(stmt => translateStatement(stmt, importManager, {
            recordWrappedNode,
            downlevelTaggedTemplates: downlevelTranslatedCode,
            downlevelVariableDeclarations: downlevelTranslatedCode,
            annotateForClosureCompiler: isClosureCompilerEnabled,
        }));
        // Preserve @fileoverview comments required by Closure, since the location might change as a
        // result of adding extra imports and constant pool statements.
        const fileOverviewMeta = isClosureCompilerEnabled ? getFileOverviewComment(sf.statements) : null;
        // Add new imports for this file.
        sf = addImports(importManager, sf, constants);
        if (fileOverviewMeta !== null) {
            setFileOverviewComment(sf, fileOverviewMeta);
        }
        return sf;
    }
    /**
     * Compute the correct target output for `$localize` messages generated by Angular
     *
     * In some versions of TypeScript, the transformation of synthetic `$localize` tagged template
     * literals is broken. See https://github.com/microsoft/TypeScript/issues/38485
     *
     * Here we compute what the expected final output target of the compilation will
     * be so that we can generate ES5 compliant `$localize` calls instead of relying upon TS to do the
     * downleveling for us.
     */
    function getLocalizeCompileTarget(context) {
        const target = context.getCompilerOptions().target || ts$1.ScriptTarget.ES2015;
        return target !== ts$1.ScriptTarget.JSON ? target : ts$1.ScriptTarget.ES2015;
    }
    function getFileOverviewComment(statements) {
        if (statements.length > 0) {
            const host = statements[0];
            let trailing = false;
            let comments = ts$1.getSyntheticLeadingComments(host);
            // If @fileoverview tag is not found in source file, tsickle produces fake node with trailing
            // comment and inject it at the very beginning of the generated file. So we need to check for
            // leading as well as trailing comments.
            if (!comments || comments.length === 0) {
                trailing = true;
                comments = ts$1.getSyntheticTrailingComments(host);
            }
            if (comments && comments.length > 0 && CLOSURE_FILE_OVERVIEW_REGEXP.test(comments[0].text)) {
                return { comments, host, trailing };
            }
        }
        return null;
    }
    function setFileOverviewComment(sf, fileoverview) {
        const { comments, host, trailing } = fileoverview;
        // If host statement is no longer the first one, it means that extra statements were added at the
        // very beginning, so we need to relocate @fileoverview comment and cleanup the original statement
        // that hosted it.
        if (sf.statements.length > 0 && host !== sf.statements[0]) {
            if (trailing) {
                ts$1.setSyntheticTrailingComments(host, undefined);
            }
            else {
                ts$1.setSyntheticLeadingComments(host, undefined);
            }
            ts$1.setSyntheticLeadingComments(sf.statements[0], comments);
        }
    }
    function maybeFilterDecorator(decorators, toRemove) {
        if (decorators === undefined) {
            return undefined;
        }
        const filtered = decorators.filter(dec => toRemove.find(decToRemove => ts$1.getOriginalNode(dec) === decToRemove) === undefined);
        if (filtered.length === 0) {
            return undefined;
        }
        return ts$1.createNodeArray(filtered);
    }
    function isFromAngularCore(decorator) {
        return decorator.import !== null && decorator.import.from === '@angular/core';
    }
    function createRecorderFn(defaultImportTracker) {
        return node => {
            const importDecl = getDefaultImportDeclaration(node);
            if (importDecl !== null) {
                defaultImportTracker.recordUsedImport(importDecl);
            }
        };
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function getConstructorDependencies(clazz, reflector, isCore) {
        const deps = [];
        const errors = [];
        let ctorParams = reflector.getConstructorParameters(clazz);
        if (ctorParams === null) {
            if (reflector.hasBaseClass(clazz)) {
                return null;
            }
            else {
                ctorParams = [];
            }
        }
        ctorParams.forEach((param, idx) => {
            let token = valueReferenceToExpression(param.typeValueReference);
            let attributeNameType = null;
            let optional = false, self = false, skipSelf = false, host = false;
            (param.decorators || []).filter(dec => isCore || isAngularCore(dec)).forEach(dec => {
                const name = isCore || dec.import === null ? dec.name : dec.import.name;
                if (name === 'Inject') {
                    if (dec.args === null || dec.args.length !== 1) {
                        throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, Decorator.nodeForError(dec), `Unexpected number of arguments to @Inject().`);
                    }
                    token = new WrappedNodeExpr(dec.args[0]);
                }
                else if (name === 'Optional') {
                    optional = true;
                }
                else if (name === 'SkipSelf') {
                    skipSelf = true;
                }
                else if (name === 'Self') {
                    self = true;
                }
                else if (name === 'Host') {
                    host = true;
                }
                else if (name === 'Attribute') {
                    if (dec.args === null || dec.args.length !== 1) {
                        throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, Decorator.nodeForError(dec), `Unexpected number of arguments to @Attribute().`);
                    }
                    const attributeName = dec.args[0];
                    token = new WrappedNodeExpr(attributeName);
                    if (ts$1.isStringLiteralLike(attributeName)) {
                        attributeNameType = new LiteralExpr(attributeName.text);
                    }
                    else {
                        attributeNameType =
                            new WrappedNodeExpr(ts$1.createKeywordTypeNode(ts$1.SyntaxKind.UnknownKeyword));
                    }
                }
                else {
                    throw new FatalDiagnosticError(ErrorCode.DECORATOR_UNEXPECTED, Decorator.nodeForError(dec), `Unexpected decorator ${name} on parameter.`);
                }
            });
            if (token === null) {
                if (param.typeValueReference.kind !== 2 /* UNAVAILABLE */) {
                    throw new Error('Illegal state: expected value reference to be unavailable if no token is present');
                }
                errors.push({
                    index: idx,
                    param,
                    reason: param.typeValueReference.reason,
                });
            }
            else {
                deps.push({ token, attributeNameType, optional, self, skipSelf, host });
            }
        });
        if (errors.length === 0) {
            return { deps };
        }
        else {
            return { deps: null, errors };
        }
    }
    function valueReferenceToExpression(valueRef) {
        if (valueRef.kind === 2 /* UNAVAILABLE */) {
            return null;
        }
        else if (valueRef.kind === 0 /* LOCAL */) {
            const expr = new WrappedNodeExpr(valueRef.expression);
            if (valueRef.defaultImportStatement !== null) {
                attachDefaultImportDeclaration(expr, valueRef.defaultImportStatement);
            }
            return expr;
        }
        else {
            let importExpr = new ExternalExpr({ moduleName: valueRef.moduleName, name: valueRef.importedName });
            if (valueRef.nestedPath !== null) {
                for (const property of valueRef.nestedPath) {
                    importExpr = new ReadPropExpr(importExpr, property);
                }
            }
            return importExpr;
        }
    }
    /**
     * Convert `ConstructorDeps` into the `R3DependencyMetadata` array for those deps if they're valid,
     * or into an `'invalid'` signal if they're not.
     *
     * This is a companion function to `validateConstructorDependencies` which accepts invalid deps.
     */
    function unwrapConstructorDependencies(deps) {
        if (deps === null) {
            return null;
        }
        else if (deps.deps !== null) {
            // These constructor dependencies are valid.
            return deps.deps;
        }
        else {
            // These deps are invalid.
            return 'invalid';
        }
    }
    function getValidConstructorDependencies(clazz, reflector, isCore) {
        return validateConstructorDependencies(clazz, getConstructorDependencies(clazz, reflector, isCore));
    }
    /**
     * Validate that `ConstructorDeps` does not have any invalid dependencies and convert them into the
     * `R3DependencyMetadata` array if so, or raise a diagnostic if some deps are invalid.
     *
     * This is a companion function to `unwrapConstructorDependencies` which does not accept invalid
     * deps.
     */
    function validateConstructorDependencies(clazz, deps) {
        if (deps === null) {
            return null;
        }
        else if (deps.deps !== null) {
            return deps.deps;
        }
        else {
            // TODO(alxhub): this cast is necessary because the g3 typescript version doesn't narrow here.
            // There is at least one error.
            const error = deps.errors[0];
            throw createUnsuitableInjectionTokenError(clazz, error);
        }
    }
    /**
     * Creates a fatal error with diagnostic for an invalid injection token.
     * @param clazz The class for which the injection token was unavailable.
     * @param error The reason why no valid injection token is available.
     */
    function createUnsuitableInjectionTokenError(clazz, error) {
        const { param, index, reason } = error;
        let chainMessage = undefined;
        let hints = undefined;
        switch (reason.kind) {
            case 5 /* UNSUPPORTED */:
                chainMessage = 'Consider using the @Inject decorator to specify an injection token.';
                hints = [
                    makeRelatedInformation(reason.typeNode, 'This type is not supported as injection token.'),
                ];
                break;
            case 1 /* NO_VALUE_DECLARATION */:
                chainMessage = 'Consider using the @Inject decorator to specify an injection token.';
                hints = [
                    makeRelatedInformation(reason.typeNode, 'This type does not have a value, so it cannot be used as injection token.'),
                ];
                if (reason.decl !== null) {
                    hints.push(makeRelatedInformation(reason.decl, 'The type is declared here.'));
                }
                break;
            case 2 /* TYPE_ONLY_IMPORT */:
                chainMessage =
                    'Consider changing the type-only import to a regular import, or use the @Inject decorator to specify an injection token.';
                hints = [
                    makeRelatedInformation(reason.typeNode, 'This type is imported using a type-only import, which prevents it from being usable as an injection token.'),
                    makeRelatedInformation(reason.importClause, 'The type-only import occurs here.'),
                ];
                break;
            case 4 /* NAMESPACE */:
                chainMessage = 'Consider using the @Inject decorator to specify an injection token.';
                hints = [
                    makeRelatedInformation(reason.typeNode, 'This type corresponds with a namespace, which cannot be used as injection token.'),
                    makeRelatedInformation(reason.importClause, 'The namespace import occurs here.'),
                ];
                break;
            case 3 /* UNKNOWN_REFERENCE */:
                chainMessage = 'The type should reference a known declaration.';
                hints = [makeRelatedInformation(reason.typeNode, 'This type could not be resolved.')];
                break;
            case 0 /* MISSING_TYPE */:
                chainMessage =
                    'Consider adding a type to the parameter or use the @Inject decorator to specify an injection token.';
                break;
        }
        const chain = {
            messageText: `No suitable injection token for parameter '${param.name || index}' of class '${clazz.name.text}'.`,
            category: ts$1.DiagnosticCategory.Error,
            code: 0,
            next: [{
                    messageText: chainMessage,
                    category: ts$1.DiagnosticCategory.Message,
                    code: 0,
                }],
        };
        return new FatalDiagnosticError(ErrorCode.PARAM_MISSING_TOKEN, param.nameNode, chain, hints);
    }
    function toR3Reference(valueRef, typeRef, valueContext, typeContext, refEmitter) {
        return {
            value: refEmitter.emit(valueRef, valueContext).expression,
            type: refEmitter
                .emit(typeRef, typeContext, ImportFlags.ForceNewImport | ImportFlags.AllowTypeImports)
                .expression,
        };
    }
    function isAngularCore(decorator) {
        return decorator.import !== null && decorator.import.from === '@angular/core';
    }
    function isAngularCoreReference(reference, symbolName) {
        return reference.ownedByModuleGuess === '@angular/core' && reference.debugName === symbolName;
    }
    function findAngularDecorator(decorators, name, isCore) {
        return decorators.find(decorator => isAngularDecorator(decorator, name, isCore));
    }
    function isAngularDecorator(decorator, name, isCore) {
        if (isCore) {
            return decorator.name === name;
        }
        else if (isAngularCore(decorator)) {
            return decorator.import.name === name;
        }
        return false;
    }
    /**
     * Unwrap a `ts.Expression`, removing outer type-casts or parentheses until the expression is in its
     * lowest level form.
     *
     * For example, the expression "(foo as Type)" unwraps to "foo".
     */
    function unwrapExpression(node) {
        while (ts$1.isAsExpression(node) || ts$1.isParenthesizedExpression(node)) {
            node = node.expression;
        }
        return node;
    }
    function expandForwardRef(arg) {
        arg = unwrapExpression(arg);
        if (!ts$1.isArrowFunction(arg) && !ts$1.isFunctionExpression(arg)) {
            return null;
        }
        const body = arg.body;
        // Either the body is a ts.Expression directly, or a block with a single return statement.
        if (ts$1.isBlock(body)) {
            // Block body - look for a single return statement.
            if (body.statements.length !== 1) {
                return null;
            }
            const stmt = body.statements[0];
            if (!ts$1.isReturnStatement(stmt) || stmt.expression === undefined) {
                return null;
            }
            return stmt.expression;
        }
        else {
            // Shorthand body - return as an expression.
            return body;
        }
    }
    /**
     * If the given `node` is a forwardRef() expression then resolve its inner value, otherwise return
     * `null`.
     *
     * @param node the forwardRef() expression to resolve
     * @param reflector a ReflectionHost
     * @returns the resolved expression, if the original expression was a forwardRef(), or `null`
     *     otherwise.
     */
    function tryUnwrapForwardRef(node, reflector) {
        node = unwrapExpression(node);
        if (!ts$1.isCallExpression(node) || node.arguments.length !== 1) {
            return null;
        }
        const fn = ts$1.isPropertyAccessExpression(node.expression) ? node.expression.name : node.expression;
        if (!ts$1.isIdentifier(fn)) {
            return null;
        }
        const expr = expandForwardRef(node.arguments[0]);
        if (expr === null) {
            return null;
        }
        const imp = reflector.getImportOfIdentifier(fn);
        if (imp === null || imp.from !== '@angular/core' || imp.name !== 'forwardRef') {
            return null;
        }
        return expr;
    }
    /**
     * A foreign function resolver for `staticallyResolve` which unwraps forwardRef() expressions.
     *
     * @param ref a Reference to the declaration of the function being called (which might be
     * forwardRef)
     * @param args the arguments to the invocation of the forwardRef expression
     * @returns an unwrapped argument if `ref` pointed to forwardRef, or null otherwise
     */
    function forwardRefResolver(ref, args) {
        if (!isAngularCoreReference(ref, 'forwardRef') || args.length !== 1) {
            return null;
        }
        return expandForwardRef(args[0]);
    }
    /**
     * Combines an array of resolver functions into a one.
     * @param resolvers Resolvers to be combined.
     */
    function combineResolvers(resolvers) {
        return (ref, args) => {
            for (const resolver of resolvers) {
                const resolved = resolver(ref, args);
                if (resolved !== null) {
                    return resolved;
                }
            }
            return null;
        };
    }
    function isExpressionForwardReference(expr, context, contextSource) {
        if (isWrappedTsNodeExpr(expr)) {
            const node = ts$1.getOriginalNode(expr.node);
            return node.getSourceFile() === contextSource && context.pos < node.pos;
        }
        else {
            return false;
        }
    }
    function isWrappedTsNodeExpr(expr) {
        return expr instanceof WrappedNodeExpr;
    }
    function readBaseClass$1(node, reflector, evaluator) {
        const baseExpression = reflector.getBaseClassExpression(node);
        if (baseExpression !== null) {
            const baseClass = evaluator.evaluate(baseExpression);
            if (baseClass instanceof Reference$1 && reflector.isClass(baseClass.node)) {
                return baseClass;
            }
            else {
                return 'dynamic';
            }
        }
        return null;
    }
    const parensWrapperTransformerFactory = (context) => {
        const visitor = (node) => {
            const visited = ts$1.visitEachChild(node, visitor, context);
            if (ts$1.isArrowFunction(visited) || ts$1.isFunctionExpression(visited)) {
                return ts$1.createParen(visited);
            }
            return visited;
        };
        return (node) => ts$1.visitEachChild(node, visitor, context);
    };
    /**
     * Wraps all functions in a given expression in parentheses. This is needed to avoid problems
     * where Tsickle annotations added between analyse and transform phases in Angular may trigger
     * automatic semicolon insertion, e.g. if a function is the expression in a `return` statement.
     * More
     * info can be found in Tsickle source code here:
     * https://github.com/angular/tsickle/blob/d7974262571c8a17d684e5ba07680e1b1993afdd/src/jsdoc_transformer.ts#L1021
     *
     * @param expression Expression where functions should be wrapped in parentheses
     */
    function wrapFunctionExpressionsInParens(expression) {
        return ts$1.transform(expression, [parensWrapperTransformerFactory]).transformed[0];
    }
    /**
     * Create a `ts.Diagnostic` which indicates the given class is part of the declarations of two or
     * more NgModules.
     *
     * The resulting `ts.Diagnostic` will have a context entry for each NgModule showing the point where
     * the directive/pipe exists in its `declarations` (if possible).
     */
    function makeDuplicateDeclarationError(node, data, kind) {
        const context = [];
        for (const decl of data) {
            if (decl.rawDeclarations === null) {
                continue;
            }
            // Try to find the reference to the declaration within the declarations array, to hang the
            // error there. If it can't be found, fall back on using the NgModule's name.
            const contextNode = decl.ref.getOriginForDiagnostics(decl.rawDeclarations, decl.ngModule.name);
            context.push(makeRelatedInformation(contextNode, `'${node.name.text}' is listed in the declarations of the NgModule '${decl.ngModule.name.text}'.`));
        }
        // Finally, produce the diagnostic.
        return makeDiagnostic(ErrorCode.NGMODULE_DECLARATION_NOT_UNIQUE, node.name, `The ${kind} '${node.name.text}' is declared by more than one NgModule.`, context);
    }
    /**
     * Resolves the given `rawProviders` into `ClassDeclarations` and returns
     * a set containing those that are known to require a factory definition.
     * @param rawProviders Expression that declared the providers array in the source.
     */
    function resolveProvidersRequiringFactory(rawProviders, reflector, evaluator) {
        const providers = new Set();
        const resolvedProviders = evaluator.evaluate(rawProviders);
        if (!Array.isArray(resolvedProviders)) {
            return providers;
        }
        resolvedProviders.forEach(function processProviders(provider) {
            let tokenClass = null;
            if (Array.isArray(provider)) {
                // If we ran into an array, recurse into it until we've resolve all the classes.
                provider.forEach(processProviders);
            }
            else if (provider instanceof Reference$1) {
                tokenClass = provider;
            }
            else if (provider instanceof Map && provider.has('useClass') && !provider.has('deps')) {
                const useExisting = provider.get('useClass');
                if (useExisting instanceof Reference$1) {
                    tokenClass = useExisting;
                }
            }
            // TODO(alxhub): there was a bug where `getConstructorParameters` would return `null` for a
            // class in a .d.ts file, always, even if the class had a constructor. This was fixed for
            // `getConstructorParameters`, but that fix causes more classes to be recognized here as needing
            // provider checks, which is a breaking change in g3. Avoid this breakage for now by skipping
            // classes from .d.ts files here directly, until g3 can be cleaned up.
            if (tokenClass !== null && !tokenClass.node.getSourceFile().isDeclarationFile &&
                reflector.isClass(tokenClass.node)) {
                const constructorParameters = reflector.getConstructorParameters(tokenClass.node);
                // Note that we only want to capture providers with a non-trivial constructor,
                // because they're the ones that might be using DI and need to be decorated.
                if (constructorParameters !== null && constructorParameters.length > 0) {
                    providers.add(tokenClass);
                }
            }
        });
        return providers;
    }
    /**
     * Create an R3Reference for a class.
     *
     * The `value` is the exported declaration of the class from its source file.
     * The `type` is an expression that would be used by ngcc in the typings (.d.ts) files.
     */
    function wrapTypeReference(reflector, clazz) {
        const dtsClass = reflector.getDtsDeclaration(clazz);
        const value = new WrappedNodeExpr(clazz.name);
        const type = dtsClass !== null && isNamedClassDeclaration(dtsClass) ?
            new WrappedNodeExpr(dtsClass.name) :
            value;
        return { value, type };
    }
    /** Creates a ParseSourceSpan for a TypeScript node. */
    function createSourceSpan(node) {
        const sf = node.getSourceFile();
        const [startOffset, endOffset] = [node.getStart(), node.getEnd()];
        const { line: startLine, character: startCol } = sf.getLineAndCharacterOfPosition(startOffset);
        const { line: endLine, character: endCol } = sf.getLineAndCharacterOfPosition(endOffset);
        const parseSf = new ParseSourceFile(sf.getFullText(), sf.fileName);
        // +1 because values are zero-indexed.
        return new ParseSourceSpan(new ParseLocation(parseSf, startOffset, startLine + 1, startCol + 1), new ParseLocation(parseSf, endOffset, endLine + 1, endCol + 1));
    }
    /**
     * Collate the factory and definition compiled results into an array of CompileResult objects.
     */
    function compileResults(fac, def, metadataStmt, propName) {
        const statements = def.statements;
        if (metadataStmt !== null) {
            statements.push(metadataStmt);
        }
        return [
            fac, {
                name: propName,
                initializer: def.expression,
                statements: def.statements,
                type: def.type,
            }
        ];
    }
    function toFactoryMetadata(meta, target) {
        return {
            name: meta.name,
            type: meta.type,
            internalType: meta.internalType,
            typeArgumentCount: meta.typeArgumentCount,
            deps: meta.deps,
            target
        };
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Creates a `FatalDiagnosticError` for a node that did not evaluate to the expected type. The
     * diagnostic that is created will include details on why the value is incorrect, i.e. it includes
     * a representation of the actual type that was unsupported, or in the case of a dynamic value the
     * trace to the node where the dynamic value originated.
     *
     * @param node The node for which the diagnostic should be produced.
     * @param value The evaluated value that has the wrong type.
     * @param messageText The message text of the error.
     */
    function createValueHasWrongTypeError(node, value, messageText) {
        var _a;
        let chainedMessage;
        let relatedInformation;
        if (value instanceof DynamicValue) {
            chainedMessage = 'Value could not be determined statically.';
            relatedInformation = traceDynamicValue(node, value);
        }
        else if (value instanceof Reference$1) {
            const target = value.debugName !== null ? `'${value.debugName}'` : 'an anonymous declaration';
            chainedMessage = `Value is a reference to ${target}.`;
            const referenceNode = (_a = identifierOfNode(value.node)) !== null && _a !== void 0 ? _a : value.node;
            relatedInformation = [makeRelatedInformation(referenceNode, 'Reference is declared here.')];
        }
        else {
            chainedMessage = `Value is of type '${describeResolvedType(value)}'.`;
        }
        const chain = {
            messageText,
            category: ts$1.DiagnosticCategory.Error,
            code: 0,
            next: [{
                    messageText: chainedMessage,
                    category: ts$1.DiagnosticCategory.Message,
                    code: 0,
                }]
        };
        return new FatalDiagnosticError(ErrorCode.VALUE_HAS_WRONG_TYPE, node, chain, relatedInformation);
    }
    /**
     * Gets the diagnostics for a set of provider classes.
     * @param providerClasses Classes that should be checked.
     * @param providersDeclaration Node that declares the providers array.
     * @param registry Registry that keeps track of the registered injectable classes.
     */
    function getProviderDiagnostics(providerClasses, providersDeclaration, registry) {
        const diagnostics = [];
        for (const provider of providerClasses) {
            if (registry.isInjectable(provider.node)) {
                continue;
            }
            const contextNode = provider.getOriginForDiagnostics(providersDeclaration);
            diagnostics.push(makeDiagnostic(ErrorCode.UNDECORATED_PROVIDER, contextNode, `The class '${provider.node.name
            .text}' cannot be created via dependency injection, as it does not have an Angular decorator. This will result in an error at runtime.

Either add the @Injectable() decorator to '${provider.node.name
            .text}', or configure a different provider (such as a provider with 'useFactory').
`, [makeRelatedInformation(provider.node, `'${provider.node.name.text}' is declared here.`)]));
        }
        return diagnostics;
    }
    function getDirectiveDiagnostics(node, reader, evaluator, reflector, scopeRegistry, kind) {
        let diagnostics = [];
        const addDiagnostics = (more) => {
            if (more === null) {
                return;
            }
            else if (diagnostics === null) {
                diagnostics = Array.isArray(more) ? more : [more];
            }
            else if (Array.isArray(more)) {
                diagnostics.push(...more);
            }
            else {
                diagnostics.push(more);
            }
        };
        const duplicateDeclarations = scopeRegistry.getDuplicateDeclarations(node);
        if (duplicateDeclarations !== null) {
            addDiagnostics(makeDuplicateDeclarationError(node, duplicateDeclarations, kind));
        }
        addDiagnostics(checkInheritanceOfDirective(node, reader, reflector, evaluator));
        return diagnostics;
    }
    function getUndecoratedClassWithAngularFeaturesDiagnostic(node) {
        return makeDiagnostic(ErrorCode.UNDECORATED_CLASS_USING_ANGULAR_FEATURES, node.name, `Class is using Angular features but is not decorated. Please add an explicit ` +
            `Angular decorator.`);
    }
    function checkInheritanceOfDirective(node, reader, reflector, evaluator) {
        if (!reflector.isClass(node) || reflector.getConstructorParameters(node) !== null) {
            // We should skip nodes that aren't classes. If a constructor exists, then no base class
            // definition is required on the runtime side - it's legal to inherit from any class.
            return null;
        }
        // The extends clause is an expression which can be as dynamic as the user wants. Try to
        // evaluate it, but fall back on ignoring the clause if it can't be understood. This is a View
        // Engine compatibility hack: View Engine ignores 'extends' expressions that it cannot understand.
        let baseClass = readBaseClass$1(node, reflector, evaluator);
        while (baseClass !== null) {
            if (baseClass === 'dynamic') {
                return null;
            }
            // We can skip the base class if it has metadata.
            const baseClassMeta = reader.getDirectiveMetadata(baseClass);
            if (baseClassMeta !== null) {
                return null;
            }
            // If the base class has a blank constructor we can skip it since it can't be using DI.
            const baseClassConstructorParams = reflector.getConstructorParameters(baseClass.node);
            const newParentClass = readBaseClass$1(baseClass.node, reflector, evaluator);
            if (baseClassConstructorParams !== null && baseClassConstructorParams.length > 0) {
                // This class has a non-trivial constructor, that's an error!
                return getInheritedUndecoratedCtorDiagnostic(node, baseClass, reader);
            }
            else if (baseClassConstructorParams !== null || newParentClass === null) {
                // This class has a trivial constructor, or no constructor + is the
                // top of the inheritance chain, so it's okay.
                return null;
            }
            // Go up the chain and continue
            baseClass = newParentClass;
        }
        return null;
    }
    function getInheritedUndecoratedCtorDiagnostic(node, baseClass, reader) {
        const subclassMeta = reader.getDirectiveMetadata(new Reference$1(node));
        const dirOrComp = subclassMeta.isComponent ? 'Component' : 'Directive';
        const baseClassName = baseClass.debugName;
        return makeDiagnostic(ErrorCode.DIRECTIVE_INHERITS_UNDECORATED_CTOR, node.name, `The ${dirOrComp.toLowerCase()} ${node.name.text} inherits its constructor from ${baseClassName}, ` +
            `but the latter does not have an Angular decorator of its own. Dependency injection will not be able to ` +
            `resolve the parameters of ${baseClassName}'s constructor. Either add a @Directive decorator ` +
            `to ${baseClassName}, or add an explicit constructor to ${node.name.text}.`);
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function compileNgFactoryDefField(metadata) {
        const res = compileFactoryFunction(metadata);
        return { name: 'fac', initializer: res.expression, statements: res.statements, type: res.type };
    }
    function compileDeclareFactory(metadata) {
        const res = compileDeclareFactoryFunction(metadata);
        return { name: 'fac', initializer: res.expression, statements: res.statements, type: res.type };
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Given a class declaration, generate a call to `setClassMetadata` with the Angular metadata
     * present on the class or its member fields. An ngDevMode guard is used to allow the call to be
     * tree-shaken away, as the `setClassMetadata` invocation is only needed for testing purposes.
     *
     * If no such metadata is present, this function returns `null`. Otherwise, the call is returned
     * as a `Statement` for inclusion along with the class.
     */
    function extractClassMetadata(clazz, reflection, isCore, annotateForClosureCompiler) {
        if (!reflection.isClass(clazz)) {
            return null;
        }
        const id = reflection.getAdjacentNameOfClass(clazz);
        // Reflect over the class decorators. If none are present, or those that are aren't from
        // Angular, then return null. Otherwise, turn them into metadata.
        const classDecorators = reflection.getDecoratorsOfDeclaration(clazz);
        if (classDecorators === null) {
            return null;
        }
        const ngClassDecorators = classDecorators.filter(dec => isAngularDecorator$1(dec, isCore))
            .map(decorator => decoratorToMetadata(decorator, annotateForClosureCompiler))
            // Since the `setClassMetadata` call is intended to be emitted after the class
            // declaration, we have to strip references to the existing identifiers or
            // TypeScript might generate invalid code when it emits to JS. In particular
            // this can break when emitting a class to ES5 which has a custom decorator
            // and is referenced inside of its own metadata (see #39509 for more information).
            .map(decorator => removeIdentifierReferences(decorator, id.text));
        if (ngClassDecorators.length === 0) {
            return null;
        }
        const metaDecorators = new WrappedNodeExpr(ts$1.createArrayLiteral(ngClassDecorators));
        // Convert the constructor parameters to metadata, passing null if none are present.
        let metaCtorParameters = null;
        const classCtorParameters = reflection.getConstructorParameters(clazz);
        if (classCtorParameters !== null) {
            const ctorParameters = classCtorParameters.map(param => ctorParameterToMetadata(param, isCore));
            metaCtorParameters = new FunctionExpr([], [
                new ReturnStatement(new LiteralArrayExpr(ctorParameters)),
            ]);
        }
        // Do the same for property decorators.
        let metaPropDecorators = null;
        const classMembers = reflection.getMembersOfClass(clazz).filter(member => !member.isStatic && member.decorators !== null && member.decorators.length > 0);
        const duplicateDecoratedMemberNames = classMembers.map(member => member.name).filter((name, i, arr) => arr.indexOf(name) < i);
        if (duplicateDecoratedMemberNames.length > 0) {
            // This should theoretically never happen, because the only way to have duplicate instance
            // member names is getter/setter pairs and decorators cannot appear in both a getter and the
            // corresponding setter.
            throw new Error(`Duplicate decorated properties found on class '${clazz.name.text}': ` +
                duplicateDecoratedMemberNames.join(', '));
        }
        const decoratedMembers = classMembers.map(member => { var _a; return classMemberToMetadata((_a = member.nameNode) !== null && _a !== void 0 ? _a : member.name, member.decorators, isCore); });
        if (decoratedMembers.length > 0) {
            metaPropDecorators = new WrappedNodeExpr(ts$1.createObjectLiteral(decoratedMembers));
        }
        return {
            type: new WrappedNodeExpr(id),
            decorators: metaDecorators,
            ctorParameters: metaCtorParameters,
            propDecorators: metaPropDecorators,
        };
    }
    /**
     * Convert a reflected constructor parameter to metadata.
     */
    function ctorParameterToMetadata(param, isCore) {
        // Parameters sometimes have a type that can be referenced. If so, then use it, otherwise
        // its type is undefined.
        const type = param.typeValueReference.kind !== 2 /* UNAVAILABLE */ ?
            valueReferenceToExpression(param.typeValueReference) :
            new LiteralExpr(undefined);
        const mapEntries = [
            { key: 'type', value: type, quoted: false },
        ];
        // If the parameter has decorators, include the ones from Angular.
        if (param.decorators !== null) {
            const ngDecorators = param.decorators.filter(dec => isAngularDecorator$1(dec, isCore))
                .map((decorator) => decoratorToMetadata(decorator));
            const value = new WrappedNodeExpr(ts$1.createArrayLiteral(ngDecorators));
            mapEntries.push({ key: 'decorators', value, quoted: false });
        }
        return literalMap(mapEntries);
    }
    /**
     * Convert a reflected class member to metadata.
     */
    function classMemberToMetadata(name, decorators, isCore) {
        const ngDecorators = decorators.filter(dec => isAngularDecorator$1(dec, isCore))
            .map((decorator) => decoratorToMetadata(decorator));
        const decoratorMeta = ts$1.createArrayLiteral(ngDecorators);
        return ts$1.createPropertyAssignment(name, decoratorMeta);
    }
    /**
     * Convert a reflected decorator to metadata.
     */
    function decoratorToMetadata(decorator, wrapFunctionsInParens) {
        if (decorator.identifier === null) {
            throw new Error('Illegal state: synthesized decorator cannot be emitted in class metadata.');
        }
        // Decorators have a type.
        const properties = [
            ts$1.createPropertyAssignment('type', ts$1.getMutableClone(decorator.identifier)),
        ];
        // Sometimes they have arguments.
        if (decorator.args !== null && decorator.args.length > 0) {
            const args = decorator.args.map(arg => {
                const expr = ts$1.getMutableClone(arg);
                return wrapFunctionsInParens ? wrapFunctionExpressionsInParens(expr) : expr;
            });
            properties.push(ts$1.createPropertyAssignment('args', ts$1.createArrayLiteral(args)));
        }
        return ts$1.createObjectLiteral(properties, true);
    }
    /**
     * Whether a given decorator should be treated as an Angular decorator.
     *
     * Either it's used in @angular/core, or it's imported from there.
     */
    function isAngularDecorator$1(decorator, isCore) {
        return isCore || (decorator.import !== null && decorator.import.from === '@angular/core');
    }
    /**
     * Recursively recreates all of the `Identifier` descendant nodes with a particular name inside
     * of an AST node, thus removing any references to them. Useful if a particular node has to be t
     * aken from one place any emitted to another one exactly as it has been written.
     */
    function removeIdentifierReferences(node, name) {
        const result = ts$1.transform(node, [context => root => ts$1.visitNode(root, function walk(current) {
                return ts$1.isIdentifier(current) && current.text === name ?
                    ts$1.createIdentifier(current.text) :
                    ts$1.visitEachChild(current, walk, context);
            })]);
        return result.transformed[0];
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const EMPTY_OBJECT = {};
    const FIELD_DECORATORS = [
        'Input', 'Output', 'ViewChild', 'ViewChildren', 'ContentChild', 'ContentChildren', 'HostBinding',
        'HostListener'
    ];
    const LIFECYCLE_HOOKS = new Set([
        'ngOnChanges', 'ngOnInit', 'ngOnDestroy', 'ngDoCheck', 'ngAfterViewInit', 'ngAfterViewChecked',
        'ngAfterContentInit', 'ngAfterContentChecked'
    ]);
    /**
     * Represents an Angular directive. Components are represented by `ComponentSymbol`, which inherits
     * from this symbol.
     */
    class DirectiveSymbol extends SemanticSymbol {
        constructor(decl, selector, inputs, outputs, exportAs, typeCheckMeta, typeParameters) {
            super(decl);
            this.selector = selector;
            this.inputs = inputs;
            this.outputs = outputs;
            this.exportAs = exportAs;
            this.typeCheckMeta = typeCheckMeta;
            this.typeParameters = typeParameters;
            this.baseClass = null;
        }
        isPublicApiAffected(previousSymbol) {
            // Note: since components and directives have exactly the same items contributing to their
            // public API, it is okay for a directive to change into a component and vice versa without
            // the API being affected.
            if (!(previousSymbol instanceof DirectiveSymbol)) {
                return true;
            }
            // Directives and components have a public API of:
            //  1. Their selector.
            //  2. The binding names of their inputs and outputs; a change in ordering is also considered
            //     to be a change in public API.
            //  3. The list of exportAs names and its ordering.
            return this.selector !== previousSymbol.selector ||
                !isArrayEqual(this.inputs.propertyNames, previousSymbol.inputs.propertyNames) ||
                !isArrayEqual(this.outputs.propertyNames, previousSymbol.outputs.propertyNames) ||
                !isArrayEqual(this.exportAs, previousSymbol.exportAs);
        }
        isTypeCheckApiAffected(previousSymbol) {
            // If the public API of the directive has changed, then so has its type-check API.
            if (this.isPublicApiAffected(previousSymbol)) {
                return true;
            }
            if (!(previousSymbol instanceof DirectiveSymbol)) {
                return true;
            }
            // The type-check block also depends on the class property names, as writes property bindings
            // directly into the backing fields.
            if (!isArrayEqual(Array.from(this.inputs), Array.from(previousSymbol.inputs), isInputMappingEqual) ||
                !isArrayEqual(Array.from(this.outputs), Array.from(previousSymbol.outputs), isInputMappingEqual)) {
                return true;
            }
            // The type parameters of a directive are emitted into the type constructors in the type-check
            // block of a component, so if the type parameters are not considered equal then consider the
            // type-check API of this directive to be affected.
            if (!areTypeParametersEqual(this.typeParameters, previousSymbol.typeParameters)) {
                return true;
            }
            // The type-check metadata is used during TCB code generation, so any changes should invalidate
            // prior type-check files.
            if (!isTypeCheckMetaEqual(this.typeCheckMeta, previousSymbol.typeCheckMeta)) {
                return true;
            }
            // Changing the base class of a directive means that its inputs/outputs etc may have changed,
            // so the type-check block of components that use this directive needs to be regenerated.
            if (!isBaseClassEqual(this.baseClass, previousSymbol.baseClass)) {
                return true;
            }
            return false;
        }
    }
    function isInputMappingEqual(current, previous) {
        return current[0] === previous[0] && current[1] === previous[1];
    }
    function isTypeCheckMetaEqual(current, previous) {
        if (current.hasNgTemplateContextGuard !== previous.hasNgTemplateContextGuard) {
            return false;
        }
        if (current.isGeneric !== previous.isGeneric) {
            // Note: changes in the number of type parameters is also considered in `areTypeParametersEqual`
            // so this check is technically not needed; it is done anyway for completeness in terms of
            // whether the `DirectiveTypeCheckMeta` struct itself compares equal or not.
            return false;
        }
        if (!isArrayEqual(current.ngTemplateGuards, previous.ngTemplateGuards, isTemplateGuardEqual)) {
            return false;
        }
        if (!isSetEqual(current.coercedInputFields, previous.coercedInputFields)) {
            return false;
        }
        if (!isSetEqual(current.restrictedInputFields, previous.restrictedInputFields)) {
            return false;
        }
        if (!isSetEqual(current.stringLiteralInputFields, previous.stringLiteralInputFields)) {
            return false;
        }
        if (!isSetEqual(current.undeclaredInputFields, previous.undeclaredInputFields)) {
            return false;
        }
        return true;
    }
    function isTemplateGuardEqual(current, previous) {
        return current.inputName === previous.inputName && current.type === previous.type;
    }
    function isBaseClassEqual(current, previous) {
        if (current === null || previous === null) {
            return current === previous;
        }
        return isSymbolEqual(current, previous);
    }
    class DirectiveDecoratorHandler {
        constructor(reflector, evaluator, metaRegistry, scopeRegistry, metaReader, injectableRegistry, isCore, semanticDepGraphUpdater, annotateForClosureCompiler, compileUndecoratedClassesWithAngularFeatures, perf) {
            this.reflector = reflector;
            this.evaluator = evaluator;
            this.metaRegistry = metaRegistry;
            this.scopeRegistry = scopeRegistry;
            this.metaReader = metaReader;
            this.injectableRegistry = injectableRegistry;
            this.isCore = isCore;
            this.semanticDepGraphUpdater = semanticDepGraphUpdater;
            this.annotateForClosureCompiler = annotateForClosureCompiler;
            this.compileUndecoratedClassesWithAngularFeatures = compileUndecoratedClassesWithAngularFeatures;
            this.perf = perf;
            this.precedence = HandlerPrecedence.PRIMARY;
            this.name = DirectiveDecoratorHandler.name;
        }
        detect(node, decorators) {
            // If a class is undecorated but uses Angular features, we detect it as an
            // abstract directive. This is an unsupported pattern as of v10, but we want
            // to still detect these patterns so that we can report diagnostics, or compile
            // them for backwards compatibility in ngcc.
            if (!decorators) {
                const angularField = this.findClassFieldWithAngularFeatures(node);
                return angularField ? { trigger: angularField.node, decorator: null, metadata: null } :
                    undefined;
            }
            else {
                const decorator = findAngularDecorator(decorators, 'Directive', this.isCore);
                return decorator ? { trigger: decorator.node, decorator, metadata: decorator } : undefined;
            }
        }
        analyze(node, decorator, flags = HandlerFlags.NONE) {
            // Skip processing of the class declaration if compilation of undecorated classes
            // with Angular features is disabled. Previously in ngtsc, such classes have always
            // been processed, but we want to enforce a consistent decorator mental model.
            // See: https://v9.angular.io/guide/migration-undecorated-classes.
            if (this.compileUndecoratedClassesWithAngularFeatures === false && decorator === null) {
                return { diagnostics: [getUndecoratedClassWithAngularFeaturesDiagnostic(node)] };
            }
            this.perf.eventCount(PerfEvent.AnalyzeDirective);
            const directiveResult = extractDirectiveMetadata(node, decorator, this.reflector, this.evaluator, this.isCore, flags, this.annotateForClosureCompiler);
            if (directiveResult === undefined) {
                return {};
            }
            const analysis = directiveResult.metadata;
            let providersRequiringFactory = null;
            if (directiveResult !== undefined && directiveResult.decorator.has('providers')) {
                providersRequiringFactory = resolveProvidersRequiringFactory(directiveResult.decorator.get('providers'), this.reflector, this.evaluator);
            }
            return {
                analysis: {
                    inputs: directiveResult.inputs,
                    outputs: directiveResult.outputs,
                    meta: analysis,
                    classMetadata: extractClassMetadata(node, this.reflector, this.isCore, this.annotateForClosureCompiler),
                    baseClass: readBaseClass$1(node, this.reflector, this.evaluator),
                    typeCheckMeta: extractDirectiveTypeCheckMeta(node, directiveResult.inputs, this.reflector),
                    providersRequiringFactory,
                    isPoisoned: false,
                    isStructural: directiveResult.isStructural,
                }
            };
        }
        symbol(node, analysis) {
            const typeParameters = extractSemanticTypeParameters(node);
            return new DirectiveSymbol(node, analysis.meta.selector, analysis.inputs, analysis.outputs, analysis.meta.exportAs, analysis.typeCheckMeta, typeParameters);
        }
        register(node, analysis) {
            // Register this directive's information with the `MetadataRegistry`. This ensures that
            // the information about the directive is available during the compile() phase.
            const ref = new Reference$1(node);
            this.metaRegistry.registerDirectiveMetadata(Object.assign(Object.assign({ type: MetaType.Directive, ref, name: node.name.text, selector: analysis.meta.selector, exportAs: analysis.meta.exportAs, inputs: analysis.inputs, outputs: analysis.outputs, queries: analysis.meta.queries.map(query => query.propertyName), isComponent: false, baseClass: analysis.baseClass }, analysis.typeCheckMeta), { isPoisoned: analysis.isPoisoned, isStructural: analysis.isStructural }));
            this.injectableRegistry.registerInjectable(node);
        }
        resolve(node, analysis, symbol) {
            if (this.semanticDepGraphUpdater !== null && analysis.baseClass instanceof Reference$1) {
                symbol.baseClass = this.semanticDepGraphUpdater.getSymbol(analysis.baseClass.node);
            }
            const diagnostics = [];
            if (analysis.providersRequiringFactory !== null &&
                analysis.meta.providers instanceof WrappedNodeExpr) {
                const providerDiagnostics = getProviderDiagnostics(analysis.providersRequiringFactory, analysis.meta.providers.node, this.injectableRegistry);
                diagnostics.push(...providerDiagnostics);
            }
            const directiveDiagnostics = getDirectiveDiagnostics(node, this.metaReader, this.evaluator, this.reflector, this.scopeRegistry, 'Directive');
            if (directiveDiagnostics !== null) {
                diagnostics.push(...directiveDiagnostics);
            }
            return { diagnostics: diagnostics.length > 0 ? diagnostics : undefined };
        }
        compileFull(node, analysis, resolution, pool) {
            const fac = compileNgFactoryDefField(toFactoryMetadata(analysis.meta, FactoryTarget.Directive));
            const def = compileDirectiveFromMetadata(analysis.meta, pool, makeBindingParser());
            const classMetadata = analysis.classMetadata !== null ?
                compileClassMetadata(analysis.classMetadata).toStmt() :
                null;
            return compileResults(fac, def, classMetadata, 'dir');
        }
        compilePartial(node, analysis, resolution) {
            const fac = compileDeclareFactory(toFactoryMetadata(analysis.meta, FactoryTarget.Directive));
            const def = compileDeclareDirectiveFromMetadata(analysis.meta);
            const classMetadata = analysis.classMetadata !== null ?
                compileDeclareClassMetadata(analysis.classMetadata).toStmt() :
                null;
            return compileResults(fac, def, classMetadata, 'dir');
        }
        /**
         * Checks if a given class uses Angular features and returns the TypeScript node
         * that indicated the usage. Classes are considered using Angular features if they
         * contain class members that are either decorated with a known Angular decorator,
         * or if they correspond to a known Angular lifecycle hook.
         */
        findClassFieldWithAngularFeatures(node) {
            return this.reflector.getMembersOfClass(node).find(member => {
                if (!member.isStatic && member.kind === ClassMemberKind.Method &&
                    LIFECYCLE_HOOKS.has(member.name)) {
                    return true;
                }
                if (member.decorators) {
                    return member.decorators.some(decorator => FIELD_DECORATORS.some(decoratorName => isAngularDecorator(decorator, decoratorName, this.isCore)));
                }
                return false;
            });
        }
    }
    /**
     * Helper function to extract metadata from a `Directive` or `Component`. `Directive`s without a
     * selector are allowed to be used for abstract base classes. These abstract directives should not
     * appear in the declarations of an `NgModule` and additional verification is done when processing
     * the module.
     */
    function extractDirectiveMetadata(clazz, decorator, reflector, evaluator, isCore, flags, annotateForClosureCompiler, defaultSelector = null) {
        let directive;
        if (decorator === null || decorator.args === null || decorator.args.length === 0) {
            directive = new Map();
        }
        else if (decorator.args.length !== 1) {
            throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, Decorator.nodeForError(decorator), `Incorrect number of arguments to @${decorator.name} decorator`);
        }
        else {
            const meta = unwrapExpression(decorator.args[0]);
            if (!ts$1.isObjectLiteralExpression(meta)) {
                throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARG_NOT_LITERAL, meta, `@${decorator.name} argument must be an object literal`);
            }
            directive = reflectObjectLiteral(meta);
        }
        if (directive.has('jit')) {
            // The only allowed value is true, so there's no need to expand further.
            return undefined;
        }
        const members = reflector.getMembersOfClass(clazz);
        // Precompute a list of ts.ClassElements that have decorators. This includes things like @Input,
        // @Output, @HostBinding, etc.
        const decoratedElements = members.filter(member => !member.isStatic && member.decorators !== null);
        const coreModule = isCore ? undefined : '@angular/core';
        // Construct the map of inputs both from the @Directive/@Component
        // decorator, and the decorated
        // fields.
        const inputsFromMeta = parseFieldToPropertyMapping(directive, 'inputs', evaluator);
        const inputsFromFields = parseDecoratedFields(filterToMembersWithDecorator(decoratedElements, 'Input', coreModule), evaluator, resolveInput);
        // And outputs.
        const outputsFromMeta = parseFieldToPropertyMapping(directive, 'outputs', evaluator);
        const outputsFromFields = parseDecoratedFields(filterToMembersWithDecorator(decoratedElements, 'Output', coreModule), evaluator, resolveOutput);
        // Construct the list of queries.
        const contentChildFromFields = queriesFromFields(filterToMembersWithDecorator(decoratedElements, 'ContentChild', coreModule), reflector, evaluator);
        const contentChildrenFromFields = queriesFromFields(filterToMembersWithDecorator(decoratedElements, 'ContentChildren', coreModule), reflector, evaluator);
        const queries = [...contentChildFromFields, ...contentChildrenFromFields];
        // Construct the list of view queries.
        const viewChildFromFields = queriesFromFields(filterToMembersWithDecorator(decoratedElements, 'ViewChild', coreModule), reflector, evaluator);
        const viewChildrenFromFields = queriesFromFields(filterToMembersWithDecorator(decoratedElements, 'ViewChildren', coreModule), reflector, evaluator);
        const viewQueries = [...viewChildFromFields, ...viewChildrenFromFields];
        if (directive.has('queries')) {
            const queriesFromDecorator = extractQueriesFromDecorator(directive.get('queries'), reflector, evaluator, isCore);
            queries.push(...queriesFromDecorator.content);
            viewQueries.push(...queriesFromDecorator.view);
        }
        // Parse the selector.
        let selector = defaultSelector;
        if (directive.has('selector')) {
            const expr = directive.get('selector');
            const resolved = evaluator.evaluate(expr);
            if (typeof resolved !== 'string') {
                throw createValueHasWrongTypeError(expr, resolved, `selector must be a string`);
            }
            // use default selector in case selector is an empty string
            selector = resolved === '' ? defaultSelector : resolved;
            if (!selector) {
                throw new FatalDiagnosticError(ErrorCode.DIRECTIVE_MISSING_SELECTOR, expr, `Directive ${clazz.name.text} has no selector, please add it!`);
            }
        }
        const host = extractHostBindings$1(decoratedElements, evaluator, coreModule, directive);
        const providers = directive.has('providers') ?
            new WrappedNodeExpr(annotateForClosureCompiler ?
                wrapFunctionExpressionsInParens(directive.get('providers')) :
                directive.get('providers')) :
            null;
        // Determine if `ngOnChanges` is a lifecycle hook defined on the component.
        const usesOnChanges = members.some(member => !member.isStatic && member.kind === ClassMemberKind.Method &&
            member.name === 'ngOnChanges');
        // Parse exportAs.
        let exportAs = null;
        if (directive.has('exportAs')) {
            const expr = directive.get('exportAs');
            const resolved = evaluator.evaluate(expr);
            if (typeof resolved !== 'string') {
                throw createValueHasWrongTypeError(expr, resolved, `exportAs must be a string`);
            }
            exportAs = resolved.split(',').map(part => part.trim());
        }
        const rawCtorDeps = getConstructorDependencies(clazz, reflector, isCore);
        // Non-abstract directives (those with a selector) require valid constructor dependencies, whereas
        // abstract directives are allowed to have invalid dependencies, given that a subclass may call
        // the constructor explicitly.
        const ctorDeps = selector !== null ? validateConstructorDependencies(clazz, rawCtorDeps) :
            unwrapConstructorDependencies(rawCtorDeps);
        // Structural directives must have a `TemplateRef` dependency.
        const isStructural = ctorDeps !== null && ctorDeps !== 'invalid' &&
            ctorDeps.some(dep => (dep.token instanceof ExternalExpr) &&
                dep.token.value.moduleName === '@angular/core' &&
                dep.token.value.name === 'TemplateRef');
        // Detect if the component inherits from another class
        const usesInheritance = reflector.hasBaseClass(clazz);
        const type = wrapTypeReference(reflector, clazz);
        const internalType = new WrappedNodeExpr(reflector.getInternalNameOfClass(clazz));
        const inputs = ClassPropertyMapping.fromMappedObject(Object.assign(Object.assign({}, inputsFromMeta), inputsFromFields));
        const outputs = ClassPropertyMapping.fromMappedObject(Object.assign(Object.assign({}, outputsFromMeta), outputsFromFields));
        const metadata = {
            name: clazz.name.text,
            deps: ctorDeps,
            host,
            lifecycle: {
                usesOnChanges,
            },
            inputs: inputs.toJointMappedObject(),
            outputs: outputs.toDirectMappedObject(),
            queries,
            viewQueries,
            selector,
            fullInheritance: !!(flags & HandlerFlags.FULL_INHERITANCE),
            type,
            internalType,
            typeArgumentCount: reflector.getGenericArityOfClass(clazz) || 0,
            typeSourceSpan: createSourceSpan(clazz.name),
            usesInheritance,
            exportAs,
            providers
        };
        return {
            decorator: directive,
            metadata,
            inputs,
            outputs,
            isStructural,
        };
    }
    function extractQueryMetadata(exprNode, name, args, propertyName, reflector, evaluator) {
        var _a;
        if (args.length === 0) {
            throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, exprNode, `@${name} must have arguments`);
        }
        const first = name === 'ViewChild' || name === 'ContentChild';
        const node = (_a = tryUnwrapForwardRef(args[0], reflector)) !== null && _a !== void 0 ? _a : args[0];
        const arg = evaluator.evaluate(node);
        /** Whether or not this query should collect only static results (see view/api.ts)  */
        let isStatic = false;
        // Extract the predicate
        let predicate = null;
        if (arg instanceof Reference$1 || arg instanceof DynamicValue) {
            // References and predicates that could not be evaluated statically are emitted as is.
            predicate = new WrappedNodeExpr(node);
        }
        else if (typeof arg === 'string') {
            predicate = [arg];
        }
        else if (isStringArrayOrDie(arg, `@${name} predicate`, node)) {
            predicate = arg;
        }
        else {
            throw createValueHasWrongTypeError(node, arg, `@${name} predicate cannot be interpreted`);
        }
        // Extract the read and descendants options.
        let read = null;
        // The default value for descendants is true for every decorator except @ContentChildren.
        let descendants = name !== 'ContentChildren';
        let emitDistinctChangesOnly = emitDistinctChangesOnlyDefaultValue;
        if (args.length === 2) {
            const optionsExpr = unwrapExpression(args[1]);
            if (!ts$1.isObjectLiteralExpression(optionsExpr)) {
                throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARG_NOT_LITERAL, optionsExpr, `@${name} options must be an object literal`);
            }
            const options = reflectObjectLiteral(optionsExpr);
            if (options.has('read')) {
                read = new WrappedNodeExpr(options.get('read'));
            }
            if (options.has('descendants')) {
                const descendantsExpr = options.get('descendants');
                const descendantsValue = evaluator.evaluate(descendantsExpr);
                if (typeof descendantsValue !== 'boolean') {
                    throw createValueHasWrongTypeError(descendantsExpr, descendantsValue, `@${name} options.descendants must be a boolean`);
                }
                descendants = descendantsValue;
            }
            if (options.has('emitDistinctChangesOnly')) {
                const emitDistinctChangesOnlyExpr = options.get('emitDistinctChangesOnly');
                const emitDistinctChangesOnlyValue = evaluator.evaluate(emitDistinctChangesOnlyExpr);
                if (typeof emitDistinctChangesOnlyValue !== 'boolean') {
                    throw createValueHasWrongTypeError(emitDistinctChangesOnlyExpr, emitDistinctChangesOnlyValue, `@${name} options.emitDistinctChangesOnly must be a boolean`);
                }
                emitDistinctChangesOnly = emitDistinctChangesOnlyValue;
            }
            if (options.has('static')) {
                const staticValue = evaluator.evaluate(options.get('static'));
                if (typeof staticValue !== 'boolean') {
                    throw createValueHasWrongTypeError(node, staticValue, `@${name} options.static must be a boolean`);
                }
                isStatic = staticValue;
            }
        }
        else if (args.length > 2) {
            // Too many arguments.
            throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, node, `@${name} has too many arguments`);
        }
        return {
            propertyName,
            predicate,
            first,
            descendants,
            read,
            static: isStatic,
            emitDistinctChangesOnly,
        };
    }
    function extractQueriesFromDecorator(queryData, reflector, evaluator, isCore) {
        const content = [], view = [];
        if (!ts$1.isObjectLiteralExpression(queryData)) {
            throw new FatalDiagnosticError(ErrorCode.VALUE_HAS_WRONG_TYPE, queryData, 'Decorator queries metadata must be an object literal');
        }
        reflectObjectLiteral(queryData).forEach((queryExpr, propertyName) => {
            queryExpr = unwrapExpression(queryExpr);
            if (!ts$1.isNewExpression(queryExpr)) {
                throw new FatalDiagnosticError(ErrorCode.VALUE_HAS_WRONG_TYPE, queryData, 'Decorator query metadata must be an instance of a query type');
            }
            const queryType = ts$1.isPropertyAccessExpression(queryExpr.expression) ?
                queryExpr.expression.name :
                queryExpr.expression;
            if (!ts$1.isIdentifier(queryType)) {
                throw new FatalDiagnosticError(ErrorCode.VALUE_HAS_WRONG_TYPE, queryData, 'Decorator query metadata must be an instance of a query type');
            }
            const type = reflector.getImportOfIdentifier(queryType);
            if (type === null || (!isCore && type.from !== '@angular/core') ||
                !QUERY_TYPES.has(type.name)) {
                throw new FatalDiagnosticError(ErrorCode.VALUE_HAS_WRONG_TYPE, queryData, 'Decorator query metadata must be an instance of a query type');
            }
            const query = extractQueryMetadata(queryExpr, type.name, queryExpr.arguments || [], propertyName, reflector, evaluator);
            if (type.name.startsWith('Content')) {
                content.push(query);
            }
            else {
                view.push(query);
            }
        });
        return { content, view };
    }
    function isStringArrayOrDie(value, name, node) {
        if (!Array.isArray(value)) {
            return false;
        }
        for (let i = 0; i < value.length; i++) {
            if (typeof value[i] !== 'string') {
                throw createValueHasWrongTypeError(node, value[i], `Failed to resolve ${name} at position ${i} to a string`);
            }
        }
        return true;
    }
    function parseFieldArrayValue(directive, field, evaluator) {
        if (!directive.has(field)) {
            return null;
        }
        // Resolve the field of interest from the directive metadata to a string[].
        const expression = directive.get(field);
        const value = evaluator.evaluate(expression);
        if (!isStringArrayOrDie(value, field, expression)) {
            throw createValueHasWrongTypeError(expression, value, `Failed to resolve @Directive.${field} to a string array`);
        }
        return value;
    }
    /**
     * Interpret property mapping fields on the decorator (e.g. inputs or outputs) and return the
     * correctly shaped metadata object.
     */
    function parseFieldToPropertyMapping(directive, field, evaluator) {
        const metaValues = parseFieldArrayValue(directive, field, evaluator);
        if (!metaValues) {
            return EMPTY_OBJECT;
        }
        return metaValues.reduce((results, value) => {
            // Either the value is 'field' or 'field: property'. In the first case, `property` will
            // be undefined, in which case the field name should also be used as the property name.
            const [field, property] = value.split(':', 2).map(str => str.trim());
            results[field] = property || field;
            return results;
        }, {});
    }
    /**
     * Parse property decorators (e.g. `Input` or `Output`) and return the correctly shaped metadata
     * object.
     */
    function parseDecoratedFields(fields, evaluator, mapValueResolver) {
        return fields.reduce((results, field) => {
            const fieldName = field.member.name;
            field.decorators.forEach(decorator => {
                // The decorator either doesn't have an argument (@Input()) in which case the property
                // name is used, or it has one argument (@Output('named')).
                if (decorator.args == null || decorator.args.length === 0) {
                    results[fieldName] = fieldName;
                }
                else if (decorator.args.length === 1) {
                    const property = evaluator.evaluate(decorator.args[0]);
                    if (typeof property !== 'string') {
                        throw createValueHasWrongTypeError(Decorator.nodeForError(decorator), property, `@${decorator.name} decorator argument must resolve to a string`);
                    }
                    results[fieldName] = mapValueResolver(property, fieldName);
                }
                else {
                    // Too many arguments.
                    throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, Decorator.nodeForError(decorator), `@${decorator.name} can have at most one argument, got ${decorator.args.length} argument(s)`);
                }
            });
            return results;
        }, {});
    }
    function resolveInput(publicName, internalName) {
        return [publicName, internalName];
    }
    function resolveOutput(publicName, internalName) {
        return publicName;
    }
    function queriesFromFields(fields, reflector, evaluator) {
        return fields.map(({ member, decorators }) => {
            const decorator = decorators[0];
            const node = member.node || Decorator.nodeForError(decorator);
            // Throw in case of `@Input() @ContentChild('foo') foo: any`, which is not supported in Ivy
            if (member.decorators.some(v => v.name === 'Input')) {
                throw new FatalDiagnosticError(ErrorCode.DECORATOR_COLLISION, node, 'Cannot combine @Input decorators with query decorators');
            }
            if (decorators.length !== 1) {
                throw new FatalDiagnosticError(ErrorCode.DECORATOR_COLLISION, node, 'Cannot have multiple query decorators on the same class member');
            }
            else if (!isPropertyTypeMember(member)) {
                throw new FatalDiagnosticError(ErrorCode.DECORATOR_UNEXPECTED, node, 'Query decorator must go on a property-type member');
            }
            return extractQueryMetadata(node, decorator.name, decorator.args || [], member.name, reflector, evaluator);
        });
    }
    function isPropertyTypeMember(member) {
        return member.kind === ClassMemberKind.Getter || member.kind === ClassMemberKind.Setter ||
            member.kind === ClassMemberKind.Property;
    }
    function evaluateHostExpressionBindings(hostExpr, evaluator) {
        const hostMetaMap = evaluator.evaluate(hostExpr);
        if (!(hostMetaMap instanceof Map)) {
            throw createValueHasWrongTypeError(hostExpr, hostMetaMap, `Decorator host metadata must be an object`);
        }
        const hostMetadata = {};
        hostMetaMap.forEach((value, key) => {
            // Resolve Enum references to their declared value.
            if (value instanceof EnumValue) {
                value = value.resolved;
            }
            if (typeof key !== 'string') {
                throw createValueHasWrongTypeError(hostExpr, key, `Decorator host metadata must be a string -> string object, but found unparseable key`);
            }
            if (typeof value == 'string') {
                hostMetadata[key] = value;
            }
            else if (value instanceof DynamicValue) {
                hostMetadata[key] = new WrappedNodeExpr(value.node);
            }
            else {
                throw createValueHasWrongTypeError(hostExpr, value, `Decorator host metadata must be a string -> string object, but found unparseable value`);
            }
        });
        const bindings = parseHostBindings(hostMetadata);
        const errors = verifyHostBindings(bindings, createSourceSpan(hostExpr));
        if (errors.length > 0) {
            throw new FatalDiagnosticError(
            // TODO: provide more granular diagnostic and output specific host expression that
            // triggered an error instead of the whole host object.
            ErrorCode.HOST_BINDING_PARSE_ERROR, hostExpr, errors.map((error) => error.msg).join('\n'));
        }
        return bindings;
    }
    function extractHostBindings$1(members, evaluator, coreModule, metadata) {
        let bindings;
        if (metadata && metadata.has('host')) {
            bindings = evaluateHostExpressionBindings(metadata.get('host'), evaluator);
        }
        else {
            bindings = parseHostBindings({});
        }
        filterToMembersWithDecorator(members, 'HostBinding', coreModule)
            .forEach(({ member, decorators }) => {
            decorators.forEach(decorator => {
                let hostPropertyName = member.name;
                if (decorator.args !== null && decorator.args.length > 0) {
                    if (decorator.args.length !== 1) {
                        throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, Decorator.nodeForError(decorator), `@HostBinding can have at most one argument, got ${decorator.args.length} argument(s)`);
                    }
                    const resolved = evaluator.evaluate(decorator.args[0]);
                    if (typeof resolved !== 'string') {
                        throw createValueHasWrongTypeError(Decorator.nodeForError(decorator), resolved, `@HostBinding's argument must be a string`);
                    }
                    hostPropertyName = resolved;
                }
                // Since this is a decorator, we know that the value is a class member. Always access it
                // through `this` so that further down the line it can't be confused for a literal value
                // (e.g. if there's a property called `true`). There is no size penalty, because all
                // values (except literals) are converted to `ctx.propName` eventually.
                bindings.properties[hostPropertyName] = getSafePropertyAccessString('this', member.name);
            });
        });
        filterToMembersWithDecorator(members, 'HostListener', coreModule)
            .forEach(({ member, decorators }) => {
            decorators.forEach(decorator => {
                let eventName = member.name;
                let args = [];
                if (decorator.args !== null && decorator.args.length > 0) {
                    if (decorator.args.length > 2) {
                        throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, decorator.args[2], `@HostListener can have at most two arguments`);
                    }
                    const resolved = evaluator.evaluate(decorator.args[0]);
                    if (typeof resolved !== 'string') {
                        throw createValueHasWrongTypeError(decorator.args[0], resolved, `@HostListener's event name argument must be a string`);
                    }
                    eventName = resolved;
                    if (decorator.args.length === 2) {
                        const expression = decorator.args[1];
                        const resolvedArgs = evaluator.evaluate(decorator.args[1]);
                        if (!isStringArrayOrDie(resolvedArgs, '@HostListener.args', expression)) {
                            throw createValueHasWrongTypeError(decorator.args[1], resolvedArgs, `@HostListener's second argument must be a string array`);
                        }
                        args = resolvedArgs;
                    }
                }
                bindings.listeners[eventName] = `${member.name}(${args.join(',')})`;
            });
        });
        return bindings;
    }
    const QUERY_TYPES = new Set([
        'ContentChild',
        'ContentChildren',
        'ViewChild',
        'ViewChildren',
    ]);

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Represents an Angular NgModule.
     */
    class NgModuleSymbol extends SemanticSymbol {
        constructor() {
            super(...arguments);
            this.remotelyScopedComponents = [];
        }
        isPublicApiAffected(previousSymbol) {
            if (!(previousSymbol instanceof NgModuleSymbol)) {
                return true;
            }
            // NgModules don't have a public API that could affect emit of Angular decorated classes.
            return false;
        }
        isEmitAffected(previousSymbol) {
            if (!(previousSymbol instanceof NgModuleSymbol)) {
                return true;
            }
            // compare our remotelyScopedComponents to the previous symbol
            if (previousSymbol.remotelyScopedComponents.length !== this.remotelyScopedComponents.length) {
                return true;
            }
            for (const currEntry of this.remotelyScopedComponents) {
                const prevEntry = previousSymbol.remotelyScopedComponents.find(prevEntry => {
                    return isSymbolEqual(prevEntry.component, currEntry.component);
                });
                if (prevEntry === undefined) {
                    // No previous entry was found, which means that this component became remotely scoped and
                    // hence this NgModule needs to be re-emitted.
                    return true;
                }
                if (!isArrayEqual(currEntry.usedDirectives, prevEntry.usedDirectives, isReferenceEqual)) {
                    // The list of used directives or their order has changed. Since this NgModule emits
                    // references to the list of used directives, it should be re-emitted to update this list.
                    // Note: the NgModule does not have to be re-emitted when any of the directives has had
                    // their public API changed, as the NgModule only emits a reference to the symbol by its
                    // name. Therefore, testing for symbol equality is sufficient.
                    return true;
                }
                if (!isArrayEqual(currEntry.usedPipes, prevEntry.usedPipes, isReferenceEqual)) {
                    return true;
                }
            }
            return false;
        }
        isTypeCheckApiAffected(previousSymbol) {
            if (!(previousSymbol instanceof NgModuleSymbol)) {
                return true;
            }
            return false;
        }
        addRemotelyScopedComponent(component, usedDirectives, usedPipes) {
            this.remotelyScopedComponents.push({ component, usedDirectives, usedPipes });
        }
    }
    /**
     * Compiles @NgModule annotations to ngModuleDef fields.
     */
    class NgModuleDecoratorHandler {
        constructor(reflector, evaluator, metaReader, metaRegistry, scopeRegistry, referencesRegistry, isCore, routeAnalyzer, refEmitter, factoryTracker, annotateForClosureCompiler, injectableRegistry, perf, localeId) {
            this.reflector = reflector;
            this.evaluator = evaluator;
            this.metaReader = metaReader;
            this.metaRegistry = metaRegistry;
            this.scopeRegistry = scopeRegistry;
            this.referencesRegistry = referencesRegistry;
            this.isCore = isCore;
            this.routeAnalyzer = routeAnalyzer;
            this.refEmitter = refEmitter;
            this.factoryTracker = factoryTracker;
            this.annotateForClosureCompiler = annotateForClosureCompiler;
            this.injectableRegistry = injectableRegistry;
            this.perf = perf;
            this.localeId = localeId;
            this.precedence = HandlerPrecedence.PRIMARY;
            this.name = NgModuleDecoratorHandler.name;
        }
        detect(node, decorators) {
            if (!decorators) {
                return undefined;
            }
            const decorator = findAngularDecorator(decorators, 'NgModule', this.isCore);
            if (decorator !== undefined) {
                return {
                    trigger: decorator.node,
                    decorator: decorator,
                    metadata: decorator,
                };
            }
            else {
                return undefined;
            }
        }
        analyze(node, decorator) {
            this.perf.eventCount(PerfEvent.AnalyzeNgModule);
            const name = node.name.text;
            if (decorator.args === null || decorator.args.length > 1) {
                throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, Decorator.nodeForError(decorator), `Incorrect number of arguments to @NgModule decorator`);
            }
            // @NgModule can be invoked without arguments. In case it is, pretend as if a blank object
            // literal was specified. This simplifies the code below.
            const meta = decorator.args.length === 1 ? unwrapExpression(decorator.args[0]) :
                ts$1.createObjectLiteral([]);
            if (!ts$1.isObjectLiteralExpression(meta)) {
                throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARG_NOT_LITERAL, meta, '@NgModule argument must be an object literal');
            }
            const ngModule = reflectObjectLiteral(meta);
            if (ngModule.has('jit')) {
                // The only allowed value is true, so there's no need to expand further.
                return {};
            }
            const moduleResolvers = combineResolvers([
                ref => this._extractModuleFromModuleWithProvidersFn(ref.node),
                forwardRefResolver,
            ]);
            const diagnostics = [];
            // Extract the module declarations, imports, and exports.
            let declarationRefs = [];
            let rawDeclarations = null;
            if (ngModule.has('declarations')) {
                rawDeclarations = ngModule.get('declarations');
                const declarationMeta = this.evaluator.evaluate(rawDeclarations, forwardRefResolver);
                declarationRefs =
                    this.resolveTypeList(rawDeclarations, declarationMeta, name, 'declarations');
                // Look through the declarations to make sure they're all a part of the current compilation.
                for (const ref of declarationRefs) {
                    if (ref.node.getSourceFile().isDeclarationFile) {
                        const errorNode = ref.getOriginForDiagnostics(rawDeclarations);
                        diagnostics.push(makeDiagnostic(ErrorCode.NGMODULE_INVALID_DECLARATION, errorNode, `Cannot declare '${ref.node.name
                        .text}' in an NgModule as it's not a part of the current compilation.`, [makeRelatedInformation(ref.node.name, `'${ref.node.name.text}' is declared here.`)]));
                    }
                }
            }
            if (diagnostics.length > 0) {
                return { diagnostics };
            }
            let importRefs = [];
            let rawImports = null;
            if (ngModule.has('imports')) {
                rawImports = ngModule.get('imports');
                const importsMeta = this.evaluator.evaluate(rawImports, moduleResolvers);
                importRefs = this.resolveTypeList(rawImports, importsMeta, name, 'imports');
            }
            let exportRefs = [];
            let rawExports = null;
            if (ngModule.has('exports')) {
                rawExports = ngModule.get('exports');
                const exportsMeta = this.evaluator.evaluate(rawExports, moduleResolvers);
                exportRefs = this.resolveTypeList(rawExports, exportsMeta, name, 'exports');
                this.referencesRegistry.add(node, ...exportRefs);
            }
            let bootstrapRefs = [];
            if (ngModule.has('bootstrap')) {
                const expr = ngModule.get('bootstrap');
                const bootstrapMeta = this.evaluator.evaluate(expr, forwardRefResolver);
                bootstrapRefs = this.resolveTypeList(expr, bootstrapMeta, name, 'bootstrap');
            }
            const schemas = [];
            if (ngModule.has('schemas')) {
                const rawExpr = ngModule.get('schemas');
                const result = this.evaluator.evaluate(rawExpr);
                if (!Array.isArray(result)) {
                    throw createValueHasWrongTypeError(rawExpr, result, `NgModule.schemas must be an array`);
                }
                for (const schemaRef of result) {
                    if (!(schemaRef instanceof Reference$1)) {
                        throw createValueHasWrongTypeError(rawExpr, result, 'NgModule.schemas must be an array of schemas');
                    }
                    const id = schemaRef.getIdentityIn(schemaRef.node.getSourceFile());
                    if (id === null || schemaRef.ownedByModuleGuess !== '@angular/core') {
                        throw createValueHasWrongTypeError(rawExpr, result, 'NgModule.schemas must be an array of schemas');
                    }
                    // Since `id` is the `ts.Identifer` within the schema ref's declaration file, it's safe to
                    // use `id.text` here to figure out which schema is in use. Even if the actual reference was
                    // renamed when the user imported it, these names will match.
                    switch (id.text) {
                        case 'CUSTOM_ELEMENTS_SCHEMA':
                            schemas.push(CUSTOM_ELEMENTS_SCHEMA);
                            break;
                        case 'NO_ERRORS_SCHEMA':
                            schemas.push(NO_ERRORS_SCHEMA);
                            break;
                        default:
                            throw createValueHasWrongTypeError(rawExpr, schemaRef, `'${schemaRef.debugName}' is not a valid NgModule schema`);
                    }
                }
            }
            const id = ngModule.has('id') ? new WrappedNodeExpr(ngModule.get('id')) : null;
            const valueContext = node.getSourceFile();
            let typeContext = valueContext;
            const typeNode = this.reflector.getDtsDeclaration(node);
            if (typeNode !== null) {
                typeContext = typeNode.getSourceFile();
            }
            const bootstrap = bootstrapRefs.map(bootstrap => this._toR3Reference(bootstrap, valueContext, typeContext));
            const declarations = declarationRefs.map(decl => this._toR3Reference(decl, valueContext, typeContext));
            const imports = importRefs.map(imp => this._toR3Reference(imp, valueContext, typeContext));
            const exports = exportRefs.map(exp => this._toR3Reference(exp, valueContext, typeContext));
            const isForwardReference = (ref) => isExpressionForwardReference(ref.value, node.name, valueContext);
            const containsForwardDecls = bootstrap.some(isForwardReference) ||
                declarations.some(isForwardReference) || imports.some(isForwardReference) ||
                exports.some(isForwardReference);
            const type = wrapTypeReference(this.reflector, node);
            const internalType = new WrappedNodeExpr(this.reflector.getInternalNameOfClass(node));
            const adjacentType = new WrappedNodeExpr(this.reflector.getAdjacentNameOfClass(node));
            const ngModuleMetadata = {
                type,
                internalType,
                adjacentType,
                bootstrap,
                declarations,
                exports,
                imports,
                containsForwardDecls,
                id,
                emitInline: false,
                // TODO: to be implemented as a part of FW-1004.
                schemas: [],
            };
            const rawProviders = ngModule.has('providers') ? ngModule.get('providers') : null;
            const wrapperProviders = rawProviders !== null ?
                new WrappedNodeExpr(this.annotateForClosureCompiler ? wrapFunctionExpressionsInParens(rawProviders) :
                    rawProviders) :
                null;
            // At this point, only add the module's imports as the injectors' imports. Any exported modules
            // are added during `resolve`, as we need scope information to be able to filter out directives
            // and pipes from the module exports.
            const injectorImports = [];
            if (ngModule.has('imports')) {
                injectorImports.push(new WrappedNodeExpr(ngModule.get('imports')));
            }
            if (this.routeAnalyzer !== null) {
                this.routeAnalyzer.add(node.getSourceFile(), name, rawImports, rawExports, rawProviders);
            }
            const injectorMetadata = {
                name,
                type,
                internalType,
                providers: wrapperProviders,
                imports: injectorImports,
            };
            const factoryMetadata = {
                name,
                type,
                internalType,
                typeArgumentCount: 0,
                deps: getValidConstructorDependencies(node, this.reflector, this.isCore),
                target: FactoryTarget.NgModule,
            };
            return {
                analysis: {
                    id,
                    schemas,
                    mod: ngModuleMetadata,
                    inj: injectorMetadata,
                    fac: factoryMetadata,
                    declarations: declarationRefs,
                    rawDeclarations,
                    imports: importRefs,
                    exports: exportRefs,
                    providers: rawProviders,
                    providersRequiringFactory: rawProviders ?
                        resolveProvidersRequiringFactory(rawProviders, this.reflector, this.evaluator) :
                        null,
                    classMetadata: extractClassMetadata(node, this.reflector, this.isCore, this.annotateForClosureCompiler),
                    factorySymbolName: node.name.text,
                },
            };
        }
        symbol(node) {
            return new NgModuleSymbol(node);
        }
        register(node, analysis) {
            // Register this module's information with the LocalModuleScopeRegistry. This ensures that
            // during the compile() phase, the module's metadata is available for selector scope
            // computation.
            this.metaRegistry.registerNgModuleMetadata({
                ref: new Reference$1(node),
                schemas: analysis.schemas,
                declarations: analysis.declarations,
                imports: analysis.imports,
                exports: analysis.exports,
                rawDeclarations: analysis.rawDeclarations,
            });
            if (this.factoryTracker !== null) {
                this.factoryTracker.track(node.getSourceFile(), {
                    name: analysis.factorySymbolName,
                    hasId: analysis.id !== null,
                });
            }
            this.injectableRegistry.registerInjectable(node);
        }
        resolve(node, analysis) {
            const scope = this.scopeRegistry.getScopeOfModule(node);
            const diagnostics = [];
            const scopeDiagnostics = this.scopeRegistry.getDiagnosticsOfModule(node);
            if (scopeDiagnostics !== null) {
                diagnostics.push(...scopeDiagnostics);
            }
            if (analysis.providersRequiringFactory !== null) {
                const providerDiagnostics = getProviderDiagnostics(analysis.providersRequiringFactory, analysis.providers, this.injectableRegistry);
                diagnostics.push(...providerDiagnostics);
            }
            const data = {
                injectorImports: [],
            };
            if (scope !== null && !scope.compilation.isPoisoned) {
                // Using the scope information, extend the injector's imports using the modules that are
                // specified as module exports.
                const context = getSourceFile(node);
                for (const exportRef of analysis.exports) {
                    if (isNgModule(exportRef.node, scope.compilation)) {
                        data.injectorImports.push(this.refEmitter.emit(exportRef, context).expression);
                    }
                }
                for (const decl of analysis.declarations) {
                    const metadata = this.metaReader.getDirectiveMetadata(decl);
                    if (metadata !== null && metadata.selector === null) {
                        throw new FatalDiagnosticError(ErrorCode.DIRECTIVE_MISSING_SELECTOR, decl.node, `Directive ${decl.node.name.text} has no selector, please add it!`);
                    }
                }
            }
            if (diagnostics.length > 0) {
                return { diagnostics };
            }
            if (scope === null || scope.compilation.isPoisoned || scope.exported.isPoisoned ||
                scope.reexports === null) {
                return { data };
            }
            else {
                return {
                    data,
                    reexports: scope.reexports,
                };
            }
        }
        compileFull(node, { inj, mod, fac, classMetadata, declarations }, { injectorImports }) {
            const factoryFn = compileNgFactoryDefField(fac);
            const ngInjectorDef = compileInjector(this.mergeInjectorImports(inj, injectorImports));
            const ngModuleDef = compileNgModule(mod);
            const statements = ngModuleDef.statements;
            const metadata = classMetadata !== null ? compileClassMetadata(classMetadata) : null;
            this.insertMetadataStatement(statements, metadata);
            this.appendRemoteScopingStatements(statements, node, declarations);
            return this.compileNgModule(factoryFn, ngInjectorDef, ngModuleDef);
        }
        compilePartial(node, { inj, fac, mod, classMetadata }, { injectorImports }) {
            const factoryFn = compileDeclareFactory(fac);
            const injectorDef = compileDeclareInjectorFromMetadata(this.mergeInjectorImports(inj, injectorImports));
            const ngModuleDef = compileDeclareNgModuleFromMetadata(mod);
            const metadata = classMetadata !== null ? compileDeclareClassMetadata(classMetadata) : null;
            this.insertMetadataStatement(ngModuleDef.statements, metadata);
            // NOTE: no remote scoping required as this is banned in partial compilation.
            return this.compileNgModule(factoryFn, injectorDef, ngModuleDef);
        }
        /**
         *  Merge the injector imports (which are 'exports' that were later found to be NgModules)
         *  computed during resolution with the ones from analysis.
         */
        mergeInjectorImports(inj, injectorImports) {
            return Object.assign(Object.assign({}, inj), { imports: [...inj.imports, ...injectorImports] });
        }
        /**
         * Add class metadata statements, if provided, to the `ngModuleStatements`.
         */
        insertMetadataStatement(ngModuleStatements, metadata) {
            if (metadata !== null) {
                ngModuleStatements.unshift(metadata.toStmt());
            }
        }
        /**
         * Add remote scoping statements, as needed, to the `ngModuleStatements`.
         */
        appendRemoteScopingStatements(ngModuleStatements, node, declarations) {
            const context = getSourceFile(node);
            for (const decl of declarations) {
                const remoteScope = this.scopeRegistry.getRemoteScope(decl.node);
                if (remoteScope !== null) {
                    const directives = remoteScope.directives.map(directive => this.refEmitter.emit(directive, context).expression);
                    const pipes = remoteScope.pipes.map(pipe => this.refEmitter.emit(pipe, context).expression);
                    const directiveArray = new LiteralArrayExpr(directives);
                    const pipesArray = new LiteralArrayExpr(pipes);
                    const declExpr = this.refEmitter.emit(decl, context).expression;
                    const setComponentScope = new ExternalExpr(Identifiers.setComponentScope);
                    const callExpr = new InvokeFunctionExpr(setComponentScope, [declExpr, directiveArray, pipesArray]);
                    ngModuleStatements.push(callExpr.toStmt());
                }
            }
        }
        compileNgModule(factoryFn, injectorDef, ngModuleDef) {
            const res = [
                factoryFn,
                {
                    name: 'mod',
                    initializer: ngModuleDef.expression,
                    statements: ngModuleDef.statements,
                    type: ngModuleDef.type,
                },
                {
                    name: 'inj',
                    initializer: injectorDef.expression,
                    statements: injectorDef.statements,
                    type: injectorDef.type,
                },
            ];
            if (this.localeId) {
                // QUESTION: can this stuff be removed?
                res.push({
                    name: 'loc',
                    initializer: new LiteralExpr(this.localeId),
                    statements: [],
                    type: STRING_TYPE
                });
            }
            return res;
        }
        _toR3Reference(valueRef, valueContext, typeContext) {
            if (valueRef.hasOwningModuleGuess) {
                return toR3Reference(valueRef, valueRef, valueContext, valueContext, this.refEmitter);
            }
            else {
                let typeRef = valueRef;
                let typeNode = this.reflector.getDtsDeclaration(typeRef.node);
                if (typeNode !== null && isNamedClassDeclaration(typeNode)) {
                    typeRef = new Reference$1(typeNode);
                }
                return toR3Reference(valueRef, typeRef, valueContext, typeContext, this.refEmitter);
            }
        }
        /**
         * Given a `FunctionDeclaration`, `MethodDeclaration` or `FunctionExpression`, check if it is
         * typed as a `ModuleWithProviders` and return an expression referencing the module if available.
         */
        _extractModuleFromModuleWithProvidersFn(node) {
            const type = node.type || null;
            return type &&
                (this._reflectModuleFromTypeParam(type, node) || this._reflectModuleFromLiteralType(type));
        }
        /**
         * Retrieve an `NgModule` identifier (T) from the specified `type`, if it is of the form:
         * `ModuleWithProviders<T>`
         * @param type The type to reflect on.
         * @returns the identifier of the NgModule type if found, or null otherwise.
         */
        _reflectModuleFromTypeParam(type, node) {
            // Examine the type of the function to see if it's a ModuleWithProviders reference.
            if (!ts$1.isTypeReferenceNode(type)) {
                return null;
            }
            const typeName = type &&
                (ts$1.isIdentifier(type.typeName) && type.typeName ||
                    ts$1.isQualifiedName(type.typeName) && type.typeName.right) ||
                null;
            if (typeName === null) {
                return null;
            }
            // Look at the type itself to see where it comes from.
            const id = this.reflector.getImportOfIdentifier(typeName);
            // If it's not named ModuleWithProviders, bail.
            if (id === null || id.name !== 'ModuleWithProviders') {
                return null;
            }
            // If it's not from @angular/core, bail.
            if (!this.isCore && id.from !== '@angular/core') {
                return null;
            }
            // If there's no type parameter specified, bail.
            if (type.typeArguments === undefined || type.typeArguments.length !== 1) {
                const parent = ts$1.isMethodDeclaration(node) && ts$1.isClassDeclaration(node.parent) ? node.parent : null;
                const symbolName = (parent && parent.name ? parent.name.getText() + '.' : '') +
                    (node.name ? node.name.getText() : 'anonymous');
                throw new FatalDiagnosticError(ErrorCode.NGMODULE_MODULE_WITH_PROVIDERS_MISSING_GENERIC, type, `${symbolName} returns a ModuleWithProviders type without a generic type argument. ` +
                    `Please add a generic type argument to the ModuleWithProviders type. If this ` +
                    `occurrence is in library code you don't control, please contact the library authors.`);
            }
            const arg = type.typeArguments[0];
            return typeNodeToValueExpr(arg);
        }
        /**
         * Retrieve an `NgModule` identifier (T) from the specified `type`, if it is of the form:
         * `A|B|{ngModule: T}|C`.
         * @param type The type to reflect on.
         * @returns the identifier of the NgModule type if found, or null otherwise.
         */
        _reflectModuleFromLiteralType(type) {
            if (!ts$1.isIntersectionTypeNode(type)) {
                return null;
            }
            for (const t of type.types) {
                if (ts$1.isTypeLiteralNode(t)) {
                    for (const m of t.members) {
                        const ngModuleType = ts$1.isPropertySignature(m) && ts$1.isIdentifier(m.name) &&
                            m.name.text === 'ngModule' && m.type ||
                            null;
                        const ngModuleExpression = ngModuleType && typeNodeToValueExpr(ngModuleType);
                        if (ngModuleExpression) {
                            return ngModuleExpression;
                        }
                    }
                }
            }
            return null;
        }
        // Verify that a "Declaration" reference is a `ClassDeclaration` reference.
        isClassDeclarationReference(ref) {
            return this.reflector.isClass(ref.node);
        }
        /**
         * Compute a list of `Reference`s from a resolved metadata value.
         */
        resolveTypeList(expr, resolvedList, className, arrayName) {
            const refList = [];
            if (!Array.isArray(resolvedList)) {
                throw createValueHasWrongTypeError(expr, resolvedList, `Expected array when reading the NgModule.${arrayName} of ${className}`);
            }
            resolvedList.forEach((entry, idx) => {
                // Unwrap ModuleWithProviders for modules that are locally declared (and thus static
                // resolution was able to descend into the function and return an object literal, a Map).
                if (entry instanceof Map && entry.has('ngModule')) {
                    entry = entry.get('ngModule');
                }
                if (Array.isArray(entry)) {
                    // Recurse into nested arrays.
                    refList.push(...this.resolveTypeList(expr, entry, className, arrayName));
                }
                else if (entry instanceof Reference$1) {
                    if (!this.isClassDeclarationReference(entry)) {
                        throw createValueHasWrongTypeError(entry.node, entry, `Value at position ${idx} in the NgModule.${arrayName} of ${className} is not a class`);
                    }
                    refList.push(entry);
                }
                else {
                    // TODO(alxhub): Produce a better diagnostic here - the array index may be an inner array.
                    throw createValueHasWrongTypeError(expr, entry, `Value at position ${idx} in the NgModule.${arrayName} of ${className} is not a reference`);
                }
            });
            return refList;
        }
    }
    function isNgModule(node, compilation) {
        return !compilation.directives.some(directive => directive.ref.node === node) &&
            !compilation.pipes.some(pipe => pipe.ref.node === node);
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const EMPTY_MAP = new Map();
    const EMPTY_ARRAY = [];
    /**
     * Represents an Angular component.
     */
    class ComponentSymbol extends DirectiveSymbol {
        constructor() {
            super(...arguments);
            this.usedDirectives = [];
            this.usedPipes = [];
            this.isRemotelyScoped = false;
        }
        isEmitAffected(previousSymbol, publicApiAffected) {
            if (!(previousSymbol instanceof ComponentSymbol)) {
                return true;
            }
            // Create an equality function that considers symbols equal if they represent the same
            // declaration, but only if the symbol in the current compilation does not have its public API
            // affected.
            const isSymbolUnaffected = (current, previous) => isReferenceEqual(current, previous) && !publicApiAffected.has(current.symbol);
            // The emit of a component is affected if either of the following is true:
            //  1. The component used to be remotely scoped but no longer is, or vice versa.
            //  2. The list of used directives has changed or any of those directives have had their public
            //     API changed. If the used directives have been reordered but not otherwise affected then
            //     the component must still be re-emitted, as this may affect directive instantiation order.
            //  3. The list of used pipes has changed, or any of those pipes have had their public API
            //     changed.
            return this.isRemotelyScoped !== previousSymbol.isRemotelyScoped ||
                !isArrayEqual(this.usedDirectives, previousSymbol.usedDirectives, isSymbolUnaffected) ||
                !isArrayEqual(this.usedPipes, previousSymbol.usedPipes, isSymbolUnaffected);
        }
        isTypeCheckBlockAffected(previousSymbol, typeCheckApiAffected) {
            if (!(previousSymbol instanceof ComponentSymbol)) {
                return true;
            }
            // To verify that a used directive is not affected we need to verify that its full inheritance
            // chain is not present in `typeCheckApiAffected`.
            const isInheritanceChainAffected = (symbol) => {
                let currentSymbol = symbol;
                while (currentSymbol instanceof DirectiveSymbol) {
                    if (typeCheckApiAffected.has(currentSymbol)) {
                        return true;
                    }
                    currentSymbol = currentSymbol.baseClass;
                }
                return false;
            };
            // Create an equality function that considers directives equal if they represent the same
            // declaration and if the symbol and all symbols it inherits from in the current compilation
            // do not have their type-check API affected.
            const isDirectiveUnaffected = (current, previous) => isReferenceEqual(current, previous) && !isInheritanceChainAffected(current.symbol);
            // Create an equality function that considers pipes equal if they represent the same
            // declaration and if the symbol in the current compilation does not have its type-check
            // API affected.
            const isPipeUnaffected = (current, previous) => isReferenceEqual(current, previous) && !typeCheckApiAffected.has(current.symbol);
            // The emit of a type-check block of a component is affected if either of the following is true:
            //  1. The list of used directives has changed or any of those directives have had their
            //     type-check API changed.
            //  2. The list of used pipes has changed, or any of those pipes have had their type-check API
            //     changed.
            return !isArrayEqual(this.usedDirectives, previousSymbol.usedDirectives, isDirectiveUnaffected) ||
                !isArrayEqual(this.usedPipes, previousSymbol.usedPipes, isPipeUnaffected);
        }
    }
    /**
     * `DecoratorHandler` which handles the `@Component` annotation.
     */
    class ComponentDecoratorHandler {
        constructor(reflector, evaluator, metaRegistry, metaReader, scopeReader, scopeRegistry, typeCheckScopeRegistry, resourceRegistry, isCore, resourceLoader, rootDirs, defaultPreserveWhitespaces, i18nUseExternalIds, enableI18nLegacyMessageIdFormat, usePoisonedData, i18nNormalizeLineEndingsInICUs, moduleResolver, cycleAnalyzer, cycleHandlingStrategy, refEmitter, depTracker, injectableRegistry, semanticDepGraphUpdater, annotateForClosureCompiler, perf) {
            this.reflector = reflector;
            this.evaluator = evaluator;
            this.metaRegistry = metaRegistry;
            this.metaReader = metaReader;
            this.scopeReader = scopeReader;
            this.scopeRegistry = scopeRegistry;
            this.typeCheckScopeRegistry = typeCheckScopeRegistry;
            this.resourceRegistry = resourceRegistry;
            this.isCore = isCore;
            this.resourceLoader = resourceLoader;
            this.rootDirs = rootDirs;
            this.defaultPreserveWhitespaces = defaultPreserveWhitespaces;
            this.i18nUseExternalIds = i18nUseExternalIds;
            this.enableI18nLegacyMessageIdFormat = enableI18nLegacyMessageIdFormat;
            this.usePoisonedData = usePoisonedData;
            this.i18nNormalizeLineEndingsInICUs = i18nNormalizeLineEndingsInICUs;
            this.moduleResolver = moduleResolver;
            this.cycleAnalyzer = cycleAnalyzer;
            this.cycleHandlingStrategy = cycleHandlingStrategy;
            this.refEmitter = refEmitter;
            this.depTracker = depTracker;
            this.injectableRegistry = injectableRegistry;
            this.semanticDepGraphUpdater = semanticDepGraphUpdater;
            this.annotateForClosureCompiler = annotateForClosureCompiler;
            this.perf = perf;
            this.literalCache = new Map();
            this.elementSchemaRegistry = new DomElementSchemaRegistry();
            /**
             * During the asynchronous preanalyze phase, it's necessary to parse the template to extract
             * any potential <link> tags which might need to be loaded. This cache ensures that work is not
             * thrown away, and the parsed template is reused during the analyze phase.
             */
            this.preanalyzeTemplateCache = new Map();
            this.preanalyzeStylesCache = new Map();
            this.precedence = HandlerPrecedence.PRIMARY;
            this.name = ComponentDecoratorHandler.name;
        }
        detect(node, decorators) {
            if (!decorators) {
                return undefined;
            }
            const decorator = findAngularDecorator(decorators, 'Component', this.isCore);
            if (decorator !== undefined) {
                return {
                    trigger: decorator.node,
                    decorator,
                    metadata: decorator,
                };
            }
            else {
                return undefined;
            }
        }
        preanalyze(node, decorator) {
            // In preanalyze, resource URLs associated with the component are asynchronously preloaded via
            // the resourceLoader. This is the only time async operations are allowed for a component.
            // These resources are:
            //
            // - the templateUrl, if there is one
            // - any styleUrls if present
            // - any stylesheets referenced from <link> tags in the template itself
            //
            // As a result of the last one, the template must be parsed as part of preanalysis to extract
            // <link> tags, which may involve waiting for the templateUrl to be resolved first.
            // If preloading isn't possible, then skip this step.
            if (!this.resourceLoader.canPreload) {
                return undefined;
            }
            const meta = this._resolveLiteral(decorator);
            const component = reflectObjectLiteral(meta);
            const containingFile = node.getSourceFile().fileName;
            const resolveStyleUrl = (styleUrl) => {
                try {
                    const resourceUrl = this.resourceLoader.resolve(styleUrl, containingFile);
                    return this.resourceLoader.preload(resourceUrl, { type: 'style', containingFile });
                }
                catch (_a) {
                    // Don't worry about failures to preload. We can handle this problem during analysis by
                    // producing a diagnostic.
                    return undefined;
                }
            };
            // A Promise that waits for the template and all <link>ed styles within it to be preloaded.
            const templateAndTemplateStyleResources = this._preloadAndParseTemplate(node, decorator, component, containingFile)
                .then((template) => {
                if (template === null) {
                    return undefined;
                }
                return Promise.all(template.styleUrls.map(styleUrl => resolveStyleUrl(styleUrl)))
                    .then(() => undefined);
            });
            // Extract all the styleUrls in the decorator.
            const componentStyleUrls = this._extractComponentStyleUrls(component);
            // Extract inline styles, process, and cache for use in synchronous analyze phase
            let inlineStyles;
            if (component.has('styles')) {
                const litStyles = parseFieldArrayValue(component, 'styles', this.evaluator);
                if (litStyles === null) {
                    this.preanalyzeStylesCache.set(node, null);
                }
                else {
                    inlineStyles = Promise
                        .all(litStyles.map(style => this.resourceLoader.preprocessInline(style, { type: 'style', containingFile })))
                        .then(styles => {
                        this.preanalyzeStylesCache.set(node, styles);
                    });
                }
            }
            else {
                this.preanalyzeStylesCache.set(node, null);
            }
            // Wait for both the template and all styleUrl resources to resolve.
            return Promise
                .all([
                templateAndTemplateStyleResources, inlineStyles,
                ...componentStyleUrls.map(styleUrl => resolveStyleUrl(styleUrl.url))
            ])
                .then(() => undefined);
        }
        analyze(node, decorator, flags = HandlerFlags.NONE) {
            var _a, _b;
            this.perf.eventCount(PerfEvent.AnalyzeComponent);
            const containingFile = node.getSourceFile().fileName;
            this.literalCache.delete(decorator);
            let diagnostics;
            let isPoisoned = false;
            // @Component inherits @Directive, so begin by extracting the @Directive metadata and building
            // on it.
            const directiveResult = extractDirectiveMetadata(node, decorator, this.reflector, this.evaluator, this.isCore, flags, this.annotateForClosureCompiler, this.elementSchemaRegistry.getDefaultComponentElementName());
            if (directiveResult === undefined) {
                // `extractDirectiveMetadata` returns undefined when the @Directive has `jit: true`. In this
                // case, compilation of the decorator is skipped. Returning an empty object signifies
                // that no analysis was produced.
                return {};
            }
            // Next, read the `@Component`-specific fields.
            const { decorator: component, metadata, inputs, outputs } = directiveResult;
            const encapsulation = (_a = this._resolveEnumValue(component, 'encapsulation', 'ViewEncapsulation')) !== null && _a !== void 0 ? _a : ViewEncapsulation.Emulated;
            const changeDetection = this._resolveEnumValue(component, 'changeDetection', 'ChangeDetectionStrategy');
            let animations = null;
            if (component.has('animations')) {
                animations = new WrappedNodeExpr(component.get('animations'));
            }
            // Go through the root directories for this project, and select the one with the smallest
            // relative path representation.
            const relativeContextFilePath = this.rootDirs.reduce((previous, rootDir) => {
                const candidate = relative(absoluteFrom(rootDir), absoluteFrom(containingFile));
                if (previous === undefined || candidate.length < previous.length) {
                    return candidate;
                }
                else {
                    return previous;
                }
            }, undefined);
            // Note that we could technically combine the `viewProvidersRequiringFactory` and
            // `providersRequiringFactory` into a single set, but we keep the separate so that
            // we can distinguish where an error is coming from when logging the diagnostics in `resolve`.
            let viewProvidersRequiringFactory = null;
            let providersRequiringFactory = null;
            let wrappedViewProviders = null;
            if (component.has('viewProviders')) {
                const viewProviders = component.get('viewProviders');
                viewProvidersRequiringFactory =
                    resolveProvidersRequiringFactory(viewProviders, this.reflector, this.evaluator);
                wrappedViewProviders = new WrappedNodeExpr(this.annotateForClosureCompiler ? wrapFunctionExpressionsInParens(viewProviders) :
                    viewProviders);
            }
            if (component.has('providers')) {
                providersRequiringFactory = resolveProvidersRequiringFactory(component.get('providers'), this.reflector, this.evaluator);
            }
            // Parse the template.
            // If a preanalyze phase was executed, the template may already exist in parsed form, so check
            // the preanalyzeTemplateCache.
            // Extract a closure of the template parsing code so that it can be reparsed with different
            // options if needed, like in the indexing pipeline.
            let template;
            if (this.preanalyzeTemplateCache.has(node)) {
                // The template was parsed in preanalyze. Use it and delete it to save memory.
                const preanalyzed = this.preanalyzeTemplateCache.get(node);
                this.preanalyzeTemplateCache.delete(node);
                template = preanalyzed;
            }
            else {
                const templateDecl = this.parseTemplateDeclaration(decorator, component, containingFile);
                template = this.extractTemplate(node, templateDecl);
            }
            const templateResource = template.declaration.isInline ? { path: null, expression: component.get('template') } : {
                path: absoluteFrom(template.declaration.resolvedTemplateUrl),
                expression: template.sourceMapping.node
            };
            // Figure out the set of styles. The ordering here is important: external resources (styleUrls)
            // precede inline styles, and styles defined in the template override styles defined in the
            // component.
            let styles = [];
            const styleResources = this._extractStyleResources(component, containingFile);
            const styleUrls = [
                ...this._extractComponentStyleUrls(component), ...this._extractTemplateStyleUrls(template)
            ];
            for (const styleUrl of styleUrls) {
                try {
                    const resourceUrl = this.resourceLoader.resolve(styleUrl.url, containingFile);
                    const resourceStr = this.resourceLoader.load(resourceUrl);
                    styles.push(resourceStr);
                    if (this.depTracker !== null) {
                        this.depTracker.addResourceDependency(node.getSourceFile(), absoluteFrom(resourceUrl));
                    }
                }
                catch (_c) {
                    if (diagnostics === undefined) {
                        diagnostics = [];
                    }
                    const resourceType = styleUrl.source === 2 /* StylesheetFromDecorator */ ?
                        2 /* StylesheetFromDecorator */ :
                        1 /* StylesheetFromTemplate */;
                    diagnostics.push(this.makeResourceNotFoundError(styleUrl.url, styleUrl.nodeForError, resourceType)
                        .toDiagnostic());
                }
            }
            if (encapsulation === ViewEncapsulation.ShadowDom && metadata.selector !== null) {
                const selectorError = checkCustomElementSelectorForErrors(metadata.selector);
                if (selectorError !== null) {
                    if (diagnostics === undefined) {
                        diagnostics = [];
                    }
                    diagnostics.push(makeDiagnostic(ErrorCode.COMPONENT_INVALID_SHADOW_DOM_SELECTOR, component.get('selector'), selectorError));
                }
            }
            // If inline styles were preprocessed use those
            let inlineStyles = null;
            if (this.preanalyzeStylesCache.has(node)) {
                inlineStyles = this.preanalyzeStylesCache.get(node);
                this.preanalyzeStylesCache.delete(node);
                if (inlineStyles !== null) {
                    styles.push(...inlineStyles);
                }
            }
            else {
                // Preprocessing is only supported asynchronously
                // If no style cache entry is present asynchronous preanalyze was not executed.
                // This protects against accidental differences in resource contents when preanalysis
                // is not used with a provided transformResource hook on the ResourceHost.
                if (this.resourceLoader.canPreprocess) {
                    throw new Error('Inline resource processing requires asynchronous preanalyze.');
                }
                if (component.has('styles')) {
                    const litStyles = parseFieldArrayValue(component, 'styles', this.evaluator);
                    if (litStyles !== null) {
                        inlineStyles = [...litStyles];
                        styles.push(...litStyles);
                    }
                }
            }
            if (template.styles.length > 0) {
                styles.push(...template.styles);
            }
            const output = {
                analysis: {
                    baseClass: readBaseClass$1(node, this.reflector, this.evaluator),
                    inputs,
                    outputs,
                    meta: Object.assign(Object.assign({}, metadata), { template: {
                            nodes: template.nodes,
                            ngContentSelectors: template.ngContentSelectors,
                        }, encapsulation, interpolation: (_b = template.interpolationConfig) !== null && _b !== void 0 ? _b : DEFAULT_INTERPOLATION_CONFIG, styles,
                        // These will be replaced during the compilation step, after all `NgModule`s have been
                        // analyzed and the full compilation scope for the component can be realized.
                        animations, viewProviders: wrappedViewProviders, i18nUseExternalIds: this.i18nUseExternalIds, relativeContextFilePath }),
                    typeCheckMeta: extractDirectiveTypeCheckMeta(node, inputs, this.reflector),
                    classMetadata: extractClassMetadata(node, this.reflector, this.isCore, this.annotateForClosureCompiler),
                    template,
                    providersRequiringFactory,
                    viewProvidersRequiringFactory,
                    inlineStyles,
                    styleUrls,
                    resources: {
                        styles: styleResources,
                        template: templateResource,
                    },
                    isPoisoned,
                },
                diagnostics,
            };
            if (changeDetection !== null) {
                output.analysis.meta.changeDetection = changeDetection;
            }
            return output;
        }
        symbol(node, analysis) {
            const typeParameters = extractSemanticTypeParameters(node);
            return new ComponentSymbol(node, analysis.meta.selector, analysis.inputs, analysis.outputs, analysis.meta.exportAs, analysis.typeCheckMeta, typeParameters);
        }
        register(node, analysis) {
            // Register this component's information with the `MetadataRegistry`. This ensures that
            // the information about the component is available during the compile() phase.
            const ref = new Reference$1(node);
            this.metaRegistry.registerDirectiveMetadata(Object.assign(Object.assign({ type: MetaType.Directive, ref, name: node.name.text, selector: analysis.meta.selector, exportAs: analysis.meta.exportAs, inputs: analysis.inputs, outputs: analysis.outputs, queries: analysis.meta.queries.map(query => query.propertyName), isComponent: true, baseClass: analysis.baseClass }, analysis.typeCheckMeta), { isPoisoned: analysis.isPoisoned, isStructural: false }));
            this.resourceRegistry.registerResources(analysis.resources, node);
            this.injectableRegistry.registerInjectable(node);
        }
        index(context, node, analysis) {
            if (analysis.isPoisoned && !this.usePoisonedData) {
                return null;
            }
            const scope = this.scopeReader.getScopeForComponent(node);
            const selector = analysis.meta.selector;
            const matcher = new SelectorMatcher();
            if (scope !== null) {
                if ((scope.compilation.isPoisoned || scope.exported.isPoisoned) && !this.usePoisonedData) {
                    // Don't bother indexing components which had erroneous scopes, unless specifically
                    // requested.
                    return null;
                }
                for (const directive of scope.compilation.directives) {
                    if (directive.selector !== null) {
                        matcher.addSelectables(CssSelector.parse(directive.selector), directive);
                    }
                }
            }
            const binder = new R3TargetBinder(matcher);
            const boundTemplate = binder.bind({ template: analysis.template.diagNodes });
            context.addComponent({
                declaration: node,
                selector,
                boundTemplate,
                templateMeta: {
                    isInline: analysis.template.declaration.isInline,
                    file: analysis.template.file,
                },
            });
        }
        typeCheck(ctx, node, meta) {
            if (this.typeCheckScopeRegistry === null || !ts$1.isClassDeclaration(node)) {
                return;
            }
            if (meta.isPoisoned && !this.usePoisonedData) {
                return;
            }
            const scope = this.typeCheckScopeRegistry.getTypeCheckScope(node);
            if (scope.isPoisoned && !this.usePoisonedData) {
                // Don't type-check components that had errors in their scopes, unless requested.
                return;
            }
            const binder = new R3TargetBinder(scope.matcher);
            ctx.addTemplate(new Reference$1(node), binder, meta.template.diagNodes, scope.pipes, scope.schemas, meta.template.sourceMapping, meta.template.file, meta.template.errors);
        }
        extendedTemplateCheck(component, extendedTemplateChecker) {
            return extendedTemplateChecker.getDiagnosticsForComponent(component);
        }
        resolve(node, analysis, symbol) {
            if (this.semanticDepGraphUpdater !== null && analysis.baseClass instanceof Reference$1) {
                symbol.baseClass = this.semanticDepGraphUpdater.getSymbol(analysis.baseClass.node);
            }
            if (analysis.isPoisoned && !this.usePoisonedData) {
                return {};
            }
            const context = node.getSourceFile();
            // Check whether this component was registered with an NgModule. If so, it should be compiled
            // under that module's compilation scope.
            const scope = this.scopeReader.getScopeForComponent(node);
            let metadata = analysis.meta;
            const data = {
                directives: EMPTY_ARRAY,
                pipes: EMPTY_MAP,
                declarationListEmitMode: 0 /* Direct */,
            };
            if (scope !== null && (!scope.compilation.isPoisoned || this.usePoisonedData)) {
                const matcher = new SelectorMatcher();
                for (const dir of scope.compilation.directives) {
                    if (dir.selector !== null) {
                        matcher.addSelectables(CssSelector.parse(dir.selector), dir);
                    }
                }
                const pipes = new Map();
                for (const pipe of scope.compilation.pipes) {
                    pipes.set(pipe.name, pipe.ref);
                }
                // Next, the component template AST is bound using the R3TargetBinder. This produces a
                // BoundTarget, which is similar to a ts.TypeChecker.
                const binder = new R3TargetBinder(matcher);
                const bound = binder.bind({ template: metadata.template.nodes });
                const usedDirectives = bound.getUsedDirectives().map(directive => {
                    const type = this.refEmitter.emit(directive.ref, context);
                    return {
                        ref: directive.ref,
                        type: type.expression,
                        importedFile: type.importedFile,
                        selector: directive.selector,
                        inputs: directive.inputs.propertyNames,
                        outputs: directive.outputs.propertyNames,
                        exportAs: directive.exportAs,
                        isComponent: directive.isComponent,
                    };
                });
                const usedPipes = [];
                for (const pipeName of bound.getUsedPipes()) {
                    if (!pipes.has(pipeName)) {
                        continue;
                    }
                    const pipe = pipes.get(pipeName);
                    const type = this.refEmitter.emit(pipe, context);
                    usedPipes.push({
                        ref: pipe,
                        pipeName,
                        expression: type.expression,
                        importedFile: type.importedFile,
                    });
                }
                if (this.semanticDepGraphUpdater !== null) {
                    symbol.usedDirectives = usedDirectives.map(dir => this.semanticDepGraphUpdater.getSemanticReference(dir.ref.node, dir.type));
                    symbol.usedPipes = usedPipes.map(pipe => this.semanticDepGraphUpdater.getSemanticReference(pipe.ref.node, pipe.expression));
                }
                // Scan through the directives/pipes actually used in the template and check whether any
                // import which needs to be generated would create a cycle.
                const cyclesFromDirectives = new Map();
                for (const usedDirective of usedDirectives) {
                    const cycle = this._checkForCyclicImport(usedDirective.importedFile, usedDirective.type, context);
                    if (cycle !== null) {
                        cyclesFromDirectives.set(usedDirective, cycle);
                    }
                }
                const cyclesFromPipes = new Map();
                for (const usedPipe of usedPipes) {
                    const cycle = this._checkForCyclicImport(usedPipe.importedFile, usedPipe.expression, context);
                    if (cycle !== null) {
                        cyclesFromPipes.set(usedPipe, cycle);
                    }
                }
                const cycleDetected = cyclesFromDirectives.size !== 0 || cyclesFromPipes.size !== 0;
                if (!cycleDetected) {
                    // No cycle was detected. Record the imports that need to be created in the cycle detector
                    // so that future cyclic import checks consider their production.
                    for (const { type, importedFile } of usedDirectives) {
                        this._recordSyntheticImport(importedFile, type, context);
                    }
                    for (const { expression, importedFile } of usedPipes) {
                        this._recordSyntheticImport(importedFile, expression, context);
                    }
                    // Check whether the directive/pipe arrays in cmp need to be wrapped in closures.
                    // This is required if any directive/pipe reference is to a declaration in the same file
                    // but declared after this component.
                    const wrapDirectivesAndPipesInClosure = usedDirectives.some(dir => isExpressionForwardReference(dir.type, node.name, context)) ||
                        usedPipes.some(pipe => isExpressionForwardReference(pipe.expression, node.name, context));
                    data.directives = usedDirectives;
                    data.pipes = new Map(usedPipes.map(pipe => [pipe.pipeName, pipe.expression]));
                    data.declarationListEmitMode = wrapDirectivesAndPipesInClosure ?
                        1 /* Closure */ :
                        0 /* Direct */;
                }
                else {
                    if (this.cycleHandlingStrategy === 0 /* UseRemoteScoping */) {
                        // Declaring the directiveDefs/pipeDefs arrays directly would require imports that would
                        // create a cycle. Instead, mark this component as requiring remote scoping, so that the
                        // NgModule file will take care of setting the directives for the component.
                        this.scopeRegistry.setComponentRemoteScope(node, usedDirectives.map(dir => dir.ref), usedPipes.map(pipe => pipe.ref));
                        symbol.isRemotelyScoped = true;
                        // If a semantic graph is being tracked, record the fact that this component is remotely
                        // scoped with the declaring NgModule symbol as the NgModule's emit becomes dependent on
                        // the directive/pipe usages of this component.
                        if (this.semanticDepGraphUpdater !== null) {
                            const moduleSymbol = this.semanticDepGraphUpdater.getSymbol(scope.ngModule);
                            if (!(moduleSymbol instanceof NgModuleSymbol)) {
                                throw new Error(`AssertionError: Expected ${scope.ngModule.name} to be an NgModuleSymbol.`);
                            }
                            moduleSymbol.addRemotelyScopedComponent(symbol, symbol.usedDirectives, symbol.usedPipes);
                        }
                    }
                    else {
                        // We are not able to handle this cycle so throw an error.
                        const relatedMessages = [];
                        for (const [dir, cycle] of cyclesFromDirectives) {
                            relatedMessages.push(makeCyclicImportInfo(dir.ref, dir.isComponent ? 'component' : 'directive', cycle));
                        }
                        for (const [pipe, cycle] of cyclesFromPipes) {
                            relatedMessages.push(makeCyclicImportInfo(pipe.ref, 'pipe', cycle));
                        }
                        throw new FatalDiagnosticError(ErrorCode.IMPORT_CYCLE_DETECTED, node, 'One or more import cycles would need to be created to compile this component, ' +
                            'which is not supported by the current compiler configuration.', relatedMessages);
                    }
                }
            }
            const diagnostics = [];
            if (analysis.providersRequiringFactory !== null &&
                analysis.meta.providers instanceof WrappedNodeExpr) {
                const providerDiagnostics = getProviderDiagnostics(analysis.providersRequiringFactory, analysis.meta.providers.node, this.injectableRegistry);
                diagnostics.push(...providerDiagnostics);
            }
            if (analysis.viewProvidersRequiringFactory !== null &&
                analysis.meta.viewProviders instanceof WrappedNodeExpr) {
                const viewProviderDiagnostics = getProviderDiagnostics(analysis.viewProvidersRequiringFactory, analysis.meta.viewProviders.node, this.injectableRegistry);
                diagnostics.push(...viewProviderDiagnostics);
            }
            const directiveDiagnostics = getDirectiveDiagnostics(node, this.metaReader, this.evaluator, this.reflector, this.scopeRegistry, 'Component');
            if (directiveDiagnostics !== null) {
                diagnostics.push(...directiveDiagnostics);
            }
            if (diagnostics.length > 0) {
                return { diagnostics };
            }
            return { data };
        }
        xi18n(ctx, node, analysis) {
            var _a;
            ctx.updateFromTemplate(analysis.template.content, analysis.template.declaration.resolvedTemplateUrl, (_a = analysis.template.interpolationConfig) !== null && _a !== void 0 ? _a : DEFAULT_INTERPOLATION_CONFIG);
        }
        updateResources(node, analysis) {
            const containingFile = node.getSourceFile().fileName;
            // If the template is external, re-parse it.
            const templateDecl = analysis.template.declaration;
            if (!templateDecl.isInline) {
                analysis.template = this.extractTemplate(node, templateDecl);
            }
            // Update any external stylesheets and rebuild the combined 'styles' list.
            // TODO(alxhub): write tests for styles when the primary compiler uses the updateResources path
            let styles = [];
            if (analysis.styleUrls !== null) {
                for (const styleUrl of analysis.styleUrls) {
                    try {
                        const resolvedStyleUrl = this.resourceLoader.resolve(styleUrl.url, containingFile);
                        const styleText = this.resourceLoader.load(resolvedStyleUrl);
                        styles.push(styleText);
                    }
                    catch (e) {
                        // Resource resolve failures should already be in the diagnostics list from the analyze
                        // stage. We do not need to do anything with them when updating resources.
                    }
                }
            }
            if (analysis.inlineStyles !== null) {
                for (const styleText of analysis.inlineStyles) {
                    styles.push(styleText);
                }
            }
            for (const styleText of analysis.template.styles) {
                styles.push(styleText);
            }
            analysis.meta.styles = styles;
        }
        compileFull(node, analysis, resolution, pool) {
            if (analysis.template.errors !== null && analysis.template.errors.length > 0) {
                return [];
            }
            const meta = Object.assign(Object.assign({}, analysis.meta), resolution);
            const fac = compileNgFactoryDefField(toFactoryMetadata(meta, FactoryTarget.Component));
            const def = compileComponentFromMetadata(meta, pool, makeBindingParser());
            const classMetadata = analysis.classMetadata !== null ?
                compileClassMetadata(analysis.classMetadata).toStmt() :
                null;
            return compileResults(fac, def, classMetadata, 'cmp');
        }
        compilePartial(node, analysis, resolution) {
            if (analysis.template.errors !== null && analysis.template.errors.length > 0) {
                return [];
            }
            const templateInfo = {
                content: analysis.template.content,
                sourceUrl: analysis.template.declaration.resolvedTemplateUrl,
                isInline: analysis.template.declaration.isInline,
                inlineTemplateLiteralExpression: analysis.template.sourceMapping.type === 'direct' ?
                    new WrappedNodeExpr(analysis.template.sourceMapping.node) :
                    null,
            };
            const meta = Object.assign(Object.assign({}, analysis.meta), resolution);
            const fac = compileDeclareFactory(toFactoryMetadata(meta, FactoryTarget.Component));
            const def = compileDeclareComponentFromMetadata(meta, analysis.template, templateInfo);
            const classMetadata = analysis.classMetadata !== null ?
                compileDeclareClassMetadata(analysis.classMetadata).toStmt() :
                null;
            return compileResults(fac, def, classMetadata, 'cmp');
        }
        _resolveLiteral(decorator) {
            if (this.literalCache.has(decorator)) {
                return this.literalCache.get(decorator);
            }
            if (decorator.args === null || decorator.args.length !== 1) {
                throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, Decorator.nodeForError(decorator), `Incorrect number of arguments to @Component decorator`);
            }
            const meta = unwrapExpression(decorator.args[0]);
            if (!ts$1.isObjectLiteralExpression(meta)) {
                throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARG_NOT_LITERAL, meta, `Decorator argument must be literal.`);
            }
            this.literalCache.set(decorator, meta);
            return meta;
        }
        _resolveEnumValue(component, field, enumSymbolName) {
            let resolved = null;
            if (component.has(field)) {
                const expr = component.get(field);
                const value = this.evaluator.evaluate(expr);
                if (value instanceof EnumValue && isAngularCoreReference(value.enumRef, enumSymbolName)) {
                    resolved = value.resolved;
                }
                else {
                    throw createValueHasWrongTypeError(expr, value, `${field} must be a member of ${enumSymbolName} enum from @angular/core`);
                }
            }
            return resolved;
        }
        _extractComponentStyleUrls(component) {
            if (!component.has('styleUrls')) {
                return [];
            }
            return this._extractStyleUrlsFromExpression(component.get('styleUrls'));
        }
        _extractStyleUrlsFromExpression(styleUrlsExpr) {
            const styleUrls = [];
            if (ts$1.isArrayLiteralExpression(styleUrlsExpr)) {
                for (const styleUrlExpr of styleUrlsExpr.elements) {
                    if (ts$1.isSpreadElement(styleUrlExpr)) {
                        styleUrls.push(...this._extractStyleUrlsFromExpression(styleUrlExpr.expression));
                    }
                    else {
                        const styleUrl = this.evaluator.evaluate(styleUrlExpr);
                        if (typeof styleUrl !== 'string') {
                            throw createValueHasWrongTypeError(styleUrlExpr, styleUrl, 'styleUrl must be a string');
                        }
                        styleUrls.push({
                            url: styleUrl,
                            source: 2 /* StylesheetFromDecorator */,
                            nodeForError: styleUrlExpr,
                        });
                    }
                }
            }
            else {
                const evaluatedStyleUrls = this.evaluator.evaluate(styleUrlsExpr);
                if (!isStringArray(evaluatedStyleUrls)) {
                    throw createValueHasWrongTypeError(styleUrlsExpr, evaluatedStyleUrls, 'styleUrls must be an array of strings');
                }
                for (const styleUrl of evaluatedStyleUrls) {
                    styleUrls.push({
                        url: styleUrl,
                        source: 2 /* StylesheetFromDecorator */,
                        nodeForError: styleUrlsExpr,
                    });
                }
            }
            return styleUrls;
        }
        _extractStyleResources(component, containingFile) {
            const styles = new Set();
            function stringLiteralElements(array) {
                return array.elements.filter((e) => ts$1.isStringLiteralLike(e));
            }
            // If styleUrls is a literal array, process each resource url individually and
            // register ones that are string literals.
            const styleUrlsExpr = component.get('styleUrls');
            if (styleUrlsExpr !== undefined && ts$1.isArrayLiteralExpression(styleUrlsExpr)) {
                for (const expression of stringLiteralElements(styleUrlsExpr)) {
                    try {
                        const resourceUrl = this.resourceLoader.resolve(expression.text, containingFile);
                        styles.add({ path: absoluteFrom(resourceUrl), expression });
                    }
                    catch (_a) {
                        // Errors in style resource extraction do not need to be handled here. We will produce
                        // diagnostics for each one that fails in the analysis, after we evaluate the `styleUrls`
                        // expression to determine _all_ style resources, not just the string literals.
                    }
                }
            }
            const stylesExpr = component.get('styles');
            if (stylesExpr !== undefined && ts$1.isArrayLiteralExpression(stylesExpr)) {
                for (const expression of stringLiteralElements(stylesExpr)) {
                    styles.add({ path: null, expression });
                }
            }
            return styles;
        }
        _preloadAndParseTemplate(node, decorator, component, containingFile) {
            if (component.has('templateUrl')) {
                // Extract the templateUrl and preload it.
                const templateUrlExpr = component.get('templateUrl');
                const templateUrl = this.evaluator.evaluate(templateUrlExpr);
                if (typeof templateUrl !== 'string') {
                    throw createValueHasWrongTypeError(templateUrlExpr, templateUrl, 'templateUrl must be a string');
                }
                try {
                    const resourceUrl = this.resourceLoader.resolve(templateUrl, containingFile);
                    const templatePromise = this.resourceLoader.preload(resourceUrl, { type: 'template', containingFile });
                    // If the preload worked, then actually load and parse the template, and wait for any style
                    // URLs to resolve.
                    if (templatePromise !== undefined) {
                        return templatePromise.then(() => {
                            const templateDecl = this.parseTemplateDeclaration(decorator, component, containingFile);
                            const template = this.extractTemplate(node, templateDecl);
                            this.preanalyzeTemplateCache.set(node, template);
                            return template;
                        });
                    }
                    else {
                        return Promise.resolve(null);
                    }
                }
                catch (e) {
                    throw this.makeResourceNotFoundError(templateUrl, templateUrlExpr, 0 /* Template */);
                }
            }
            else {
                const templateDecl = this.parseTemplateDeclaration(decorator, component, containingFile);
                const template = this.extractTemplate(node, templateDecl);
                this.preanalyzeTemplateCache.set(node, template);
                return Promise.resolve(template);
            }
        }
        extractTemplate(node, template) {
            if (template.isInline) {
                let sourceStr;
                let sourceParseRange = null;
                let templateContent;
                let sourceMapping;
                let escapedString = false;
                let sourceMapUrl;
                // We only support SourceMaps for inline templates that are simple string literals.
                if (ts$1.isStringLiteral(template.expression) ||
                    ts$1.isNoSubstitutionTemplateLiteral(template.expression)) {
                    // the start and end of the `templateExpr` node includes the quotation marks, which we must
                    // strip
                    sourceParseRange = getTemplateRange(template.expression);
                    sourceStr = template.expression.getSourceFile().text;
                    templateContent = template.expression.text;
                    escapedString = true;
                    sourceMapping = {
                        type: 'direct',
                        node: template.expression,
                    };
                    sourceMapUrl = template.resolvedTemplateUrl;
                }
                else {
                    const resolvedTemplate = this.evaluator.evaluate(template.expression);
                    if (typeof resolvedTemplate !== 'string') {
                        throw createValueHasWrongTypeError(template.expression, resolvedTemplate, 'template must be a string');
                    }
                    // We do not parse the template directly from the source file using a lexer range, so
                    // the template source and content are set to the statically resolved template.
                    sourceStr = resolvedTemplate;
                    templateContent = resolvedTemplate;
                    sourceMapping = {
                        type: 'indirect',
                        node: template.expression,
                        componentClass: node,
                        template: templateContent,
                    };
                    // Indirect templates cannot be mapped to a particular byte range of any input file, since
                    // they're computed by expressions that may span many files. Don't attempt to map them back
                    // to a given file.
                    sourceMapUrl = null;
                }
                return Object.assign(Object.assign({}, this._parseTemplate(template, sourceStr, sourceParseRange, escapedString, sourceMapUrl)), { content: templateContent, sourceMapping, declaration: template });
            }
            else {
                const templateContent = this.resourceLoader.load(template.resolvedTemplateUrl);
                if (this.depTracker !== null) {
                    this.depTracker.addResourceDependency(node.getSourceFile(), absoluteFrom(template.resolvedTemplateUrl));
                }
                return Object.assign(Object.assign({}, this._parseTemplate(template, /* sourceStr */ templateContent, /* sourceParseRange */ null, 
                /* escapedString */ false, 
                /* sourceMapUrl */ template.resolvedTemplateUrl)), { content: templateContent, sourceMapping: {
                        type: 'external',
                        componentClass: node,
                        // TODO(alxhub): TS in g3 is unable to make this inference on its own, so cast it here
                        // until g3 is able to figure this out.
                        node: template.templateUrlExpression,
                        template: templateContent,
                        templateUrl: template.resolvedTemplateUrl,
                    }, declaration: template });
            }
        }
        _parseTemplate(template, sourceStr, sourceParseRange, escapedString, sourceMapUrl) {
            // We always normalize line endings if the template has been escaped (i.e. is inline).
            const i18nNormalizeLineEndingsInICUs = escapedString || this.i18nNormalizeLineEndingsInICUs;
            const parsedTemplate = parseTemplate(sourceStr, sourceMapUrl !== null && sourceMapUrl !== void 0 ? sourceMapUrl : '', {
                preserveWhitespaces: template.preserveWhitespaces,
                interpolationConfig: template.interpolationConfig,
                range: sourceParseRange !== null && sourceParseRange !== void 0 ? sourceParseRange : undefined,
                escapedString,
                enableI18nLegacyMessageIdFormat: this.enableI18nLegacyMessageIdFormat,
                i18nNormalizeLineEndingsInICUs,
                alwaysAttemptHtmlToR3AstConversion: this.usePoisonedData,
            });
            // Unfortunately, the primary parse of the template above may not contain accurate source map
            // information. If used directly, it would result in incorrect code locations in template
            // errors, etc. There are three main problems:
            //
            // 1. `preserveWhitespaces: false` annihilates the correctness of template source mapping, as
            //    the whitespace transformation changes the contents of HTML text nodes before they're
            //    parsed into Angular expressions.
            // 2. `preserveLineEndings: false` causes growing misalignments in templates that use '\r\n'
            //    line endings, by normalizing them to '\n'.
            // 3. By default, the template parser strips leading trivia characters (like spaces, tabs, and
            //    newlines). This also destroys source mapping information.
            //
            // In order to guarantee the correctness of diagnostics, templates are parsed a second time
            // with the above options set to preserve source mappings.
            const { nodes: diagNodes } = parseTemplate(sourceStr, sourceMapUrl !== null && sourceMapUrl !== void 0 ? sourceMapUrl : '', {
                preserveWhitespaces: true,
                preserveLineEndings: true,
                interpolationConfig: template.interpolationConfig,
                range: sourceParseRange !== null && sourceParseRange !== void 0 ? sourceParseRange : undefined,
                escapedString,
                enableI18nLegacyMessageIdFormat: this.enableI18nLegacyMessageIdFormat,
                i18nNormalizeLineEndingsInICUs,
                leadingTriviaChars: [],
                alwaysAttemptHtmlToR3AstConversion: this.usePoisonedData,
            });
            return Object.assign(Object.assign({}, parsedTemplate), { diagNodes, file: new ParseSourceFile(sourceStr, sourceMapUrl !== null && sourceMapUrl !== void 0 ? sourceMapUrl : '') });
        }
        parseTemplateDeclaration(decorator, component, containingFile) {
            let preserveWhitespaces = this.defaultPreserveWhitespaces;
            if (component.has('preserveWhitespaces')) {
                const expr = component.get('preserveWhitespaces');
                const value = this.evaluator.evaluate(expr);
                if (typeof value !== 'boolean') {
                    throw createValueHasWrongTypeError(expr, value, 'preserveWhitespaces must be a boolean');
                }
                preserveWhitespaces = value;
            }
            let interpolationConfig = DEFAULT_INTERPOLATION_CONFIG;
            if (component.has('interpolation')) {
                const expr = component.get('interpolation');
                const value = this.evaluator.evaluate(expr);
                if (!Array.isArray(value) || value.length !== 2 ||
                    !value.every(element => typeof element === 'string')) {
                    throw createValueHasWrongTypeError(expr, value, 'interpolation must be an array with 2 elements of string type');
                }
                interpolationConfig = InterpolationConfig.fromArray(value);
            }
            if (component.has('templateUrl')) {
                const templateUrlExpr = component.get('templateUrl');
                const templateUrl = this.evaluator.evaluate(templateUrlExpr);
                if (typeof templateUrl !== 'string') {
                    throw createValueHasWrongTypeError(templateUrlExpr, templateUrl, 'templateUrl must be a string');
                }
                try {
                    const resourceUrl = this.resourceLoader.resolve(templateUrl, containingFile);
                    return {
                        isInline: false,
                        interpolationConfig,
                        preserveWhitespaces,
                        templateUrl,
                        templateUrlExpression: templateUrlExpr,
                        resolvedTemplateUrl: resourceUrl,
                    };
                }
                catch (e) {
                    throw this.makeResourceNotFoundError(templateUrl, templateUrlExpr, 0 /* Template */);
                }
            }
            else if (component.has('template')) {
                return {
                    isInline: true,
                    interpolationConfig,
                    preserveWhitespaces,
                    expression: component.get('template'),
                    templateUrl: containingFile,
                    resolvedTemplateUrl: containingFile,
                };
            }
            else {
                throw new FatalDiagnosticError(ErrorCode.COMPONENT_MISSING_TEMPLATE, Decorator.nodeForError(decorator), 'component is missing a template');
            }
        }
        _resolveImportedFile(importedFile, expr, origin) {
            // If `importedFile` is not 'unknown' then it accurately reflects the source file that is
            // being imported.
            if (importedFile !== 'unknown') {
                return importedFile;
            }
            // Otherwise `expr` has to be inspected to determine the file that is being imported. If `expr`
            // is not an `ExternalExpr` then it does not correspond with an import, so return null in that
            // case.
            if (!(expr instanceof ExternalExpr)) {
                return null;
            }
            // Figure out what file is being imported.
            return this.moduleResolver.resolveModule(expr.value.moduleName, origin.fileName);
        }
        /**
         * Check whether adding an import from `origin` to the source-file corresponding to `expr` would
         * create a cyclic import.
         *
         * @returns a `Cycle` object if a cycle would be created, otherwise `null`.
         */
        _checkForCyclicImport(importedFile, expr, origin) {
            const imported = this._resolveImportedFile(importedFile, expr, origin);
            if (imported === null) {
                return null;
            }
            // Check whether the import is legal.
            return this.cycleAnalyzer.wouldCreateCycle(origin, imported);
        }
        _recordSyntheticImport(importedFile, expr, origin) {
            const imported = this._resolveImportedFile(importedFile, expr, origin);
            if (imported === null) {
                return;
            }
            this.cycleAnalyzer.recordSyntheticImport(origin, imported);
        }
        makeResourceNotFoundError(file, nodeForError, resourceType) {
            let errorText;
            switch (resourceType) {
                case 0 /* Template */:
                    errorText = `Could not find template file '${file}'.`;
                    break;
                case 1 /* StylesheetFromTemplate */:
                    errorText = `Could not find stylesheet file '${file}' linked from the template.`;
                    break;
                case 2 /* StylesheetFromDecorator */:
                    errorText = `Could not find stylesheet file '${file}'.`;
                    break;
            }
            return new FatalDiagnosticError(ErrorCode.COMPONENT_RESOURCE_NOT_FOUND, nodeForError, errorText);
        }
        _extractTemplateStyleUrls(template) {
            if (template.styleUrls === null) {
                return [];
            }
            const nodeForError = getTemplateDeclarationNodeForError(template.declaration);
            return template.styleUrls.map(url => ({ url, source: 1 /* StylesheetFromTemplate */, nodeForError }));
        }
    }
    function getTemplateRange(templateExpr) {
        const startPos = templateExpr.getStart() + 1;
        const { line, character } = ts$1.getLineAndCharacterOfPosition(templateExpr.getSourceFile(), startPos);
        return {
            startPos,
            startLine: line,
            startCol: character,
            endPos: templateExpr.getEnd() - 1,
        };
    }
    /** Determines if the result of an evaluation is a string array. */
    function isStringArray(resolvedValue) {
        return Array.isArray(resolvedValue) && resolvedValue.every(elem => typeof elem === 'string');
    }
    /** Determines the node to use for debugging purposes for the given TemplateDeclaration. */
    function getTemplateDeclarationNodeForError(declaration) {
        // TODO(zarend): Change this to if/else when that is compatible with g3. This uses a switch
        // because if/else fails to compile on g3. That is because g3 compiles this in non-strict mode
        // where type inference does not work correctly.
        switch (declaration.isInline) {
            case true:
                return declaration.expression;
            case false:
                return declaration.templateUrlExpression;
        }
    }
    /**
     * Generate a diagnostic related information object that describes a potential cyclic import path.
     */
    function makeCyclicImportInfo(ref, type, cycle) {
        const name = ref.debugName || '(unknown)';
        const path = cycle.getPath().map(sf => sf.fileName).join(' -> ');
        const message = `The ${type} '${name}' is used in the template but importing it would create a cycle: `;
        return makeRelatedInformation(ref.node, message + path);
    }
    /**
     * Checks whether a selector is a valid custom element tag name.
     * Based loosely on https://github.com/sindresorhus/validate-element-name.
     */
    function checkCustomElementSelectorForErrors(selector) {
        // Avoid flagging components with an attribute or class selector. This isn't bulletproof since it
        // won't catch cases like `foo[]bar`, but we don't need it to be. This is mainly to avoid flagging
        // something like `foo-bar[baz]` incorrectly.
        if (selector.includes('.') || (selector.includes('[') && selector.includes(']'))) {
            return null;
        }
        if (!(/^[a-z]/.test(selector))) {
            return 'Selector of a ShadowDom-encapsulated component must start with a lower case letter.';
        }
        if (/[A-Z]/.test(selector)) {
            return 'Selector of a ShadowDom-encapsulated component must all be in lower case.';
        }
        if (!selector.includes('-')) {
            return 'Selector of a component that uses ViewEncapsulation.ShadowDom must contain a hyphen.';
        }
        return null;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Adapts the `compileInjectable` compiler for `@Injectable` decorators to the Ivy compiler.
     */
    class InjectableDecoratorHandler {
        constructor(reflector, isCore, strictCtorDeps, injectableRegistry, perf, 
        /**
         * What to do if the injectable already contains a prov property.
         *
         * If true then an error diagnostic is reported.
         * If false then there is no error and a new prov property is not added.
         */
        errorOnDuplicateProv = true) {
            this.reflector = reflector;
            this.isCore = isCore;
            this.strictCtorDeps = strictCtorDeps;
            this.injectableRegistry = injectableRegistry;
            this.perf = perf;
            this.errorOnDuplicateProv = errorOnDuplicateProv;
            this.precedence = HandlerPrecedence.SHARED;
            this.name = InjectableDecoratorHandler.name;
        }
        detect(node, decorators) {
            if (!decorators) {
                return undefined;
            }
            const decorator = findAngularDecorator(decorators, 'Injectable', this.isCore);
            if (decorator !== undefined) {
                return {
                    trigger: decorator.node,
                    decorator: decorator,
                    metadata: decorator,
                };
            }
            else {
                return undefined;
            }
        }
        analyze(node, decorator) {
            this.perf.eventCount(PerfEvent.AnalyzeInjectable);
            const meta = extractInjectableMetadata(node, decorator, this.reflector);
            const decorators = this.reflector.getDecoratorsOfDeclaration(node);
            return {
                analysis: {
                    meta,
                    ctorDeps: extractInjectableCtorDeps(node, meta, decorator, this.reflector, this.isCore, this.strictCtorDeps),
                    classMetadata: extractClassMetadata(node, this.reflector, this.isCore),
                    // Avoid generating multiple factories if a class has
                    // more Angular decorators, apart from Injectable.
                    needsFactory: !decorators ||
                        decorators.every(current => !isAngularCore(current) || current.name === 'Injectable')
                },
            };
        }
        symbol() {
            return null;
        }
        register(node) {
            this.injectableRegistry.registerInjectable(node);
        }
        compileFull(node, analysis) {
            return this.compile(compileNgFactoryDefField, meta => compileInjectable(meta, false), compileClassMetadata, node, analysis);
        }
        compilePartial(node, analysis) {
            return this.compile(compileDeclareFactory, compileDeclareInjectableFromMetadata, compileDeclareClassMetadata, node, analysis);
        }
        compile(compileFactoryFn, compileInjectableFn, compileClassMetadataFn, node, analysis) {
            const results = [];
            if (analysis.needsFactory) {
                const meta = analysis.meta;
                const factoryRes = compileFactoryFn(toFactoryMetadata(Object.assign(Object.assign({}, meta), { deps: analysis.ctorDeps }), FactoryTarget.Injectable));
                if (analysis.classMetadata !== null) {
                    factoryRes.statements.push(compileClassMetadataFn(analysis.classMetadata).toStmt());
                }
                results.push(factoryRes);
            }
            const prov = this.reflector.getMembersOfClass(node).find(member => member.name === 'prov');
            if (prov !== undefined && this.errorOnDuplicateProv) {
                throw new FatalDiagnosticError(ErrorCode.INJECTABLE_DUPLICATE_PROV, prov.nameNode || prov.node || node, 'Injectables cannot contain a static prov property, because the compiler is going to generate one.');
            }
            if (prov === undefined) {
                // Only add a new prov if there is not one already
                const res = compileInjectableFn(analysis.meta);
                results.push({ name: 'prov', initializer: res.expression, statements: res.statements, type: res.type });
            }
            return results;
        }
    }
    /**
     * Read metadata from the `@Injectable` decorator and produce the `IvyInjectableMetadata`, the
     * input metadata needed to run `compileInjectable`.
     *
     * A `null` return value indicates this is @Injectable has invalid data.
     */
    function extractInjectableMetadata(clazz, decorator, reflector) {
        const name = clazz.name.text;
        const type = wrapTypeReference(reflector, clazz);
        const internalType = new WrappedNodeExpr(reflector.getInternalNameOfClass(clazz));
        const typeArgumentCount = reflector.getGenericArityOfClass(clazz) || 0;
        if (decorator.args === null) {
            throw new FatalDiagnosticError(ErrorCode.DECORATOR_NOT_CALLED, Decorator.nodeForError(decorator), '@Injectable must be called');
        }
        if (decorator.args.length === 0) {
            return {
                name,
                type,
                typeArgumentCount,
                internalType,
                providedIn: createR3ProviderExpression(new LiteralExpr(null), false),
            };
        }
        else if (decorator.args.length === 1) {
            const metaNode = decorator.args[0];
            // Firstly make sure the decorator argument is an inline literal - if not, it's illegal to
            // transport references from one location to another. This is the problem that lowering
            // used to solve - if this restriction proves too undesirable we can re-implement lowering.
            if (!ts$1.isObjectLiteralExpression(metaNode)) {
                throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARG_NOT_LITERAL, metaNode, `@Injectable argument must be an object literal`);
            }
            // Resolve the fields of the literal into a map of field name to expression.
            const meta = reflectObjectLiteral(metaNode);
            const providedIn = meta.has('providedIn') ?
                getProviderExpression(meta.get('providedIn'), reflector) :
                createR3ProviderExpression(new LiteralExpr(null), false);
            let deps = undefined;
            if ((meta.has('useClass') || meta.has('useFactory')) && meta.has('deps')) {
                const depsExpr = meta.get('deps');
                if (!ts$1.isArrayLiteralExpression(depsExpr)) {
                    throw new FatalDiagnosticError(ErrorCode.VALUE_NOT_LITERAL, depsExpr, `@Injectable deps metadata must be an inline array`);
                }
                deps = depsExpr.elements.map(dep => getDep(dep, reflector));
            }
            const result = { name, type, typeArgumentCount, internalType, providedIn };
            if (meta.has('useValue')) {
                result.useValue = getProviderExpression(meta.get('useValue'), reflector);
            }
            else if (meta.has('useExisting')) {
                result.useExisting = getProviderExpression(meta.get('useExisting'), reflector);
            }
            else if (meta.has('useClass')) {
                result.useClass = getProviderExpression(meta.get('useClass'), reflector);
                result.deps = deps;
            }
            else if (meta.has('useFactory')) {
                result.useFactory = new WrappedNodeExpr(meta.get('useFactory'));
                result.deps = deps;
            }
            return result;
        }
        else {
            throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, decorator.args[2], 'Too many arguments to @Injectable');
        }
    }
    /**
     * Get the `R3ProviderExpression` for this `expression`.
     *
     * The `useValue`, `useExisting` and `useClass` properties might be wrapped in a `ForwardRef`, which
     * needs to be unwrapped. This function will do that unwrapping and set a flag on the returned
     * object to indicate whether the value needed unwrapping.
     */
    function getProviderExpression(expression, reflector) {
        const forwardRefValue = tryUnwrapForwardRef(expression, reflector);
        return createR3ProviderExpression(new WrappedNodeExpr(forwardRefValue !== null && forwardRefValue !== void 0 ? forwardRefValue : expression), forwardRefValue !== null);
    }
    function extractInjectableCtorDeps(clazz, meta, decorator, reflector, isCore, strictCtorDeps) {
        if (decorator.args === null) {
            throw new FatalDiagnosticError(ErrorCode.DECORATOR_NOT_CALLED, Decorator.nodeForError(decorator), '@Injectable must be called');
        }
        let ctorDeps = null;
        if (decorator.args.length === 0) {
            // Ideally, using @Injectable() would have the same effect as using @Injectable({...}), and be
            // subject to the same validation. However, existing Angular code abuses @Injectable, applying
            // it to things like abstract classes with constructors that were never meant for use with
            // Angular's DI.
            //
            // To deal with this, @Injectable() without an argument is more lenient, and if the
            // constructor signature does not work for DI then a factory definition (fac) that throws is
            // generated.
            if (strictCtorDeps) {
                ctorDeps = getValidConstructorDependencies(clazz, reflector, isCore);
            }
            else {
                ctorDeps =
                    unwrapConstructorDependencies(getConstructorDependencies(clazz, reflector, isCore));
            }
            return ctorDeps;
        }
        else if (decorator.args.length === 1) {
            const rawCtorDeps = getConstructorDependencies(clazz, reflector, isCore);
            if (strictCtorDeps && meta.useValue === undefined && meta.useExisting === undefined &&
                meta.useClass === undefined && meta.useFactory === undefined) {
                // Since use* was not provided, validate the deps according to strictCtorDeps.
                ctorDeps = validateConstructorDependencies(clazz, rawCtorDeps);
            }
            else {
                ctorDeps = unwrapConstructorDependencies(rawCtorDeps);
            }
        }
        return ctorDeps;
    }
    function getDep(dep, reflector) {
        const meta = {
            token: new WrappedNodeExpr(dep),
            attributeNameType: null,
            host: false,
            optional: false,
            self: false,
            skipSelf: false,
        };
        function maybeUpdateDecorator(dec, reflector, token) {
            const source = reflector.getImportOfIdentifier(dec);
            if (source === null || source.from !== '@angular/core') {
                return false;
            }
            switch (source.name) {
                case 'Inject':
                    if (token !== undefined) {
                        meta.token = new WrappedNodeExpr(token);
                    }
                    break;
                case 'Optional':
                    meta.optional = true;
                    break;
                case 'SkipSelf':
                    meta.skipSelf = true;
                    break;
                case 'Self':
                    meta.self = true;
                    break;
                default:
                    return false;
            }
            return true;
        }
        if (ts$1.isArrayLiteralExpression(dep)) {
            dep.elements.forEach(el => {
                let isDecorator = false;
                if (ts$1.isIdentifier(el)) {
                    isDecorator = maybeUpdateDecorator(el, reflector);
                }
                else if (ts$1.isNewExpression(el) && ts$1.isIdentifier(el.expression)) {
                    const token = el.arguments && el.arguments.length > 0 && el.arguments[0] || undefined;
                    isDecorator = maybeUpdateDecorator(el.expression, reflector, token);
                }
                if (!isDecorator) {
                    meta.token = new WrappedNodeExpr(el);
                }
            });
        }
        return meta;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Represents an Angular pipe.
     */
    class PipeSymbol extends SemanticSymbol {
        constructor(decl, name) {
            super(decl);
            this.name = name;
        }
        isPublicApiAffected(previousSymbol) {
            if (!(previousSymbol instanceof PipeSymbol)) {
                return true;
            }
            return this.name !== previousSymbol.name;
        }
        isTypeCheckApiAffected(previousSymbol) {
            return this.isPublicApiAffected(previousSymbol);
        }
    }
    class PipeDecoratorHandler {
        constructor(reflector, evaluator, metaRegistry, scopeRegistry, injectableRegistry, isCore, perf) {
            this.reflector = reflector;
            this.evaluator = evaluator;
            this.metaRegistry = metaRegistry;
            this.scopeRegistry = scopeRegistry;
            this.injectableRegistry = injectableRegistry;
            this.isCore = isCore;
            this.perf = perf;
            this.precedence = HandlerPrecedence.PRIMARY;
            this.name = PipeDecoratorHandler.name;
        }
        detect(node, decorators) {
            if (!decorators) {
                return undefined;
            }
            const decorator = findAngularDecorator(decorators, 'Pipe', this.isCore);
            if (decorator !== undefined) {
                return {
                    trigger: decorator.node,
                    decorator: decorator,
                    metadata: decorator,
                };
            }
            else {
                return undefined;
            }
        }
        analyze(clazz, decorator) {
            this.perf.eventCount(PerfEvent.AnalyzePipe);
            const name = clazz.name.text;
            const type = wrapTypeReference(this.reflector, clazz);
            const internalType = new WrappedNodeExpr(this.reflector.getInternalNameOfClass(clazz));
            if (decorator.args === null) {
                throw new FatalDiagnosticError(ErrorCode.DECORATOR_NOT_CALLED, Decorator.nodeForError(decorator), `@Pipe must be called`);
            }
            if (decorator.args.length !== 1) {
                throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, Decorator.nodeForError(decorator), '@Pipe must have exactly one argument');
            }
            const meta = unwrapExpression(decorator.args[0]);
            if (!ts$1.isObjectLiteralExpression(meta)) {
                throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARG_NOT_LITERAL, meta, '@Pipe must have a literal argument');
            }
            const pipe = reflectObjectLiteral(meta);
            if (!pipe.has('name')) {
                throw new FatalDiagnosticError(ErrorCode.PIPE_MISSING_NAME, meta, `@Pipe decorator is missing name field`);
            }
            const pipeNameExpr = pipe.get('name');
            const pipeName = this.evaluator.evaluate(pipeNameExpr);
            if (typeof pipeName !== 'string') {
                throw createValueHasWrongTypeError(pipeNameExpr, pipeName, `@Pipe.name must be a string`);
            }
            let pure = true;
            if (pipe.has('pure')) {
                const expr = pipe.get('pure');
                const pureValue = this.evaluator.evaluate(expr);
                if (typeof pureValue !== 'boolean') {
                    throw createValueHasWrongTypeError(expr, pureValue, `@Pipe.pure must be a boolean`);
                }
                pure = pureValue;
            }
            return {
                analysis: {
                    meta: {
                        name,
                        type,
                        internalType,
                        typeArgumentCount: this.reflector.getGenericArityOfClass(clazz) || 0,
                        pipeName,
                        deps: getValidConstructorDependencies(clazz, this.reflector, this.isCore),
                        pure,
                    },
                    classMetadata: extractClassMetadata(clazz, this.reflector, this.isCore),
                    pipeNameExpr,
                },
            };
        }
        symbol(node, analysis) {
            return new PipeSymbol(node, analysis.meta.name);
        }
        register(node, analysis) {
            const ref = new Reference$1(node);
            this.metaRegistry.registerPipeMetadata({ type: MetaType.Pipe, ref, name: analysis.meta.pipeName, nameExpr: analysis.pipeNameExpr });
            this.injectableRegistry.registerInjectable(node);
        }
        resolve(node) {
            const duplicateDeclData = this.scopeRegistry.getDuplicateDeclarations(node);
            if (duplicateDeclData !== null) {
                // This pipe was declared twice (or more).
                return {
                    diagnostics: [makeDuplicateDeclarationError(node, duplicateDeclData, 'Pipe')],
                };
            }
            return {};
        }
        compileFull(node, analysis) {
            const fac = compileNgFactoryDefField(toFactoryMetadata(analysis.meta, FactoryTarget.Pipe));
            const def = compilePipeFromMetadata(analysis.meta);
            const classMetadata = analysis.classMetadata !== null ?
                compileClassMetadata(analysis.classMetadata).toStmt() :
                null;
            return compileResults(fac, def, classMetadata, 'pipe');
        }
        compilePartial(node, analysis) {
            const fac = compileDeclareFactory(toFactoryMetadata(analysis.meta, FactoryTarget.Pipe));
            const def = compileDeclarePipeFromMetadata(analysis.meta);
            const classMetadata = analysis.classMetadata !== null ?
                compileDeclareClassMetadata(analysis.classMetadata).toStmt() :
                null;
            return compileResults(fac, def, classMetadata, 'pipe');
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * This registry does nothing, since ngtsc does not currently need
     * this functionality.
     * The ngcc tool implements a working version for its purposes.
     */
    class NoopReferencesRegistry {
        add(source, ...references) { }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Analyzes a `ts.Program` for cycles.
     */
    class CycleAnalyzer {
        constructor(importGraph) {
            this.importGraph = importGraph;
            /**
             * Cycle detection is requested with the same `from` source file for all used directives and pipes
             * within a component, which makes it beneficial to cache the results as long as the `from` source
             * file has not changed. This avoids visiting the import graph that is reachable from multiple
             * directives/pipes more than once.
             */
            this.cachedResults = null;
        }
        /**
         * Check for a cycle to be created in the `ts.Program` by adding an import between `from` and
         * `to`.
         *
         * @returns a `Cycle` object if an import between `from` and `to` would create a cycle; `null`
         *     otherwise.
         */
        wouldCreateCycle(from, to) {
            // Try to reuse the cached results as long as the `from` source file is the same.
            if (this.cachedResults === null || this.cachedResults.from !== from) {
                this.cachedResults = new CycleResults(from, this.importGraph);
            }
            // Import of 'from' -> 'to' is illegal if an edge 'to' -> 'from' already exists.
            return this.cachedResults.wouldBeCyclic(to) ? new Cycle(this.importGraph, from, to) : null;
        }
        /**
         * Record a synthetic import from `from` to `to`.
         *
         * This is an import that doesn't exist in the `ts.Program` but will be considered as part of the
         * import graph for cycle creation.
         */
        recordSyntheticImport(from, to) {
            this.cachedResults = null;
            this.importGraph.addSyntheticImport(from, to);
        }
    }
    const NgCyclicResult = Symbol('NgCyclicResult');
    /**
     * Stores the results of cycle detection in a memory efficient manner. A symbol is attached to
     * source files that indicate what the cyclic analysis result is, as indicated by two markers that
     * are unique to this instance. This alleviates memory pressure in large import graphs, as each
     * execution is able to store its results in the same memory location (i.e. in the symbol
     * on the source file) as earlier executions.
     */
    class CycleResults {
        constructor(from, importGraph) {
            this.from = from;
            this.importGraph = importGraph;
            this.cyclic = {};
            this.acyclic = {};
        }
        wouldBeCyclic(sf) {
            const cached = this.getCachedResult(sf);
            if (cached !== null) {
                // The result for this source file has already been computed, so return its result.
                return cached;
            }
            if (sf === this.from) {
                // We have reached the source file that we want to create an import from, which means that
                // doing so would create a cycle.
                return true;
            }
            // Assume for now that the file will be acyclic; this prevents infinite recursion in the case
            // that `sf` is visited again as part of an existing cycle in the graph.
            this.markAcyclic(sf);
            const imports = this.importGraph.importsOf(sf);
            for (const imported of imports) {
                if (this.wouldBeCyclic(imported)) {
                    this.markCyclic(sf);
                    return true;
                }
            }
            return false;
        }
        /**
         * Returns whether the source file is already known to be cyclic, or `null` if the result is not
         * yet known.
         */
        getCachedResult(sf) {
            const result = sf[NgCyclicResult];
            if (result === this.cyclic) {
                return true;
            }
            else if (result === this.acyclic) {
                return false;
            }
            else {
                // Either the symbol is missing or its value does not correspond with one of the current
                // result markers. As such, the result is unknown.
                return null;
            }
        }
        markCyclic(sf) {
            sf[NgCyclicResult] = this.cyclic;
        }
        markAcyclic(sf) {
            sf[NgCyclicResult] = this.acyclic;
        }
    }
    /**
     * Represents an import cycle between `from` and `to` in the program.
     *
     * This class allows us to do the work to compute the cyclic path between `from` and `to` only if
     * needed.
     */
    class Cycle {
        constructor(importGraph, from, to) {
            this.importGraph = importGraph;
            this.from = from;
            this.to = to;
        }
        /**
         * Compute an array of source-files that illustrates the cyclic path between `from` and `to`.
         *
         * Note that a `Cycle` will not be created unless a path is available between `to` and `from`,
         * so `findPath()` will never return `null`.
         */
        getPath() {
            return [this.from, ...this.importGraph.findPath(this.to, this.from)];
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A cached graph of imports in the `ts.Program`.
     *
     * The `ImportGraph` keeps track of dependencies (imports) of individual `ts.SourceFile`s. Only
     * dependencies within the same program are tracked; imports into packages on NPM are not.
     */
    class ImportGraph {
        constructor(checker, perf) {
            this.checker = checker;
            this.perf = perf;
            this.imports = new Map();
        }
        /**
         * List the direct (not transitive) imports of a given `ts.SourceFile`.
         *
         * This operation is cached.
         */
        importsOf(sf) {
            if (!this.imports.has(sf)) {
                this.imports.set(sf, this.scanImports(sf));
            }
            return this.imports.get(sf);
        }
        /**
         * Find an import path from the `start` SourceFile to the `end` SourceFile.
         *
         * This function implements a breadth first search that results in finding the
         * shortest path between the `start` and `end` points.
         *
         * @param start the starting point of the path.
         * @param end the ending point of the path.
         * @returns an array of source files that connect the `start` and `end` source files, or `null` if
         *     no path could be found.
         */
        findPath(start, end) {
            if (start === end) {
                // Escape early for the case where `start` and `end` are the same.
                return [start];
            }
            const found = new Set([start]);
            const queue = [new Found(start, null)];
            while (queue.length > 0) {
                const current = queue.shift();
                const imports = this.importsOf(current.sourceFile);
                for (const importedFile of imports) {
                    if (!found.has(importedFile)) {
                        const next = new Found(importedFile, current);
                        if (next.sourceFile === end) {
                            // We have hit the target `end` path so we can stop here.
                            return next.toPath();
                        }
                        found.add(importedFile);
                        queue.push(next);
                    }
                }
            }
            return null;
        }
        /**
         * Add a record of an import from `sf` to `imported`, that's not present in the original
         * `ts.Program` but will be remembered by the `ImportGraph`.
         */
        addSyntheticImport(sf, imported) {
            if (isLocalFile(imported)) {
                this.importsOf(sf).add(imported);
            }
        }
        scanImports(sf) {
            return this.perf.inPhase(PerfPhase.CycleDetection, () => {
                const imports = new Set();
                // Look through the source file for import and export statements.
                for (const stmt of sf.statements) {
                    if ((!ts$1.isImportDeclaration(stmt) && !ts$1.isExportDeclaration(stmt)) ||
                        stmt.moduleSpecifier === undefined) {
                        continue;
                    }
                    if (ts$1.isImportDeclaration(stmt) && stmt.importClause !== undefined &&
                        stmt.importClause.isTypeOnly) {
                        // Exclude type-only imports as they are always elided, so they don't contribute to
                        // cycles.
                        continue;
                    }
                    const symbol = this.checker.getSymbolAtLocation(stmt.moduleSpecifier);
                    if (symbol === undefined || symbol.valueDeclaration === undefined) {
                        // No symbol could be found to skip over this import/export.
                        continue;
                    }
                    const moduleFile = symbol.valueDeclaration;
                    if (ts$1.isSourceFile(moduleFile) && isLocalFile(moduleFile)) {
                        // Record this local import.
                        imports.add(moduleFile);
                    }
                }
                return imports;
            });
        }
    }
    function isLocalFile(sf) {
        return !sf.isDeclarationFile;
    }
    /**
     * A helper class to track which SourceFiles are being processed when searching for a path in
     * `getPath()` above.
     */
    class Found {
        constructor(sourceFile, parent) {
            this.sourceFile = sourceFile;
            this.parent = parent;
        }
        /**
         * Back track through this found SourceFile and its ancestors to generate an array of
         * SourceFiles that form am import path between two SourceFiles.
         */
        toPath() {
            const array = [];
            let current = this;
            while (current !== null) {
                array.push(current.sourceFile);
                current = current.parent;
            }
            // Pushing and then reversing, O(n), rather than unshifting repeatedly, O(n^2), avoids
            // manipulating the array on every iteration: https://stackoverflow.com/a/26370620
            return array.reverse();
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Produce `ts.Diagnostic`s for classes that are visible from exported types (e.g. directives
     * exposed by exported `NgModule`s) that are not themselves exported.
     *
     * This function reconciles two concepts:
     *
     * A class is Exported if it's exported from the main library `entryPoint` file.
     * A class is Visible if, via Angular semantics, a downstream consumer can import an Exported class
     * and be affected by the class in question. For example, an Exported NgModule may expose a
     * directive class to its consumers. Consumers that import the NgModule may have the directive
     * applied to elements in their templates. In this case, the directive is considered Visible.
     *
     * `checkForPrivateExports` attempts to verify that all Visible classes are Exported, and report
     * `ts.Diagnostic`s for those that aren't.
     *
     * @param entryPoint `ts.SourceFile` of the library's entrypoint, which should export the library's
     * public API.
     * @param checker `ts.TypeChecker` for the current program.
     * @param refGraph `ReferenceGraph` tracking the visibility of Angular types.
     * @returns an array of `ts.Diagnostic`s representing errors when visible classes are not exported
     * properly.
     */
    function checkForPrivateExports(entryPoint, checker, refGraph) {
        const diagnostics = [];
        // Firstly, compute the exports of the entry point. These are all the Exported classes.
        const topLevelExports = new Set();
        // Do this via `ts.TypeChecker.getExportsOfModule`.
        const moduleSymbol = checker.getSymbolAtLocation(entryPoint);
        if (moduleSymbol === undefined) {
            throw new Error(`Internal error: failed to get symbol for entrypoint`);
        }
        const exportedSymbols = checker.getExportsOfModule(moduleSymbol);
        // Loop through the exported symbols, de-alias if needed, and add them to `topLevelExports`.
        // TODO(alxhub): use proper iteration when build.sh is removed. (#27762)
        exportedSymbols.forEach(symbol => {
            if (symbol.flags & ts$1.SymbolFlags.Alias) {
                symbol = checker.getAliasedSymbol(symbol);
            }
            const decl = symbol.valueDeclaration;
            if (decl !== undefined) {
                topLevelExports.add(decl);
            }
        });
        // Next, go through each exported class and expand it to the set of classes it makes Visible,
        // using the `ReferenceGraph`. For each Visible class, verify that it's also Exported, and queue
        // an error if it isn't. `checkedSet` ensures only one error is queued per class.
        const checkedSet = new Set();
        // Loop through each Exported class.
        // TODO(alxhub): use proper iteration when the legacy build is removed. (#27762)
        topLevelExports.forEach(mainExport => {
            // Loop through each class made Visible by the Exported class.
            refGraph.transitiveReferencesOf(mainExport).forEach(transitiveReference => {
                // Skip classes which have already been checked.
                if (checkedSet.has(transitiveReference)) {
                    return;
                }
                checkedSet.add(transitiveReference);
                // Verify that the Visible class is also Exported.
                if (!topLevelExports.has(transitiveReference)) {
                    // This is an error, `mainExport` makes `transitiveReference` Visible, but
                    // `transitiveReference` is not Exported from the entrypoint. Construct a diagnostic to
                    // give to the user explaining the situation.
                    const descriptor = getDescriptorOfDeclaration(transitiveReference);
                    const name = getNameOfDeclaration(transitiveReference);
                    // Construct the path of visibility, from `mainExport` to `transitiveReference`.
                    let visibleVia = 'NgModule exports';
                    const transitivePath = refGraph.pathFrom(mainExport, transitiveReference);
                    if (transitivePath !== null) {
                        visibleVia = transitivePath.map(seg => getNameOfDeclaration(seg)).join(' -> ');
                    }
                    const diagnostic = Object.assign(Object.assign({ category: ts$1.DiagnosticCategory.Error, code: ngErrorCode(ErrorCode.SYMBOL_NOT_EXPORTED), file: transitiveReference.getSourceFile() }, getPosOfDeclaration(transitiveReference)), { messageText: `Unsupported private ${descriptor} ${name}. This ${descriptor} is visible to consumers via ${visibleVia}, but is not exported from the top-level library entrypoint.` });
                    diagnostics.push(diagnostic);
                }
            });
        });
        return diagnostics;
    }
    function getPosOfDeclaration(decl) {
        const node = getIdentifierOfDeclaration(decl) || decl;
        return {
            start: node.getStart(),
            length: node.getEnd() + 1 - node.getStart(),
        };
    }
    function getIdentifierOfDeclaration(decl) {
        if ((ts$1.isClassDeclaration(decl) || ts$1.isVariableDeclaration(decl) ||
            ts$1.isFunctionDeclaration(decl)) &&
            decl.name !== undefined && ts$1.isIdentifier(decl.name)) {
            return decl.name;
        }
        else {
            return null;
        }
    }
    function getNameOfDeclaration(decl) {
        const id = getIdentifierOfDeclaration(decl);
        return id !== null ? id.text : '(unnamed)';
    }
    function getDescriptorOfDeclaration(decl) {
        switch (decl.kind) {
            case ts$1.SyntaxKind.ClassDeclaration:
                return 'class';
            case ts$1.SyntaxKind.FunctionDeclaration:
                return 'function';
            case ts$1.SyntaxKind.VariableDeclaration:
                return 'variable';
            case ts$1.SyntaxKind.EnumDeclaration:
                return 'enum';
            default:
                return 'declaration';
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class ReferenceGraph {
        constructor() {
            this.references = new Map();
        }
        add(from, to) {
            if (!this.references.has(from)) {
                this.references.set(from, new Set());
            }
            this.references.get(from).add(to);
        }
        transitiveReferencesOf(target) {
            const set = new Set();
            this.collectTransitiveReferences(set, target);
            return set;
        }
        pathFrom(source, target) {
            return this.collectPathFrom(source, target, new Set());
        }
        collectPathFrom(source, target, seen) {
            if (source === target) {
                // Looking for a path from the target to itself - that path is just the target. This is the
                // "base case" of the search.
                return [target];
            }
            else if (seen.has(source)) {
                // The search has already looked through this source before.
                return null;
            }
            // Consider outgoing edges from `source`.
            seen.add(source);
            if (!this.references.has(source)) {
                // There are no outgoing edges from `source`.
                return null;
            }
            else {
                // Look through the outgoing edges of `source`.
                // TODO(alxhub): use proper iteration when the legacy build is removed. (#27762)
                let candidatePath = null;
                this.references.get(source).forEach(edge => {
                    // Early exit if a path has already been found.
                    if (candidatePath !== null) {
                        return;
                    }
                    // Look for a path from this outgoing edge to `target`.
                    const partialPath = this.collectPathFrom(edge, target, seen);
                    if (partialPath !== null) {
                        // A path exists from `edge` to `target`. Insert `source` at the beginning.
                        candidatePath = [source, ...partialPath];
                    }
                });
                return candidatePath;
            }
        }
        collectTransitiveReferences(set, decl) {
            if (this.references.has(decl)) {
                // TODO(alxhub): use proper iteration when the legacy build is removed. (#27762)
                this.references.get(decl).forEach(ref => {
                    if (!set.has(ref)) {
                        set.add(ref);
                        this.collectTransitiveReferences(set, ref);
                    }
                });
            }
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const NgOriginalFile = Symbol('NgOriginalFile');
    var UpdateMode;
    (function (UpdateMode) {
        /**
         * A complete update creates a completely new overlay of type-checking code on top of the user's
         * original program, which doesn't include type-checking code from previous calls to
         * `updateFiles`.
         */
        UpdateMode[UpdateMode["Complete"] = 0] = "Complete";
        /**
         * An incremental update changes the contents of some files in the type-checking program without
         * reverting any prior changes.
         */
        UpdateMode[UpdateMode["Incremental"] = 1] = "Incremental";
    })(UpdateMode || (UpdateMode = {}));

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A `Symbol` which is used to patch extension data onto `ts.SourceFile`s.
     */
    const NgExtension = Symbol('NgExtension');
    /**
     * Narrows a `ts.SourceFile` if it has an `NgExtension` property.
     */
    function isExtended(sf) {
        return sf[NgExtension] !== undefined;
    }
    /**
     * Check whether `sf` is a shim `ts.SourceFile` (either a per-file shim or a top-level shim).
     */
    function isShim(sf) {
        return isExtended(sf) && (sf[NgExtension].fileShim !== null || sf[NgExtension].isTopLevelShim);
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const STRIP_NG_FACTORY = /(.*)NgFactory$/;
    function generatedFactoryTransform(factoryMap, importRewriter) {
        return (context) => {
            return (file) => {
                return transformFactorySourceFile(factoryMap, context, importRewriter, file);
            };
        };
    }
    function transformFactorySourceFile(factoryMap, context, importRewriter, file) {
        // If this is not a generated file, it won't have factory info associated with it.
        if (!factoryMap.has(file.fileName)) {
            // Don't transform non-generated code.
            return file;
        }
        const { moduleSymbols, sourceFilePath } = factoryMap.get(file.fileName);
        // Not every exported factory statement is valid. They were generated before the program was
        // analyzed, and before ngtsc knew which symbols were actually NgModules. factoryMap contains
        // that knowledge now, so this transform filters the statement list and removes exported factories
        // that aren't actually factories.
        //
        // This could leave the generated factory file empty. To prevent this (it causes issues with
        // closure compiler) a 'NonEmptyModule' export was added when the factory shim was created.
        // Preserve that export if needed, and remove it otherwise.
        //
        // Additionally, an import to @angular/core is generated, but the current compilation unit could
        // actually be @angular/core, in which case such an import is invalid and should be replaced with
        // the proper path to access Ivy symbols in core.
        // The filtered set of statements.
        const transformedStatements = [];
        // The statement identified as the NonEmptyModule export.
        let nonEmptyExport = null;
        // Extracted identifiers which refer to import statements from @angular/core.
        const coreImportIdentifiers = new Set();
        // Consider all the statements.
        for (const stmt of file.statements) {
            // Look for imports to @angular/core.
            if (ts$1.isImportDeclaration(stmt) && ts$1.isStringLiteral(stmt.moduleSpecifier) &&
                stmt.moduleSpecifier.text === '@angular/core') {
                // Update the import path to point to the correct file using the ImportRewriter.
                const rewrittenModuleSpecifier = importRewriter.rewriteSpecifier('@angular/core', sourceFilePath);
                if (rewrittenModuleSpecifier !== stmt.moduleSpecifier.text) {
                    transformedStatements.push(ts$1.updateImportDeclaration(stmt, stmt.decorators, stmt.modifiers, stmt.importClause, ts$1.createStringLiteral(rewrittenModuleSpecifier)));
                    // Record the identifier by which this imported module goes, so references to its symbols
                    // can be discovered later.
                    if (stmt.importClause !== undefined && stmt.importClause.namedBindings !== undefined &&
                        ts$1.isNamespaceImport(stmt.importClause.namedBindings)) {
                        coreImportIdentifiers.add(stmt.importClause.namedBindings.name.text);
                    }
                }
                else {
                    transformedStatements.push(stmt);
                }
            }
            else if (ts$1.isVariableStatement(stmt) && stmt.declarationList.declarations.length === 1) {
                const decl = stmt.declarationList.declarations[0];
                // If this is the NonEmptyModule export, then save it for later.
                if (ts$1.isIdentifier(decl.name)) {
                    if (decl.name.text === 'NonEmptyModule') {
                        nonEmptyExport = stmt;
                        continue;
                    }
                    // Otherwise, check if this export is a factory for a known NgModule, and retain it if so.
                    const match = STRIP_NG_FACTORY.exec(decl.name.text);
                    const module = match ? moduleSymbols.get(match[1]) : null;
                    if (module) {
                        // If the module can be tree shaken, then the factory should be wrapped in a
                        // `noSideEffects()` call which tells Closure to treat the expression as pure, allowing
                        // it to be removed if the result is not used.
                        //
                        // `NgModule`s with an `id` property will be lazy loaded. Google-internal lazy loading
                        // infra relies on a side effect from the `new NgModuleFactory()` call, which registers
                        // the module globally. Because of this, we **cannot** tree shake any module which has
                        // an `id` property. Doing so would cause lazy loaded modules to never be registered.
                        const moduleIsTreeShakable = !module.hasId;
                        const newStmt = !moduleIsTreeShakable ?
                            stmt :
                            updateInitializers(stmt, (init) => init ? wrapInNoSideEffects(init) : undefined);
                        transformedStatements.push(newStmt);
                    }
                }
                else {
                    // Leave the statement alone, as it can't be understood.
                    transformedStatements.push(stmt);
                }
            }
            else {
                // Include non-variable statements (imports, etc).
                transformedStatements.push(stmt);
            }
        }
        // Check whether the empty module export is still needed.
        if (!transformedStatements.some(ts$1.isVariableStatement) && nonEmptyExport !== null) {
            // If the resulting file has no factories, include an empty export to
            // satisfy closure compiler.
            transformedStatements.push(nonEmptyExport);
        }
        file = ts$1.updateSourceFileNode(file, transformedStatements);
        // If any imports to @angular/core were detected and rewritten (which happens when compiling
        // @angular/core), go through the SourceFile and rewrite references to symbols imported from core.
        if (coreImportIdentifiers.size > 0) {
            const visit = (node) => {
                node = ts$1.visitEachChild(node, child => visit(child), context);
                // Look for expressions of the form "i.s" where 'i' is a detected name for an @angular/core
                // import that was changed above. Rewrite 's' using the ImportResolver.
                if (ts$1.isPropertyAccessExpression(node) && ts$1.isIdentifier(node.expression) &&
                    coreImportIdentifiers.has(node.expression.text)) {
                    // This is an import of a symbol from @angular/core. Transform it with the importRewriter.
                    const rewrittenSymbol = importRewriter.rewriteSymbol(node.name.text, '@angular/core');
                    if (rewrittenSymbol !== node.name.text) {
                        const updated = ts$1.updatePropertyAccess(node, node.expression, ts$1.createIdentifier(rewrittenSymbol));
                        node = updated;
                    }
                }
                return node;
            };
            file = visit(file);
        }
        return file;
    }
    /**
     * Wraps the given expression in a call to `noSideEffects()`, which tells
     * Closure we don't care about the side effects of this expression and it should
     * be treated as "pure". Closure is free to tree shake this expression if its
     * result is not used.
     *
     * Example: Takes `1 + 2` and returns `i0.noSideEffects(() => 1 + 2)`.
     */
    function wrapInNoSideEffects(expr) {
        const noSideEffects = ts$1.createPropertyAccess(ts$1.createIdentifier('i0'), 'noSideEffects');
        return ts$1.createCall(noSideEffects, 
        /* typeArguments */ [], 
        /* arguments */
        [
            ts$1.createFunctionExpression(
            /* modifiers */ [], 
            /* asteriskToken */ undefined, 
            /* name */ undefined, 
            /* typeParameters */ [], 
            /* parameters */ [], 
            /* type */ undefined, 
            /* body */ ts$1.createBlock([
                ts$1.createReturn(expr),
            ])),
        ]);
    }
    /**
     * Clones and updates the initializers for a given statement to use the new
     * expression provided. Does not mutate the input statement.
     */
    function updateInitializers(stmt, update) {
        return ts$1.updateVariableStatement(stmt, stmt.modifiers, ts$1.updateVariableDeclarationList(stmt.declarationList, stmt.declarationList.declarations.map((decl) => ts$1.updateVariableDeclaration(decl, decl.name, decl.type, update(decl.initializer)))));
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * An implementation of the `DependencyTracker` dependency graph API.
     *
     * The `FileDependencyGraph`'s primary job is to determine whether a given file has "logically"
     * changed, given the set of physical changes (direct changes to files on disk).
     *
     * A file is logically changed if at least one of three conditions is met:
     *
     * 1. The file itself has physically changed.
     * 2. One of its dependencies has physically changed.
     * 3. One of its resource dependencies has physically changed.
     */
    class FileDependencyGraph {
        constructor() {
            this.nodes = new Map();
        }
        addDependency(from, on) {
            this.nodeFor(from).dependsOn.add(absoluteFromSourceFile(on));
        }
        addResourceDependency(from, resource) {
            this.nodeFor(from).usesResources.add(resource);
        }
        recordDependencyAnalysisFailure(file) {
            this.nodeFor(file).failedAnalysis = true;
        }
        getResourceDependencies(from) {
            const node = this.nodes.get(from);
            return node ? [...node.usesResources] : [];
        }
        /**
         * Update the current dependency graph from a previous one, incorporating a set of physical
         * changes.
         *
         * This method performs two tasks:
         *
         * 1. For files which have not logically changed, their dependencies from `previous` are added to
         *    `this` graph.
         * 2. For files which have logically changed, they're added to a set of logically changed files
         *    which is eventually returned.
         *
         * In essence, for build `n`, this method performs:
         *
         * G(n) + L(n) = G(n - 1) + P(n)
         *
         * where:
         *
         * G(n) = the dependency graph of build `n`
         * L(n) = the logically changed files from build n - 1 to build n.
         * P(n) = the physically changed files from build n - 1 to build n.
         */
        updateWithPhysicalChanges(previous, changedTsPaths, deletedTsPaths, changedResources) {
            const logicallyChanged = new Set();
            for (const sf of previous.nodes.keys()) {
                const sfPath = absoluteFromSourceFile(sf);
                const node = previous.nodeFor(sf);
                if (isLogicallyChanged(sf, node, changedTsPaths, deletedTsPaths, changedResources)) {
                    logicallyChanged.add(sfPath);
                }
                else if (!deletedTsPaths.has(sfPath)) {
                    this.nodes.set(sf, {
                        dependsOn: new Set(node.dependsOn),
                        usesResources: new Set(node.usesResources),
                        failedAnalysis: false,
                    });
                }
            }
            return logicallyChanged;
        }
        nodeFor(sf) {
            if (!this.nodes.has(sf)) {
                this.nodes.set(sf, {
                    dependsOn: new Set(),
                    usesResources: new Set(),
                    failedAnalysis: false,
                });
            }
            return this.nodes.get(sf);
        }
    }
    /**
     * Determine whether `sf` has logically changed, given its dependencies and the set of physically
     * changed files and resources.
     */
    function isLogicallyChanged(sf, node, changedTsPaths, deletedTsPaths, changedResources) {
        // A file is assumed to have logically changed if its dependencies could not be determined
        // accurately.
        if (node.failedAnalysis) {
            return true;
        }
        const sfPath = absoluteFromSourceFile(sf);
        // A file is logically changed if it has physically changed itself (including being deleted).
        if (changedTsPaths.has(sfPath) || deletedTsPaths.has(sfPath)) {
            return true;
        }
        // A file is logically changed if one of its dependencies has physically changed.
        for (const dep of node.dependsOn) {
            if (changedTsPaths.has(dep) || deletedTsPaths.has(dep)) {
                return true;
            }
        }
        // A file is logically changed if one of its resources has physically changed.
        for (const dep of node.usesResources) {
            if (changedResources.has(dep)) {
                return true;
            }
        }
        return false;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Discriminant of the `IncrementalState` union.
     */
    var IncrementalStateKind;
    (function (IncrementalStateKind) {
        IncrementalStateKind[IncrementalStateKind["Fresh"] = 0] = "Fresh";
        IncrementalStateKind[IncrementalStateKind["Delta"] = 1] = "Delta";
        IncrementalStateKind[IncrementalStateKind["Analyzed"] = 2] = "Analyzed";
    })(IncrementalStateKind || (IncrementalStateKind = {}));

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Discriminant of the `Phase` type union.
     */
    var PhaseKind;
    (function (PhaseKind) {
        PhaseKind[PhaseKind["Analysis"] = 0] = "Analysis";
        PhaseKind[PhaseKind["TypeCheckAndEmit"] = 1] = "TypeCheckAndEmit";
    })(PhaseKind || (PhaseKind = {}));
    /**
     * Manages the incremental portion of an Angular compilation, allowing for reuse of a prior
     * compilation if available, and producing an output state for reuse of the current compilation in a
     * future one.
     */
    class IncrementalCompilation {
        constructor(state, depGraph, versions, step) {
            this.depGraph = depGraph;
            this.versions = versions;
            this.step = step;
            this._state = state;
            // The compilation begins in analysis phase.
            this.phase = {
                kind: PhaseKind.Analysis,
                semanticDepGraphUpdater: new SemanticDepGraphUpdater(step !== null ? step.priorState.semanticDepGraph : null),
            };
        }
        /**
         * Begin a fresh `IncrementalCompilation`.
         */
        static fresh(program, versions) {
            const state = {
                kind: IncrementalStateKind.Fresh,
            };
            return new IncrementalCompilation(state, new FileDependencyGraph(), versions, /* reuse */ null);
        }
        static incremental(program, newVersions, oldProgram, oldState, modifiedResourceFiles, perf) {
            return perf.inPhase(PerfPhase.Reconciliation, () => {
                const physicallyChangedTsFiles = new Set();
                const changedResourceFiles = new Set(modifiedResourceFiles !== null && modifiedResourceFiles !== void 0 ? modifiedResourceFiles : []);
                let priorAnalysis;
                switch (oldState.kind) {
                    case IncrementalStateKind.Fresh:
                        // Since this line of program has never been successfully analyzed to begin with, treat
                        // this as a fresh compilation.
                        return IncrementalCompilation.fresh(program, newVersions);
                    case IncrementalStateKind.Analyzed:
                        // The most recent program was analyzed successfully, so we can use that as our prior
                        // state and don't need to consider any other deltas except changes in the most recent
                        // program.
                        priorAnalysis = oldState;
                        break;
                    case IncrementalStateKind.Delta:
                        // There is an ancestor program which was analyzed successfully and can be used as a
                        // starting point, but we need to determine what's changed since that program.
                        priorAnalysis = oldState.lastAnalyzedState;
                        for (const sfPath of oldState.physicallyChangedTsFiles) {
                            physicallyChangedTsFiles.add(sfPath);
                        }
                        for (const resourcePath of oldState.changedResourceFiles) {
                            changedResourceFiles.add(resourcePath);
                        }
                        break;
                }
                const oldVersions = priorAnalysis.versions;
                const oldFilesArray = oldProgram.getSourceFiles().map(toOriginalSourceFile);
                const oldFiles = new Set(oldFilesArray);
                const deletedTsFiles = new Set(oldFilesArray.map(sf => absoluteFromSourceFile(sf)));
                for (const possiblyRedirectedNewFile of program.getSourceFiles()) {
                    const sf = toOriginalSourceFile(possiblyRedirectedNewFile);
                    const sfPath = absoluteFromSourceFile(sf);
                    // Since we're seeing a file in the incoming program with this name, it can't have been
                    // deleted.
                    deletedTsFiles.delete(sfPath);
                    if (oldFiles.has(sf)) {
                        // This source file has the same object identity as in the previous program. We need to
                        // determine if it's really the same file, or if it might have changed versions since the
                        // last program without changing its identity.
                        // If there's no version information available, then this is the same file, and we can
                        // skip it.
                        if (oldVersions === null || newVersions === null) {
                            continue;
                        }
                        // If a version is available for the file from both the prior and the current program, and
                        // that version is the same, then this is the same file, and we can skip it.
                        if (oldVersions.has(sfPath) && newVersions.has(sfPath) &&
                            oldVersions.get(sfPath) === newVersions.get(sfPath)) {
                            continue;
                        }
                        // Otherwise, assume that the file has changed. Either its versions didn't match, or we
                        // were missing version information about it on one side for some reason.
                    }
                    // Bail out if a .d.ts file changes - the semantic dep graph is not able to process such
                    // changes correctly yet.
                    if (sf.isDeclarationFile) {
                        return IncrementalCompilation.fresh(program, newVersions);
                    }
                    // The file has changed physically, so record it.
                    physicallyChangedTsFiles.add(sfPath);
                }
                // Remove any files that have been deleted from the list of physical changes.
                for (const deletedFileName of deletedTsFiles) {
                    physicallyChangedTsFiles.delete(resolve(deletedFileName));
                }
                // Use the prior dependency graph to project physical changes into a set of logically changed
                // files.
                const depGraph = new FileDependencyGraph();
                const logicallyChangedTsFiles = depGraph.updateWithPhysicalChanges(priorAnalysis.depGraph, physicallyChangedTsFiles, deletedTsFiles, changedResourceFiles);
                // Physically changed files aren't necessarily counted as logically changed by the dependency
                // graph (files do not have edges to themselves), so add them to the logical changes
                // explicitly.
                for (const sfPath of physicallyChangedTsFiles) {
                    logicallyChangedTsFiles.add(sfPath);
                }
                // Start off in a `DeltaIncrementalState` as a delta against the previous successful analysis,
                // until this compilation completes its own analysis.
                const state = {
                    kind: IncrementalStateKind.Delta,
                    physicallyChangedTsFiles,
                    changedResourceFiles,
                    lastAnalyzedState: priorAnalysis,
                };
                return new IncrementalCompilation(state, depGraph, newVersions, {
                    priorState: priorAnalysis,
                    logicallyChangedTsFiles,
                });
            });
        }
        get state() {
            return this._state;
        }
        get semanticDepGraphUpdater() {
            if (this.phase.kind !== PhaseKind.Analysis) {
                throw new Error(`AssertionError: Cannot update the SemanticDepGraph after analysis completes`);
            }
            return this.phase.semanticDepGraphUpdater;
        }
        recordSuccessfulAnalysis(traitCompiler) {
            if (this.phase.kind !== PhaseKind.Analysis) {
                throw new Error(`AssertionError: Incremental compilation in phase ${PhaseKind[this.phase.kind]}, expected Analysis`);
            }
            const { needsEmit, needsTypeCheckEmit, newGraph } = this.phase.semanticDepGraphUpdater.finalize();
            // Determine the set of files which have already been emitted.
            let emitted;
            if (this.step === null) {
                // Since there is no prior compilation, no files have yet been emitted.
                emitted = new Set();
            }
            else {
                // Begin with the files emitted by the prior successful compilation, but remove those which we
                // know need to bee re-emitted.
                emitted = new Set(this.step.priorState.emitted);
                // Files need re-emitted if they've logically changed.
                for (const sfPath of this.step.logicallyChangedTsFiles) {
                    emitted.delete(sfPath);
                }
                // Files need re-emitted if they've semantically changed.
                for (const sfPath of needsEmit) {
                    emitted.delete(sfPath);
                }
            }
            // Transition to a successfully analyzed compilation. At this point, a subsequent compilation
            // could use this state as a starting point.
            this._state = {
                kind: IncrementalStateKind.Analyzed,
                versions: this.versions,
                depGraph: this.depGraph,
                semanticDepGraph: newGraph,
                priorAnalysis: traitCompiler.getAnalyzedRecords(),
                typeCheckResults: null,
                emitted,
            };
            // We now enter the type-check and emit phase of compilation.
            this.phase = {
                kind: PhaseKind.TypeCheckAndEmit,
                needsEmit,
                needsTypeCheckEmit,
            };
        }
        recordSuccessfulTypeCheck(results) {
            if (this._state.kind !== IncrementalStateKind.Analyzed) {
                throw new Error(`AssertionError: Expected successfully analyzed compilation.`);
            }
            else if (this.phase.kind !== PhaseKind.TypeCheckAndEmit) {
                throw new Error(`AssertionError: Incremental compilation in phase ${PhaseKind[this.phase.kind]}, expected TypeCheck`);
            }
            this._state.typeCheckResults = results;
        }
        recordSuccessfulEmit(sf) {
            if (this._state.kind !== IncrementalStateKind.Analyzed) {
                throw new Error(`AssertionError: Expected successfully analyzed compilation.`);
            }
            this._state.emitted.add(absoluteFromSourceFile(sf));
        }
        priorAnalysisFor(sf) {
            if (this.step === null) {
                return null;
            }
            const sfPath = absoluteFromSourceFile(sf);
            // If the file has logically changed, its previous analysis cannot be reused.
            if (this.step.logicallyChangedTsFiles.has(sfPath)) {
                return null;
            }
            const priorAnalysis = this.step.priorState.priorAnalysis;
            if (!priorAnalysis.has(sf)) {
                return null;
            }
            return priorAnalysis.get(sf);
        }
        priorTypeCheckingResultsFor(sf) {
            if (this.phase.kind !== PhaseKind.TypeCheckAndEmit) {
                throw new Error(`AssertionError: Expected successfully analyzed compilation.`);
            }
            if (this.step === null) {
                return null;
            }
            const sfPath = absoluteFromSourceFile(sf);
            // If the file has logically changed, or its template type-checking results have semantically
            // changed, then past type-checking results cannot be reused.
            if (this.step.logicallyChangedTsFiles.has(sfPath) ||
                this.phase.needsTypeCheckEmit.has(sfPath)) {
                return null;
            }
            // Past results also cannot be reused if they're not available.
            if (this.step.priorState.typeCheckResults === null ||
                !this.step.priorState.typeCheckResults.has(sfPath)) {
                return null;
            }
            const priorResults = this.step.priorState.typeCheckResults.get(sfPath);
            // If the past results relied on inlining, they're not safe for reuse.
            if (priorResults.hasInlines) {
                return null;
            }
            return priorResults;
        }
        safeToSkipEmit(sf) {
            // If this is a fresh compilation, it's never safe to skip an emit.
            if (this.step === null) {
                return false;
            }
            const sfPath = absoluteFromSourceFile(sf);
            // If the file has itself logically changed, it must be emitted.
            if (this.step.logicallyChangedTsFiles.has(sfPath)) {
                return false;
            }
            if (this.phase.kind !== PhaseKind.TypeCheckAndEmit) {
                throw new Error(`AssertionError: Expected successful analysis before attempting to emit files`);
            }
            // If during analysis it was determined that this file has semantically changed, it must be
            // emitted.
            if (this.phase.needsEmit.has(sfPath)) {
                return false;
            }
            // Generally it should be safe to assume here that the file was previously emitted by the last
            // successful compilation. However, as a defense-in-depth against incorrectness, we explicitly
            // check that the last emit included this file, and re-emit it otherwise.
            return this.step.priorState.emitted.has(sfPath);
        }
    }
    /**
     * To accurately detect whether a source file was affected during an incremental rebuild, the
     * "original" source file needs to be consistently used.
     *
     * First, TypeScript may have created source file redirects when declaration files of the same
     * version of a library are included multiple times. The non-redirected source file should be used
     * to detect changes, as otherwise the redirected source files cause a mismatch when compared to
     * a prior program.
     *
     * Second, the program that is used for template type checking may contain mutated source files, if
     * inline type constructors or inline template type-check blocks had to be used. Such source files
     * store their original, non-mutated source file from the original program in a symbol. For
     * computing the affected files in an incremental build this original source file should be used, as
     * the mutated source file would always be considered affected.
     */
    function toOriginalSourceFile(sf) {
        const unredirectedSf = toUnredirectedSourceFile(sf);
        const originalFile = unredirectedSf[NgOriginalFile];
        if (originalFile !== undefined) {
            return originalFile;
        }
        else {
            return unredirectedSf;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Tracks an `IncrementalDriver` within the strategy itself.
     */
    class TrackedIncrementalBuildStrategy {
        constructor() {
            this.state = null;
            this.isSet = false;
        }
        getIncrementalState() {
            return this.state;
        }
        setIncrementalState(state) {
            this.state = state;
            this.isSet = true;
        }
        toNextBuildStrategy() {
            const strategy = new TrackedIncrementalBuildStrategy();
            // Only reuse state that was explicitly set via `setIncrementalState`.
            strategy.state = this.isSet ? this.state : null;
            return strategy;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Describes the kind of identifier found in a template.
     */
    var IdentifierKind;
    (function (IdentifierKind) {
        IdentifierKind[IdentifierKind["Property"] = 0] = "Property";
        IdentifierKind[IdentifierKind["Method"] = 1] = "Method";
        IdentifierKind[IdentifierKind["Element"] = 2] = "Element";
        IdentifierKind[IdentifierKind["Template"] = 3] = "Template";
        IdentifierKind[IdentifierKind["Attribute"] = 4] = "Attribute";
        IdentifierKind[IdentifierKind["Reference"] = 5] = "Reference";
        IdentifierKind[IdentifierKind["Variable"] = 6] = "Variable";
    })(IdentifierKind || (IdentifierKind = {}));
    /**
     * Describes the absolute byte offsets of a text anchor in a source code.
     */
    class AbsoluteSourceSpan$1 {
        constructor(start, end) {
            this.start = start;
            this.end = end;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A context for storing indexing infromation about components of a program.
     *
     * An `IndexingContext` collects component and template analysis information from
     * `DecoratorHandler`s and exposes them to be indexed.
     */
    class IndexingContext {
        constructor() {
            this.components = new Set();
        }
        /**
         * Adds a component to the context.
         */
        addComponent(info) {
            this.components.add(info);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Visits the AST of an Angular template syntax expression, finding interesting
     * entities (variable references, etc.). Creates an array of Entities found in
     * the expression, with the location of the Entities being relative to the
     * expression.
     *
     * Visiting `text {{prop}}` will return
     * `[TopLevelIdentifier {name: 'prop', span: {start: 7, end: 11}}]`.
     */
    class ExpressionVisitor extends RecursiveAstVisitor {
        constructor(expressionStr, absoluteOffset, boundTemplate, targetToIdentifier) {
            super();
            this.expressionStr = expressionStr;
            this.absoluteOffset = absoluteOffset;
            this.boundTemplate = boundTemplate;
            this.targetToIdentifier = targetToIdentifier;
            this.identifiers = [];
        }
        /**
         * Returns identifiers discovered in an expression.
         *
         * @param ast expression AST to visit
         * @param source expression AST source code
         * @param absoluteOffset absolute byte offset from start of the file to the start of the AST
         * source code.
         * @param boundTemplate bound target of the entire template, which can be used to query for the
         * entities expressions target.
         * @param targetToIdentifier closure converting a template target node to its identifier.
         */
        static getIdentifiers(ast, source, absoluteOffset, boundTemplate, targetToIdentifier) {
            const visitor = new ExpressionVisitor(source, absoluteOffset, boundTemplate, targetToIdentifier);
            visitor.visit(ast);
            return visitor.identifiers;
        }
        visit(ast) {
            ast.visit(this);
        }
        visitMethodCall(ast, context) {
            this.visitIdentifier(ast, IdentifierKind.Method);
            super.visitMethodCall(ast, context);
        }
        visitPropertyRead(ast, context) {
            this.visitIdentifier(ast, IdentifierKind.Property);
            super.visitPropertyRead(ast, context);
        }
        visitPropertyWrite(ast, context) {
            this.visitIdentifier(ast, IdentifierKind.Property);
            super.visitPropertyWrite(ast, context);
        }
        /**
         * Visits an identifier, adding it to the identifier store if it is useful for indexing.
         *
         * @param ast expression AST the identifier is in
         * @param kind identifier kind
         */
        visitIdentifier(ast, kind) {
            // The definition of a non-top-level property such as `bar` in `{{foo.bar}}` is currently
            // impossible to determine by an indexer and unsupported by the indexing module.
            // The indexing module also does not currently support references to identifiers declared in the
            // template itself, which have a non-null expression target.
            if (!(ast.receiver instanceof ImplicitReceiver)) {
                return;
            }
            // The source span of the requested AST starts at a location that is offset from the expression.
            const identifierStart = ast.sourceSpan.start - this.absoluteOffset;
            if (!this.expressionStr.substring(identifierStart).startsWith(ast.name)) {
                throw new Error(`Impossible state: "${ast.name}" not found in "${this.expressionStr}" at location ${identifierStart}`);
            }
            // Join the relative position of the expression within a node with the absolute position
            // of the node to get the absolute position of the expression in the source code.
            const absoluteStart = this.absoluteOffset + identifierStart;
            const span = new AbsoluteSourceSpan$1(absoluteStart, absoluteStart + ast.name.length);
            const targetAst = this.boundTemplate.getExpressionTarget(ast);
            const target = targetAst ? this.targetToIdentifier(targetAst) : null;
            const identifier = {
                name: ast.name,
                span,
                kind,
                target,
            };
            this.identifiers.push(identifier);
        }
    }
    /**
     * Visits the AST of a parsed Angular template. Discovers and stores
     * identifiers of interest, deferring to an `ExpressionVisitor` as needed.
     */
    class TemplateVisitor extends RecursiveVisitor {
        /**
         * Creates a template visitor for a bound template target. The bound target can be used when
         * deferred to the expression visitor to get information about the target of an expression.
         *
         * @param boundTemplate bound template target
         */
        constructor(boundTemplate) {
            super();
            this.boundTemplate = boundTemplate;
            // Identifiers of interest found in the template.
            this.identifiers = new Set();
            // Map of targets in a template to their identifiers.
            this.targetIdentifierCache = new Map();
            // Map of elements and templates to their identifiers.
            this.elementAndTemplateIdentifierCache = new Map();
        }
        /**
         * Visits a node in the template.
         *
         * @param node node to visit
         */
        visit(node) {
            node.visit(this);
        }
        visitAll(nodes) {
            nodes.forEach(node => this.visit(node));
        }
        /**
         * Add an identifier for an HTML element and visit its children recursively.
         *
         * @param element
         */
        visitElement(element) {
            const elementIdentifier = this.elementOrTemplateToIdentifier(element);
            this.identifiers.add(elementIdentifier);
            this.visitAll(element.references);
            this.visitAll(element.inputs);
            this.visitAll(element.attributes);
            this.visitAll(element.children);
            this.visitAll(element.outputs);
        }
        visitTemplate(template) {
            const templateIdentifier = this.elementOrTemplateToIdentifier(template);
            this.identifiers.add(templateIdentifier);
            this.visitAll(template.variables);
            this.visitAll(template.attributes);
            this.visitAll(template.templateAttrs);
            this.visitAll(template.children);
            this.visitAll(template.references);
        }
        visitBoundAttribute(attribute) {
            // If the bound attribute has no value, it cannot have any identifiers in the value expression.
            if (attribute.valueSpan === undefined) {
                return;
            }
            const identifiers = ExpressionVisitor.getIdentifiers(attribute.value, attribute.valueSpan.toString(), attribute.valueSpan.start.offset, this.boundTemplate, this.targetToIdentifier.bind(this));
            identifiers.forEach(id => this.identifiers.add(id));
        }
        visitBoundEvent(attribute) {
            this.visitExpression(attribute.handler);
        }
        visitBoundText(text) {
            this.visitExpression(text.value);
        }
        visitReference(reference) {
            const referenceIdentifer = this.targetToIdentifier(reference);
            this.identifiers.add(referenceIdentifer);
        }
        visitVariable(variable) {
            const variableIdentifier = this.targetToIdentifier(variable);
            this.identifiers.add(variableIdentifier);
        }
        /** Creates an identifier for a template element or template node. */
        elementOrTemplateToIdentifier(node) {
            // If this node has already been seen, return the cached result.
            if (this.elementAndTemplateIdentifierCache.has(node)) {
                return this.elementAndTemplateIdentifierCache.get(node);
            }
            let name;
            let kind;
            if (node instanceof Template) {
                name = node.tagName;
                kind = IdentifierKind.Template;
            }
            else {
                name = node.name;
                kind = IdentifierKind.Element;
            }
            const sourceSpan = node.startSourceSpan;
            // An element's or template's source span can be of the form `<element>`, `<element />`, or
            // `<element></element>`. Only the selector is interesting to the indexer, so the source is
            // searched for the first occurrence of the element (selector) name.
            const start = this.getStartLocation(name, sourceSpan);
            const absoluteSpan = new AbsoluteSourceSpan$1(start, start + name.length);
            // Record the nodes's attributes, which an indexer can later traverse to see if any of them
            // specify a used directive on the node.
            const attributes = node.attributes.map(({ name, sourceSpan }) => {
                return {
                    name,
                    span: new AbsoluteSourceSpan$1(sourceSpan.start.offset, sourceSpan.end.offset),
                    kind: IdentifierKind.Attribute,
                };
            });
            const usedDirectives = this.boundTemplate.getDirectivesOfNode(node) || [];
            const identifier = {
                name,
                span: absoluteSpan,
                kind,
                attributes: new Set(attributes),
                usedDirectives: new Set(usedDirectives.map(dir => {
                    return {
                        node: dir.ref.node,
                        selector: dir.selector,
                    };
                })),
                // cast b/c pre-TypeScript 3.5 unions aren't well discriminated
            };
            this.elementAndTemplateIdentifierCache.set(node, identifier);
            return identifier;
        }
        /** Creates an identifier for a template reference or template variable target. */
        targetToIdentifier(node) {
            // If this node has already been seen, return the cached result.
            if (this.targetIdentifierCache.has(node)) {
                return this.targetIdentifierCache.get(node);
            }
            const { name, sourceSpan } = node;
            const start = this.getStartLocation(name, sourceSpan);
            const span = new AbsoluteSourceSpan$1(start, start + name.length);
            let identifier;
            if (node instanceof Reference) {
                // If the node is a reference, we care about its target. The target can be an element, a
                // template, a directive applied on a template or element (in which case the directive field
                // is non-null), or nothing at all.
                const refTarget = this.boundTemplate.getReferenceTarget(node);
                let target = null;
                if (refTarget) {
                    if (refTarget instanceof Element || refTarget instanceof Template) {
                        target = {
                            node: this.elementOrTemplateToIdentifier(refTarget),
                            directive: null,
                        };
                    }
                    else {
                        target = {
                            node: this.elementOrTemplateToIdentifier(refTarget.node),
                            directive: refTarget.directive.ref.node,
                        };
                    }
                }
                identifier = {
                    name,
                    span,
                    kind: IdentifierKind.Reference,
                    target,
                };
            }
            else {
                identifier = {
                    name,
                    span,
                    kind: IdentifierKind.Variable,
                };
            }
            this.targetIdentifierCache.set(node, identifier);
            return identifier;
        }
        /** Gets the start location of a string in a SourceSpan */
        getStartLocation(name, context) {
            const localStr = context.toString();
            if (!localStr.includes(name)) {
                throw new Error(`Impossible state: "${name}" not found in "${localStr}"`);
            }
            return context.start.offset + localStr.indexOf(name);
        }
        /**
         * Visits a node's expression and adds its identifiers, if any, to the visitor's state.
         * Only ASTs with information about the expression source and its location are visited.
         *
         * @param node node whose expression to visit
         */
        visitExpression(ast) {
            // Only include ASTs that have information about their source and absolute source spans.
            if (ast instanceof ASTWithSource && ast.source !== null) {
                // Make target to identifier mapping closure stateful to this visitor instance.
                const targetToIdentifier = this.targetToIdentifier.bind(this);
                const absoluteOffset = ast.sourceSpan.start;
                const identifiers = ExpressionVisitor.getIdentifiers(ast, ast.source, absoluteOffset, this.boundTemplate, targetToIdentifier);
                identifiers.forEach(id => this.identifiers.add(id));
            }
        }
    }
    /**
     * Traverses a template AST and builds identifiers discovered in it.
     *
     * @param boundTemplate bound template target, which can be used for querying expression targets.
     * @return identifiers in template
     */
    function getTemplateIdentifiers(boundTemplate) {
        const visitor = new TemplateVisitor(boundTemplate);
        if (boundTemplate.target.template !== undefined) {
            visitor.visitAll(boundTemplate.target.template);
        }
        return visitor.identifiers;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Generates `IndexedComponent` entries from a `IndexingContext`, which has information
     * about components discovered in the program registered in it.
     *
     * The context must be populated before `generateAnalysis` is called.
     */
    function generateAnalysis(context) {
        const analysis = new Map();
        context.components.forEach(({ declaration, selector, boundTemplate, templateMeta }) => {
            const name = declaration.name.getText();
            const usedComponents = new Set();
            const usedDirs = boundTemplate.getUsedDirectives();
            usedDirs.forEach(dir => {
                if (dir.isComponent) {
                    usedComponents.add(dir.ref.node);
                }
            });
            // Get source files for the component and the template. If the template is inline, its source
            // file is the component's.
            const componentFile = new ParseSourceFile(declaration.getSourceFile().getFullText(), declaration.getSourceFile().fileName);
            let templateFile;
            if (templateMeta.isInline) {
                templateFile = componentFile;
            }
            else {
                templateFile = templateMeta.file;
            }
            analysis.set(declaration, {
                name,
                selector,
                file: componentFile,
                template: {
                    identifiers: getTemplateIdentifiers(boundTemplate),
                    usedComponents,
                    isInline: templateMeta.isInline,
                    file: templateFile,
                },
            });
        });
        return analysis;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const CSS_PREPROCESSOR_EXT = /(\.scss|\.sass|\.less|\.styl)$/;
    const RESOURCE_MARKER = '.$ngresource$';
    const RESOURCE_MARKER_TS = RESOURCE_MARKER + '.ts';
    /**
     * `ResourceLoader` which delegates to an `NgCompilerAdapter`'s resource loading methods.
     */
    class AdapterResourceLoader {
        constructor(adapter, options) {
            this.adapter = adapter;
            this.options = options;
            this.cache = new Map();
            this.fetching = new Map();
            this.lookupResolutionHost = createLookupResolutionHost(this.adapter);
            this.canPreload = !!this.adapter.readResource;
            this.canPreprocess = !!this.adapter.transformResource;
        }
        /**
         * Resolve the url of a resource relative to the file that contains the reference to it.
         * The return value of this method can be used in the `load()` and `preload()` methods.
         *
         * Uses the provided CompilerHost if it supports mapping resources to filenames.
         * Otherwise, uses a fallback mechanism that searches the module resolution candidates.
         *
         * @param url The, possibly relative, url of the resource.
         * @param fromFile The path to the file that contains the URL of the resource.
         * @returns A resolved url of resource.
         * @throws An error if the resource cannot be resolved.
         */
        resolve(url, fromFile) {
            let resolvedUrl = null;
            if (this.adapter.resourceNameToFileName) {
                resolvedUrl = this.adapter.resourceNameToFileName(url, fromFile, (url, fromFile) => this.fallbackResolve(url, fromFile));
            }
            else {
                resolvedUrl = this.fallbackResolve(url, fromFile);
            }
            if (resolvedUrl === null) {
                throw new Error(`HostResourceResolver: could not resolve ${url} in context of ${fromFile})`);
            }
            return resolvedUrl;
        }
        /**
         * Preload the specified resource, asynchronously.
         *
         * Once the resource is loaded, its value is cached so it can be accessed synchronously via the
         * `load()` method.
         *
         * @param resolvedUrl The url (resolved by a call to `resolve()`) of the resource to preload.
         * @param context Information about the resource such as the type and containing file.
         * @returns A Promise that is resolved once the resource has been loaded or `undefined` if the
         * file has already been loaded.
         * @throws An Error if pre-loading is not available.
         */
        preload(resolvedUrl, context) {
            if (!this.adapter.readResource) {
                throw new Error('HostResourceLoader: the CompilerHost provided does not support pre-loading resources.');
            }
            if (this.cache.has(resolvedUrl)) {
                return undefined;
            }
            else if (this.fetching.has(resolvedUrl)) {
                return this.fetching.get(resolvedUrl);
            }
            let result = this.adapter.readResource(resolvedUrl);
            if (this.adapter.transformResource && context.type === 'style') {
                const resourceContext = {
                    type: 'style',
                    containingFile: context.containingFile,
                    resourceFile: resolvedUrl,
                };
                result = Promise.resolve(result).then((str) => __awaiter(this, void 0, void 0, function* () {
                    const transformResult = yield this.adapter.transformResource(str, resourceContext);
                    return transformResult === null ? str : transformResult.content;
                }));
            }
            if (typeof result === 'string') {
                this.cache.set(resolvedUrl, result);
                return undefined;
            }
            else {
                const fetchCompletion = result.then(str => {
                    this.fetching.delete(resolvedUrl);
                    this.cache.set(resolvedUrl, str);
                });
                this.fetching.set(resolvedUrl, fetchCompletion);
                return fetchCompletion;
            }
        }
        /**
         * Preprocess the content data of an inline resource, asynchronously.
         *
         * @param data The existing content data from the inline resource.
         * @param context Information regarding the resource such as the type and containing file.
         * @returns A Promise that resolves to the processed data. If no processing occurs, the
         * same data string that was passed to the function will be resolved.
         */
        preprocessInline(data, context) {
            return __awaiter(this, void 0, void 0, function* () {
                if (!this.adapter.transformResource || context.type !== 'style') {
                    return data;
                }
                const transformResult = yield this.adapter.transformResource(data, { type: 'style', containingFile: context.containingFile, resourceFile: null });
                if (transformResult === null) {
                    return data;
                }
                return transformResult.content;
            });
        }
        /**
         * Load the resource at the given url, synchronously.
         *
         * The contents of the resource may have been cached by a previous call to `preload()`.
         *
         * @param resolvedUrl The url (resolved by a call to `resolve()`) of the resource to load.
         * @returns The contents of the resource.
         */
        load(resolvedUrl) {
            if (this.cache.has(resolvedUrl)) {
                return this.cache.get(resolvedUrl);
            }
            const result = this.adapter.readResource ? this.adapter.readResource(resolvedUrl) :
                this.adapter.readFile(resolvedUrl);
            if (typeof result !== 'string') {
                throw new Error(`HostResourceLoader: loader(${resolvedUrl}) returned a Promise`);
            }
            this.cache.set(resolvedUrl, result);
            return result;
        }
        /**
         * Invalidate the entire resource cache.
         */
        invalidate() {
            this.cache.clear();
        }
        /**
         * Attempt to resolve `url` in the context of `fromFile`, while respecting the rootDirs
         * option from the tsconfig. First, normalize the file name.
         */
        fallbackResolve(url, fromFile) {
            let candidateLocations;
            if (url.startsWith('/')) {
                // This path is not really an absolute path, but instead the leading '/' means that it's
                // rooted in the project rootDirs. So look for it according to the rootDirs.
                candidateLocations = this.getRootedCandidateLocations(url);
            }
            else {
                // This path is a "relative" path and can be resolved as such. To make this easier on the
                // downstream resolver, the './' prefix is added if missing to distinguish these paths from
                // absolute node_modules paths.
                if (!url.startsWith('.')) {
                    url = `./${url}`;
                }
                candidateLocations = this.getResolvedCandidateLocations(url, fromFile);
            }
            for (const candidate of candidateLocations) {
                if (this.adapter.fileExists(candidate)) {
                    return candidate;
                }
                else if (CSS_PREPROCESSOR_EXT.test(candidate)) {
                    /**
                     * If the user specified styleUrl points to *.scss, but the Sass compiler was run before
                     * Angular, then the resource may have been generated as *.css. Simply try the resolution
                     * again.
                     */
                    const cssFallbackUrl = candidate.replace(CSS_PREPROCESSOR_EXT, '.css');
                    if (this.adapter.fileExists(cssFallbackUrl)) {
                        return cssFallbackUrl;
                    }
                }
            }
            return null;
        }
        getRootedCandidateLocations(url) {
            // The path already starts with '/', so add a '.' to make it relative.
            const segment = ('.' + url);
            return this.adapter.rootDirs.map(rootDir => join(rootDir, segment));
        }
        /**
         * TypeScript provides utilities to resolve module names, but not resource files (which aren't
         * a part of the ts.Program). However, TypeScript's module resolution can be used creatively
         * to locate where resource files should be expected to exist. Since module resolution returns
         * a list of file names that were considered, the loader can enumerate the possible locations
         * for the file by setting up a module resolution for it that will fail.
         */
        getResolvedCandidateLocations(url, fromFile) {
            // clang-format off
            const failedLookup = ts$1.resolveModuleName(url + RESOURCE_MARKER, fromFile, this.options, this.lookupResolutionHost);
            // clang-format on
            if (failedLookup.failedLookupLocations === undefined) {
                throw new Error(`Internal error: expected to find failedLookupLocations during resolution of resource '${url}' in context of ${fromFile}`);
            }
            return failedLookup.failedLookupLocations
                .filter(candidate => candidate.endsWith(RESOURCE_MARKER_TS))
                .map(candidate => candidate.slice(0, -RESOURCE_MARKER_TS.length));
        }
    }
    /**
     * Derives a `ts.ModuleResolutionHost` from a compiler adapter that recognizes the special resource
     * marker and does not go to the filesystem for these requests, as they are known not to exist.
     */
    function createLookupResolutionHost(adapter) {
        var _a, _b, _c;
        return {
            directoryExists(directoryName) {
                if (directoryName.includes(RESOURCE_MARKER)) {
                    return false;
                }
                else if (adapter.directoryExists !== undefined) {
                    return adapter.directoryExists(directoryName);
                }
                else {
                    // TypeScript's module resolution logic assumes that the directory exists when no host
                    // implementation is available.
                    return true;
                }
            },
            fileExists(fileName) {
                if (fileName.includes(RESOURCE_MARKER)) {
                    return false;
                }
                else {
                    return adapter.fileExists(fileName);
                }
            },
            readFile: adapter.readFile.bind(adapter),
            getCurrentDirectory: adapter.getCurrentDirectory.bind(adapter),
            getDirectories: (_a = adapter.getDirectories) === null || _a === void 0 ? void 0 : _a.bind(adapter),
            realpath: (_b = adapter.realpath) === null || _b === void 0 ? void 0 : _b.bind(adapter),
            trace: (_c = adapter.trace) === null || _c === void 0 ? void 0 : _c.bind(adapter),
        };
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class RouterEntryPointImpl {
        constructor(filePath, moduleName) {
            this.filePath = filePath;
            this.moduleName = moduleName;
        }
        get name() {
            return this.moduleName;
        }
        // For debugging purposes.
        toString() {
            return `RouterEntryPoint(name: ${this.name}, filePath: ${this.filePath})`;
        }
    }
    class RouterEntryPointManager {
        constructor(moduleResolver) {
            this.moduleResolver = moduleResolver;
            this.map = new Map();
        }
        resolveLoadChildrenIdentifier(loadChildrenIdentifier, context) {
            const [relativeFile, moduleName] = loadChildrenIdentifier.split('#');
            if (moduleName === undefined) {
                return null;
            }
            const resolvedSf = this.moduleResolver.resolveModule(relativeFile, context.fileName);
            if (resolvedSf === null) {
                return null;
            }
            return this.fromNgModule(resolvedSf, moduleName);
        }
        fromNgModule(sf, moduleName) {
            const key = entryPointKeyFor(sf.fileName, moduleName);
            if (!this.map.has(key)) {
                this.map.set(key, new RouterEntryPointImpl(sf.fileName, moduleName));
            }
            return this.map.get(key);
        }
    }
    function entryPointKeyFor(filePath, moduleName) {
        // Drop the extension to be compatible with how cli calls `listLazyRoutes(entryRoute)`.
        return `${filePath.replace(/\.tsx?$/i, '')}#${moduleName}`;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const ROUTES_MARKER = '__ngRoutesMarker__';
    function scanForCandidateTransitiveModules(expr, evaluator) {
        if (expr === null) {
            return [];
        }
        const candidateModuleKeys = [];
        const entries = evaluator.evaluate(expr);
        function recursivelyAddModules(entry) {
            if (Array.isArray(entry)) {
                for (const e of entry) {
                    recursivelyAddModules(e);
                }
            }
            else if (entry instanceof Map) {
                if (entry.has('ngModule')) {
                    recursivelyAddModules(entry.get('ngModule'));
                }
            }
            else if ((entry instanceof Reference$1) && hasIdentifier(entry.node)) {
                const filePath = entry.node.getSourceFile().fileName;
                const moduleName = entry.node.name.text;
                candidateModuleKeys.push(entryPointKeyFor(filePath, moduleName));
            }
        }
        recursivelyAddModules(entries);
        return candidateModuleKeys;
    }
    function scanForRouteEntryPoints(ngModule, moduleName, data, entryPointManager, evaluator) {
        const loadChildrenIdentifiers = [];
        const from = entryPointManager.fromNgModule(ngModule, moduleName);
        if (data.providers !== null) {
            loadChildrenIdentifiers.push(...scanForProviders(data.providers, evaluator));
        }
        if (data.imports !== null) {
            loadChildrenIdentifiers.push(...scanForRouterModuleUsage(data.imports, evaluator));
        }
        if (data.exports !== null) {
            loadChildrenIdentifiers.push(...scanForRouterModuleUsage(data.exports, evaluator));
        }
        const routes = [];
        for (const loadChildren of loadChildrenIdentifiers) {
            const resolvedTo = entryPointManager.resolveLoadChildrenIdentifier(loadChildren, ngModule);
            if (resolvedTo !== null) {
                routes.push({
                    loadChildren,
                    from,
                    resolvedTo,
                });
            }
        }
        return routes;
    }
    function scanForProviders(expr, evaluator) {
        const loadChildrenIdentifiers = [];
        const providers = evaluator.evaluate(expr);
        function recursivelyAddProviders(provider) {
            if (Array.isArray(provider)) {
                for (const entry of provider) {
                    recursivelyAddProviders(entry);
                }
            }
            else if (provider instanceof Map) {
                if (provider.has('provide') && provider.has('useValue')) {
                    const provide = provider.get('provide');
                    const useValue = provider.get('useValue');
                    if (isRouteToken(provide) && Array.isArray(useValue)) {
                        loadChildrenIdentifiers.push(...scanForLazyRoutes(useValue));
                    }
                }
            }
        }
        recursivelyAddProviders(providers);
        return loadChildrenIdentifiers;
    }
    function scanForRouterModuleUsage(expr, evaluator) {
        const loadChildrenIdentifiers = [];
        const imports = evaluator.evaluate(expr, routerModuleFFR);
        function recursivelyAddRoutes(imp) {
            if (Array.isArray(imp)) {
                for (const entry of imp) {
                    recursivelyAddRoutes(entry);
                }
            }
            else if (imp instanceof Map) {
                if (imp.has(ROUTES_MARKER) && imp.has('routes')) {
                    const routes = imp.get('routes');
                    if (Array.isArray(routes)) {
                        loadChildrenIdentifiers.push(...scanForLazyRoutes(routes));
                    }
                }
            }
        }
        recursivelyAddRoutes(imports);
        return loadChildrenIdentifiers;
    }
    function scanForLazyRoutes(routes) {
        const loadChildrenIdentifiers = [];
        function recursivelyScanRoutes(routes) {
            for (let route of routes) {
                if (!(route instanceof Map)) {
                    continue;
                }
                if (route.has('loadChildren')) {
                    const loadChildren = route.get('loadChildren');
                    if (typeof loadChildren === 'string') {
                        loadChildrenIdentifiers.push(loadChildren);
                    }
                }
                else if (route.has('children')) {
                    const children = route.get('children');
                    if (Array.isArray(children)) {
                        recursivelyScanRoutes(children);
                    }
                }
            }
        }
        recursivelyScanRoutes(routes);
        return loadChildrenIdentifiers;
    }
    /**
     * A foreign function resolver that converts `RouterModule.forRoot/forChild(X)` to a special object
     * of the form `{__ngRoutesMarker__: true, routes: X}`.
     *
     * These objects are then recognizable inside the larger set of imports/exports.
     */
    const routerModuleFFR = function routerModuleFFR(ref, args) {
        if (!isMethodNodeReference(ref) || !ts$1.isClassDeclaration(ref.node.parent)) {
            return null;
        }
        else if (ref.bestGuessOwningModule === null ||
            ref.bestGuessOwningModule.specifier !== '@angular/router') {
            return null;
        }
        else if (ref.node.parent.name === undefined || ref.node.parent.name.text !== 'RouterModule') {
            return null;
        }
        else if (!ts$1.isIdentifier(ref.node.name) ||
            (ref.node.name.text !== 'forRoot' && ref.node.name.text !== 'forChild')) {
            return null;
        }
        const routes = args[0];
        return ts$1.createObjectLiteral([
            ts$1.createPropertyAssignment(ROUTES_MARKER, ts$1.createTrue()),
            ts$1.createPropertyAssignment('routes', routes),
        ]);
    };
    function hasIdentifier(node) {
        const node_ = node;
        return (node_.name !== undefined) && ts$1.isIdentifier(node_.name);
    }
    function isMethodNodeReference(ref) {
        return ts$1.isMethodDeclaration(ref.node);
    }
    function isRouteToken(ref) {
        return ref instanceof Reference$1 && ref.bestGuessOwningModule !== null &&
            ref.bestGuessOwningModule.specifier === '@angular/router' && ref.debugName === 'ROUTES';
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class NgModuleRouteAnalyzer {
        constructor(moduleResolver, evaluator) {
            this.evaluator = evaluator;
            this.modules = new Map();
            this.entryPointManager = new RouterEntryPointManager(moduleResolver);
        }
        add(sourceFile, moduleName, imports, exports, providers) {
            const key = entryPointKeyFor(sourceFile.fileName, moduleName);
            if (this.modules.has(key)) {
                throw new Error(`Double route analyzing for '${key}'.`);
            }
            this.modules.set(key, {
                sourceFile,
                moduleName,
                imports,
                exports,
                providers,
            });
        }
        listLazyRoutes(entryModuleKey) {
            if ((entryModuleKey !== undefined) && !this.modules.has(entryModuleKey)) {
                throw new Error(`Failed to list lazy routes: Unknown module '${entryModuleKey}'.`);
            }
            const routes = [];
            const scannedModuleKeys = new Set();
            const pendingModuleKeys = entryModuleKey ? [entryModuleKey] : Array.from(this.modules.keys());
            // When listing lazy routes for a specific entry module, we need to recursively extract
            // "transitive" routes from imported/exported modules. This is not necessary when listing all
            // lazy routes, because all analyzed modules will be scanned anyway.
            const scanRecursively = entryModuleKey !== undefined;
            while (pendingModuleKeys.length > 0) {
                const key = pendingModuleKeys.pop();
                if (scannedModuleKeys.has(key)) {
                    continue;
                }
                else {
                    scannedModuleKeys.add(key);
                }
                const data = this.modules.get(key);
                const entryPoints = scanForRouteEntryPoints(data.sourceFile, data.moduleName, data, this.entryPointManager, this.evaluator);
                routes.push(...entryPoints.map(entryPoint => ({
                    route: entryPoint.loadChildren,
                    module: entryPoint.from,
                    referencedModule: entryPoint.resolvedTo,
                })));
                if (scanRecursively) {
                    pendingModuleKeys.push(...[
                        // Scan the retrieved lazy route entry points.
                        ...entryPoints.map(({ resolvedTo }) => entryPointKeyFor(resolvedTo.filePath, resolvedTo.moduleName)),
                        // Scan the current module's imported modules.
                        ...scanForCandidateTransitiveModules(data.imports, this.evaluator),
                        // Scan the current module's exported modules.
                        ...scanForCandidateTransitiveModules(data.exports, this.evaluator),
                    ].filter(key => this.modules.has(key)));
                }
            }
            return routes;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Reads Angular metadata from classes declared in .d.ts files and computes an `ExportScope`.
     *
     * Given an NgModule declared in a .d.ts file, this resolver can produce a transitive `ExportScope`
     * of all of the directives/pipes it exports. It does this by reading metadata off of Ivy static
     * fields on directives, components, pipes, and NgModules.
     */
    class MetadataDtsModuleScopeResolver {
        /**
         * @param dtsMetaReader a `MetadataReader` which can read metadata from `.d.ts` files.
         */
        constructor(dtsMetaReader, aliasingHost) {
            this.dtsMetaReader = dtsMetaReader;
            this.aliasingHost = aliasingHost;
            /**
             * Cache which holds fully resolved scopes for NgModule classes from .d.ts files.
             */
            this.cache = new Map();
        }
        /**
         * Resolve a `Reference`'d NgModule from a .d.ts file and produce a transitive `ExportScope`
         * listing the directives and pipes which that NgModule exports to others.
         *
         * This operation relies on a `Reference` instead of a direct TypeScrpt node as the `Reference`s
         * produced depend on how the original NgModule was imported.
         */
        resolve(ref) {
            const clazz = ref.node;
            const sourceFile = clazz.getSourceFile();
            if (!sourceFile.isDeclarationFile) {
                throw new Error(`Debug error: DtsModuleScopeResolver.read(${ref.debugName} from ${sourceFile.fileName}), but not a .d.ts file`);
            }
            if (this.cache.has(clazz)) {
                return this.cache.get(clazz);
            }
            // Build up the export scope - those directives and pipes made visible by this module.
            const directives = [];
            const pipes = [];
            const ngModules = new Set([clazz]);
            const meta = this.dtsMetaReader.getNgModuleMetadata(ref);
            if (meta === null) {
                this.cache.set(clazz, null);
                return null;
            }
            const declarations = new Set();
            for (const declRef of meta.declarations) {
                declarations.add(declRef.node);
            }
            // Only the 'exports' field of the NgModule's metadata is important. Imports and declarations
            // don't affect the export scope.
            for (const exportRef of meta.exports) {
                // Attempt to process the export as a directive.
                const directive = this.dtsMetaReader.getDirectiveMetadata(exportRef);
                if (directive !== null) {
                    const isReExport = !declarations.has(exportRef.node);
                    directives.push(this.maybeAlias(directive, sourceFile, isReExport));
                    continue;
                }
                // Attempt to process the export as a pipe.
                const pipe = this.dtsMetaReader.getPipeMetadata(exportRef);
                if (pipe !== null) {
                    const isReExport = !declarations.has(exportRef.node);
                    pipes.push(this.maybeAlias(pipe, sourceFile, isReExport));
                    continue;
                }
                // Attempt to process the export as a module.
                const exportScope = this.resolve(exportRef);
                if (exportScope !== null) {
                    // It is a module. Add exported directives and pipes to the current scope. This might
                    // involve rewriting the `Reference`s to those types to have an alias expression if one is
                    // required.
                    if (this.aliasingHost === null) {
                        // Fast path when aliases aren't required.
                        directives.push(...exportScope.exported.directives);
                        pipes.push(...exportScope.exported.pipes);
                    }
                    else {
                        // It's necessary to rewrite the `Reference`s to add alias expressions. This way, imports
                        // generated to these directives and pipes will use a shallow import to `sourceFile`
                        // instead of a deep import directly to the directive or pipe class.
                        //
                        // One important check here is whether the directive/pipe is declared in the same
                        // source file as the re-exporting NgModule. This can happen if both a directive, its
                        // NgModule, and the re-exporting NgModule are all in the same file. In this case,
                        // no import alias is needed as it would go to the same file anyway.
                        for (const directive of exportScope.exported.directives) {
                            directives.push(this.maybeAlias(directive, sourceFile, /* isReExport */ true));
                        }
                        for (const pipe of exportScope.exported.pipes) {
                            pipes.push(this.maybeAlias(pipe, sourceFile, /* isReExport */ true));
                        }
                        for (const ngModule of exportScope.exported.ngModules) {
                            ngModules.add(ngModule);
                        }
                    }
                }
                continue;
                // The export was not a directive, a pipe, or a module. This is an error.
                // TODO(alxhub): produce a ts.Diagnostic
            }
            const exportScope = {
                exported: {
                    directives,
                    pipes,
                    ngModules: Array.from(ngModules),
                    isPoisoned: false,
                },
            };
            this.cache.set(clazz, exportScope);
            return exportScope;
        }
        maybeAlias(dirOrPipe, maybeAliasFrom, isReExport) {
            const ref = dirOrPipe.ref;
            if (this.aliasingHost === null || ref.node.getSourceFile() === maybeAliasFrom) {
                return dirOrPipe;
            }
            const alias = this.aliasingHost.getAliasIn(ref.node, maybeAliasFrom, isReExport);
            if (alias === null) {
                return dirOrPipe;
            }
            // TypeScript incorrectly narrows the type here:
            // https://github.com/microsoft/TypeScript/issues/43966.
            // TODO: Remove/Update once https://github.com/microsoft/TypeScript/issues/43966 is resolved.
            return Object.assign(Object.assign({}, dirOrPipe), { ref: ref.cloneWithAlias(alias) });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A registry which collects information about NgModules, Directives, Components, and Pipes which
     * are local (declared in the ts.Program being compiled), and can produce `LocalModuleScope`s
     * which summarize the compilation scope of a component.
     *
     * This class implements the logic of NgModule declarations, imports, and exports and can produce,
     * for a given component, the set of directives and pipes which are "visible" in that component's
     * template.
     *
     * The `LocalModuleScopeRegistry` has two "modes" of operation. During analysis, data for each
     * individual NgModule, Directive, Component, and Pipe is added to the registry. No attempt is made
     * to traverse or validate the NgModule graph (imports, exports, etc). After analysis, one of
     * `getScopeOfModule` or `getScopeForComponent` can be called, which traverses the NgModule graph
     * and applies the NgModule logic to generate a `LocalModuleScope`, the full scope for the given
     * module or component.
     *
     * The `LocalModuleScopeRegistry` is also capable of producing `ts.Diagnostic` errors when Angular
     * semantics are violated.
     */
    class LocalModuleScopeRegistry {
        constructor(localReader, dependencyScopeReader, refEmitter, aliasingHost) {
            this.localReader = localReader;
            this.dependencyScopeReader = dependencyScopeReader;
            this.refEmitter = refEmitter;
            this.aliasingHost = aliasingHost;
            /**
             * Tracks whether the registry has been asked to produce scopes for a module or component. Once
             * this is true, the registry cannot accept registrations of new directives/pipes/modules as it
             * would invalidate the cached scope data.
             */
            this.sealed = false;
            /**
             * A map of components from the current compilation unit to the NgModule which declared them.
             *
             * As components and directives are not distinguished at the NgModule level, this map may also
             * contain directives. This doesn't cause any problems but isn't useful as there is no concept of
             * a directive's compilation scope.
             */
            this.declarationToModule = new Map();
            /**
             * This maps from the directive/pipe class to a map of data for each NgModule that declares the
             * directive/pipe. This data is needed to produce an error for the given class.
             */
            this.duplicateDeclarations = new Map();
            this.moduleToRef = new Map();
            /**
             * A cache of calculated `LocalModuleScope`s for each NgModule declared in the current program.
          
             */
            this.cache = new Map();
            /**
             * Tracks the `RemoteScope` for components requiring "remote scoping".
             *
             * Remote scoping is when the set of directives which apply to a given component is set in the
             * NgModule's file instead of directly on the component def (which is sometimes needed to get
             * around cyclic import issues). This is not used in calculation of `LocalModuleScope`s, but is
             * tracked here for convenience.
             */
            this.remoteScoping = new Map();
            /**
             * Tracks errors accumulated in the processing of scopes for each module declaration.
             */
            this.scopeErrors = new Map();
            /**
             * Tracks which NgModules have directives/pipes that are declared in more than one module.
             */
            this.modulesWithStructuralErrors = new Set();
        }
        /**
         * Add an NgModule's data to the registry.
         */
        registerNgModuleMetadata(data) {
            this.assertCollecting();
            const ngModule = data.ref.node;
            this.moduleToRef.set(data.ref.node, data.ref);
            // Iterate over the module's declarations, and add them to declarationToModule. If duplicates
            // are found, they're instead tracked in duplicateDeclarations.
            for (const decl of data.declarations) {
                this.registerDeclarationOfModule(ngModule, decl, data.rawDeclarations);
            }
        }
        registerDirectiveMetadata(directive) { }
        registerPipeMetadata(pipe) { }
        getScopeForComponent(clazz) {
            const scope = !this.declarationToModule.has(clazz) ?
                null :
                this.getScopeOfModule(this.declarationToModule.get(clazz).ngModule);
            return scope;
        }
        /**
         * If `node` is declared in more than one NgModule (duplicate declaration), then get the
         * `DeclarationData` for each offending declaration.
         *
         * Ordinarily a class is only declared in one NgModule, in which case this function returns
         * `null`.
         */
        getDuplicateDeclarations(node) {
            if (!this.duplicateDeclarations.has(node)) {
                return null;
            }
            return Array.from(this.duplicateDeclarations.get(node).values());
        }
        /**
         * Collects registered data for a module and its directives/pipes and convert it into a full
         * `LocalModuleScope`.
         *
         * This method implements the logic of NgModule imports and exports. It returns the
         * `LocalModuleScope` for the given NgModule if one can be produced, `null` if no scope was ever
         * defined, or the string `'error'` if the scope contained errors.
         */
        getScopeOfModule(clazz) {
            return this.moduleToRef.has(clazz) ?
                this.getScopeOfModuleReference(this.moduleToRef.get(clazz)) :
                null;
        }
        /**
         * Retrieves any `ts.Diagnostic`s produced during the calculation of the `LocalModuleScope` for
         * the given NgModule, or `null` if no errors were present.
         */
        getDiagnosticsOfModule(clazz) {
            // Required to ensure the errors are populated for the given class. If it has been processed
            // before, this will be a no-op due to the scope cache.
            this.getScopeOfModule(clazz);
            if (this.scopeErrors.has(clazz)) {
                return this.scopeErrors.get(clazz);
            }
            else {
                return null;
            }
        }
        registerDeclarationOfModule(ngModule, decl, rawDeclarations) {
            const declData = {
                ngModule,
                ref: decl,
                rawDeclarations,
            };
            // First, check for duplicate declarations of the same directive/pipe.
            if (this.duplicateDeclarations.has(decl.node)) {
                // This directive/pipe has already been identified as being duplicated. Add this module to the
                // map of modules for which a duplicate declaration exists.
                this.duplicateDeclarations.get(decl.node).set(ngModule, declData);
            }
            else if (this.declarationToModule.has(decl.node) &&
                this.declarationToModule.get(decl.node).ngModule !== ngModule) {
                // This directive/pipe is already registered as declared in another module. Mark it as a
                // duplicate instead.
                const duplicateDeclMap = new Map();
                const firstDeclData = this.declarationToModule.get(decl.node);
                // Mark both modules as having duplicate declarations.
                this.modulesWithStructuralErrors.add(firstDeclData.ngModule);
                this.modulesWithStructuralErrors.add(ngModule);
                // Being detected as a duplicate means there are two NgModules (for now) which declare this
                // directive/pipe. Add both of them to the duplicate tracking map.
                duplicateDeclMap.set(firstDeclData.ngModule, firstDeclData);
                duplicateDeclMap.set(ngModule, declData);
                this.duplicateDeclarations.set(decl.node, duplicateDeclMap);
                // Remove the directive/pipe from `declarationToModule` as it's a duplicate declaration, and
                // therefore not valid.
                this.declarationToModule.delete(decl.node);
            }
            else {
                // This is the first declaration of this directive/pipe, so map it.
                this.declarationToModule.set(decl.node, declData);
            }
        }
        /**
         * Implementation of `getScopeOfModule` which accepts a reference to a class.
         */
        getScopeOfModuleReference(ref) {
            if (this.cache.has(ref.node)) {
                return this.cache.get(ref.node);
            }
            // Seal the registry to protect the integrity of the `LocalModuleScope` cache.
            this.sealed = true;
            // `ref` should be an NgModule previously added to the registry. If not, a scope for it
            // cannot be produced.
            const ngModule = this.localReader.getNgModuleMetadata(ref);
            if (ngModule === null) {
                this.cache.set(ref.node, null);
                return null;
            }
            // Modules which contributed to the compilation scope of this module.
            const compilationModules = new Set([ngModule.ref.node]);
            // Modules which contributed to the export scope of this module.
            const exportedModules = new Set([ngModule.ref.node]);
            // Errors produced during computation of the scope are recorded here. At the end, if this array
            // isn't empty then `undefined` will be cached and returned to indicate this scope is invalid.
            const diagnostics = [];
            // At this point, the goal is to produce two distinct transitive sets:
            // - the directives and pipes which are visible to components declared in the NgModule.
            // - the directives and pipes which are exported to any NgModules which import this one.
            // Directives and pipes in the compilation scope.
            const compilationDirectives = new Map();
            const compilationPipes = new Map();
            const declared = new Set();
            // Directives and pipes exported to any importing NgModules.
            const exportDirectives = new Map();
            const exportPipes = new Map();
            // The algorithm is as follows:
            // 1) Add all of the directives/pipes from each NgModule imported into the current one to the
            //    compilation scope.
            // 2) Add directives/pipes declared in the NgModule to the compilation scope. At this point, the
            //    compilation scope is complete.
            // 3) For each entry in the NgModule's exports:
            //    a) Attempt to resolve it as an NgModule with its own exported directives/pipes. If it is
            //       one, add them to the export scope of this NgModule.
            //    b) Otherwise, it should be a class in the compilation scope of this NgModule. If it is,
            //       add it to the export scope.
            //    c) If it's neither an NgModule nor a directive/pipe in the compilation scope, then this
            //       is an error.
            //
            let isPoisoned = false;
            if (this.modulesWithStructuralErrors.has(ngModule.ref.node)) {
                // If the module contains declarations that are duplicates, then it's considered poisoned.
                isPoisoned = true;
            }
            // 1) process imports.
            for (const decl of ngModule.imports) {
                const importScope = this.getExportedScope(decl, diagnostics, ref.node, 'import');
                if (importScope === null) {
                    // An import wasn't an NgModule, so record an error.
                    diagnostics.push(invalidRef(ref.node, decl, 'import'));
                    isPoisoned = true;
                    continue;
                }
                else if (importScope === 'invalid' || importScope.exported.isPoisoned) {
                    // An import was an NgModule but contained errors of its own. Record this as an error too,
                    // because this scope is always going to be incorrect if one of its imports could not be
                    // read.
                    diagnostics.push(invalidTransitiveNgModuleRef(ref.node, decl, 'import'));
                    isPoisoned = true;
                    if (importScope === 'invalid') {
                        continue;
                    }
                }
                for (const directive of importScope.exported.directives) {
                    compilationDirectives.set(directive.ref.node, directive);
                }
                for (const pipe of importScope.exported.pipes) {
                    compilationPipes.set(pipe.ref.node, pipe);
                }
                for (const importedModule of importScope.exported.ngModules) {
                    compilationModules.add(importedModule);
                }
            }
            // 2) add declarations.
            for (const decl of ngModule.declarations) {
                const directive = this.localReader.getDirectiveMetadata(decl);
                const pipe = this.localReader.getPipeMetadata(decl);
                if (directive !== null) {
                    compilationDirectives.set(decl.node, Object.assign(Object.assign({}, directive), { ref: decl }));
                    if (directive.isPoisoned) {
                        isPoisoned = true;
                    }
                }
                else if (pipe !== null) {
                    compilationPipes.set(decl.node, Object.assign(Object.assign({}, pipe), { ref: decl }));
                }
                else {
                    const errorNode = decl.getOriginForDiagnostics(ngModule.rawDeclarations);
                    diagnostics.push(makeDiagnostic(ErrorCode.NGMODULE_INVALID_DECLARATION, errorNode, `The class '${decl.node.name.text}' is listed in the declarations ` +
                        `of the NgModule '${ngModule.ref.node.name
                        .text}', but is not a directive, a component, or a pipe. ` +
                        `Either remove it from the NgModule's declarations, or add an appropriate Angular decorator.`, [makeRelatedInformation(decl.node.name, `'${decl.node.name.text}' is declared here.`)]));
                    isPoisoned = true;
                    continue;
                }
                declared.add(decl.node);
            }
            // 3) process exports.
            // Exports can contain modules, components, or directives. They're processed differently.
            // Modules are straightforward. Directives and pipes from exported modules are added to the
            // export maps. Directives/pipes are different - they might be exports of declared types or
            // imported types.
            for (const decl of ngModule.exports) {
                // Attempt to resolve decl as an NgModule.
                const exportScope = this.getExportedScope(decl, diagnostics, ref.node, 'export');
                if (exportScope === 'invalid' || (exportScope !== null && exportScope.exported.isPoisoned)) {
                    // An export was an NgModule but contained errors of its own. Record this as an error too,
                    // because this scope is always going to be incorrect if one of its exports could not be
                    // read.
                    diagnostics.push(invalidTransitiveNgModuleRef(ref.node, decl, 'export'));
                    isPoisoned = true;
                    if (exportScope === 'invalid') {
                        continue;
                    }
                }
                else if (exportScope !== null) {
                    // decl is an NgModule.
                    for (const directive of exportScope.exported.directives) {
                        exportDirectives.set(directive.ref.node, directive);
                    }
                    for (const pipe of exportScope.exported.pipes) {
                        exportPipes.set(pipe.ref.node, pipe);
                    }
                    for (const exportedModule of exportScope.exported.ngModules) {
                        exportedModules.add(exportedModule);
                    }
                }
                else if (compilationDirectives.has(decl.node)) {
                    // decl is a directive or component in the compilation scope of this NgModule.
                    const directive = compilationDirectives.get(decl.node);
                    exportDirectives.set(decl.node, directive);
                }
                else if (compilationPipes.has(decl.node)) {
                    // decl is a pipe in the compilation scope of this NgModule.
                    const pipe = compilationPipes.get(decl.node);
                    exportPipes.set(decl.node, pipe);
                }
                else {
                    // decl is an unknown export.
                    if (this.localReader.getDirectiveMetadata(decl) !== null ||
                        this.localReader.getPipeMetadata(decl) !== null) {
                        diagnostics.push(invalidReexport(ref.node, decl));
                    }
                    else {
                        diagnostics.push(invalidRef(ref.node, decl, 'export'));
                    }
                    isPoisoned = true;
                    continue;
                }
            }
            const exported = {
                directives: Array.from(exportDirectives.values()),
                pipes: Array.from(exportPipes.values()),
                ngModules: Array.from(exportedModules),
                isPoisoned,
            };
            const reexports = this.getReexports(ngModule, ref, declared, exported, diagnostics);
            // Finally, produce the `LocalModuleScope` with both the compilation and export scopes.
            const scope = {
                ngModule: ngModule.ref.node,
                compilation: {
                    directives: Array.from(compilationDirectives.values()),
                    pipes: Array.from(compilationPipes.values()),
                    ngModules: Array.from(compilationModules),
                    isPoisoned,
                },
                exported,
                reexports,
                schemas: ngModule.schemas,
            };
            // Check if this scope had any errors during production.
            if (diagnostics.length > 0) {
                // Save the errors for retrieval.
                this.scopeErrors.set(ref.node, diagnostics);
                // Mark this module as being tainted.
                this.modulesWithStructuralErrors.add(ref.node);
            }
            this.cache.set(ref.node, scope);
            return scope;
        }
        /**
         * Check whether a component requires remote scoping.
         */
        getRemoteScope(node) {
            return this.remoteScoping.has(node) ? this.remoteScoping.get(node) : null;
        }
        /**
         * Set a component as requiring remote scoping, with the given directives and pipes to be
         * registered remotely.
         */
        setComponentRemoteScope(node, directives, pipes) {
            this.remoteScoping.set(node, { directives, pipes });
        }
        /**
         * Look up the `ExportScope` of a given `Reference` to an NgModule.
         *
         * The NgModule in question may be declared locally in the current ts.Program, or it may be
         * declared in a .d.ts file.
         *
         * @returns `null` if no scope could be found, or `'invalid'` if the `Reference` is not a valid
         *     NgModule.
         *
         * May also contribute diagnostics of its own by adding to the given `diagnostics`
         * array parameter.
         */
        getExportedScope(ref, diagnostics, ownerForErrors, type) {
            if (ref.node.getSourceFile().isDeclarationFile) {
                // The NgModule is declared in a .d.ts file. Resolve it with the `DependencyScopeReader`.
                if (!ts$1.isClassDeclaration(ref.node)) {
                    // The NgModule is in a .d.ts file but is not declared as a ts.ClassDeclaration. This is an
                    // error in the .d.ts metadata.
                    const code = type === 'import' ? ErrorCode.NGMODULE_INVALID_IMPORT :
                        ErrorCode.NGMODULE_INVALID_EXPORT;
                    diagnostics.push(makeDiagnostic(code, identifierOfNode(ref.node) || ref.node, `Appears in the NgModule.${type}s of ${nodeNameForError(ownerForErrors)}, but could not be resolved to an NgModule`));
                    return 'invalid';
                }
                return this.dependencyScopeReader.resolve(ref);
            }
            else {
                // The NgModule is declared locally in the current program. Resolve it from the registry.
                return this.getScopeOfModuleReference(ref);
            }
        }
        getReexports(ngModule, ref, declared, exported, diagnostics) {
            let reexports = null;
            const sourceFile = ref.node.getSourceFile();
            if (this.aliasingHost === null) {
                return null;
            }
            reexports = [];
            // Track re-exports by symbol name, to produce diagnostics if two alias re-exports would share
            // the same name.
            const reexportMap = new Map();
            // Alias ngModuleRef added for readability below.
            const ngModuleRef = ref;
            const addReexport = (exportRef) => {
                if (exportRef.node.getSourceFile() === sourceFile) {
                    return;
                }
                const isReExport = !declared.has(exportRef.node);
                const exportName = this.aliasingHost.maybeAliasSymbolAs(exportRef, sourceFile, ngModule.ref.node.name.text, isReExport);
                if (exportName === null) {
                    return;
                }
                if (!reexportMap.has(exportName)) {
                    if (exportRef.alias && exportRef.alias instanceof ExternalExpr) {
                        reexports.push({
                            fromModule: exportRef.alias.value.moduleName,
                            symbolName: exportRef.alias.value.name,
                            asAlias: exportName,
                        });
                    }
                    else {
                        const expr = this.refEmitter.emit(exportRef.cloneWithNoIdentifiers(), sourceFile).expression;
                        if (!(expr instanceof ExternalExpr) || expr.value.moduleName === null ||
                            expr.value.name === null) {
                            throw new Error('Expected ExternalExpr');
                        }
                        reexports.push({
                            fromModule: expr.value.moduleName,
                            symbolName: expr.value.name,
                            asAlias: exportName,
                        });
                    }
                    reexportMap.set(exportName, exportRef);
                }
                else {
                    // Another re-export already used this name. Produce a diagnostic.
                    const prevRef = reexportMap.get(exportName);
                    diagnostics.push(reexportCollision(ngModuleRef.node, prevRef, exportRef));
                }
            };
            for (const { ref } of exported.directives) {
                addReexport(ref);
            }
            for (const { ref } of exported.pipes) {
                addReexport(ref);
            }
            return reexports;
        }
        assertCollecting() {
            if (this.sealed) {
                throw new Error(`Assertion: LocalModuleScopeRegistry is not COLLECTING`);
            }
        }
    }
    /**
     * Produce a `ts.Diagnostic` for an invalid import or export from an NgModule.
     */
    function invalidRef(clazz, decl, type) {
        const code = type === 'import' ? ErrorCode.NGMODULE_INVALID_IMPORT : ErrorCode.NGMODULE_INVALID_EXPORT;
        const resolveTarget = type === 'import' ? 'NgModule' : 'NgModule, Component, Directive, or Pipe';
        let message = `Appears in the NgModule.${type}s of ${nodeNameForError(clazz)}, but could not be resolved to an ${resolveTarget} class.` +
            '\n\n';
        const library = decl.ownedByModuleGuess !== null ? ` (${decl.ownedByModuleGuess})` : '';
        const sf = decl.node.getSourceFile();
        // Provide extra context to the error for the user.
        if (!sf.isDeclarationFile) {
            // This is a file in the user's program.
            const annotationType = type === 'import' ? '@NgModule' : 'Angular';
            message += `Is it missing an ${annotationType} annotation?`;
        }
        else if (sf.fileName.indexOf('node_modules') !== -1) {
            // This file comes from a third-party library in node_modules.
            message +=
                `This likely means that the library${library} which declares ${decl.debugName} has not ` +
                    'been processed correctly by ngcc, or is not compatible with Angular Ivy. Check if a ' +
                    'newer version of the library is available, and update if so. Also consider checking ' +
                    'with the library\'s authors to see if the library is expected to be compatible with Ivy.';
        }
        else {
            // This is a monorepo style local dependency. Unfortunately these are too different to really
            // offer much moreadvice than this.
            message += `This likely means that the dependency${library} which declares ${decl.debugName} has not been processed correctly by ngcc.`;
        }
        return makeDiagnostic(code, identifierOfNode(decl.node) || decl.node, message);
    }
    /**
     * Produce a `ts.Diagnostic` for an import or export which itself has errors.
     */
    function invalidTransitiveNgModuleRef(clazz, decl, type) {
        const code = type === 'import' ? ErrorCode.NGMODULE_INVALID_IMPORT : ErrorCode.NGMODULE_INVALID_EXPORT;
        return makeDiagnostic(code, identifierOfNode(decl.node) || decl.node, `Appears in the NgModule.${type}s of ${nodeNameForError(clazz)}, but itself has errors`);
    }
    /**
     * Produce a `ts.Diagnostic` for an exported directive or pipe which was not declared or imported
     * by the NgModule in question.
     */
    function invalidReexport(clazz, decl) {
        return makeDiagnostic(ErrorCode.NGMODULE_INVALID_REEXPORT, identifierOfNode(decl.node) || decl.node, `Present in the NgModule.exports of ${nodeNameForError(clazz)} but neither declared nor imported`);
    }
    /**
     * Produce a `ts.Diagnostic` for a collision in re-export names between two directives/pipes.
     */
    function reexportCollision(module, refA, refB) {
        const childMessageText = `This directive/pipe is part of the exports of '${module.name.text}' and shares the same name as another exported directive/pipe.`;
        return makeDiagnostic(ErrorCode.NGMODULE_REEXPORT_NAME_COLLISION, module.name, `
    There was a name collision between two classes named '${refA.node.name.text}', which are both part of the exports of '${module.name.text}'.

    Angular generates re-exports of an NgModule's exported directives/pipes from the module's source file in certain cases, using the declared name of the class. If two classes of the same name are exported, this automatic naming does not work.

    To fix this problem please re-export one or both classes directly from this file.
  `.trim(), [
            makeRelatedInformation(refA.node.name, childMessageText),
            makeRelatedInformation(refB.node.name, childMessageText),
        ]);
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Computes scope information to be used in template type checking.
     */
    class TypeCheckScopeRegistry {
        constructor(scopeReader, metaReader) {
            this.scopeReader = scopeReader;
            this.metaReader = metaReader;
            /**
             * Cache of flattened directive metadata. Because flattened metadata is scope-invariant it's
             * cached individually, such that all scopes refer to the same flattened metadata.
             */
            this.flattenedDirectiveMetaCache = new Map();
            /**
             * Cache of the computed type check scope per NgModule declaration.
             */
            this.scopeCache = new Map();
        }
        /**
         * Computes the type-check scope information for the component declaration. If the NgModule
         * contains an error, then 'error' is returned. If the component is not declared in any NgModule,
         * an empty type-check scope is returned.
         */
        getTypeCheckScope(node) {
            const matcher = new SelectorMatcher();
            const directives = [];
            const pipes = new Map();
            const scope = this.scopeReader.getScopeForComponent(node);
            if (scope === null) {
                return {
                    matcher,
                    directives,
                    pipes,
                    schemas: [],
                    isPoisoned: false,
                };
            }
            if (this.scopeCache.has(scope.ngModule)) {
                return this.scopeCache.get(scope.ngModule);
            }
            for (const meta of scope.compilation.directives) {
                if (meta.selector !== null) {
                    const extMeta = this.getTypeCheckDirectiveMetadata(meta.ref);
                    matcher.addSelectables(CssSelector.parse(meta.selector), extMeta);
                    directives.push(extMeta);
                }
            }
            for (const { name, ref } of scope.compilation.pipes) {
                if (!ts$1.isClassDeclaration(ref.node)) {
                    throw new Error(`Unexpected non-class declaration ${ts$1.SyntaxKind[ref.node.kind]} for pipe ${ref.debugName}`);
                }
                pipes.set(name, ref);
            }
            const typeCheckScope = {
                matcher,
                directives,
                pipes,
                schemas: scope.schemas,
                isPoisoned: scope.compilation.isPoisoned || scope.exported.isPoisoned,
            };
            this.scopeCache.set(scope.ngModule, typeCheckScope);
            return typeCheckScope;
        }
        getTypeCheckDirectiveMetadata(ref) {
            const clazz = ref.node;
            if (this.flattenedDirectiveMetaCache.has(clazz)) {
                return this.flattenedDirectiveMetaCache.get(clazz);
            }
            const meta = flattenInheritedDirectiveMetadata(this.metaReader, ref);
            this.flattenedDirectiveMetaCache.set(clazz, meta);
            return meta;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const IVY_SWITCH_PRE_SUFFIX = '__PRE_R3__';
    const IVY_SWITCH_POST_SUFFIX = '__POST_R3__';
    function ivySwitchTransform(_) {
        return flipIvySwitchInFile;
    }
    function flipIvySwitchInFile(sf) {
        // To replace the statements array, it must be copied. This only needs to happen if a statement
        // must actually be replaced within the array, so the newStatements array is lazily initialized.
        let newStatements = undefined;
        // Iterate over the statements in the file.
        for (let i = 0; i < sf.statements.length; i++) {
            const statement = sf.statements[i];
            // Skip over everything that isn't a variable statement.
            if (!ts$1.isVariableStatement(statement) || !hasIvySwitches(statement)) {
                continue;
            }
            // This statement needs to be replaced. Check if the newStatements array needs to be lazily
            // initialized to a copy of the original statements.
            if (newStatements === undefined) {
                newStatements = [...sf.statements];
            }
            // Flip any switches in the VariableStatement. If there were any, a new statement will be
            // returned; otherwise the old statement will be.
            newStatements[i] = flipIvySwitchesInVariableStatement(statement, sf.statements);
        }
        // Only update the statements in the SourceFile if any have changed.
        if (newStatements !== undefined) {
            return ts$1.updateSourceFileNode(sf, newStatements);
        }
        return sf;
    }
    /**
     * Look for the ts.Identifier of a ts.Declaration with this name.
     *
     * The real identifier is needed (rather than fabricating one) as TypeScript decides how to
     * reference this identifier based on information stored against its node in the AST, which a
     * synthetic node would not have. In particular, since the post-switch variable is often exported,
     * TypeScript needs to know this so it can write `exports.VAR` instead of just `VAR` when emitting
     * code.
     *
     * Only variable, function, and class declarations are currently searched.
     */
    function findPostSwitchIdentifier(statements, name) {
        for (const stmt of statements) {
            if (ts$1.isVariableStatement(stmt)) {
                const decl = stmt.declarationList.declarations.find(decl => ts$1.isIdentifier(decl.name) && decl.name.text === name);
                if (decl !== undefined) {
                    return decl.name;
                }
            }
            else if (ts$1.isFunctionDeclaration(stmt) || ts$1.isClassDeclaration(stmt)) {
                if (stmt.name !== undefined && ts$1.isIdentifier(stmt.name) && stmt.name.text === name) {
                    return stmt.name;
                }
            }
        }
        return null;
    }
    /**
     * Flip any Ivy switches which are discovered in the given ts.VariableStatement.
     */
    function flipIvySwitchesInVariableStatement(stmt, statements) {
        // Build a new list of variable declarations. Specific declarations that are initialized to a
        // pre-switch identifier will be replaced with a declaration initialized to the post-switch
        // identifier.
        const newDeclarations = [...stmt.declarationList.declarations];
        for (let i = 0; i < newDeclarations.length; i++) {
            const decl = newDeclarations[i];
            // Skip declarations that aren't initialized to an identifier.
            if (decl.initializer === undefined || !ts$1.isIdentifier(decl.initializer)) {
                continue;
            }
            // Skip declarations that aren't Ivy switches.
            if (!decl.initializer.text.endsWith(IVY_SWITCH_PRE_SUFFIX)) {
                continue;
            }
            // Determine the name of the post-switch variable.
            const postSwitchName = decl.initializer.text.replace(IVY_SWITCH_PRE_SUFFIX, IVY_SWITCH_POST_SUFFIX);
            // Find the post-switch variable identifier. If one can't be found, it's an error. This is
            // reported as a thrown error and not a diagnostic as transformers cannot output diagnostics.
            const newIdentifier = findPostSwitchIdentifier(statements, postSwitchName);
            if (newIdentifier === null) {
                throw new Error(`Unable to find identifier ${postSwitchName} in ${stmt.getSourceFile().fileName} for the Ivy switch.`);
            }
            newDeclarations[i] = ts$1.updateVariableDeclaration(
            /* node */ decl, 
            /* name */ decl.name, 
            /* type */ decl.type, 
            /* initializer */ newIdentifier);
        }
        const newDeclList = ts$1.updateVariableDeclarationList(
        /* declarationList */ stmt.declarationList, 
        /* declarations */ newDeclarations);
        const newStmt = ts$1.updateVariableStatement(
        /* statement */ stmt, 
        /* modifiers */ stmt.modifiers, 
        /* declarationList */ newDeclList);
        return newStmt;
    }
    /**
     * Check whether the given VariableStatement has any Ivy switch variables.
     */
    function hasIvySwitches(stmt) {
        return stmt.declarationList.declarations.some(decl => decl.initializer !== undefined && ts$1.isIdentifier(decl.initializer) &&
            decl.initializer.text.endsWith(IVY_SWITCH_PRE_SUFFIX));
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Describes the scope of the caller's interest in template type-checking results.
     */
    var OptimizeFor;
    (function (OptimizeFor) {
        /**
         * Indicates that a consumer of a `TemplateTypeChecker` is only interested in results for a given
         * file, and wants them as fast as possible.
         *
         * Calling `TemplateTypeChecker` methods successively for multiple files while specifying
         * `OptimizeFor.SingleFile` can result in significant unnecessary overhead overall.
         */
        OptimizeFor[OptimizeFor["SingleFile"] = 0] = "SingleFile";
        /**
         * Indicates that a consumer of a `TemplateTypeChecker` intends to query for results pertaining to
         * the entire user program, and so the type-checker should internally optimize for this case.
         *
         * Initial calls to retrieve type-checking information may take longer, but repeated calls to
         * gather information for the whole user program will be significantly faster with this mode of
         * optimization.
         */
        OptimizeFor[OptimizeFor["WholeProgram"] = 1] = "WholeProgram";
    })(OptimizeFor || (OptimizeFor = {}));

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Discriminant of an autocompletion source (a `Completion`).
     */
    var CompletionKind;
    (function (CompletionKind) {
        CompletionKind[CompletionKind["Reference"] = 0] = "Reference";
        CompletionKind[CompletionKind["Variable"] = 1] = "Variable";
    })(CompletionKind || (CompletionKind = {}));

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var SymbolKind;
    (function (SymbolKind) {
        SymbolKind[SymbolKind["Input"] = 0] = "Input";
        SymbolKind[SymbolKind["Output"] = 1] = "Output";
        SymbolKind[SymbolKind["Binding"] = 2] = "Binding";
        SymbolKind[SymbolKind["Reference"] = 3] = "Reference";
        SymbolKind[SymbolKind["Variable"] = 4] = "Variable";
        SymbolKind[SymbolKind["Directive"] = 5] = "Directive";
        SymbolKind[SymbolKind["Element"] = 6] = "Element";
        SymbolKind[SymbolKind["Template"] = 7] = "Template";
        SymbolKind[SymbolKind["Expression"] = 8] = "Expression";
        SymbolKind[SymbolKind["DomBinding"] = 9] = "DomBinding";
        SymbolKind[SymbolKind["Pipe"] = 10] = "Pipe";
    })(SymbolKind || (SymbolKind = {}));

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Constructs a `ts.Diagnostic` for a given `ParseSourceSpan` within a template.
     */
    function makeTemplateDiagnostic(templateId, mapping, span, category, code, messageText, relatedMessages) {
        if (mapping.type === 'direct') {
            let relatedInformation = undefined;
            if (relatedMessages !== undefined) {
                relatedInformation = [];
                for (const relatedMessage of relatedMessages) {
                    relatedInformation.push({
                        category: ts$1.DiagnosticCategory.Message,
                        code: 0,
                        file: relatedMessage.sourceFile,
                        start: relatedMessage.start,
                        length: relatedMessage.end - relatedMessage.start,
                        messageText: relatedMessage.text,
                    });
                }
            }
            // For direct mappings, the error is shown inline as ngtsc was able to pinpoint a string
            // constant within the `@Component` decorator for the template. This allows us to map the error
            // directly into the bytes of the source file.
            return {
                source: 'ngtsc',
                code,
                category,
                messageText,
                file: mapping.node.getSourceFile(),
                componentFile: mapping.node.getSourceFile(),
                templateId,
                start: span.start.offset,
                length: span.end.offset - span.start.offset,
                relatedInformation,
            };
        }
        else if (mapping.type === 'indirect' || mapping.type === 'external') {
            // For indirect mappings (template was declared inline, but ngtsc couldn't map it directly
            // to a string constant in the decorator), the component's file name is given with a suffix
            // indicating it's not the TS file being displayed, but a template.
            // For external temoplates, the HTML filename is used.
            const componentSf = mapping.componentClass.getSourceFile();
            const componentName = mapping.componentClass.name.text;
            // TODO(alxhub): remove cast when TS in g3 supports this narrowing.
            const fileName = mapping.type === 'indirect' ?
                `${componentSf.fileName} (${componentName} template)` :
                mapping.templateUrl;
            // TODO(alxhub): investigate creating a fake `ts.SourceFile` here instead of invoking the TS
            // parser against the template (HTML is just really syntactically invalid TypeScript code ;).
            // Also investigate caching the file to avoid running the parser multiple times.
            const sf = ts$1.createSourceFile(fileName, mapping.template, ts$1.ScriptTarget.Latest, false, ts$1.ScriptKind.JSX);
            let relatedInformation = [];
            if (relatedMessages !== undefined) {
                for (const relatedMessage of relatedMessages) {
                    relatedInformation.push({
                        category: ts$1.DiagnosticCategory.Message,
                        code: 0,
                        file: relatedMessage.sourceFile,
                        start: relatedMessage.start,
                        length: relatedMessage.end - relatedMessage.start,
                        messageText: relatedMessage.text,
                    });
                }
            }
            relatedInformation.push({
                category: ts$1.DiagnosticCategory.Message,
                code: 0,
                file: componentSf,
                // mapping.node represents either the 'template' or 'templateUrl' expression. getStart()
                // and getEnd() are used because they don't include surrounding whitespace.
                start: mapping.node.getStart(),
                length: mapping.node.getEnd() - mapping.node.getStart(),
                messageText: `Error occurs in the template of component ${componentName}.`,
            });
            return {
                source: 'ngtsc',
                category,
                code,
                messageText,
                file: sf,
                componentFile: componentSf,
                templateId,
                start: span.start.offset,
                length: span.end.offset - span.start.offset,
                // Show a secondary message indicating the component whose template contains the error.
                relatedInformation,
            };
        }
        else {
            throw new Error(`Unexpected source mapping type: ${mapping.type}`);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const TEMPLATE_ID = Symbol('ngTemplateId');
    const NEXT_TEMPLATE_ID = Symbol('ngNextTemplateId');
    function getTemplateId(clazz) {
        const node = clazz;
        if (node[TEMPLATE_ID] === undefined) {
            node[TEMPLATE_ID] = allocateTemplateId(node.getSourceFile());
        }
        return node[TEMPLATE_ID];
    }
    function allocateTemplateId(sf) {
        if (sf[NEXT_TEMPLATE_ID] === undefined) {
            sf[NEXT_TEMPLATE_ID] = 1;
        }
        return (`tcb${sf[NEXT_TEMPLATE_ID]++}`);
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const parseSpanComment = /^(\d+),(\d+)$/;
    /**
     * Reads the trailing comments and finds the first match which is a span comment (i.e. 4,10) on a
     * node and returns it as an `AbsoluteSourceSpan`.
     *
     * Will return `null` if no trailing comments on the node match the expected form of a source span.
     */
    function readSpanComment(node, sourceFile = node.getSourceFile()) {
        return ts$1.forEachTrailingCommentRange(sourceFile.text, node.getEnd(), (pos, end, kind) => {
            if (kind !== ts$1.SyntaxKind.MultiLineCommentTrivia) {
                return null;
            }
            const commentText = sourceFile.text.substring(pos + 2, end - 2);
            const match = commentText.match(parseSpanComment);
            if (match === null) {
                return null;
            }
            return new AbsoluteSourceSpan(+match[1], +match[2]);
        }) || null;
    }
    /** Used to identify what type the comment is. */
    var CommentTriviaType;
    (function (CommentTriviaType) {
        CommentTriviaType["DIAGNOSTIC"] = "D";
        CommentTriviaType["EXPRESSION_TYPE_IDENTIFIER"] = "T";
    })(CommentTriviaType || (CommentTriviaType = {}));
    /** Identifies what the TCB expression is for (for example, a directive declaration). */
    var ExpressionIdentifier;
    (function (ExpressionIdentifier) {
        ExpressionIdentifier["DIRECTIVE"] = "DIR";
        ExpressionIdentifier["COMPONENT_COMPLETION"] = "COMPCOMP";
        ExpressionIdentifier["EVENT_PARAMETER"] = "EP";
    })(ExpressionIdentifier || (ExpressionIdentifier = {}));
    /** Tags the node with the given expression identifier. */
    function addExpressionIdentifier(node, identifier) {
        ts$1.addSyntheticTrailingComment(node, ts$1.SyntaxKind.MultiLineCommentTrivia, `${CommentTriviaType.EXPRESSION_TYPE_IDENTIFIER}:${identifier}`, 
        /* hasTrailingNewLine */ false);
    }
    const IGNORE_FOR_DIAGNOSTICS_MARKER = `${CommentTriviaType.DIAGNOSTIC}:ignore`;
    /**
     * Tag the `ts.Node` with an indication that any errors arising from the evaluation of the node
     * should be ignored.
     */
    function markIgnoreDiagnostics(node) {
        ts$1.addSyntheticTrailingComment(node, ts$1.SyntaxKind.MultiLineCommentTrivia, IGNORE_FOR_DIAGNOSTICS_MARKER, 
        /* hasTrailingNewLine */ false);
    }
    /** Returns true if the node has a marker that indicates diagnostics errors should be ignored.  */
    function hasIgnoreForDiagnosticsMarker(node, sourceFile) {
        return ts$1.forEachTrailingCommentRange(sourceFile.text, node.getEnd(), (pos, end, kind) => {
            if (kind !== ts$1.SyntaxKind.MultiLineCommentTrivia) {
                return null;
            }
            const commentText = sourceFile.text.substring(pos + 2, end - 2);
            return commentText === IGNORE_FOR_DIAGNOSTICS_MARKER;
        }) === true;
    }
    function makeRecursiveVisitor(visitor) {
        function recursiveVisitor(node) {
            const res = visitor(node);
            return res !== null ? res : node.forEachChild(recursiveVisitor);
        }
        return recursiveVisitor;
    }
    function getSpanFromOptions(opts) {
        let withSpan = null;
        if (opts.withSpan !== undefined) {
            if (opts.withSpan instanceof AbsoluteSourceSpan) {
                withSpan = opts.withSpan;
            }
            else {
                withSpan = { start: opts.withSpan.start.offset, end: opts.withSpan.end.offset };
            }
        }
        return withSpan;
    }
    /**
     * Given a `ts.Node` with finds the first node whose matching the criteria specified
     * by the `FindOptions`.
     *
     * Returns `null` when no `ts.Node` matches the given conditions.
     */
    function findFirstMatchingNode(tcb, opts) {
        var _a;
        const withSpan = getSpanFromOptions(opts);
        const withExpressionIdentifier = opts.withExpressionIdentifier;
        const sf = tcb.getSourceFile();
        const visitor = makeRecursiveVisitor(node => {
            if (!opts.filter(node)) {
                return null;
            }
            if (withSpan !== null) {
                const comment = readSpanComment(node, sf);
                if (comment === null || withSpan.start !== comment.start || withSpan.end !== comment.end) {
                    return null;
                }
            }
            if (withExpressionIdentifier !== undefined &&
                !hasExpressionIdentifier(sf, node, withExpressionIdentifier)) {
                return null;
            }
            return node;
        });
        return (_a = tcb.forEachChild(visitor)) !== null && _a !== void 0 ? _a : null;
    }
    /**
     * Given a `ts.Node` with source span comments, finds the first node whose source span comment
     * matches the given `sourceSpan`. Additionally, the `filter` function allows matching only
     * `ts.Nodes` of a given type, which provides the ability to select only matches of a given type
     * when there may be more than one.
     *
     * Returns `null` when no `ts.Node` matches the given conditions.
     */
    function findAllMatchingNodes(tcb, opts) {
        const withSpan = getSpanFromOptions(opts);
        const withExpressionIdentifier = opts.withExpressionIdentifier;
        const results = [];
        const stack = [tcb];
        const sf = tcb.getSourceFile();
        while (stack.length > 0) {
            const node = stack.pop();
            if (!opts.filter(node)) {
                stack.push(...node.getChildren());
                continue;
            }
            if (withSpan !== null) {
                const comment = readSpanComment(node, sf);
                if (comment === null || withSpan.start !== comment.start || withSpan.end !== comment.end) {
                    stack.push(...node.getChildren());
                    continue;
                }
            }
            if (withExpressionIdentifier !== undefined &&
                !hasExpressionIdentifier(sf, node, withExpressionIdentifier)) {
                continue;
            }
            results.push(node);
        }
        return results;
    }
    function hasExpressionIdentifier(sourceFile, node, identifier) {
        return ts$1.forEachTrailingCommentRange(sourceFile.text, node.getEnd(), (pos, end, kind) => {
            if (kind !== ts$1.SyntaxKind.MultiLineCommentTrivia) {
                return false;
            }
            const commentText = sourceFile.text.substring(pos + 2, end - 2);
            return commentText === `${CommentTriviaType.EXPRESSION_TYPE_IDENTIFIER}:${identifier}`;
        }) || false;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Powers autocompletion for a specific component.
     *
     * Internally caches autocompletion results, and must be discarded if the component template or
     * surrounding TS program have changed.
     */
    class CompletionEngine {
        constructor(tcb, data, shimPath) {
            this.tcb = tcb;
            this.data = data;
            this.shimPath = shimPath;
            /**
             * Cache of completions for various levels of the template, including the root template (`null`).
             * Memoizes `getTemplateContextCompletions`.
             */
            this.templateContextCache = new Map();
            this.expressionCompletionCache = new Map();
            // Find the component completion expression within the TCB. This looks like: `ctx. /* ... */;`
            const globalRead = findFirstMatchingNode(this.tcb, {
                filter: ts$1.isPropertyAccessExpression,
                withExpressionIdentifier: ExpressionIdentifier.COMPONENT_COMPLETION
            });
            if (globalRead !== null) {
                this.componentContext = {
                    shimPath: this.shimPath,
                    // `globalRead.name` is an empty `ts.Identifier`, so its start position immediately follows
                    // the `.` in `ctx.`. TS autocompletion APIs can then be used to access completion results
                    // for the component context.
                    positionInShimFile: globalRead.name.getStart(),
                };
            }
            else {
                this.componentContext = null;
            }
        }
        /**
         * Get global completions within the given template context and AST node.
         *
         * @param context the given template context - either a `TmplAstTemplate` embedded view, or `null`
         *     for the root
         * template context.
         * @param node the given AST node
         */
        getGlobalCompletions(context, node) {
            if (this.componentContext === null) {
                return null;
            }
            const templateContext = this.getTemplateContextCompletions(context);
            if (templateContext === null) {
                return null;
            }
            let nodeContext = null;
            if (node instanceof EmptyExpr) {
                const nodeLocation = findFirstMatchingNode(this.tcb, {
                    filter: ts$1.isIdentifier,
                    withSpan: node.sourceSpan,
                });
                if (nodeLocation !== null) {
                    nodeContext = {
                        shimPath: this.shimPath,
                        positionInShimFile: nodeLocation.getStart(),
                    };
                }
            }
            if (node instanceof PropertyRead && node.receiver instanceof ImplicitReceiver) {
                const nodeLocation = findFirstMatchingNode(this.tcb, {
                    filter: ts$1.isPropertyAccessExpression,
                    withSpan: node.sourceSpan,
                });
                if (nodeLocation) {
                    nodeContext = {
                        shimPath: this.shimPath,
                        positionInShimFile: nodeLocation.getStart(),
                    };
                }
            }
            return {
                componentContext: this.componentContext,
                templateContext,
                nodeContext,
            };
        }
        getExpressionCompletionLocation(expr) {
            if (this.expressionCompletionCache.has(expr)) {
                return this.expressionCompletionCache.get(expr);
            }
            // Completion works inside property reads and method calls.
            let tsExpr = null;
            if (expr instanceof PropertyRead || expr instanceof MethodCall ||
                expr instanceof PropertyWrite) {
                // Non-safe navigation operations are trivial: `foo.bar` or `foo.bar()`
                tsExpr = findFirstMatchingNode(this.tcb, {
                    filter: ts$1.isPropertyAccessExpression,
                    withSpan: expr.nameSpan,
                });
            }
            else if (expr instanceof SafePropertyRead || expr instanceof SafeMethodCall) {
                // Safe navigation operations are a little more complex, and involve a ternary. Completion
                // happens in the "true" case of the ternary.
                const ternaryExpr = findFirstMatchingNode(this.tcb, {
                    filter: ts$1.isParenthesizedExpression,
                    withSpan: expr.sourceSpan,
                });
                if (ternaryExpr === null || !ts$1.isConditionalExpression(ternaryExpr.expression)) {
                    return null;
                }
                const whenTrue = ternaryExpr.expression.whenTrue;
                if (expr instanceof SafePropertyRead && ts$1.isPropertyAccessExpression(whenTrue)) {
                    tsExpr = whenTrue;
                }
                else if (expr instanceof SafeMethodCall && ts$1.isCallExpression(whenTrue) &&
                    ts$1.isPropertyAccessExpression(whenTrue.expression)) {
                    tsExpr = whenTrue.expression;
                }
            }
            if (tsExpr === null) {
                return null;
            }
            const res = {
                shimPath: this.shimPath,
                positionInShimFile: tsExpr.name.getEnd(),
            };
            this.expressionCompletionCache.set(expr, res);
            return res;
        }
        getLiteralCompletionLocation(expr) {
            if (this.expressionCompletionCache.has(expr)) {
                return this.expressionCompletionCache.get(expr);
            }
            let tsExpr = null;
            if (expr instanceof TextAttribute) {
                const strNode = findFirstMatchingNode(this.tcb, {
                    filter: ts$1.isParenthesizedExpression,
                    withSpan: expr.sourceSpan,
                });
                if (strNode !== null && ts$1.isStringLiteral(strNode.expression)) {
                    tsExpr = strNode.expression;
                }
            }
            else {
                tsExpr = findFirstMatchingNode(this.tcb, {
                    filter: (n) => ts$1.isStringLiteral(n) || ts$1.isNumericLiteral(n),
                    withSpan: expr.sourceSpan,
                });
            }
            if (tsExpr === null) {
                return null;
            }
            let positionInShimFile = tsExpr.getEnd();
            if (ts$1.isStringLiteral(tsExpr)) {
                // In the shimFile, if `tsExpr` is a string, the position should be in the quotes.
                positionInShimFile -= 1;
            }
            const res = {
                shimPath: this.shimPath,
                positionInShimFile,
            };
            this.expressionCompletionCache.set(expr, res);
            return res;
        }
        /**
         * Get global completions within the given template context - either a `TmplAstTemplate` embedded
         * view, or `null` for the root context.
         */
        getTemplateContextCompletions(context) {
            if (this.templateContextCache.has(context)) {
                return this.templateContextCache.get(context);
            }
            const templateContext = new Map();
            // The bound template already has details about the references and variables in scope in the
            // `context` template - they just need to be converted to `Completion`s.
            for (const node of this.data.boundTarget.getEntitiesInTemplateScope(context)) {
                if (node instanceof Reference) {
                    templateContext.set(node.name, {
                        kind: CompletionKind.Reference,
                        node,
                    });
                }
                else {
                    templateContext.set(node.name, {
                        kind: CompletionKind.Variable,
                        node,
                    });
                }
            }
            this.templateContextCache.set(context, templateContext);
            return templateContext;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const REGISTRY = new DomElementSchemaRegistry();
    const REMOVE_XHTML_REGEX = /^:xhtml:/;
    /**
     * Checks non-Angular elements and properties against the `DomElementSchemaRegistry`, a schema
     * maintained by the Angular team via extraction from a browser IDL.
     */
    class RegistryDomSchemaChecker {
        constructor(resolver) {
            this.resolver = resolver;
            this._diagnostics = [];
        }
        get diagnostics() {
            return this._diagnostics;
        }
        checkElement(id, element, schemas) {
            // HTML elements inside an SVG `foreignObject` are declared in the `xhtml` namespace.
            // We need to strip it before handing it over to the registry because all HTML tag names
            // in the registry are without a namespace.
            const name = element.name.replace(REMOVE_XHTML_REGEX, '');
            if (!REGISTRY.hasElement(name, schemas)) {
                const mapping = this.resolver.getSourceMapping(id);
                let errorMsg = `'${name}' is not a known element:\n`;
                errorMsg +=
                    `1. If '${name}' is an Angular component, then verify that it is part of this module.\n`;
                if (name.indexOf('-') > -1) {
                    errorMsg += `2. If '${name}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the '@NgModule.schemas' of this component to suppress this message.`;
                }
                else {
                    errorMsg +=
                        `2. To allow any element add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.`;
                }
                const diag = makeTemplateDiagnostic(id, mapping, element.startSourceSpan, ts$1.DiagnosticCategory.Error, ngErrorCode(ErrorCode.SCHEMA_INVALID_ELEMENT), errorMsg);
                this._diagnostics.push(diag);
            }
        }
        checkProperty(id, element, name, span, schemas) {
            if (!REGISTRY.hasProperty(element.name, name, schemas)) {
                const mapping = this.resolver.getSourceMapping(id);
                let errorMsg = `Can't bind to '${name}' since it isn't a known property of '${element.name}'.`;
                if (element.name.startsWith('ng-')) {
                    errorMsg +=
                        `\n1. If '${name}' is an Angular directive, then add 'CommonModule' to the '@NgModule.imports' of this component.` +
                            `\n2. To allow any property add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.`;
                }
                else if (element.name.indexOf('-') > -1) {
                    errorMsg +=
                        `\n1. If '${element.name}' is an Angular component and it has '${name}' input, then verify that it is part of this module.` +
                            `\n2. If '${element
                            .name}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the '@NgModule.schemas' of this component to suppress this message.` +
                            `\n3. To allow any property add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.`;
                }
                const diag = makeTemplateDiagnostic(id, mapping, span, ts$1.DiagnosticCategory.Error, ngErrorCode(ErrorCode.SCHEMA_INVALID_ATTRIBUTE), errorMsg);
                this._diagnostics.push(diag);
            }
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A `Set` of `ts.SyntaxKind`s of `ts.Expression` which are safe to wrap in a `ts.AsExpression`
     * without needing to be wrapped in parentheses.
     *
     * For example, `foo.bar()` is a `ts.CallExpression`, and can be safely cast to `any` with
     * `foo.bar() as any`. however, `foo !== bar` is a `ts.BinaryExpression`, and attempting to cast
     * without the parentheses yields the expression `foo !== bar as any`. This is semantically
     * equivalent to `foo !== (bar as any)`, which is not what was intended. Thus,
     * `ts.BinaryExpression`s need to be wrapped in parentheses before casting.
     */
    //
    const SAFE_TO_CAST_WITHOUT_PARENS = new Set([
        // Expressions which are already parenthesized can be cast without further wrapping.
        ts$1.SyntaxKind.ParenthesizedExpression,
        // Expressions which form a single lexical unit leave no room for precedence issues with the cast.
        ts$1.SyntaxKind.Identifier,
        ts$1.SyntaxKind.CallExpression,
        ts$1.SyntaxKind.NonNullExpression,
        ts$1.SyntaxKind.ElementAccessExpression,
        ts$1.SyntaxKind.PropertyAccessExpression,
        ts$1.SyntaxKind.ArrayLiteralExpression,
        ts$1.SyntaxKind.ObjectLiteralExpression,
        // The same goes for various literals.
        ts$1.SyntaxKind.StringLiteral,
        ts$1.SyntaxKind.NumericLiteral,
        ts$1.SyntaxKind.TrueKeyword,
        ts$1.SyntaxKind.FalseKeyword,
        ts$1.SyntaxKind.NullKeyword,
        ts$1.SyntaxKind.UndefinedKeyword,
    ]);
    function tsCastToAny(expr) {
        // Wrap `expr` in parentheses if needed (see `SAFE_TO_CAST_WITHOUT_PARENS` above).
        if (!SAFE_TO_CAST_WITHOUT_PARENS.has(expr.kind)) {
            expr = ts$1.createParen(expr);
        }
        // The outer expression is always wrapped in parentheses.
        return ts$1.createParen(ts$1.createAsExpression(expr, ts$1.createKeywordTypeNode(ts$1.SyntaxKind.AnyKeyword)));
    }
    /**
     * Create an expression which instantiates an element by its HTML tagName.
     *
     * Thanks to narrowing of `document.createElement()`, this expression will have its type inferred
     * based on the tag name, including for custom elements that have appropriate .d.ts definitions.
     */
    function tsCreateElement(tagName) {
        const createElement = ts$1.createPropertyAccess(
        /* expression */ ts$1.createIdentifier('document'), 'createElement');
        return ts$1.createCall(
        /* expression */ createElement, 
        /* typeArguments */ undefined, 
        /* argumentsArray */ [ts$1.createLiteral(tagName)]);
    }
    /**
     * Create a `ts.VariableStatement` which declares a variable without explicit initialization.
     *
     * The initializer `null!` is used to bypass strict variable initialization checks.
     *
     * Unlike with `tsCreateVariable`, the type of the variable is explicitly specified.
     */
    function tsDeclareVariable(id, type) {
        const decl = ts$1.createVariableDeclaration(
        /* name */ id, 
        /* type */ type, 
        /* initializer */ ts$1.createNonNullExpression(ts$1.createNull()));
        return ts$1.createVariableStatement(
        /* modifiers */ undefined, 
        /* declarationList */ [decl]);
    }
    /**
     * Creates a `ts.TypeQueryNode` for a coerced input.
     *
     * For example: `typeof MatInput.ngAcceptInputType_value`, where MatInput is `typeName` and `value`
     * is the `coercedInputName`.
     *
     * @param typeName The `EntityName` of the Directive where the static coerced input is defined.
     * @param coercedInputName The field name of the coerced input.
     */
    function tsCreateTypeQueryForCoercedInput(typeName, coercedInputName) {
        return ts$1.createTypeQueryNode(ts$1.createQualifiedName(typeName, `ngAcceptInputType_${coercedInputName}`));
    }
    /**
     * Create a `ts.VariableStatement` that initializes a variable with a given expression.
     *
     * Unlike with `tsDeclareVariable`, the type of the variable is inferred from the initializer
     * expression.
     */
    function tsCreateVariable(id, initializer) {
        const decl = ts$1.createVariableDeclaration(
        /* name */ id, 
        /* type */ undefined, 
        /* initializer */ initializer);
        return ts$1.createVariableStatement(
        /* modifiers */ undefined, 
        /* declarationList */ [decl]);
    }
    /**
     * Construct a `ts.CallExpression` that calls a method on a receiver.
     */
    function tsCallMethod(receiver, methodName, args = []) {
        const methodAccess = ts$1.createPropertyAccess(receiver, methodName);
        return ts$1.createCall(
        /* expression */ methodAccess, 
        /* typeArguments */ undefined, 
        /* argumentsArray */ args);
    }
    function checkIfClassIsExported(node) {
        // A class is exported if one of two conditions is met:
        // 1) it has the 'export' modifier.
        // 2) it's declared at the top level, and there is an export statement for the class.
        if (node.modifiers !== undefined &&
            node.modifiers.some(mod => mod.kind === ts$1.SyntaxKind.ExportKeyword)) {
            // Condition 1 is true, the class has an 'export' keyword attached.
            return true;
        }
        else if (node.parent !== undefined && ts$1.isSourceFile(node.parent) &&
            checkIfFileHasExport(node.parent, node.name.text)) {
            // Condition 2 is true, the class is exported via an 'export {}' statement.
            return true;
        }
        return false;
    }
    function checkIfFileHasExport(sf, name) {
        for (const stmt of sf.statements) {
            if (ts$1.isExportDeclaration(stmt) && stmt.exportClause !== undefined &&
                ts$1.isNamedExports(stmt.exportClause)) {
                for (const element of stmt.exportClause.elements) {
                    if (element.propertyName === undefined && element.name.text === name) {
                        // The named declaration is directly exported.
                        return true;
                    }
                    else if (element.propertyName !== undefined && element.propertyName.text == name) {
                        // The named declaration is exported via an alias.
                        return true;
                    }
                }
            }
        }
        return false;
    }
    function isAccessExpression(node) {
        return ts$1.isPropertyAccessExpression(node) || ts$1.isElementAccessExpression(node);
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const INELIGIBLE = {};
    /**
     * Determines whether the provided type can be emitted, which means that it can be safely emitted
     * into a different location.
     *
     * If this function returns true, a `TypeEmitter` should be able to succeed. Vice versa, if this
     * function returns false, then using the `TypeEmitter` should not be attempted as it is known to
     * fail.
     */
    function canEmitType(type, resolver) {
        return canEmitTypeWorker(type);
        function canEmitTypeWorker(type) {
            return visitNode(type) !== INELIGIBLE;
        }
        // To determine whether a type can be emitted, we have to recursively look through all type nodes.
        // If an unsupported type node is found at any position within the type, then the `INELIGIBLE`
        // constant is returned to stop the recursive walk as the type as a whole cannot be emitted in
        // that case. Otherwise, the result of visiting all child nodes determines the result. If no
        // ineligible type reference node is found then the walk returns `undefined`, indicating that
        // no type node was visited that could not be emitted.
        function visitNode(node) {
            // `import('module')` type nodes are not supported, as it may require rewriting the module
            // specifier which is currently not done.
            if (ts$1.isImportTypeNode(node)) {
                return INELIGIBLE;
            }
            // Emitting a type reference node in a different context requires that an import for the type
            // can be created. If a type reference node cannot be emitted, `INELIGIBLE` is returned to stop
            // the walk.
            if (ts$1.isTypeReferenceNode(node) && !canEmitTypeReference(node)) {
                return INELIGIBLE;
            }
            else {
                return ts$1.forEachChild(node, visitNode);
            }
        }
        function canEmitTypeReference(type) {
            const reference = resolver(type);
            // If the type could not be resolved, it can not be emitted.
            if (reference === null) {
                return false;
            }
            // If the type is a reference, consider the type to be eligible for emitting.
            if (reference instanceof Reference$1) {
                return true;
            }
            // The type can be emitted if either it does not have any type arguments, or all of them can be
            // emitted.
            return type.typeArguments === undefined || type.typeArguments.every(canEmitTypeWorker);
        }
    }
    /**
     * Given a `ts.TypeNode`, this class derives an equivalent `ts.TypeNode` that has been emitted into
     * a different context.
     *
     * For example, consider the following code:
     *
     * ```
     * import {NgIterable} from '@angular/core';
     *
     * class NgForOf<T, U extends NgIterable<T>> {}
     * ```
     *
     * Here, the generic type parameters `T` and `U` can be emitted into a different context, as the
     * type reference to `NgIterable` originates from an absolute module import so that it can be
     * emitted anywhere, using that same module import. The process of emitting translates the
     * `NgIterable` type reference to a type reference that is valid in the context in which it is
     * emitted, for example:
     *
     * ```
     * import * as i0 from '@angular/core';
     * import * as i1 from '@angular/common';
     *
     * const _ctor1: <T, U extends i0.NgIterable<T>>(o: Pick<i1.NgForOf<T, U>, 'ngForOf'>):
     * i1.NgForOf<T, U>;
     * ```
     *
     * Notice how the type reference for `NgIterable` has been translated into a qualified name,
     * referring to the namespace import that was created.
     */
    class TypeEmitter {
        constructor(resolver, emitReference) {
            this.resolver = resolver;
            this.emitReference = emitReference;
        }
        emitType(type) {
            const typeReferenceTransformer = context => {
                const visitNode = (node) => {
                    if (ts$1.isImportTypeNode(node)) {
                        throw new Error('Unable to emit import type');
                    }
                    if (ts$1.isTypeReferenceNode(node)) {
                        return this.emitTypeReference(node);
                    }
                    else if (ts$1.isLiteralExpression(node)) {
                        // TypeScript would typically take the emit text for a literal expression from the source
                        // file itself. As the type node is being emitted into a different file, however,
                        // TypeScript would extract the literal text from the wrong source file. To mitigate this
                        // issue the literal is cloned and explicitly marked as synthesized by setting its text
                        // range to a negative range, forcing TypeScript to determine the node's literal text from
                        // the synthesized node's text instead of the incorrect source file.
                        const clone = ts$1.getMutableClone(node);
                        ts$1.setTextRange(clone, { pos: -1, end: -1 });
                        return clone;
                    }
                    else {
                        return ts$1.visitEachChild(node, visitNode, context);
                    }
                };
                return node => ts$1.visitNode(node, visitNode);
            };
            return ts$1.transform(type, [typeReferenceTransformer]).transformed[0];
        }
        emitTypeReference(type) {
            // Determine the reference that the type corresponds with.
            const reference = this.resolver(type);
            if (reference === null) {
                throw new Error('Unable to emit an unresolved reference');
            }
            // Emit the type arguments, if any.
            let typeArguments = undefined;
            if (type.typeArguments !== undefined) {
                typeArguments = ts$1.createNodeArray(type.typeArguments.map(typeArg => this.emitType(typeArg)));
            }
            // Emit the type name.
            let typeName = type.typeName;
            if (reference instanceof Reference$1) {
                const emittedType = this.emitReference(reference);
                if (!ts$1.isTypeReferenceNode(emittedType)) {
                    throw new Error(`Expected TypeReferenceNode for emitted reference, got ${ts$1.SyntaxKind[emittedType.kind]}`);
                }
                typeName = emittedType.typeName;
            }
            return ts$1.updateTypeReferenceNode(type, typeName, typeArguments);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * See `TypeEmitter` for more information on the emitting process.
     */
    class TypeParameterEmitter {
        constructor(typeParameters, reflector) {
            this.typeParameters = typeParameters;
            this.reflector = reflector;
        }
        /**
         * Determines whether the type parameters can be emitted. If this returns true, then a call to
         * `emit` is known to succeed. Vice versa, if false is returned then `emit` should not be
         * called, as it would fail.
         */
        canEmit() {
            if (this.typeParameters === undefined) {
                return true;
            }
            return this.typeParameters.every(typeParam => {
                return this.canEmitType(typeParam.constraint) && this.canEmitType(typeParam.default);
            });
        }
        canEmitType(type) {
            if (type === undefined) {
                return true;
            }
            return canEmitType(type, typeReference => this.resolveTypeReference(typeReference));
        }
        /**
         * Emits the type parameters using the provided emitter function for `Reference`s.
         */
        emit(emitReference) {
            if (this.typeParameters === undefined) {
                return undefined;
            }
            const emitter = new TypeEmitter(type => this.resolveTypeReference(type), emitReference);
            return this.typeParameters.map(typeParam => {
                const constraint = typeParam.constraint !== undefined ? emitter.emitType(typeParam.constraint) : undefined;
                const defaultType = typeParam.default !== undefined ? emitter.emitType(typeParam.default) : undefined;
                return ts$1.updateTypeParameterDeclaration(
                /* node */ typeParam, 
                /* name */ typeParam.name, 
                /* constraint */ constraint, 
                /* defaultType */ defaultType);
            });
        }
        resolveTypeReference(type) {
            const target = ts$1.isIdentifier(type.typeName) ? type.typeName : type.typeName.right;
            const declaration = this.reflector.getDeclarationOfIdentifier(target);
            // If no declaration could be resolved or does not have a `ts.Declaration`, the type cannot be
            // resolved.
            if (declaration === null || declaration.node === null) {
                return null;
            }
            // If the declaration corresponds with a local type parameter, the type reference can be used
            // as is.
            if (this.isLocalTypeParameter(declaration.node)) {
                return type;
            }
            let owningModule = null;
            if (declaration.viaModule !== null) {
                owningModule = {
                    specifier: declaration.viaModule,
                    resolutionContext: type.getSourceFile().fileName,
                };
            }
            // The declaration needs to be exported as a top-level export to be able to emit an import
            // statement for it. If the declaration is not exported, null is returned to prevent emit.
            if (!this.isTopLevelExport(declaration.node)) {
                return null;
            }
            return new Reference$1(declaration.node, owningModule);
        }
        isTopLevelExport(decl) {
            if (decl.parent === undefined || !ts$1.isSourceFile(decl.parent)) {
                // The declaration has to exist at the top-level, as the reference emitters are not capable of
                // generating imports to classes declared in a namespace.
                return false;
            }
            return this.reflector.isStaticallyExported(decl);
        }
        isLocalTypeParameter(decl) {
            // Checking for local type parameters only occurs during resolution of type parameters, so it is
            // guaranteed that type parameters are present.
            return this.typeParameters.some(param => param === decl);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Indicates whether a particular component requires an inline type check block.
     *
     * This is not a boolean state as inlining might only be required to get the best possible
     * type-checking, but the component could theoretically still be checked without it.
     */
    var TcbInliningRequirement;
    (function (TcbInliningRequirement) {
        /**
         * There is no way to type check this component without inlining.
         */
        TcbInliningRequirement[TcbInliningRequirement["MustInline"] = 0] = "MustInline";
        /**
         * Inlining should be used due to the component's generic bounds, but a non-inlining fallback
         * method can be used if that's not possible.
         */
        TcbInliningRequirement[TcbInliningRequirement["ShouldInlineForGenericBounds"] = 1] = "ShouldInlineForGenericBounds";
        /**
         * There is no requirement for this component's TCB to be inlined.
         */
        TcbInliningRequirement[TcbInliningRequirement["None"] = 2] = "None";
    })(TcbInliningRequirement || (TcbInliningRequirement = {}));
    function requiresInlineTypeCheckBlock(node, usedPipes, reflector) {
        // In order to qualify for a declared TCB (not inline) two conditions must be met:
        // 1) the class must be exported
        // 2) it must not have contextual generic type bounds
        if (!checkIfClassIsExported(node)) {
            // Condition 1 is false, the class is not exported.
            return TcbInliningRequirement.MustInline;
        }
        else if (!checkIfGenericTypeBoundsAreContextFree(node, reflector)) {
            // Condition 2 is false, the class has constrained generic types. It should be checked with an
            // inline TCB if possible, but can potentially use fallbacks to avoid inlining if not.
            return TcbInliningRequirement.ShouldInlineForGenericBounds;
        }
        else if (Array.from(usedPipes.values())
            .some(pipeRef => !checkIfClassIsExported(pipeRef.node))) {
            // If one of the pipes used by the component is not exported, a non-inline TCB will not be able
            // to import it, so this requires an inline TCB.
            return TcbInliningRequirement.MustInline;
        }
        else {
            return TcbInliningRequirement.None;
        }
    }
    /** Maps a shim position back to a template location. */
    function getTemplateMapping(shimSf, position, resolver, isDiagnosticRequest) {
        const node = getTokenAtPosition(shimSf, position);
        const sourceLocation = findSourceLocation(node, shimSf, isDiagnosticRequest);
        if (sourceLocation === null) {
            return null;
        }
        const mapping = resolver.getSourceMapping(sourceLocation.id);
        const span = resolver.toParseSourceSpan(sourceLocation.id, sourceLocation.span);
        if (span === null) {
            return null;
        }
        // TODO(atscott): Consider adding a context span by walking up from `node` until we get a
        // different span.
        return { sourceLocation, templateSourceMapping: mapping, span };
    }
    function findTypeCheckBlock(file, id, isDiagnosticRequest) {
        for (const stmt of file.statements) {
            if (ts$1.isFunctionDeclaration(stmt) && getTemplateId$1(stmt, file, isDiagnosticRequest) === id) {
                return stmt;
            }
        }
        return null;
    }
    /**
     * Traverses up the AST starting from the given node to extract the source location from comments
     * that have been emitted into the TCB. If the node does not exist within a TCB, or if an ignore
     * marker comment is found up the tree (and this is part of a diagnostic request), this function
     * returns null.
     */
    function findSourceLocation(node, sourceFile, isDiagnosticsRequest) {
        // Search for comments until the TCB's function declaration is encountered.
        while (node !== undefined && !ts$1.isFunctionDeclaration(node)) {
            if (hasIgnoreForDiagnosticsMarker(node, sourceFile) && isDiagnosticsRequest) {
                // There's an ignore marker on this node, so the diagnostic should not be reported.
                return null;
            }
            const span = readSpanComment(node, sourceFile);
            if (span !== null) {
                // Once the positional information has been extracted, search further up the TCB to extract
                // the unique id that is attached with the TCB's function declaration.
                const id = getTemplateId$1(node, sourceFile, isDiagnosticsRequest);
                if (id === null) {
                    return null;
                }
                return { id, span };
            }
            node = node.parent;
        }
        return null;
    }
    function getTemplateId$1(node, sourceFile, isDiagnosticRequest) {
        // Walk up to the function declaration of the TCB, the file information is attached there.
        while (!ts$1.isFunctionDeclaration(node)) {
            if (hasIgnoreForDiagnosticsMarker(node, sourceFile) && isDiagnosticRequest) {
                // There's an ignore marker on this node, so the diagnostic should not be reported.
                return null;
            }
            node = node.parent;
            // Bail once we have reached the root.
            if (node === undefined) {
                return null;
            }
        }
        const start = node.getFullStart();
        return ts$1.forEachLeadingCommentRange(sourceFile.text, start, (pos, end, kind) => {
            if (kind !== ts$1.SyntaxKind.MultiLineCommentTrivia) {
                return null;
            }
            const commentText = sourceFile.text.substring(pos + 2, end - 2);
            return commentText;
        }) || null;
    }
    function checkIfGenericTypeBoundsAreContextFree(node, reflector) {
        // Generic type parameters are considered context free if they can be emitted into any context.
        return new TypeParameterEmitter(node.typeParameters, reflector).canEmit();
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function generateTypeCtorDeclarationFn(node, meta, nodeTypeRef, typeParams, reflector) {
        if (requiresInlineTypeCtor(node, reflector)) {
            throw new Error(`${node.name.text} requires an inline type constructor`);
        }
        const rawTypeArgs = typeParams !== undefined ? generateGenericArgs(typeParams) : undefined;
        const rawType = ts$1.createTypeReferenceNode(nodeTypeRef, rawTypeArgs);
        const initParam = constructTypeCtorParameter(node, meta, rawType);
        const typeParameters = typeParametersWithDefaultTypes(typeParams);
        if (meta.body) {
            const fnType = ts$1.createFunctionTypeNode(
            /* typeParameters */ typeParameters, 
            /* parameters */ [initParam], 
            /* type */ rawType);
            const decl = ts$1.createVariableDeclaration(
            /* name */ meta.fnName, 
            /* type */ fnType, 
            /* body */ ts$1.createNonNullExpression(ts$1.createNull()));
            const declList = ts$1.createVariableDeclarationList([decl], ts$1.NodeFlags.Const);
            return ts$1.createVariableStatement(
            /* modifiers */ undefined, 
            /* declarationList */ declList);
        }
        else {
            return ts$1.createFunctionDeclaration(
            /* decorators */ undefined, 
            /* modifiers */ [ts$1.createModifier(ts$1.SyntaxKind.DeclareKeyword)], 
            /* asteriskToken */ undefined, 
            /* name */ meta.fnName, 
            /* typeParameters */ typeParameters, 
            /* parameters */ [initParam], 
            /* type */ rawType, 
            /* body */ undefined);
        }
    }
    /**
     * Generate an inline type constructor for the given class and metadata.
     *
     * An inline type constructor is a specially shaped TypeScript static method, intended to be placed
     * within a directive class itself, that permits type inference of any generic type parameters of
     * the class from the types of expressions bound to inputs or outputs, and the types of elements
     * that match queries performed by the directive. It also catches any errors in the types of these
     * expressions. This method is never called at runtime, but is used in type-check blocks to
     * construct directive types.
     *
     * An inline type constructor for NgFor looks like:
     *
     * static ngTypeCtor<T>(init: Pick<NgForOf<T>, 'ngForOf'|'ngForTrackBy'|'ngForTemplate'>):
     *   NgForOf<T>;
     *
     * A typical constructor would be:
     *
     * NgForOf.ngTypeCtor(init: {
     *   ngForOf: ['foo', 'bar'],
     *   ngForTrackBy: null as any,
     *   ngForTemplate: null as any,
     * }); // Infers a type of NgForOf<string>.
     *
     * Any inputs declared on the type for which no property binding is present are assigned a value of
     * type `any`, to avoid producing any type errors for unset inputs.
     *
     * Inline type constructors are used when the type being created has bounded generic types which
     * make writing a declared type constructor (via `generateTypeCtorDeclarationFn`) difficult or
     * impossible.
     *
     * @param node the `ClassDeclaration<ts.ClassDeclaration>` for which a type constructor will be
     * generated.
     * @param meta additional metadata required to generate the type constructor.
     * @returns a `ts.MethodDeclaration` for the type constructor.
     */
    function generateInlineTypeCtor(node, meta) {
        // Build rawType, a `ts.TypeNode` of the class with its generic parameters passed through from
        // the definition without any type bounds. For example, if the class is
        // `FooDirective<T extends Bar>`, its rawType would be `FooDirective<T>`.
        const rawTypeArgs = node.typeParameters !== undefined ? generateGenericArgs(node.typeParameters) : undefined;
        const rawType = ts$1.createTypeReferenceNode(node.name, rawTypeArgs);
        const initParam = constructTypeCtorParameter(node, meta, rawType);
        // If this constructor is being generated into a .ts file, then it needs a fake body. The body
        // is set to a return of `null!`. If the type constructor is being generated into a .d.ts file,
        // it needs no body.
        let body = undefined;
        if (meta.body) {
            body = ts$1.createBlock([
                ts$1.createReturn(ts$1.createNonNullExpression(ts$1.createNull())),
            ]);
        }
        // Create the type constructor method declaration.
        return ts$1.createMethod(
        /* decorators */ undefined, 
        /* modifiers */ [ts$1.createModifier(ts$1.SyntaxKind.StaticKeyword)], 
        /* asteriskToken */ undefined, 
        /* name */ meta.fnName, 
        /* questionToken */ undefined, 
        /* typeParameters */ typeParametersWithDefaultTypes(node.typeParameters), 
        /* parameters */ [initParam], 
        /* type */ rawType, 
        /* body */ body);
    }
    function constructTypeCtorParameter(node, meta, rawType) {
        // initType is the type of 'init', the single argument to the type constructor method.
        // If the Directive has any inputs, its initType will be:
        //
        // Pick<rawType, 'inputA'|'inputB'>
        //
        // Pick here is used to select only those fields from which the generic type parameters of the
        // directive will be inferred.
        //
        // In the special case there are no inputs, initType is set to {}.
        let initType = null;
        const keys = meta.fields.inputs;
        const plainKeys = [];
        const coercedKeys = [];
        for (const key of keys) {
            if (!meta.coercedInputFields.has(key)) {
                plainKeys.push(ts$1.createLiteralTypeNode(ts$1.createStringLiteral(key)));
            }
            else {
                coercedKeys.push(ts$1.createPropertySignature(
                /* modifiers */ undefined, 
                /* name */ key, 
                /* questionToken */ undefined, 
                /* type */ tsCreateTypeQueryForCoercedInput(rawType.typeName, key), 
                /* initializer */ undefined));
            }
        }
        if (plainKeys.length > 0) {
            // Construct a union of all the field names.
            const keyTypeUnion = ts$1.createUnionTypeNode(plainKeys);
            // Construct the Pick<rawType, keyTypeUnion>.
            initType = ts$1.createTypeReferenceNode('Pick', [rawType, keyTypeUnion]);
        }
        if (coercedKeys.length > 0) {
            const coercedLiteral = ts$1.createTypeLiteralNode(coercedKeys);
            initType = initType !== null ? ts$1.createIntersectionTypeNode([initType, coercedLiteral]) :
                coercedLiteral;
        }
        if (initType === null) {
            // Special case - no inputs, outputs, or other fields which could influence the result type.
            initType = ts$1.createTypeLiteralNode([]);
        }
        // Create the 'init' parameter itself.
        return ts$1.createParameter(
        /* decorators */ undefined, 
        /* modifiers */ undefined, 
        /* dotDotDotToken */ undefined, 
        /* name */ 'init', 
        /* questionToken */ undefined, 
        /* type */ initType, 
        /* initializer */ undefined);
    }
    function generateGenericArgs(params) {
        return params.map(param => ts$1.createTypeReferenceNode(param.name, undefined));
    }
    function requiresInlineTypeCtor(node, host) {
        // The class requires an inline type constructor if it has generic type bounds that can not be
        // emitted into a different context.
        return !checkIfGenericTypeBoundsAreContextFree(node, host);
    }
    /**
     * Add a default `= any` to type parameters that don't have a default value already.
     *
     * TypeScript uses the default type of a type parameter whenever inference of that parameter fails.
     * This can happen when inferring a complex type from 'any'. For example, if `NgFor`'s inference is
     * done with the TCB code:
     *
     * ```
     * class NgFor<T> {
     *   ngForOf: T[];
     * }
     *
     * declare function ctor<T>(o: Pick<NgFor<T>, 'ngForOf'|'ngForTrackBy'|'ngForTemplate'>): NgFor<T>;
     * ```
     *
     * An invocation looks like:
     *
     * ```
     * var _t1 = ctor({ngForOf: [1, 2], ngForTrackBy: null as any, ngForTemplate: null as any});
     * ```
     *
     * This correctly infers the type `NgFor<number>` for `_t1`, since `T` is inferred from the
     * assignment of type `number[]` to `ngForOf`'s type `T[]`. However, if `any` is passed instead:
     *
     * ```
     * var _t2 = ctor({ngForOf: [1, 2] as any, ngForTrackBy: null as any, ngForTemplate: null as any});
     * ```
     *
     * then inference for `T` fails (it cannot be inferred from `T[] = any`). In this case, `T` takes
     * the type `{}`, and so `_t2` is inferred as `NgFor<{}>`. This is obviously wrong.
     *
     * Adding a default type to the generic declaration in the constructor solves this problem, as the
     * default type will be used in the event that inference fails.
     *
     * ```
     * declare function ctor<T = any>(o: Pick<NgFor<T>, 'ngForOf'>): NgFor<T>;
     *
     * var _t3 = ctor({ngForOf: [1, 2] as any});
     * ```
     *
     * This correctly infers `T` as `any`, and therefore `_t3` as `NgFor<any>`.
     */
    function typeParametersWithDefaultTypes(params) {
        if (params === undefined) {
            return undefined;
        }
        return params.map(param => {
            if (param.default === undefined) {
                return ts$1.updateTypeParameterDeclaration(
                /* node */ param, 
                /* name */ param.name, 
                /* constraint */ param.constraint, 
                /* defaultType */ ts$1.createKeywordTypeNode(ts$1.SyntaxKind.AnyKeyword));
            }
            else {
                return param;
            }
        });
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A context which hosts one or more Type Check Blocks (TCBs).
     *
     * An `Environment` supports the generation of TCBs by tracking necessary imports, declarations of
     * type constructors, and other statements beyond the type-checking code within the TCB itself.
     * Through method calls on `Environment`, the TCB generator can request `ts.Expression`s which
     * reference declarations in the `Environment` for these artifacts`.
     *
     * `Environment` can be used in a standalone fashion, or can be extended to support more specialized
     * usage.
     */
    class Environment {
        constructor(config, importManager, refEmitter, reflector, contextFile) {
            this.config = config;
            this.importManager = importManager;
            this.refEmitter = refEmitter;
            this.reflector = reflector;
            this.contextFile = contextFile;
            this.nextIds = {
                pipeInst: 1,
                typeCtor: 1,
            };
            this.typeCtors = new Map();
            this.typeCtorStatements = [];
            this.pipeInsts = new Map();
            this.pipeInstStatements = [];
        }
        /**
         * Get an expression referring to a type constructor for the given directive.
         *
         * Depending on the shape of the directive itself, this could be either a reference to a declared
         * type constructor, or to an inline type constructor.
         */
        typeCtorFor(dir) {
            const dirRef = dir.ref;
            const node = dirRef.node;
            if (this.typeCtors.has(node)) {
                return this.typeCtors.get(node);
            }
            if (requiresInlineTypeCtor(node, this.reflector)) {
                // The constructor has already been created inline, we just need to construct a reference to
                // it.
                const ref = this.reference(dirRef);
                const typeCtorExpr = ts$1.createPropertyAccess(ref, 'ngTypeCtor');
                this.typeCtors.set(node, typeCtorExpr);
                return typeCtorExpr;
            }
            else {
                const fnName = `_ctor${this.nextIds.typeCtor++}`;
                const nodeTypeRef = this.referenceType(dirRef);
                if (!ts$1.isTypeReferenceNode(nodeTypeRef)) {
                    throw new Error(`Expected TypeReferenceNode from reference to ${dirRef.debugName}`);
                }
                const meta = {
                    fnName,
                    body: true,
                    fields: {
                        inputs: dir.inputs.classPropertyNames,
                        outputs: dir.outputs.classPropertyNames,
                        // TODO: support queries
                        queries: dir.queries,
                    },
                    coercedInputFields: dir.coercedInputFields,
                };
                const typeParams = this.emitTypeParameters(node);
                const typeCtor = generateTypeCtorDeclarationFn(node, meta, nodeTypeRef.typeName, typeParams, this.reflector);
                this.typeCtorStatements.push(typeCtor);
                const fnId = ts$1.createIdentifier(fnName);
                this.typeCtors.set(node, fnId);
                return fnId;
            }
        }
        /*
         * Get an expression referring to an instance of the given pipe.
         */
        pipeInst(ref) {
            if (this.pipeInsts.has(ref.node)) {
                return this.pipeInsts.get(ref.node);
            }
            const pipeType = this.referenceType(ref);
            const pipeInstId = ts$1.createIdentifier(`_pipe${this.nextIds.pipeInst++}`);
            this.pipeInstStatements.push(tsDeclareVariable(pipeInstId, pipeType));
            this.pipeInsts.set(ref.node, pipeInstId);
            return pipeInstId;
        }
        /**
         * Generate a `ts.Expression` that references the given node.
         *
         * This may involve importing the node into the file if it's not declared there already.
         */
        reference(ref) {
            // Disable aliasing for imports generated in a template type-checking context, as there is no
            // guarantee that any alias re-exports exist in the .d.ts files. It's safe to use direct imports
            // in these cases as there is no strict dependency checking during the template type-checking
            // pass.
            const ngExpr = this.refEmitter.emit(ref, this.contextFile, ImportFlags.NoAliasing);
            // Use `translateExpression` to convert the `Expression` into a `ts.Expression`.
            return translateExpression(ngExpr.expression, this.importManager);
        }
        /**
         * Generate a `ts.TypeNode` that references the given node as a type.
         *
         * This may involve importing the node into the file if it's not declared there already.
         */
        referenceType(ref) {
            const ngExpr = this.refEmitter.emit(ref, this.contextFile, ImportFlags.NoAliasing | ImportFlags.AllowTypeImports);
            // Create an `ExpressionType` from the `Expression` and translate it via `translateType`.
            // TODO(alxhub): support references to types with generic arguments in a clean way.
            return translateType(new ExpressionType(ngExpr.expression), this.importManager);
        }
        emitTypeParameters(declaration) {
            const emitter = new TypeParameterEmitter(declaration.typeParameters, this.reflector);
            return emitter.emit(ref => this.referenceType(ref));
        }
        /**
         * Generate a `ts.TypeNode` that references a given type from the provided module.
         *
         * This will involve importing the type into the file, and will also add type parameters if
         * provided.
         */
        referenceExternalType(moduleName, name, typeParams) {
            const external = new ExternalExpr({ moduleName, name });
            return translateType(new ExpressionType(external, [ /* modifiers */], typeParams), this.importManager);
        }
        getPreludeStatements() {
            return [
                ...this.pipeInstStatements,
                ...this.typeCtorStatements,
            ];
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class OutOfBandDiagnosticRecorderImpl {
        constructor(resolver) {
            this.resolver = resolver;
            this._diagnostics = [];
            /**
             * Tracks which `BindingPipe` nodes have already been recorded as invalid, so only one diagnostic
             * is ever produced per node.
             */
            this.recordedPipes = new Set();
        }
        get diagnostics() {
            return this._diagnostics;
        }
        missingReferenceTarget(templateId, ref) {
            const mapping = this.resolver.getSourceMapping(templateId);
            const value = ref.value.trim();
            const errorMsg = `No directive found with exportAs '${value}'.`;
            this._diagnostics.push(makeTemplateDiagnostic(templateId, mapping, ref.valueSpan || ref.sourceSpan, ts$1.DiagnosticCategory.Error, ngErrorCode(ErrorCode.MISSING_REFERENCE_TARGET), errorMsg));
        }
        missingPipe(templateId, ast) {
            if (this.recordedPipes.has(ast)) {
                return;
            }
            const mapping = this.resolver.getSourceMapping(templateId);
            const errorMsg = `No pipe found with name '${ast.name}'.`;
            const sourceSpan = this.resolver.toParseSourceSpan(templateId, ast.nameSpan);
            if (sourceSpan === null) {
                throw new Error(`Assertion failure: no SourceLocation found for usage of pipe '${ast.name}'.`);
            }
            this._diagnostics.push(makeTemplateDiagnostic(templateId, mapping, sourceSpan, ts$1.DiagnosticCategory.Error, ngErrorCode(ErrorCode.MISSING_PIPE), errorMsg));
            this.recordedPipes.add(ast);
        }
        illegalAssignmentToTemplateVar(templateId, assignment, target) {
            var _a, _b;
            const mapping = this.resolver.getSourceMapping(templateId);
            const errorMsg = `Cannot use variable '${assignment
            .name}' as the left-hand side of an assignment expression. Template variables are read-only.`;
            const sourceSpan = this.resolver.toParseSourceSpan(templateId, assignment.sourceSpan);
            if (sourceSpan === null) {
                throw new Error(`Assertion failure: no SourceLocation found for property binding.`);
            }
            this._diagnostics.push(makeTemplateDiagnostic(templateId, mapping, sourceSpan, ts$1.DiagnosticCategory.Error, ngErrorCode(ErrorCode.WRITE_TO_READ_ONLY_VARIABLE), errorMsg, [{
                    text: `The variable ${assignment.name} is declared here.`,
                    start: ((_a = target.valueSpan) === null || _a === void 0 ? void 0 : _a.start.offset) || target.sourceSpan.start.offset,
                    end: ((_b = target.valueSpan) === null || _b === void 0 ? void 0 : _b.end.offset) || target.sourceSpan.end.offset,
                    sourceFile: mapping.node.getSourceFile(),
                }]));
        }
        duplicateTemplateVar(templateId, variable, firstDecl) {
            const mapping = this.resolver.getSourceMapping(templateId);
            const errorMsg = `Cannot redeclare variable '${variable.name}' as it was previously declared elsewhere for the same template.`;
            // The allocation of the error here is pretty useless for variables declared in microsyntax,
            // since the sourceSpan refers to the entire microsyntax property, not a span for the specific
            // variable in question.
            //
            // TODO(alxhub): allocate to a tighter span once one is available.
            this._diagnostics.push(makeTemplateDiagnostic(templateId, mapping, variable.sourceSpan, ts$1.DiagnosticCategory.Error, ngErrorCode(ErrorCode.DUPLICATE_VARIABLE_DECLARATION), errorMsg, [{
                    text: `The variable '${firstDecl.name}' was first declared here.`,
                    start: firstDecl.sourceSpan.start.offset,
                    end: firstDecl.sourceSpan.end.offset,
                    sourceFile: mapping.node.getSourceFile(),
                }]));
        }
        requiresInlineTcb(templateId, node) {
            this._diagnostics.push(makeInlineDiagnostic(templateId, ErrorCode.INLINE_TCB_REQUIRED, node.name, `This component requires inline template type-checking, which is not supported by the current environment.`));
        }
        requiresInlineTypeConstructors(templateId, node, directives) {
            let message;
            if (directives.length > 1) {
                message =
                    `This component uses directives which require inline type constructors, which are not supported by the current environment.`;
            }
            else {
                message =
                    `This component uses a directive which requires an inline type constructor, which is not supported by the current environment.`;
            }
            this._diagnostics.push(makeInlineDiagnostic(templateId, ErrorCode.INLINE_TYPE_CTOR_REQUIRED, node.name, message, directives.map(dir => makeRelatedInformation(dir.name, `Requires an inline type constructor.`))));
        }
        suboptimalTypeInference(templateId, variables) {
            const mapping = this.resolver.getSourceMapping(templateId);
            // Select one of the template variables that's most suitable for reporting the diagnostic. Any
            // variable will do, but prefer one bound to the context's $implicit if present.
            let diagnosticVar = null;
            for (const variable of variables) {
                if (diagnosticVar === null || (variable.value === '' || variable.value === '$implicit')) {
                    diagnosticVar = variable;
                }
            }
            if (diagnosticVar === null) {
                // There is no variable on which to report the diagnostic.
                return;
            }
            let varIdentification = `'${diagnosticVar.name}'`;
            if (variables.length === 2) {
                varIdentification += ` (and 1 other)`;
            }
            else if (variables.length > 2) {
                varIdentification += ` (and ${variables.length - 1} others)`;
            }
            const message = `This structural directive supports advanced type inference, but the current compiler configuration prevents its usage. The variable ${varIdentification} will have type 'any' as a result.\n\nConsider enabling the 'strictTemplates' option in your tsconfig.json for better type inference within this template.`;
            this._diagnostics.push(makeTemplateDiagnostic(templateId, mapping, diagnosticVar.keySpan, ts$1.DiagnosticCategory.Suggestion, ngErrorCode(ErrorCode.SUGGEST_SUBOPTIMAL_TYPE_INFERENCE), message));
        }
        splitTwoWayBinding(templateId, input, output, inputConsumer, outputConsumer) {
            const mapping = this.resolver.getSourceMapping(templateId);
            const errorMsg = `The property and event halves of the two-way binding '${input.name}' are not bound to the same target.
            Find more at https://angular.io/guide/two-way-binding#how-two-way-binding-works`;
            const relatedMessages = [];
            relatedMessages.push({
                text: `The property half of the binding is to the '${inputConsumer.name.text}' component.`,
                start: inputConsumer.name.getStart(),
                end: inputConsumer.name.getEnd(),
                sourceFile: inputConsumer.name.getSourceFile(),
            });
            if (outputConsumer instanceof Element) {
                let message = `The event half of the binding is to a native event called '${input.name}' on the <${outputConsumer.name}> DOM element.`;
                if (!mapping.node.getSourceFile().isDeclarationFile) {
                    message += `\n \n Are you missing an output declaration called '${output.name}'?`;
                }
                relatedMessages.push({
                    text: message,
                    start: outputConsumer.sourceSpan.start.offset + 1,
                    end: outputConsumer.sourceSpan.start.offset + outputConsumer.name.length + 1,
                    sourceFile: mapping.node.getSourceFile(),
                });
            }
            else {
                relatedMessages.push({
                    text: `The event half of the binding is to the '${outputConsumer.name.text}' component.`,
                    start: outputConsumer.name.getStart(),
                    end: outputConsumer.name.getEnd(),
                    sourceFile: outputConsumer.name.getSourceFile(),
                });
            }
            this._diagnostics.push(makeTemplateDiagnostic(templateId, mapping, input.keySpan, ts$1.DiagnosticCategory.Error, ngErrorCode(ErrorCode.SPLIT_TWO_WAY_BINDING), errorMsg, relatedMessages));
        }
    }
    function makeInlineDiagnostic(templateId, code, node, messageText, relatedInformation) {
        return Object.assign(Object.assign({}, makeDiagnostic(code, node, messageText, relatedInformation)), { componentFile: node.getSourceFile(), templateId });
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A `ShimGenerator` which adds type-checking files to the `ts.Program`.
     *
     * This is a requirement for performant template type-checking, as TypeScript will only reuse
     * information in the main program when creating the type-checking program if the set of files in
     * each are exactly the same. Thus, the main program also needs the synthetic type-checking files.
     */
    class TypeCheckShimGenerator {
        constructor() {
            this.extensionPrefix = 'ngtypecheck';
            this.shouldEmit = false;
        }
        generateShimForFile(sf, genFilePath, priorShimSf) {
            if (priorShimSf !== null) {
                // If this shim existed in the previous program, reuse it now. It might not be correct, but
                // reusing it in the main program allows the shape of its imports to potentially remain the
                // same and TS can then use the fastest path for incremental program creation. Later during
                // the type-checking phase it's going to either be reused, or replaced anyways. Thus there's
                // no harm in reuse here even if it's out of date.
                return priorShimSf;
            }
            return ts$1.createSourceFile(genFilePath, 'export const USED_FOR_NG_TYPE_CHECKING = true;', ts$1.ScriptTarget.Latest, true, ts$1.ScriptKind.TS);
        }
        static shimFor(fileName) {
            return absoluteFrom(fileName.replace(/\.tsx?$/, '.ngtypecheck.ts'));
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Wraps the node in parenthesis such that inserted span comments become attached to the proper
     * node. This is an alias for `ts.createParen` with the benefit that it signifies that the
     * inserted parenthesis are for diagnostic purposes, not for correctness of the rendered TCB code.
     *
     * Note that it is important that nodes and its attached comment are not wrapped into parenthesis
     * by default, as it prevents correct translation of e.g. diagnostics produced for incorrect method
     * arguments. Such diagnostics would then be produced for the parenthesised node whereas the
     * positional comment would be located within that node, resulting in a mismatch.
     */
    function wrapForDiagnostics(expr) {
        return ts$1.createParen(expr);
    }
    /**
     * Wraps the node in parenthesis such that inserted span comments become attached to the proper
     * node. This is an alias for `ts.createParen` with the benefit that it signifies that the
     * inserted parenthesis are for use by the type checker, not for correctness of the rendered TCB
     * code.
     */
    function wrapForTypeChecker(expr) {
        return ts$1.createParen(expr);
    }
    /**
     * Adds a synthetic comment to the expression that represents the parse span of the provided node.
     * This comment can later be retrieved as trivia of a node to recover original source locations.
     */
    function addParseSpanInfo(node, span) {
        let commentText;
        if (span instanceof AbsoluteSourceSpan) {
            commentText = `${span.start},${span.end}`;
        }
        else {
            commentText = `${span.start.offset},${span.end.offset}`;
        }
        ts$1.addSyntheticTrailingComment(node, ts$1.SyntaxKind.MultiLineCommentTrivia, commentText, /* hasTrailingNewLine */ false);
    }
    /**
     * Adds a synthetic comment to the function declaration that contains the template id
     * of the class declaration.
     */
    function addTemplateId(tcb, id) {
        ts$1.addSyntheticLeadingComment(tcb, ts$1.SyntaxKind.MultiLineCommentTrivia, id, true);
    }
    /**
     * Determines if the diagnostic should be reported. Some diagnostics are produced because of the
     * way TCBs are generated; those diagnostics should not be reported as type check errors of the
     * template.
     */
    function shouldReportDiagnostic(diagnostic) {
        const { code } = diagnostic;
        if (code === 6133 /* $var is declared but its value is never read. */) {
            return false;
        }
        else if (code === 6199 /* All variables are unused. */) {
            return false;
        }
        else if (code === 2695 /* Left side of comma operator is unused and has no side effects. */) {
            return false;
        }
        else if (code === 7006 /* Parameter '$event' implicitly has an 'any' type. */) {
            return false;
        }
        return true;
    }
    /**
     * Attempts to translate a TypeScript diagnostic produced during template type-checking to their
     * location of origin, based on the comments that are emitted in the TCB code.
     *
     * If the diagnostic could not be translated, `null` is returned to indicate that the diagnostic
     * should not be reported at all. This prevents diagnostics from non-TCB code in a user's source
     * file from being reported as type-check errors.
     */
    function translateDiagnostic(diagnostic, resolver) {
        if (diagnostic.file === undefined || diagnostic.start === undefined) {
            return null;
        }
        const fullMapping = getTemplateMapping(diagnostic.file, diagnostic.start, resolver, /*isDiagnosticsRequest*/ true);
        if (fullMapping === null) {
            return null;
        }
        const { sourceLocation, templateSourceMapping, span } = fullMapping;
        return makeTemplateDiagnostic(sourceLocation.id, templateSourceMapping, span, diagnostic.category, diagnostic.code, diagnostic.messageText);
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const NULL_AS_ANY = ts$1.createAsExpression(ts$1.createNull(), ts$1.createKeywordTypeNode(ts$1.SyntaxKind.AnyKeyword));
    const UNDEFINED = ts$1.createIdentifier('undefined');
    const UNARY_OPS = new Map([
        ['+', ts$1.SyntaxKind.PlusToken],
        ['-', ts$1.SyntaxKind.MinusToken],
    ]);
    const BINARY_OPS = new Map([
        ['+', ts$1.SyntaxKind.PlusToken],
        ['-', ts$1.SyntaxKind.MinusToken],
        ['<', ts$1.SyntaxKind.LessThanToken],
        ['>', ts$1.SyntaxKind.GreaterThanToken],
        ['<=', ts$1.SyntaxKind.LessThanEqualsToken],
        ['>=', ts$1.SyntaxKind.GreaterThanEqualsToken],
        ['==', ts$1.SyntaxKind.EqualsEqualsToken],
        ['===', ts$1.SyntaxKind.EqualsEqualsEqualsToken],
        ['*', ts$1.SyntaxKind.AsteriskToken],
        ['/', ts$1.SyntaxKind.SlashToken],
        ['%', ts$1.SyntaxKind.PercentToken],
        ['!=', ts$1.SyntaxKind.ExclamationEqualsToken],
        ['!==', ts$1.SyntaxKind.ExclamationEqualsEqualsToken],
        ['||', ts$1.SyntaxKind.BarBarToken],
        ['&&', ts$1.SyntaxKind.AmpersandAmpersandToken],
        ['&', ts$1.SyntaxKind.AmpersandToken],
        ['|', ts$1.SyntaxKind.BarToken],
        ['??', ts$1.SyntaxKind.QuestionQuestionToken],
    ]);
    /**
     * Convert an `AST` to TypeScript code directly, without going through an intermediate `Expression`
     * AST.
     */
    function astToTypescript(ast, maybeResolve, config) {
        const translator = new AstTranslator(maybeResolve, config);
        return translator.translate(ast);
    }
    class AstTranslator {
        constructor(maybeResolve, config) {
            this.maybeResolve = maybeResolve;
            this.config = config;
        }
        translate(ast) {
            // Skip over an `ASTWithSource` as its `visit` method calls directly into its ast's `visit`,
            // which would prevent any custom resolution through `maybeResolve` for that node.
            if (ast instanceof ASTWithSource) {
                ast = ast.ast;
            }
            // The `EmptyExpr` doesn't have a dedicated method on `AstVisitor`, so it's special cased here.
            if (ast instanceof EmptyExpr) {
                const res = ts$1.factory.createIdentifier('undefined');
                addParseSpanInfo(res, ast.sourceSpan);
                return res;
            }
            // First attempt to let any custom resolution logic provide a translation for the given node.
            const resolved = this.maybeResolve(ast);
            if (resolved !== null) {
                return resolved;
            }
            return ast.visit(this);
        }
        visitUnary(ast) {
            const expr = this.translate(ast.expr);
            const op = UNARY_OPS.get(ast.operator);
            if (op === undefined) {
                throw new Error(`Unsupported Unary.operator: ${ast.operator}`);
            }
            const node = wrapForDiagnostics(ts$1.createPrefix(op, expr));
            addParseSpanInfo(node, ast.sourceSpan);
            return node;
        }
        visitBinary(ast) {
            const lhs = wrapForDiagnostics(this.translate(ast.left));
            const rhs = wrapForDiagnostics(this.translate(ast.right));
            const op = BINARY_OPS.get(ast.operation);
            if (op === undefined) {
                throw new Error(`Unsupported Binary.operation: ${ast.operation}`);
            }
            const node = ts$1.createBinary(lhs, op, rhs);
            addParseSpanInfo(node, ast.sourceSpan);
            return node;
        }
        visitChain(ast) {
            const elements = ast.expressions.map(expr => this.translate(expr));
            const node = wrapForDiagnostics(ts$1.createCommaList(elements));
            addParseSpanInfo(node, ast.sourceSpan);
            return node;
        }
        visitConditional(ast) {
            const condExpr = this.translate(ast.condition);
            const trueExpr = this.translate(ast.trueExp);
            // Wrap `falseExpr` in parens so that the trailing parse span info is not attributed to the
            // whole conditional.
            // In the following example, the last source span comment (5,6) could be seen as the
            // trailing comment for _either_ the whole conditional expression _or_ just the `falseExpr` that
            // is immediately before it:
            // `conditional /*1,2*/ ? trueExpr /*3,4*/ : falseExpr /*5,6*/`
            // This should be instead be `conditional /*1,2*/ ? trueExpr /*3,4*/ : (falseExpr /*5,6*/)`
            const falseExpr = wrapForTypeChecker(this.translate(ast.falseExp));
            const node = ts$1.createParen(ts$1.createConditional(condExpr, trueExpr, falseExpr));
            addParseSpanInfo(node, ast.sourceSpan);
            return node;
        }
        visitFunctionCall(ast) {
            const receiver = wrapForDiagnostics(this.translate(ast.target));
            const args = ast.args.map(expr => this.translate(expr));
            const node = ts$1.createCall(receiver, undefined, args);
            addParseSpanInfo(node, ast.sourceSpan);
            return node;
        }
        visitImplicitReceiver(ast) {
            throw new Error('Method not implemented.');
        }
        visitThisReceiver(ast) {
            throw new Error('Method not implemented.');
        }
        visitInterpolation(ast) {
            // Build up a chain of binary + operations to simulate the string concatenation of the
            // interpolation's expressions. The chain is started using an actual string literal to ensure
            // the type is inferred as 'string'.
            return ast.expressions.reduce((lhs, ast) => ts$1.createBinary(lhs, ts$1.SyntaxKind.PlusToken, wrapForTypeChecker(this.translate(ast))), ts$1.createLiteral(''));
        }
        visitKeyedRead(ast) {
            const receiver = wrapForDiagnostics(this.translate(ast.receiver));
            const key = this.translate(ast.key);
            const node = ts$1.createElementAccess(receiver, key);
            addParseSpanInfo(node, ast.sourceSpan);
            return node;
        }
        visitKeyedWrite(ast) {
            const receiver = wrapForDiagnostics(this.translate(ast.receiver));
            const left = ts$1.createElementAccess(receiver, this.translate(ast.key));
            // TODO(joost): annotate `left` with the span of the element access, which is not currently
            //  available on `ast`.
            const right = wrapForTypeChecker(this.translate(ast.value));
            const node = wrapForDiagnostics(ts$1.createBinary(left, ts$1.SyntaxKind.EqualsToken, right));
            addParseSpanInfo(node, ast.sourceSpan);
            return node;
        }
        visitLiteralArray(ast) {
            const elements = ast.expressions.map(expr => this.translate(expr));
            const literal = ts$1.createArrayLiteral(elements);
            // If strictLiteralTypes is disabled, array literals are cast to `any`.
            const node = this.config.strictLiteralTypes ? literal : tsCastToAny(literal);
            addParseSpanInfo(node, ast.sourceSpan);
            return node;
        }
        visitLiteralMap(ast) {
            const properties = ast.keys.map(({ key }, idx) => {
                const value = this.translate(ast.values[idx]);
                return ts$1.createPropertyAssignment(ts$1.createStringLiteral(key), value);
            });
            const literal = ts$1.createObjectLiteral(properties, true);
            // If strictLiteralTypes is disabled, object literals are cast to `any`.
            const node = this.config.strictLiteralTypes ? literal : tsCastToAny(literal);
            addParseSpanInfo(node, ast.sourceSpan);
            return node;
        }
        visitLiteralPrimitive(ast) {
            let node;
            if (ast.value === undefined) {
                node = ts$1.createIdentifier('undefined');
            }
            else if (ast.value === null) {
                node = ts$1.createNull();
            }
            else {
                node = ts$1.createLiteral(ast.value);
            }
            addParseSpanInfo(node, ast.sourceSpan);
            return node;
        }
        visitMethodCall(ast) {
            const receiver = wrapForDiagnostics(this.translate(ast.receiver));
            const method = ts$1.createPropertyAccess(receiver, ast.name);
            addParseSpanInfo(method, ast.nameSpan);
            const args = ast.args.map(expr => this.translate(expr));
            const node = ts$1.createCall(method, undefined, args);
            addParseSpanInfo(node, ast.sourceSpan);
            return node;
        }
        visitNonNullAssert(ast) {
            const expr = wrapForDiagnostics(this.translate(ast.expression));
            const node = ts$1.createNonNullExpression(expr);
            addParseSpanInfo(node, ast.sourceSpan);
            return node;
        }
        visitPipe(ast) {
            throw new Error('Method not implemented.');
        }
        visitPrefixNot(ast) {
            const expression = wrapForDiagnostics(this.translate(ast.expression));
            const node = ts$1.createLogicalNot(expression);
            addParseSpanInfo(node, ast.sourceSpan);
            return node;
        }
        visitPropertyRead(ast) {
            // This is a normal property read - convert the receiver to an expression and emit the correct
            // TypeScript expression to read the property.
            const receiver = wrapForDiagnostics(this.translate(ast.receiver));
            const name = ts$1.createPropertyAccess(receiver, ast.name);
            addParseSpanInfo(name, ast.nameSpan);
            const node = wrapForDiagnostics(name);
            addParseSpanInfo(node, ast.sourceSpan);
            return node;
        }
        visitPropertyWrite(ast) {
            const receiver = wrapForDiagnostics(this.translate(ast.receiver));
            const left = ts$1.createPropertyAccess(receiver, ast.name);
            addParseSpanInfo(left, ast.nameSpan);
            // TypeScript reports assignment errors on the entire lvalue expression. Annotate the lvalue of
            // the assignment with the sourceSpan, which includes receivers, rather than nameSpan for
            // consistency of the diagnostic location.
            // a.b.c = 1
            // ^^^^^^^^^ sourceSpan
            //     ^     nameSpan
            const leftWithPath = wrapForDiagnostics(left);
            addParseSpanInfo(leftWithPath, ast.sourceSpan);
            // The right needs to be wrapped in parens as well or we cannot accurately match its
            // span to just the RHS. For example, the span in `e = $event /*0,10*/` is ambiguous.
            // It could refer to either the whole binary expression or just the RHS.
            // We should instead generate `e = ($event /*0,10*/)` so we know the span 0,10 matches RHS.
            const right = wrapForTypeChecker(this.translate(ast.value));
            const node = wrapForDiagnostics(ts$1.createBinary(leftWithPath, ts$1.SyntaxKind.EqualsToken, right));
            addParseSpanInfo(node, ast.sourceSpan);
            return node;
        }
        visitQuote(ast) {
            return NULL_AS_ANY;
        }
        visitSafeMethodCall(ast) {
            // See the comments in SafePropertyRead above for an explanation of the cases here.
            let node;
            const receiver = wrapForDiagnostics(this.translate(ast.receiver));
            const args = ast.args.map(expr => this.translate(expr));
            if (this.config.strictSafeNavigationTypes) {
                // "a?.method(...)" becomes (null as any ? a!.method(...) : undefined)
                const method = ts$1.createPropertyAccess(ts$1.createNonNullExpression(receiver), ast.name);
                addParseSpanInfo(method, ast.nameSpan);
                const call = ts$1.createCall(method, undefined, args);
                node = ts$1.createParen(ts$1.createConditional(NULL_AS_ANY, call, UNDEFINED));
            }
            else if (VeSafeLhsInferenceBugDetector.veWillInferAnyFor(ast)) {
                // "a?.method(...)" becomes (a as any).method(...)
                const method = ts$1.createPropertyAccess(tsCastToAny(receiver), ast.name);
                addParseSpanInfo(method, ast.nameSpan);
                node = ts$1.createCall(method, undefined, args);
            }
            else {
                // "a?.method(...)" becomes (a!.method(...) as any)
                const method = ts$1.createPropertyAccess(ts$1.createNonNullExpression(receiver), ast.name);
                addParseSpanInfo(method, ast.nameSpan);
                node = tsCastToAny(ts$1.createCall(method, undefined, args));
            }
            addParseSpanInfo(node, ast.sourceSpan);
            return node;
        }
        visitSafePropertyRead(ast) {
            let node;
            const receiver = wrapForDiagnostics(this.translate(ast.receiver));
            // The form of safe property reads depends on whether strictness is in use.
            if (this.config.strictSafeNavigationTypes) {
                // Basically, the return here is either the type of the complete expression with a null-safe
                // property read, or `undefined`. So a ternary is used to create an "or" type:
                // "a?.b" becomes (null as any ? a!.b : undefined)
                // The type of this expression is (typeof a!.b) | undefined, which is exactly as desired.
                const expr = ts$1.createPropertyAccess(ts$1.createNonNullExpression(receiver), ast.name);
                addParseSpanInfo(expr, ast.nameSpan);
                node = ts$1.createParen(ts$1.createConditional(NULL_AS_ANY, expr, UNDEFINED));
            }
            else if (VeSafeLhsInferenceBugDetector.veWillInferAnyFor(ast)) {
                // Emulate a View Engine bug where 'any' is inferred for the left-hand side of the safe
                // navigation operation. With this bug, the type of the left-hand side is regarded as any.
                // Therefore, the left-hand side only needs repeating in the output (to validate it), and then
                // 'any' is used for the rest of the expression. This is done using a comma operator:
                // "a?.b" becomes (a as any).b, which will of course have type 'any'.
                node = ts$1.createPropertyAccess(tsCastToAny(receiver), ast.name);
            }
            else {
                // The View Engine bug isn't active, so check the entire type of the expression, but the final
                // result is still inferred as `any`.
                // "a?.b" becomes (a!.b as any)
                const expr = ts$1.createPropertyAccess(ts$1.createNonNullExpression(receiver), ast.name);
                addParseSpanInfo(expr, ast.nameSpan);
                node = tsCastToAny(expr);
            }
            addParseSpanInfo(node, ast.sourceSpan);
            return node;
        }
        visitSafeKeyedRead(ast) {
            const receiver = wrapForDiagnostics(this.translate(ast.receiver));
            const key = this.translate(ast.key);
            let node;
            // The form of safe property reads depends on whether strictness is in use.
            if (this.config.strictSafeNavigationTypes) {
                // "a?.[...]" becomes (null as any ? a![...] : undefined)
                const expr = ts$1.createElementAccess(ts$1.createNonNullExpression(receiver), key);
                addParseSpanInfo(expr, ast.sourceSpan);
                node = ts$1.createParen(ts$1.createConditional(NULL_AS_ANY, expr, UNDEFINED));
            }
            else if (VeSafeLhsInferenceBugDetector.veWillInferAnyFor(ast)) {
                // "a?.[...]" becomes (a as any)[...]
                node = ts$1.createElementAccess(tsCastToAny(receiver), key);
            }
            else {
                // "a?.[...]" becomes (a!.[...] as any)
                const expr = ts$1.createElementAccess(ts$1.createNonNullExpression(receiver), key);
                addParseSpanInfo(expr, ast.sourceSpan);
                node = tsCastToAny(expr);
            }
            addParseSpanInfo(node, ast.sourceSpan);
            return node;
        }
    }
    /**
     * Checks whether View Engine will infer a type of 'any' for the left-hand side of a safe navigation
     * operation.
     *
     * In View Engine's template type-checker, certain receivers of safe navigation operations will
     * cause a temporary variable to be allocated as part of the checking expression, to save the value
     * of the receiver and use it more than once in the expression. This temporary variable has type
     * 'any'. In practice, this means certain receivers cause View Engine to not check the full
     * expression, and other receivers will receive more complete checking.
     *
     * For compatibility, this logic is adapted from View Engine's expression_converter.ts so that the
     * Ivy checker can emulate this bug when needed.
     */
    class VeSafeLhsInferenceBugDetector {
        static veWillInferAnyFor(ast) {
            const visitor = VeSafeLhsInferenceBugDetector.SINGLETON;
            return ast instanceof SafeKeyedRead ? ast.receiver.visit(visitor) : ast.receiver.visit(visitor);
        }
        visitUnary(ast) {
            return ast.expr.visit(this);
        }
        visitBinary(ast) {
            return ast.left.visit(this) || ast.right.visit(this);
        }
        visitChain(ast) {
            return false;
        }
        visitConditional(ast) {
            return ast.condition.visit(this) || ast.trueExp.visit(this) || ast.falseExp.visit(this);
        }
        visitFunctionCall(ast) {
            return true;
        }
        visitImplicitReceiver(ast) {
            return false;
        }
        visitThisReceiver(ast) {
            return false;
        }
        visitInterpolation(ast) {
            return ast.expressions.some(exp => exp.visit(this));
        }
        visitKeyedRead(ast) {
            return false;
        }
        visitKeyedWrite(ast) {
            return false;
        }
        visitLiteralArray(ast) {
            return true;
        }
        visitLiteralMap(ast) {
            return true;
        }
        visitLiteralPrimitive(ast) {
            return false;
        }
        visitMethodCall(ast) {
            return true;
        }
        visitPipe(ast) {
            return true;
        }
        visitPrefixNot(ast) {
            return ast.expression.visit(this);
        }
        visitNonNullAssert(ast) {
            return ast.expression.visit(this);
        }
        visitPropertyRead(ast) {
            return false;
        }
        visitPropertyWrite(ast) {
            return false;
        }
        visitQuote(ast) {
            return false;
        }
        visitSafeMethodCall(ast) {
            return true;
        }
        visitSafePropertyRead(ast) {
            return false;
        }
        visitSafeKeyedRead(ast) {
            return false;
        }
    }
    VeSafeLhsInferenceBugDetector.SINGLETON = new VeSafeLhsInferenceBugDetector();

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Visits a template and records any semantic errors within its expressions.
     */
    class ExpressionSemanticVisitor extends RecursiveAstVisitor {
        constructor(templateId, boundTarget, oob) {
            super();
            this.templateId = templateId;
            this.boundTarget = boundTarget;
            this.oob = oob;
        }
        visitPropertyWrite(ast, context) {
            super.visitPropertyWrite(ast, context);
            if (!(ast.receiver instanceof ImplicitReceiver)) {
                return;
            }
            const target = this.boundTarget.getExpressionTarget(ast);
            if (target instanceof Variable) {
                // Template variables are read-only.
                this.oob.illegalAssignmentToTemplateVar(this.templateId, ast, target);
            }
        }
        static visit(ast, id, boundTarget, oob) {
            ast.visit(new ExpressionSemanticVisitor(id, boundTarget, oob));
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Controls how generics for the component context class will be handled during TCB generation.
     */
    var TcbGenericContextBehavior;
    (function (TcbGenericContextBehavior) {
        /**
         * References to generic parameter bounds will be emitted via the `TypeParameterEmitter`.
         *
         * The caller must verify that all parameter bounds are emittable in order to use this mode.
         */
        TcbGenericContextBehavior[TcbGenericContextBehavior["UseEmitter"] = 0] = "UseEmitter";
        /**
         * Generic parameter declarations will be copied directly from the `ts.ClassDeclaration` of the
         * component class.
         *
         * The caller must only use the generated TCB code in a context where such copies will still be
         * valid, such as an inline type check block.
         */
        TcbGenericContextBehavior[TcbGenericContextBehavior["CopyClassNodes"] = 1] = "CopyClassNodes";
        /**
         * Any generic parameters for the component context class will be set to `any`.
         *
         * Produces a less useful type, but is always safe to use.
         */
        TcbGenericContextBehavior[TcbGenericContextBehavior["FallbackToAny"] = 2] = "FallbackToAny";
    })(TcbGenericContextBehavior || (TcbGenericContextBehavior = {}));
    /**
     * Given a `ts.ClassDeclaration` for a component, and metadata regarding that component, compose a
     * "type check block" function.
     *
     * When passed through TypeScript's TypeChecker, type errors that arise within the type check block
     * function indicate issues in the template itself.
     *
     * As a side effect of generating a TCB for the component, `ts.Diagnostic`s may also be produced
     * directly for issues within the template which are identified during generation. These issues are
     * recorded in either the `domSchemaChecker` (which checks usage of DOM elements and bindings) as
     * well as the `oobRecorder` (which records errors when the type-checking code generator is unable
     * to sufficiently understand a template).
     *
     * @param env an `Environment` into which type-checking code will be generated.
     * @param ref a `Reference` to the component class which should be type-checked.
     * @param name a `ts.Identifier` to use for the generated `ts.FunctionDeclaration`.
     * @param meta metadata about the component's template and the function being generated.
     * @param domSchemaChecker used to check and record errors regarding improper usage of DOM elements
     * and bindings.
     * @param oobRecorder used to record errors regarding template elements which could not be correctly
     * translated into types during TCB generation.
     * @param genericContextBehavior controls how generic parameters (especially parameters with generic
     * bounds) will be referenced from the generated TCB code.
     */
    function generateTypeCheckBlock(env, ref, name, meta, domSchemaChecker, oobRecorder, genericContextBehavior) {
        const tcb = new Context$1(env, domSchemaChecker, oobRecorder, meta.id, meta.boundTarget, meta.pipes, meta.schemas);
        const scope = Scope$1.forNodes(tcb, null, tcb.boundTarget.target.template, /* guard */ null);
        const ctxRawType = env.referenceType(ref);
        if (!ts$1.isTypeReferenceNode(ctxRawType)) {
            throw new Error(`Expected TypeReferenceNode when referencing the ctx param for ${ref.debugName}`);
        }
        let typeParameters = undefined;
        let typeArguments = undefined;
        if (ref.node.typeParameters !== undefined) {
            if (!env.config.useContextGenericType) {
                genericContextBehavior = TcbGenericContextBehavior.FallbackToAny;
            }
            switch (genericContextBehavior) {
                case TcbGenericContextBehavior.UseEmitter:
                    // Guaranteed to emit type parameters since we checked that the class has them above.
                    typeParameters = new TypeParameterEmitter(ref.node.typeParameters, env.reflector)
                        .emit(typeRef => env.referenceType(typeRef));
                    typeArguments = typeParameters.map(param => ts$1.factory.createTypeReferenceNode(param.name));
                    break;
                case TcbGenericContextBehavior.CopyClassNodes:
                    typeParameters = [...ref.node.typeParameters];
                    typeArguments = typeParameters.map(param => ts$1.factory.createTypeReferenceNode(param.name));
                    break;
                case TcbGenericContextBehavior.FallbackToAny:
                    typeArguments = ref.node.typeParameters.map(() => ts$1.factory.createKeywordTypeNode(ts$1.SyntaxKind.AnyKeyword));
                    break;
            }
        }
        const paramList = [tcbCtxParam(ref.node, ctxRawType.typeName, typeArguments)];
        const scopeStatements = scope.render();
        const innerBody = ts$1.createBlock([
            ...env.getPreludeStatements(),
            ...scopeStatements,
        ]);
        // Wrap the body in an "if (true)" expression. This is unnecessary but has the effect of causing
        // the `ts.Printer` to format the type-check block nicely.
        const body = ts$1.createBlock([ts$1.createIf(ts$1.createTrue(), innerBody, undefined)]);
        const fnDecl = ts$1.createFunctionDeclaration(
        /* decorators */ undefined, 
        /* modifiers */ undefined, 
        /* asteriskToken */ undefined, 
        /* name */ name, 
        /* typeParameters */ env.config.useContextGenericType ? typeParameters : undefined, 
        /* parameters */ paramList, 
        /* type */ undefined, 
        /* body */ body);
        addTemplateId(fnDecl, meta.id);
        return fnDecl;
    }
    /**
     * A code generation operation that's involved in the construction of a Type Check Block.
     *
     * The generation of a TCB is non-linear. Bindings within a template may result in the need to
     * construct certain types earlier than they otherwise would be constructed. That is, if the
     * generation of a TCB for a template is broken down into specific operations (constructing a
     * directive, extracting a variable from a let- operation, etc), then it's possible for operations
     * earlier in the sequence to depend on operations which occur later in the sequence.
     *
     * `TcbOp` abstracts the different types of operations which are required to convert a template into
     * a TCB. This allows for two phases of processing for the template, where 1) a linear sequence of
     * `TcbOp`s is generated, and then 2) these operations are executed, not necessarily in linear
     * order.
     *
     * Each `TcbOp` may insert statements into the body of the TCB, and also optionally return a
     * `ts.Expression` which can be used to reference the operation's result.
     */
    class TcbOp {
        /**
         * Replacement value or operation used while this `TcbOp` is executing (i.e. to resolve circular
         * references during its execution).
         *
         * This is usually a `null!` expression (which asks TS to infer an appropriate type), but another
         * `TcbOp` can be returned in cases where additional code generation is necessary to deal with
         * circular references.
         */
        circularFallback() {
            return INFER_TYPE_FOR_CIRCULAR_OP_EXPR;
        }
    }
    /**
     * A `TcbOp` which creates an expression for a native DOM element (or web component) from a
     * `TmplAstElement`.
     *
     * Executing this operation returns a reference to the element variable.
     */
    class TcbElementOp extends TcbOp {
        constructor(tcb, scope, element) {
            super();
            this.tcb = tcb;
            this.scope = scope;
            this.element = element;
        }
        get optional() {
            // The statement generated by this operation is only used for type-inference of the DOM
            // element's type and won't report diagnostics by itself, so the operation is marked as optional
            // to avoid generating statements for DOM elements that are never referenced.
            return true;
        }
        execute() {
            const id = this.tcb.allocateId();
            // Add the declaration of the element using document.createElement.
            const initializer = tsCreateElement(this.element.name);
            addParseSpanInfo(initializer, this.element.startSourceSpan || this.element.sourceSpan);
            this.scope.addStatement(tsCreateVariable(id, initializer));
            return id;
        }
    }
    /**
     * A `TcbOp` which creates an expression for particular let- `TmplAstVariable` on a
     * `TmplAstTemplate`'s context.
     *
     * Executing this operation returns a reference to the variable variable (lol).
     */
    class TcbVariableOp extends TcbOp {
        constructor(tcb, scope, template, variable) {
            super();
            this.tcb = tcb;
            this.scope = scope;
            this.template = template;
            this.variable = variable;
        }
        get optional() {
            return false;
        }
        execute() {
            // Look for a context variable for the template.
            const ctx = this.scope.resolve(this.template);
            // Allocate an identifier for the TmplAstVariable, and initialize it to a read of the variable
            // on the template context.
            const id = this.tcb.allocateId();
            const initializer = ts$1.createPropertyAccess(
            /* expression */ ctx, 
            /* name */ this.variable.value || '$implicit');
            addParseSpanInfo(id, this.variable.keySpan);
            // Declare the variable, and return its identifier.
            let variable;
            if (this.variable.valueSpan !== undefined) {
                addParseSpanInfo(initializer, this.variable.valueSpan);
                variable = tsCreateVariable(id, wrapForTypeChecker(initializer));
            }
            else {
                variable = tsCreateVariable(id, initializer);
            }
            addParseSpanInfo(variable.declarationList.declarations[0], this.variable.sourceSpan);
            this.scope.addStatement(variable);
            return id;
        }
    }
    /**
     * A `TcbOp` which generates a variable for a `TmplAstTemplate`'s context.
     *
     * Executing this operation returns a reference to the template's context variable.
     */
    class TcbTemplateContextOp extends TcbOp {
        constructor(tcb, scope) {
            super();
            this.tcb = tcb;
            this.scope = scope;
            // The declaration of the context variable is only needed when the context is actually referenced.
            this.optional = true;
        }
        execute() {
            // Allocate a template ctx variable and declare it with an 'any' type. The type of this variable
            // may be narrowed as a result of template guard conditions.
            const ctx = this.tcb.allocateId();
            const type = ts$1.createKeywordTypeNode(ts$1.SyntaxKind.AnyKeyword);
            this.scope.addStatement(tsDeclareVariable(ctx, type));
            return ctx;
        }
    }
    /**
     * A `TcbOp` which descends into a `TmplAstTemplate`'s children and generates type-checking code for
     * them.
     *
     * This operation wraps the children's type-checking code in an `if` block, which may include one
     * or more type guard conditions that narrow types within the template body.
     */
    class TcbTemplateBodyOp extends TcbOp {
        constructor(tcb, scope, template) {
            super();
            this.tcb = tcb;
            this.scope = scope;
            this.template = template;
        }
        get optional() {
            return false;
        }
        execute() {
            // An `if` will be constructed, within which the template's children will be type checked. The
            // `if` is used for two reasons: it creates a new syntactic scope, isolating variables declared
            // in the template's TCB from the outer context, and it allows any directives on the templates
            // to perform type narrowing of either expressions or the template's context.
            //
            // The guard is the `if` block's condition. It's usually set to `true` but directives that exist
            // on the template can trigger extra guard expressions that serve to narrow types within the
            // `if`. `guard` is calculated by starting with `true` and adding other conditions as needed.
            // Collect these into `guards` by processing the directives.
            const directiveGuards = [];
            const directives = this.tcb.boundTarget.getDirectivesOfNode(this.template);
            if (directives !== null) {
                for (const dir of directives) {
                    const dirInstId = this.scope.resolve(this.template, dir);
                    const dirId = this.tcb.env.reference(dir.ref);
                    // There are two kinds of guards. Template guards (ngTemplateGuards) allow type narrowing of
                    // the expression passed to an @Input of the directive. Scan the directive to see if it has
                    // any template guards, and generate them if needed.
                    dir.ngTemplateGuards.forEach(guard => {
                        // For each template guard function on the directive, look for a binding to that input.
                        const boundInput = this.template.inputs.find(i => i.name === guard.inputName) ||
                            this.template.templateAttrs.find((i) => i instanceof BoundAttribute && i.name === guard.inputName);
                        if (boundInput !== undefined) {
                            // If there is such a binding, generate an expression for it.
                            const expr = tcbExpression(boundInput.value, this.tcb, this.scope);
                            // The expression has already been checked in the type constructor invocation, so
                            // it should be ignored when used within a template guard.
                            markIgnoreDiagnostics(expr);
                            if (guard.type === 'binding') {
                                // Use the binding expression itself as guard.
                                directiveGuards.push(expr);
                            }
                            else {
                                // Call the guard function on the directive with the directive instance and that
                                // expression.
                                const guardInvoke = tsCallMethod(dirId, `ngTemplateGuard_${guard.inputName}`, [
                                    dirInstId,
                                    expr,
                                ]);
                                addParseSpanInfo(guardInvoke, boundInput.value.sourceSpan);
                                directiveGuards.push(guardInvoke);
                            }
                        }
                    });
                    // The second kind of guard is a template context guard. This guard narrows the template
                    // rendering context variable `ctx`.
                    if (dir.hasNgTemplateContextGuard) {
                        if (this.tcb.env.config.applyTemplateContextGuards) {
                            const ctx = this.scope.resolve(this.template);
                            const guardInvoke = tsCallMethod(dirId, 'ngTemplateContextGuard', [dirInstId, ctx]);
                            addParseSpanInfo(guardInvoke, this.template.sourceSpan);
                            directiveGuards.push(guardInvoke);
                        }
                        else if (this.template.variables.length > 0 &&
                            this.tcb.env.config.suggestionsForSuboptimalTypeInference) {
                            // The compiler could have inferred a better type for the variables in this template,
                            // but was prevented from doing so by the type-checking configuration. Issue a warning
                            // diagnostic.
                            this.tcb.oobRecorder.suboptimalTypeInference(this.tcb.id, this.template.variables);
                        }
                    }
                }
            }
            // By default the guard is simply `true`.
            let guard = null;
            // If there are any guards from directives, use them instead.
            if (directiveGuards.length > 0) {
                // Pop the first value and use it as the initializer to reduce(). This way, a single guard
                // will be used on its own, but two or more will be combined into binary AND expressions.
                guard = directiveGuards.reduce((expr, dirGuard) => ts$1.createBinary(expr, ts$1.SyntaxKind.AmpersandAmpersandToken, dirGuard), directiveGuards.pop());
            }
            // Create a new Scope for the template. This constructs the list of operations for the template
            // children, as well as tracks bindings within the template.
            const tmplScope = Scope$1.forNodes(this.tcb, this.scope, this.template, guard);
            // Render the template's `Scope` into its statements.
            const statements = tmplScope.render();
            if (statements.length === 0) {
                // As an optimization, don't generate the scope's block if it has no statements. This is
                // beneficial for templates that contain for example `<span *ngIf="first"></span>`, in which
                // case there's no need to render the `NgIf` guard expression. This seems like a minor
                // improvement, however it reduces the number of flow-node antecedents that TypeScript needs
                // to keep into account for such cases, resulting in an overall reduction of
                // type-checking time.
                return null;
            }
            let tmplBlock = ts$1.createBlock(statements);
            if (guard !== null) {
                // The scope has a guard that needs to be applied, so wrap the template block into an `if`
                // statement containing the guard expression.
                tmplBlock = ts$1.createIf(/* expression */ guard, /* thenStatement */ tmplBlock);
            }
            this.scope.addStatement(tmplBlock);
            return null;
        }
    }
    /**
     * A `TcbOp` which renders a text binding (interpolation) into the TCB.
     *
     * Executing this operation returns nothing.
     */
    class TcbTextInterpolationOp extends TcbOp {
        constructor(tcb, scope, binding) {
            super();
            this.tcb = tcb;
            this.scope = scope;
            this.binding = binding;
        }
        get optional() {
            return false;
        }
        execute() {
            const expr = tcbExpression(this.binding.value, this.tcb, this.scope);
            this.scope.addStatement(ts$1.createExpressionStatement(expr));
            return null;
        }
    }
    /**
     * A `TcbOp` which constructs an instance of a directive. For generic directives, generic
     * parameters are set to `any` type.
     */
    class TcbDirectiveTypeOpBase extends TcbOp {
        constructor(tcb, scope, node, dir) {
            super();
            this.tcb = tcb;
            this.scope = scope;
            this.node = node;
            this.dir = dir;
        }
        get optional() {
            // The statement generated by this operation is only used to declare the directive's type and
            // won't report diagnostics by itself, so the operation is marked as optional to avoid
            // generating declarations for directives that don't have any inputs/outputs.
            return true;
        }
        execute() {
            const dirRef = this.dir.ref;
            const rawType = this.tcb.env.referenceType(this.dir.ref);
            let type;
            if (this.dir.isGeneric === false || dirRef.node.typeParameters === undefined) {
                type = rawType;
            }
            else {
                if (!ts$1.isTypeReferenceNode(rawType)) {
                    throw new Error(`Expected TypeReferenceNode when referencing the type for ${this.dir.ref.debugName}`);
                }
                const typeArguments = dirRef.node.typeParameters.map(() => ts$1.factory.createKeywordTypeNode(ts$1.SyntaxKind.AnyKeyword));
                type = ts$1.factory.createTypeReferenceNode(rawType.typeName, typeArguments);
            }
            const id = this.tcb.allocateId();
            addExpressionIdentifier(type, ExpressionIdentifier.DIRECTIVE);
            addParseSpanInfo(type, this.node.startSourceSpan || this.node.sourceSpan);
            this.scope.addStatement(tsDeclareVariable(id, type));
            return id;
        }
    }
    /**
     * A `TcbOp` which constructs an instance of a non-generic directive _without_ setting any of its
     * inputs. Inputs are later set in the `TcbDirectiveInputsOp`. Type checking was found to be
     * faster when done in this way as opposed to `TcbDirectiveCtorOp` which is only necessary when the
     * directive is generic.
     *
     * Executing this operation returns a reference to the directive instance variable with its inferred
     * type.
     */
    class TcbNonGenericDirectiveTypeOp extends TcbDirectiveTypeOpBase {
        /**
         * Creates a variable declaration for this op's directive of the argument type. Returns the id of
         * the newly created variable.
         */
        execute() {
            const dirRef = this.dir.ref;
            if (this.dir.isGeneric) {
                throw new Error(`Assertion Error: expected ${dirRef.debugName} not to be generic.`);
            }
            return super.execute();
        }
    }
    /**
     * A `TcbOp` which constructs an instance of a generic directive with its generic parameters set
     * to `any` type. This op is like `TcbDirectiveTypeOp`, except that generic parameters are set to
     * `any` type. This is used for situations where we want to avoid inlining.
     *
     * Executing this operation returns a reference to the directive instance variable with its generic
     * type parameters set to `any`.
     */
    class TcbGenericDirectiveTypeWithAnyParamsOp extends TcbDirectiveTypeOpBase {
        execute() {
            const dirRef = this.dir.ref;
            if (dirRef.node.typeParameters === undefined) {
                throw new Error(`Assertion Error: expected typeParameters when creating a declaration for ${dirRef.debugName}`);
            }
            return super.execute();
        }
    }
    /**
     * A `TcbOp` which creates a variable for a local ref in a template.
     * The initializer for the variable is the variable expression for the directive, template, or
     * element the ref refers to. When the reference is used in the template, those TCB statements will
     * access this variable as well. For example:
     * ```
     * var _t1 = document.createElement('div');
     * var _t2 = _t1;
     * _t2.value
     * ```
     * This operation supports more fluent lookups for the `TemplateTypeChecker` when getting a symbol
     * for a reference. In most cases, this isn't essential; that is, the information for the symbol
     * could be gathered without this operation using the `BoundTarget`. However, for the case of
     * ng-template references, we will need this reference variable to not only provide a location in
     * the shim file, but also to narrow the variable to the correct `TemplateRef<T>` type rather than
     * `TemplateRef<any>` (this work is still TODO).
     *
     * Executing this operation returns a reference to the directive instance variable with its inferred
     * type.
     */
    class TcbReferenceOp extends TcbOp {
        constructor(tcb, scope, node, host, target) {
            super();
            this.tcb = tcb;
            this.scope = scope;
            this.node = node;
            this.host = host;
            this.target = target;
            // The statement generated by this operation is only used to for the Type Checker
            // so it can map a reference variable in the template directly to a node in the TCB.
            this.optional = true;
        }
        execute() {
            const id = this.tcb.allocateId();
            let initializer = this.target instanceof Template || this.target instanceof Element ?
                this.scope.resolve(this.target) :
                this.scope.resolve(this.host, this.target);
            // The reference is either to an element, an <ng-template> node, or to a directive on an
            // element or template.
            if ((this.target instanceof Element && !this.tcb.env.config.checkTypeOfDomReferences) ||
                !this.tcb.env.config.checkTypeOfNonDomReferences) {
                // References to DOM nodes are pinned to 'any' when `checkTypeOfDomReferences` is `false`.
                // References to `TemplateRef`s and directives are pinned to 'any' when
                // `checkTypeOfNonDomReferences` is `false`.
                initializer =
                    ts$1.createAsExpression(initializer, ts$1.createKeywordTypeNode(ts$1.SyntaxKind.AnyKeyword));
            }
            else if (this.target instanceof Template) {
                // Direct references to an <ng-template> node simply require a value of type
                // `TemplateRef<any>`. To get this, an expression of the form
                // `(_t1 as any as TemplateRef<any>)` is constructed.
                initializer =
                    ts$1.createAsExpression(initializer, ts$1.createKeywordTypeNode(ts$1.SyntaxKind.AnyKeyword));
                initializer = ts$1.createAsExpression(initializer, this.tcb.env.referenceExternalType('@angular/core', 'TemplateRef', [DYNAMIC_TYPE]));
                initializer = ts$1.createParen(initializer);
            }
            addParseSpanInfo(initializer, this.node.sourceSpan);
            addParseSpanInfo(id, this.node.keySpan);
            this.scope.addStatement(tsCreateVariable(id, initializer));
            return id;
        }
    }
    /**
     * A `TcbOp` which is used when the target of a reference is missing. This operation generates a
     * variable of type any for usages of the invalid reference to resolve to. The invalid reference
     * itself is recorded out-of-band.
     */
    class TcbInvalidReferenceOp extends TcbOp {
        constructor(tcb, scope) {
            super();
            this.tcb = tcb;
            this.scope = scope;
            // The declaration of a missing reference is only needed when the reference is resolved.
            this.optional = true;
        }
        execute() {
            const id = this.tcb.allocateId();
            this.scope.addStatement(tsCreateVariable(id, NULL_AS_ANY));
            return id;
        }
    }
    /**
     * A `TcbOp` which constructs an instance of a directive with types inferred from its inputs. The
     * inputs themselves are not checked here; checking of inputs is achieved in `TcbDirectiveInputsOp`.
     * Any errors reported in this statement are ignored, as the type constructor call is only present
     * for type-inference.
     *
     * When a Directive is generic, it is required that the TCB generates the instance using this method
     * in order to infer the type information correctly.
     *
     * Executing this operation returns a reference to the directive instance variable with its inferred
     * type.
     */
    class TcbDirectiveCtorOp extends TcbOp {
        constructor(tcb, scope, node, dir) {
            super();
            this.tcb = tcb;
            this.scope = scope;
            this.node = node;
            this.dir = dir;
        }
        get optional() {
            // The statement generated by this operation is only used to infer the directive's type and
            // won't report diagnostics by itself, so the operation is marked as optional.
            return true;
        }
        execute() {
            const id = this.tcb.allocateId();
            addExpressionIdentifier(id, ExpressionIdentifier.DIRECTIVE);
            addParseSpanInfo(id, this.node.startSourceSpan || this.node.sourceSpan);
            const genericInputs = new Map();
            const inputs = getBoundInputs(this.dir, this.node, this.tcb);
            for (const input of inputs) {
                // Skip text attributes if configured to do so.
                if (!this.tcb.env.config.checkTypeOfAttributes &&
                    input.attribute instanceof TextAttribute) {
                    continue;
                }
                for (const fieldName of input.fieldNames) {
                    // Skip the field if an attribute has already been bound to it; we can't have a duplicate
                    // key in the type constructor call.
                    if (genericInputs.has(fieldName)) {
                        continue;
                    }
                    const expression = translateInput(input.attribute, this.tcb, this.scope);
                    genericInputs.set(fieldName, {
                        type: 'binding',
                        field: fieldName,
                        expression,
                        sourceSpan: input.attribute.sourceSpan
                    });
                }
            }
            // Add unset directive inputs for each of the remaining unset fields.
            for (const [fieldName] of this.dir.inputs) {
                if (!genericInputs.has(fieldName)) {
                    genericInputs.set(fieldName, { type: 'unset', field: fieldName });
                }
            }
            // Call the type constructor of the directive to infer a type, and assign the directive
            // instance.
            const typeCtor = tcbCallTypeCtor(this.dir, this.tcb, Array.from(genericInputs.values()));
            markIgnoreDiagnostics(typeCtor);
            this.scope.addStatement(tsCreateVariable(id, typeCtor));
            return id;
        }
        circularFallback() {
            return new TcbDirectiveCtorCircularFallbackOp(this.tcb, this.scope, this.node, this.dir);
        }
    }
    /**
     * A `TcbOp` which generates code to check input bindings on an element that correspond with the
     * members of a directive.
     *
     * Executing this operation returns nothing.
     */
    class TcbDirectiveInputsOp extends TcbOp {
        constructor(tcb, scope, node, dir) {
            super();
            this.tcb = tcb;
            this.scope = scope;
            this.node = node;
            this.dir = dir;
        }
        get optional() {
            return false;
        }
        execute() {
            let dirId = null;
            // TODO(joost): report duplicate properties
            const inputs = getBoundInputs(this.dir, this.node, this.tcb);
            for (const input of inputs) {
                // For bound inputs, the property is assigned the binding expression.
                let expr = translateInput(input.attribute, this.tcb, this.scope);
                if (!this.tcb.env.config.checkTypeOfInputBindings) {
                    // If checking the type of bindings is disabled, cast the resulting expression to 'any'
                    // before the assignment.
                    expr = tsCastToAny(expr);
                }
                else if (!this.tcb.env.config.strictNullInputBindings) {
                    // If strict null checks are disabled, erase `null` and `undefined` from the type by
                    // wrapping the expression in a non-null assertion.
                    expr = ts$1.createNonNullExpression(expr);
                }
                let assignment = wrapForDiagnostics(expr);
                for (const fieldName of input.fieldNames) {
                    let target;
                    if (this.dir.coercedInputFields.has(fieldName)) {
                        // The input has a coercion declaration which should be used instead of assigning the
                        // expression into the input field directly. To achieve this, a variable is declared
                        // with a type of `typeof Directive.ngAcceptInputType_fieldName` which is then used as
                        // target of the assignment.
                        const dirTypeRef = this.tcb.env.referenceType(this.dir.ref);
                        if (!ts$1.isTypeReferenceNode(dirTypeRef)) {
                            throw new Error(`Expected TypeReferenceNode from reference to ${this.dir.ref.debugName}`);
                        }
                        const id = this.tcb.allocateId();
                        const type = tsCreateTypeQueryForCoercedInput(dirTypeRef.typeName, fieldName);
                        this.scope.addStatement(tsDeclareVariable(id, type));
                        target = id;
                    }
                    else if (this.dir.undeclaredInputFields.has(fieldName)) {
                        // If no coercion declaration is present nor is the field declared (i.e. the input is
                        // declared in a `@Directive` or `@Component` decorator's `inputs` property) there is no
                        // assignment target available, so this field is skipped.
                        continue;
                    }
                    else if (!this.tcb.env.config.honorAccessModifiersForInputBindings &&
                        this.dir.restrictedInputFields.has(fieldName)) {
                        // If strict checking of access modifiers is disabled and the field is restricted
                        // (i.e. private/protected/readonly), generate an assignment into a temporary variable
                        // that has the type of the field. This achieves type-checking but circumvents the access
                        // modifiers.
                        if (dirId === null) {
                            dirId = this.scope.resolve(this.node, this.dir);
                        }
                        const id = this.tcb.allocateId();
                        const dirTypeRef = this.tcb.env.referenceType(this.dir.ref);
                        if (!ts$1.isTypeReferenceNode(dirTypeRef)) {
                            throw new Error(`Expected TypeReferenceNode from reference to ${this.dir.ref.debugName}`);
                        }
                        const type = ts$1.createIndexedAccessTypeNode(ts$1.createTypeQueryNode(dirId), ts$1.createLiteralTypeNode(ts$1.createStringLiteral(fieldName)));
                        const temp = tsDeclareVariable(id, type);
                        this.scope.addStatement(temp);
                        target = id;
                    }
                    else {
                        if (dirId === null) {
                            dirId = this.scope.resolve(this.node, this.dir);
                        }
                        // To get errors assign directly to the fields on the instance, using property access
                        // when possible. String literal fields may not be valid JS identifiers so we use
                        // literal element access instead for those cases.
                        target = this.dir.stringLiteralInputFields.has(fieldName) ?
                            ts$1.createElementAccess(dirId, ts$1.createStringLiteral(fieldName)) :
                            ts$1.createPropertyAccess(dirId, ts$1.createIdentifier(fieldName));
                    }
                    if (input.attribute.keySpan !== undefined) {
                        addParseSpanInfo(target, input.attribute.keySpan);
                    }
                    // Finally the assignment is extended by assigning it into the target expression.
                    assignment = ts$1.createBinary(target, ts$1.SyntaxKind.EqualsToken, assignment);
                }
                addParseSpanInfo(assignment, input.attribute.sourceSpan);
                // Ignore diagnostics for text attributes if configured to do so.
                if (!this.tcb.env.config.checkTypeOfAttributes &&
                    input.attribute instanceof TextAttribute) {
                    markIgnoreDiagnostics(assignment);
                }
                this.scope.addStatement(ts$1.createExpressionStatement(assignment));
            }
            return null;
        }
    }
    /**
     * A `TcbOp` which is used to generate a fallback expression if the inference of a directive type
     * via `TcbDirectiveCtorOp` requires a reference to its own type. This can happen using a template
     * reference:
     *
     * ```html
     * <some-cmp #ref [prop]="ref.foo"></some-cmp>
     * ```
     *
     * In this case, `TcbDirectiveCtorCircularFallbackOp` will add a second inference of the directive
     * type to the type-check block, this time calling the directive's type constructor without any
     * input expressions. This infers the widest possible supertype for the directive, which is used to
     * resolve any recursive references required to infer the real type.
     */
    class TcbDirectiveCtorCircularFallbackOp extends TcbOp {
        constructor(tcb, scope, node, dir) {
            super();
            this.tcb = tcb;
            this.scope = scope;
            this.node = node;
            this.dir = dir;
        }
        get optional() {
            return false;
        }
        execute() {
            const id = this.tcb.allocateId();
            const typeCtor = this.tcb.env.typeCtorFor(this.dir);
            const circularPlaceholder = ts$1.createCall(typeCtor, /* typeArguments */ undefined, [ts$1.createNonNullExpression(ts$1.createNull())]);
            this.scope.addStatement(tsCreateVariable(id, circularPlaceholder));
            return id;
        }
    }
    /**
     * A `TcbOp` which feeds elements and unclaimed properties to the `DomSchemaChecker`.
     *
     * The DOM schema is not checked via TCB code generation. Instead, the `DomSchemaChecker` ingests
     * elements and property bindings and accumulates synthetic `ts.Diagnostic`s out-of-band. These are
     * later merged with the diagnostics generated from the TCB.
     *
     * For convenience, the TCB iteration of the template is used to drive the `DomSchemaChecker` via
     * the `TcbDomSchemaCheckerOp`.
     */
    class TcbDomSchemaCheckerOp extends TcbOp {
        constructor(tcb, element, checkElement, claimedInputs) {
            super();
            this.tcb = tcb;
            this.element = element;
            this.checkElement = checkElement;
            this.claimedInputs = claimedInputs;
        }
        get optional() {
            return false;
        }
        execute() {
            if (this.checkElement) {
                this.tcb.domSchemaChecker.checkElement(this.tcb.id, this.element, this.tcb.schemas);
            }
            // TODO(alxhub): this could be more efficient.
            for (const binding of this.element.inputs) {
                if (binding.type === 0 /* Property */ && this.claimedInputs.has(binding.name)) {
                    // Skip this binding as it was claimed by a directive.
                    continue;
                }
                if (binding.type === 0 /* Property */) {
                    if (binding.name !== 'style' && binding.name !== 'class') {
                        // A direct binding to a property.
                        const propertyName = ATTR_TO_PROP[binding.name] || binding.name;
                        this.tcb.domSchemaChecker.checkProperty(this.tcb.id, this.element, propertyName, binding.sourceSpan, this.tcb.schemas);
                    }
                }
            }
            return null;
        }
    }
    /**
     * Mapping between attributes names that don't correspond to their element property names.
     * Note: this mapping has to be kept in sync with the equally named mapping in the runtime.
     */
    const ATTR_TO_PROP = {
        'class': 'className',
        'for': 'htmlFor',
        'formaction': 'formAction',
        'innerHtml': 'innerHTML',
        'readonly': 'readOnly',
        'tabindex': 'tabIndex',
    };
    /**
     * A `TcbOp` which generates code to check "unclaimed inputs" - bindings on an element which were
     * not attributed to any directive or component, and are instead processed against the HTML element
     * itself.
     *
     * Currently, only the expressions of these bindings are checked. The targets of the bindings are
     * checked against the DOM schema via a `TcbDomSchemaCheckerOp`.
     *
     * Executing this operation returns nothing.
     */
    class TcbUnclaimedInputsOp extends TcbOp {
        constructor(tcb, scope, element, claimedInputs) {
            super();
            this.tcb = tcb;
            this.scope = scope;
            this.element = element;
            this.claimedInputs = claimedInputs;
        }
        get optional() {
            return false;
        }
        execute() {
            // `this.inputs` contains only those bindings not matched by any directive. These bindings go to
            // the element itself.
            let elId = null;
            // TODO(alxhub): this could be more efficient.
            for (const binding of this.element.inputs) {
                if (binding.type === 0 /* Property */ && this.claimedInputs.has(binding.name)) {
                    // Skip this binding as it was claimed by a directive.
                    continue;
                }
                let expr = tcbExpression(binding.value, this.tcb, this.scope);
                if (!this.tcb.env.config.checkTypeOfInputBindings) {
                    // If checking the type of bindings is disabled, cast the resulting expression to 'any'
                    // before the assignment.
                    expr = tsCastToAny(expr);
                }
                else if (!this.tcb.env.config.strictNullInputBindings) {
                    // If strict null checks are disabled, erase `null` and `undefined` from the type by
                    // wrapping the expression in a non-null assertion.
                    expr = ts$1.createNonNullExpression(expr);
                }
                if (this.tcb.env.config.checkTypeOfDomBindings && binding.type === 0 /* Property */) {
                    if (binding.name !== 'style' && binding.name !== 'class') {
                        if (elId === null) {
                            elId = this.scope.resolve(this.element);
                        }
                        // A direct binding to a property.
                        const propertyName = ATTR_TO_PROP[binding.name] || binding.name;
                        const prop = ts$1.createElementAccess(elId, ts$1.createStringLiteral(propertyName));
                        const stmt = ts$1.createBinary(prop, ts$1.SyntaxKind.EqualsToken, wrapForDiagnostics(expr));
                        addParseSpanInfo(stmt, binding.sourceSpan);
                        this.scope.addStatement(ts$1.createExpressionStatement(stmt));
                    }
                    else {
                        this.scope.addStatement(ts$1.createExpressionStatement(expr));
                    }
                }
                else {
                    // A binding to an animation, attribute, class or style. For now, only validate the right-
                    // hand side of the expression.
                    // TODO: properly check class and style bindings.
                    this.scope.addStatement(ts$1.createExpressionStatement(expr));
                }
            }
            return null;
        }
    }
    /**
     * A `TcbOp` which generates code to check event bindings on an element that correspond with the
     * outputs of a directive.
     *
     * Executing this operation returns nothing.
     */
    class TcbDirectiveOutputsOp extends TcbOp {
        constructor(tcb, scope, node, dir) {
            super();
            this.tcb = tcb;
            this.scope = scope;
            this.node = node;
            this.dir = dir;
        }
        get optional() {
            return false;
        }
        execute() {
            let dirId = null;
            const outputs = this.dir.outputs;
            for (const output of this.node.outputs) {
                if (output.type !== 0 /* Regular */ || !outputs.hasBindingPropertyName(output.name)) {
                    continue;
                }
                if (this.tcb.env.config.checkTypeOfOutputEvents && output.name.endsWith('Change')) {
                    const inputName = output.name.slice(0, -6);
                    isSplitTwoWayBinding(inputName, output, this.node.inputs, this.tcb);
                }
                // TODO(alxhub): consider supporting multiple fields with the same property name for outputs.
                const field = outputs.getByBindingPropertyName(output.name)[0].classPropertyName;
                if (dirId === null) {
                    dirId = this.scope.resolve(this.node, this.dir);
                }
                const outputField = ts$1.createElementAccess(dirId, ts$1.createStringLiteral(field));
                addParseSpanInfo(outputField, output.keySpan);
                if (this.tcb.env.config.checkTypeOfOutputEvents) {
                    // For strict checking of directive events, generate a call to the `subscribe` method
                    // on the directive's output field to let type information flow into the handler function's
                    // `$event` parameter.
                    const handler = tcbCreateEventHandler(output, this.tcb, this.scope, 0 /* Infer */);
                    const subscribeFn = ts$1.createPropertyAccess(outputField, 'subscribe');
                    const call = ts$1.createCall(subscribeFn, /* typeArguments */ undefined, [handler]);
                    addParseSpanInfo(call, output.sourceSpan);
                    this.scope.addStatement(ts$1.createExpressionStatement(call));
                }
                else {
                    // If strict checking of directive events is disabled:
                    //
                    // * We still generate the access to the output field as a statement in the TCB so consumers
                    //   of the `TemplateTypeChecker` can still find the node for the class member for the
                    //   output.
                    // * Emit a handler function where the `$event` parameter has an explicit `any` type.
                    this.scope.addStatement(ts$1.createExpressionStatement(outputField));
                    const handler = tcbCreateEventHandler(output, this.tcb, this.scope, 1 /* Any */);
                    this.scope.addStatement(ts$1.createExpressionStatement(handler));
                }
                ExpressionSemanticVisitor.visit(output.handler, this.tcb.id, this.tcb.boundTarget, this.tcb.oobRecorder);
            }
            return null;
        }
    }
    /**
     * A `TcbOp` which generates code to check "unclaimed outputs" - event bindings on an element which
     * were not attributed to any directive or component, and are instead processed against the HTML
     * element itself.
     *
     * Executing this operation returns nothing.
     */
    class TcbUnclaimedOutputsOp extends TcbOp {
        constructor(tcb, scope, element, claimedOutputs) {
            super();
            this.tcb = tcb;
            this.scope = scope;
            this.element = element;
            this.claimedOutputs = claimedOutputs;
        }
        get optional() {
            return false;
        }
        execute() {
            let elId = null;
            // TODO(alxhub): this could be more efficient.
            for (const output of this.element.outputs) {
                if (this.claimedOutputs.has(output.name)) {
                    // Skip this event handler as it was claimed by a directive.
                    continue;
                }
                if (this.tcb.env.config.checkTypeOfOutputEvents && output.name.endsWith('Change')) {
                    const inputName = output.name.slice(0, -6);
                    if (isSplitTwoWayBinding(inputName, output, this.element.inputs, this.tcb)) {
                        // Skip this event handler as the error was already handled.
                        continue;
                    }
                }
                if (output.type === 1 /* Animation */) {
                    // Animation output bindings always have an `$event` parameter of type `AnimationEvent`.
                    const eventType = this.tcb.env.config.checkTypeOfAnimationEvents ?
                        this.tcb.env.referenceExternalType('@angular/animations', 'AnimationEvent') :
                        1 /* Any */;
                    const handler = tcbCreateEventHandler(output, this.tcb, this.scope, eventType);
                    this.scope.addStatement(ts$1.createExpressionStatement(handler));
                }
                else if (this.tcb.env.config.checkTypeOfDomEvents) {
                    // If strict checking of DOM events is enabled, generate a call to `addEventListener` on
                    // the element instance so that TypeScript's type inference for
                    // `HTMLElement.addEventListener` using `HTMLElementEventMap` to infer an accurate type for
                    // `$event` depending on the event name. For unknown event names, TypeScript resorts to the
                    // base `Event` type.
                    const handler = tcbCreateEventHandler(output, this.tcb, this.scope, 0 /* Infer */);
                    if (elId === null) {
                        elId = this.scope.resolve(this.element);
                    }
                    const propertyAccess = ts$1.createPropertyAccess(elId, 'addEventListener');
                    addParseSpanInfo(propertyAccess, output.keySpan);
                    const call = ts$1.createCall(
                    /* expression */ propertyAccess, 
                    /* typeArguments */ undefined, 
                    /* arguments */ [ts$1.createStringLiteral(output.name), handler]);
                    addParseSpanInfo(call, output.sourceSpan);
                    this.scope.addStatement(ts$1.createExpressionStatement(call));
                }
                else {
                    // If strict checking of DOM inputs is disabled, emit a handler function where the `$event`
                    // parameter has an explicit `any` type.
                    const handler = tcbCreateEventHandler(output, this.tcb, this.scope, 1 /* Any */);
                    this.scope.addStatement(ts$1.createExpressionStatement(handler));
                }
                ExpressionSemanticVisitor.visit(output.handler, this.tcb.id, this.tcb.boundTarget, this.tcb.oobRecorder);
            }
            return null;
        }
    }
    /**
     * A `TcbOp` which generates a completion point for the component context.
     *
     * This completion point looks like `ctx. ;` in the TCB output, and does not produce diagnostics.
     * TypeScript autocompletion APIs can be used at this completion point (after the '.') to produce
     * autocompletion results of properties and methods from the template's component context.
     */
    class TcbComponentContextCompletionOp extends TcbOp {
        constructor(scope) {
            super();
            this.scope = scope;
            this.optional = false;
        }
        execute() {
            const ctx = ts$1.createIdentifier('ctx');
            const ctxDot = ts$1.createPropertyAccess(ctx, '');
            markIgnoreDiagnostics(ctxDot);
            addExpressionIdentifier(ctxDot, ExpressionIdentifier.COMPONENT_COMPLETION);
            this.scope.addStatement(ts$1.createExpressionStatement(ctxDot));
            return null;
        }
    }
    /**
     * Value used to break a circular reference between `TcbOp`s.
     *
     * This value is returned whenever `TcbOp`s have a circular dependency. The expression is a non-null
     * assertion of the null value (in TypeScript, the expression `null!`). This construction will infer
     * the least narrow type for whatever it's assigned to.
     */
    const INFER_TYPE_FOR_CIRCULAR_OP_EXPR = ts$1.createNonNullExpression(ts$1.createNull());
    /**
     * Overall generation context for the type check block.
     *
     * `Context` handles operations during code generation which are global with respect to the whole
     * block. It's responsible for variable name allocation and management of any imports needed. It
     * also contains the template metadata itself.
     */
    class Context$1 {
        constructor(env, domSchemaChecker, oobRecorder, id, boundTarget, pipes, schemas) {
            this.env = env;
            this.domSchemaChecker = domSchemaChecker;
            this.oobRecorder = oobRecorder;
            this.id = id;
            this.boundTarget = boundTarget;
            this.pipes = pipes;
            this.schemas = schemas;
            this.nextId = 1;
        }
        /**
         * Allocate a new variable name for use within the `Context`.
         *
         * Currently this uses a monotonically increasing counter, but in the future the variable name
         * might change depending on the type of data being stored.
         */
        allocateId() {
            return ts$1.createIdentifier(`_t${this.nextId++}`);
        }
        getPipeByName(name) {
            if (!this.pipes.has(name)) {
                return null;
            }
            return this.pipes.get(name);
        }
    }
    /**
     * Local scope within the type check block for a particular template.
     *
     * The top-level template and each nested `<ng-template>` have their own `Scope`, which exist in a
     * hierarchy. The structure of this hierarchy mirrors the syntactic scopes in the generated type
     * check block, where each nested template is encased in an `if` structure.
     *
     * As a template's `TcbOp`s are executed in a given `Scope`, statements are added via
     * `addStatement()`. When this processing is complete, the `Scope` can be turned into a `ts.Block`
     * via `renderToBlock()`.
     *
     * If a `TcbOp` requires the output of another, it can call `resolve()`.
     */
    class Scope$1 {
        constructor(tcb, parent = null, guard = null) {
            this.tcb = tcb;
            this.parent = parent;
            this.guard = guard;
            /**
             * A queue of operations which need to be performed to generate the TCB code for this scope.
             *
             * This array can contain either a `TcbOp` which has yet to be executed, or a `ts.Expression|null`
             * representing the memoized result of executing the operation. As operations are executed, their
             * results are written into the `opQueue`, overwriting the original operation.
             *
             * If an operation is in the process of being executed, it is temporarily overwritten here with
             * `INFER_TYPE_FOR_CIRCULAR_OP_EXPR`. This way, if a cycle is encountered where an operation
             * depends transitively on its own result, the inner operation will infer the least narrow type
             * that fits instead. This has the same semantics as TypeScript itself when types are referenced
             * circularly.
             */
            this.opQueue = [];
            /**
             * A map of `TmplAstElement`s to the index of their `TcbElementOp` in the `opQueue`
             */
            this.elementOpMap = new Map();
            /**
             * A map of maps which tracks the index of `TcbDirectiveCtorOp`s in the `opQueue` for each
             * directive on a `TmplAstElement` or `TmplAstTemplate` node.
             */
            this.directiveOpMap = new Map();
            /**
             * A map of `TmplAstReference`s to the index of their `TcbReferenceOp` in the `opQueue`
             */
            this.referenceOpMap = new Map();
            /**
             * Map of immediately nested <ng-template>s (within this `Scope`) represented by `TmplAstTemplate`
             * nodes to the index of their `TcbTemplateContextOp`s in the `opQueue`.
             */
            this.templateCtxOpMap = new Map();
            /**
             * Map of variables declared on the template that created this `Scope` (represented by
             * `TmplAstVariable` nodes) to the index of their `TcbVariableOp`s in the `opQueue`.
             */
            this.varMap = new Map();
            /**
             * Statements for this template.
             *
             * Executing the `TcbOp`s in the `opQueue` populates this array.
             */
            this.statements = [];
        }
        /**
         * Constructs a `Scope` given either a `TmplAstTemplate` or a list of `TmplAstNode`s.
         *
         * @param tcb the overall context of TCB generation.
         * @param parent the `Scope` of the parent template (if any) or `null` if this is the root
         * `Scope`.
         * @param templateOrNodes either a `TmplAstTemplate` representing the template for which to
         * calculate the `Scope`, or a list of nodes if no outer template object is available.
         * @param guard an expression that is applied to this scope for type narrowing purposes.
         */
        static forNodes(tcb, parent, templateOrNodes, guard) {
            const scope = new Scope$1(tcb, parent, guard);
            if (parent === null && tcb.env.config.enableTemplateTypeChecker) {
                // Add an autocompletion point for the component context.
                scope.opQueue.push(new TcbComponentContextCompletionOp(scope));
            }
            let children;
            // If given an actual `TmplAstTemplate` instance, then process any additional information it
            // has.
            if (templateOrNodes instanceof Template) {
                // The template's variable declarations need to be added as `TcbVariableOp`s.
                const varMap = new Map();
                for (const v of templateOrNodes.variables) {
                    // Validate that variables on the `TmplAstTemplate` are only declared once.
                    if (!varMap.has(v.name)) {
                        varMap.set(v.name, v);
                    }
                    else {
                        const firstDecl = varMap.get(v.name);
                        tcb.oobRecorder.duplicateTemplateVar(tcb.id, v, firstDecl);
                    }
                    const opIndex = scope.opQueue.push(new TcbVariableOp(tcb, scope, templateOrNodes, v)) - 1;
                    scope.varMap.set(v, opIndex);
                }
                children = templateOrNodes.children;
            }
            else {
                children = templateOrNodes;
            }
            for (const node of children) {
                scope.appendNode(node);
            }
            return scope;
        }
        /**
         * Look up a `ts.Expression` representing the value of some operation in the current `Scope`,
         * including any parent scope(s). This method always returns a mutable clone of the
         * `ts.Expression` with the comments cleared.
         *
         * @param node a `TmplAstNode` of the operation in question. The lookup performed will depend on
         * the type of this node:
         *
         * Assuming `directive` is not present, then `resolve` will return:
         *
         * * `TmplAstElement` - retrieve the expression for the element DOM node
         * * `TmplAstTemplate` - retrieve the template context variable
         * * `TmplAstVariable` - retrieve a template let- variable
         * * `TmplAstReference` - retrieve variable created for the local ref
         *
         * @param directive if present, a directive type on a `TmplAstElement` or `TmplAstTemplate` to
         * look up instead of the default for an element or template node.
         */
        resolve(node, directive) {
            // Attempt to resolve the operation locally.
            const res = this.resolveLocal(node, directive);
            if (res !== null) {
                // We want to get a clone of the resolved expression and clear the trailing comments
                // so they don't continue to appear in every place the expression is used.
                // As an example, this would otherwise produce:
                // var _t1 /**T:DIR*/ /*1,2*/ = _ctor1();
                // _t1 /**T:DIR*/ /*1,2*/.input = 'value';
                //
                // In addition, returning a clone prevents the consumer of `Scope#resolve` from
                // attaching comments at the declaration site.
                const clone = ts$1.getMutableClone(res);
                ts$1.setSyntheticTrailingComments(clone, []);
                return clone;
            }
            else if (this.parent !== null) {
                // Check with the parent.
                return this.parent.resolve(node, directive);
            }
            else {
                throw new Error(`Could not resolve ${node} / ${directive}`);
            }
        }
        /**
         * Add a statement to this scope.
         */
        addStatement(stmt) {
            this.statements.push(stmt);
        }
        /**
         * Get the statements.
         */
        render() {
            for (let i = 0; i < this.opQueue.length; i++) {
                // Optional statements cannot be skipped when we are generating the TCB for use
                // by the TemplateTypeChecker.
                const skipOptional = !this.tcb.env.config.enableTemplateTypeChecker;
                this.executeOp(i, skipOptional);
            }
            return this.statements;
        }
        /**
         * Returns an expression of all template guards that apply to this scope, including those of
         * parent scopes. If no guards have been applied, null is returned.
         */
        guards() {
            let parentGuards = null;
            if (this.parent !== null) {
                // Start with the guards from the parent scope, if present.
                parentGuards = this.parent.guards();
            }
            if (this.guard === null) {
                // This scope does not have a guard, so return the parent's guards as is.
                return parentGuards;
            }
            else if (parentGuards === null) {
                // There's no guards from the parent scope, so this scope's guard represents all available
                // guards.
                return this.guard;
            }
            else {
                // Both the parent scope and this scope provide a guard, so create a combination of the two.
                // It is important that the parent guard is used as left operand, given that it may provide
                // narrowing that is required for this scope's guard to be valid.
                return ts$1.createBinary(parentGuards, ts$1.SyntaxKind.AmpersandAmpersandToken, this.guard);
            }
        }
        resolveLocal(ref, directive) {
            if (ref instanceof Reference && this.referenceOpMap.has(ref)) {
                return this.resolveOp(this.referenceOpMap.get(ref));
            }
            else if (ref instanceof Variable && this.varMap.has(ref)) {
                // Resolving a context variable for this template.
                // Execute the `TcbVariableOp` associated with the `TmplAstVariable`.
                return this.resolveOp(this.varMap.get(ref));
            }
            else if (ref instanceof Template && directive === undefined &&
                this.templateCtxOpMap.has(ref)) {
                // Resolving the context of the given sub-template.
                // Execute the `TcbTemplateContextOp` for the template.
                return this.resolveOp(this.templateCtxOpMap.get(ref));
            }
            else if ((ref instanceof Element || ref instanceof Template) &&
                directive !== undefined && this.directiveOpMap.has(ref)) {
                // Resolving a directive on an element or sub-template.
                const dirMap = this.directiveOpMap.get(ref);
                if (dirMap.has(directive)) {
                    return this.resolveOp(dirMap.get(directive));
                }
                else {
                    return null;
                }
            }
            else if (ref instanceof Element && this.elementOpMap.has(ref)) {
                // Resolving the DOM node of an element in this template.
                return this.resolveOp(this.elementOpMap.get(ref));
            }
            else {
                return null;
            }
        }
        /**
         * Like `executeOp`, but assert that the operation actually returned `ts.Expression`.
         */
        resolveOp(opIndex) {
            const res = this.executeOp(opIndex, /* skipOptional */ false);
            if (res === null) {
                throw new Error(`Error resolving operation, got null`);
            }
            return res;
        }
        /**
         * Execute a particular `TcbOp` in the `opQueue`.
         *
         * This method replaces the operation in the `opQueue` with the result of execution (once done)
         * and also protects against a circular dependency from the operation to itself by temporarily
         * setting the operation's result to a special expression.
         */
        executeOp(opIndex, skipOptional) {
            const op = this.opQueue[opIndex];
            if (!(op instanceof TcbOp)) {
                return op;
            }
            if (skipOptional && op.optional) {
                return null;
            }
            // Set the result of the operation in the queue to its circular fallback. If executing this
            // operation results in a circular dependency, this will prevent an infinite loop and allow for
            // the resolution of such cycles.
            this.opQueue[opIndex] = op.circularFallback();
            const res = op.execute();
            // Once the operation has finished executing, it's safe to cache the real result.
            this.opQueue[opIndex] = res;
            return res;
        }
        appendNode(node) {
            if (node instanceof Element) {
                const opIndex = this.opQueue.push(new TcbElementOp(this.tcb, this, node)) - 1;
                this.elementOpMap.set(node, opIndex);
                this.appendDirectivesAndInputsOfNode(node);
                this.appendOutputsOfNode(node);
                for (const child of node.children) {
                    this.appendNode(child);
                }
                this.checkAndAppendReferencesOfNode(node);
            }
            else if (node instanceof Template) {
                // Template children are rendered in a child scope.
                this.appendDirectivesAndInputsOfNode(node);
                this.appendOutputsOfNode(node);
                const ctxIndex = this.opQueue.push(new TcbTemplateContextOp(this.tcb, this)) - 1;
                this.templateCtxOpMap.set(node, ctxIndex);
                if (this.tcb.env.config.checkTemplateBodies) {
                    this.opQueue.push(new TcbTemplateBodyOp(this.tcb, this, node));
                }
                else if (this.tcb.env.config.alwaysCheckSchemaInTemplateBodies) {
                    this.appendDeepSchemaChecks(node.children);
                }
                this.checkAndAppendReferencesOfNode(node);
            }
            else if (node instanceof BoundText) {
                this.opQueue.push(new TcbTextInterpolationOp(this.tcb, this, node));
            }
            else if (node instanceof Icu) {
                this.appendIcuExpressions(node);
            }
        }
        checkAndAppendReferencesOfNode(node) {
            for (const ref of node.references) {
                const target = this.tcb.boundTarget.getReferenceTarget(ref);
                let ctxIndex;
                if (target === null) {
                    // The reference is invalid if it doesn't have a target, so report it as an error.
                    this.tcb.oobRecorder.missingReferenceTarget(this.tcb.id, ref);
                    // Any usages of the invalid reference will be resolved to a variable of type any.
                    ctxIndex = this.opQueue.push(new TcbInvalidReferenceOp(this.tcb, this)) - 1;
                }
                else if (target instanceof Template || target instanceof Element) {
                    ctxIndex = this.opQueue.push(new TcbReferenceOp(this.tcb, this, ref, node, target)) - 1;
                }
                else {
                    ctxIndex =
                        this.opQueue.push(new TcbReferenceOp(this.tcb, this, ref, node, target.directive)) - 1;
                }
                this.referenceOpMap.set(ref, ctxIndex);
            }
        }
        appendDirectivesAndInputsOfNode(node) {
            // Collect all the inputs on the element.
            const claimedInputs = new Set();
            const directives = this.tcb.boundTarget.getDirectivesOfNode(node);
            if (directives === null || directives.length === 0) {
                // If there are no directives, then all inputs are unclaimed inputs, so queue an operation
                // to add them if needed.
                if (node instanceof Element) {
                    this.opQueue.push(new TcbUnclaimedInputsOp(this.tcb, this, node, claimedInputs));
                    this.opQueue.push(new TcbDomSchemaCheckerOp(this.tcb, node, /* checkElement */ true, claimedInputs));
                }
                return;
            }
            const dirMap = new Map();
            for (const dir of directives) {
                let directiveOp;
                const host = this.tcb.env.reflector;
                const dirRef = dir.ref;
                if (!dir.isGeneric) {
                    // The most common case is that when a directive is not generic, we use the normal
                    // `TcbNonDirectiveTypeOp`.
                    directiveOp = new TcbNonGenericDirectiveTypeOp(this.tcb, this, node, dir);
                }
                else if (!requiresInlineTypeCtor(dirRef.node, host) ||
                    this.tcb.env.config.useInlineTypeConstructors) {
                    // For generic directives, we use a type constructor to infer types. If a directive requires
                    // an inline type constructor, then inlining must be available to use the
                    // `TcbDirectiveCtorOp`. If not we, we fallback to using `any`  see below.
                    directiveOp = new TcbDirectiveCtorOp(this.tcb, this, node, dir);
                }
                else {
                    // If inlining is not available, then we give up on infering the generic params, and use
                    // `any` type for the directive's generic parameters.
                    directiveOp = new TcbGenericDirectiveTypeWithAnyParamsOp(this.tcb, this, node, dir);
                }
                const dirIndex = this.opQueue.push(directiveOp) - 1;
                dirMap.set(dir, dirIndex);
                this.opQueue.push(new TcbDirectiveInputsOp(this.tcb, this, node, dir));
            }
            this.directiveOpMap.set(node, dirMap);
            // After expanding the directives, we might need to queue an operation to check any unclaimed
            // inputs.
            if (node instanceof Element) {
                // Go through the directives and remove any inputs that it claims from `elementInputs`.
                for (const dir of directives) {
                    for (const propertyName of dir.inputs.propertyNames) {
                        claimedInputs.add(propertyName);
                    }
                }
                this.opQueue.push(new TcbUnclaimedInputsOp(this.tcb, this, node, claimedInputs));
                // If there are no directives which match this element, then it's a "plain" DOM element (or a
                // web component), and should be checked against the DOM schema. If any directives match,
                // we must assume that the element could be custom (either a component, or a directive like
                // <router-outlet>) and shouldn't validate the element name itself.
                const checkElement = directives.length === 0;
                this.opQueue.push(new TcbDomSchemaCheckerOp(this.tcb, node, checkElement, claimedInputs));
            }
        }
        appendOutputsOfNode(node) {
            // Collect all the outputs on the element.
            const claimedOutputs = new Set();
            const directives = this.tcb.boundTarget.getDirectivesOfNode(node);
            if (directives === null || directives.length === 0) {
                // If there are no directives, then all outputs are unclaimed outputs, so queue an operation
                // to add them if needed.
                if (node instanceof Element) {
                    this.opQueue.push(new TcbUnclaimedOutputsOp(this.tcb, this, node, claimedOutputs));
                }
                return;
            }
            // Queue operations for all directives to check the relevant outputs for a directive.
            for (const dir of directives) {
                this.opQueue.push(new TcbDirectiveOutputsOp(this.tcb, this, node, dir));
            }
            // After expanding the directives, we might need to queue an operation to check any unclaimed
            // outputs.
            if (node instanceof Element) {
                // Go through the directives and register any outputs that it claims in `claimedOutputs`.
                for (const dir of directives) {
                    for (const outputProperty of dir.outputs.propertyNames) {
                        claimedOutputs.add(outputProperty);
                    }
                }
                this.opQueue.push(new TcbUnclaimedOutputsOp(this.tcb, this, node, claimedOutputs));
            }
        }
        appendDeepSchemaChecks(nodes) {
            for (const node of nodes) {
                if (!(node instanceof Element || node instanceof Template)) {
                    continue;
                }
                if (node instanceof Element) {
                    const claimedInputs = new Set();
                    const directives = this.tcb.boundTarget.getDirectivesOfNode(node);
                    let hasDirectives;
                    if (directives === null || directives.length === 0) {
                        hasDirectives = false;
                    }
                    else {
                        hasDirectives = true;
                        for (const dir of directives) {
                            for (const propertyName of dir.inputs.propertyNames) {
                                claimedInputs.add(propertyName);
                            }
                        }
                    }
                    this.opQueue.push(new TcbDomSchemaCheckerOp(this.tcb, node, !hasDirectives, claimedInputs));
                }
                this.appendDeepSchemaChecks(node.children);
            }
        }
        appendIcuExpressions(node) {
            for (const variable of Object.values(node.vars)) {
                this.opQueue.push(new TcbTextInterpolationOp(this.tcb, this, variable));
            }
            for (const placeholder of Object.values(node.placeholders)) {
                if (placeholder instanceof BoundText) {
                    this.opQueue.push(new TcbTextInterpolationOp(this.tcb, this, placeholder));
                }
            }
        }
    }
    /**
     * Create the `ctx` parameter to the top-level TCB function, with the given generic type arguments.
     */
    function tcbCtxParam(node, name, typeArguments) {
        const type = ts$1.factory.createTypeReferenceNode(name, typeArguments);
        return ts$1.factory.createParameterDeclaration(
        /* decorators */ undefined, 
        /* modifiers */ undefined, 
        /* dotDotDotToken */ undefined, 
        /* name */ 'ctx', 
        /* questionToken */ undefined, 
        /* type */ type, 
        /* initializer */ undefined);
    }
    /**
     * Process an `AST` expression and convert it into a `ts.Expression`, generating references to the
     * correct identifiers in the current scope.
     */
    function tcbExpression(ast, tcb, scope) {
        const translator = new TcbExpressionTranslator(tcb, scope);
        return translator.translate(ast);
    }
    class TcbExpressionTranslator {
        constructor(tcb, scope) {
            this.tcb = tcb;
            this.scope = scope;
        }
        translate(ast) {
            // `astToTypescript` actually does the conversion. A special resolver `tcbResolve` is passed
            // which interprets specific expression nodes that interact with the `ImplicitReceiver`. These
            // nodes actually refer to identifiers within the current scope.
            return astToTypescript(ast, ast => this.resolve(ast), this.tcb.env.config);
        }
        /**
         * Resolve an `AST` expression within the given scope.
         *
         * Some `AST` expressions refer to top-level concepts (references, variables, the component
         * context). This method assists in resolving those.
         */
        resolve(ast) {
            if (ast instanceof PropertyRead && ast.receiver instanceof ImplicitReceiver) {
                // Try to resolve a bound target for this expression. If no such target is available, then
                // the expression is referencing the top-level component context. In that case, `null` is
                // returned here to let it fall through resolution so it will be caught when the
                // `ImplicitReceiver` is resolved in the branch below.
                return this.resolveTarget(ast);
            }
            else if (ast instanceof PropertyWrite && ast.receiver instanceof ImplicitReceiver) {
                const target = this.resolveTarget(ast);
                if (target === null) {
                    return null;
                }
                const expr = this.translate(ast.value);
                const result = ts$1.createParen(ts$1.createBinary(target, ts$1.SyntaxKind.EqualsToken, expr));
                addParseSpanInfo(result, ast.sourceSpan);
                return result;
            }
            else if (ast instanceof ImplicitReceiver) {
                // AST instances representing variables and references look very similar to property reads
                // or method calls from the component context: both have the shape
                // PropertyRead(ImplicitReceiver, 'propName') or MethodCall(ImplicitReceiver, 'methodName').
                //
                // `translate` will first try to `resolve` the outer PropertyRead/MethodCall. If this works,
                // it's because the `BoundTarget` found an expression target for the whole expression, and
                // therefore `translate` will never attempt to `resolve` the ImplicitReceiver of that
                // PropertyRead/MethodCall.
                //
                // Therefore if `resolve` is called on an `ImplicitReceiver`, it's because no outer
                // PropertyRead/MethodCall resolved to a variable or reference, and therefore this is a
                // property read or method call on the component context itself.
                return ts$1.createIdentifier('ctx');
            }
            else if (ast instanceof BindingPipe) {
                const expr = this.translate(ast.exp);
                const pipeRef = this.tcb.getPipeByName(ast.name);
                let pipe;
                if (pipeRef === null) {
                    // No pipe by that name exists in scope. Record this as an error.
                    this.tcb.oobRecorder.missingPipe(this.tcb.id, ast);
                    // Use an 'any' value to at least allow the rest of the expression to be checked.
                    pipe = NULL_AS_ANY;
                }
                else {
                    // Use a variable declared as the pipe's type.
                    pipe = this.tcb.env.pipeInst(pipeRef);
                }
                const args = ast.args.map(arg => this.translate(arg));
                let methodAccess = ts$1.factory.createPropertyAccessExpression(pipe, 'transform');
                addParseSpanInfo(methodAccess, ast.nameSpan);
                if (!this.tcb.env.config.checkTypeOfPipes) {
                    methodAccess = ts$1.factory.createAsExpression(methodAccess, ts$1.factory.createKeywordTypeNode(ts$1.SyntaxKind.AnyKeyword));
                }
                const result = ts$1.createCall(
                /* expression */ methodAccess, 
                /* typeArguments */ undefined, 
                /* argumentsArray */ [expr, ...args]);
                addParseSpanInfo(result, ast.sourceSpan);
                return result;
            }
            else if (ast instanceof MethodCall && ast.receiver instanceof ImplicitReceiver &&
                !(ast.receiver instanceof ThisReceiver)) {
                // Resolve the special `$any(expr)` syntax to insert a cast of the argument to type `any`.
                // `$any(expr)` -> `expr as any`
                if (ast.name === '$any' && ast.args.length === 1) {
                    const expr = this.translate(ast.args[0]);
                    const exprAsAny = ts$1.createAsExpression(expr, ts$1.createKeywordTypeNode(ts$1.SyntaxKind.AnyKeyword));
                    const result = ts$1.createParen(exprAsAny);
                    addParseSpanInfo(result, ast.sourceSpan);
                    return result;
                }
                // Attempt to resolve a bound target for the method, and generate the method call if a target
                // could be resolved. If no target is available, then the method is referencing the top-level
                // component context, in which case `null` is returned to let the `ImplicitReceiver` being
                // resolved to the component context.
                const receiver = this.resolveTarget(ast);
                if (receiver === null) {
                    return null;
                }
                const method = wrapForDiagnostics(receiver);
                addParseSpanInfo(method, ast.nameSpan);
                const args = ast.args.map(arg => this.translate(arg));
                const node = ts$1.createCall(method, undefined, args);
                addParseSpanInfo(node, ast.sourceSpan);
                return node;
            }
            else {
                // This AST isn't special after all.
                return null;
            }
        }
        /**
         * Attempts to resolve a bound target for a given expression, and translates it into the
         * appropriate `ts.Expression` that represents the bound target. If no target is available,
         * `null` is returned.
         */
        resolveTarget(ast) {
            const binding = this.tcb.boundTarget.getExpressionTarget(ast);
            if (binding === null) {
                return null;
            }
            const expr = this.scope.resolve(binding);
            addParseSpanInfo(expr, ast.sourceSpan);
            return expr;
        }
    }
    /**
     * Call the type constructor of a directive instance on a given template node, inferring a type for
     * the directive instance from any bound inputs.
     */
    function tcbCallTypeCtor(dir, tcb, inputs) {
        const typeCtor = tcb.env.typeCtorFor(dir);
        // Construct an array of `ts.PropertyAssignment`s for each of the directive's inputs.
        const members = inputs.map(input => {
            const propertyName = ts$1.createStringLiteral(input.field);
            if (input.type === 'binding') {
                // For bound inputs, the property is assigned the binding expression.
                let expr = input.expression;
                if (!tcb.env.config.checkTypeOfInputBindings) {
                    // If checking the type of bindings is disabled, cast the resulting expression to 'any'
                    // before the assignment.
                    expr = tsCastToAny(expr);
                }
                else if (!tcb.env.config.strictNullInputBindings) {
                    // If strict null checks are disabled, erase `null` and `undefined` from the type by
                    // wrapping the expression in a non-null assertion.
                    expr = ts$1.createNonNullExpression(expr);
                }
                const assignment = ts$1.createPropertyAssignment(propertyName, wrapForDiagnostics(expr));
                addParseSpanInfo(assignment, input.sourceSpan);
                return assignment;
            }
            else {
                // A type constructor is required to be called with all input properties, so any unset
                // inputs are simply assigned a value of type `any` to ignore them.
                return ts$1.createPropertyAssignment(propertyName, NULL_AS_ANY);
            }
        });
        // Call the `ngTypeCtor` method on the directive class, with an object literal argument created
        // from the matched inputs.
        return ts$1.createCall(
        /* expression */ typeCtor, 
        /* typeArguments */ undefined, 
        /* argumentsArray */ [ts$1.createObjectLiteral(members)]);
    }
    function getBoundInputs(directive, node, tcb) {
        const boundInputs = [];
        const processAttribute = (attr) => {
            // Skip non-property bindings.
            if (attr instanceof BoundAttribute && attr.type !== 0 /* Property */) {
                return;
            }
            // Skip the attribute if the directive does not have an input for it.
            const inputs = directive.inputs.getByBindingPropertyName(attr.name);
            if (inputs === null) {
                return;
            }
            const fieldNames = inputs.map(input => input.classPropertyName);
            boundInputs.push({ attribute: attr, fieldNames });
        };
        node.inputs.forEach(processAttribute);
        node.attributes.forEach(processAttribute);
        if (node instanceof Template) {
            node.templateAttrs.forEach(processAttribute);
        }
        return boundInputs;
    }
    /**
     * Translates the given attribute binding to a `ts.Expression`.
     */
    function translateInput(attr, tcb, scope) {
        if (attr instanceof BoundAttribute) {
            // Produce an expression representing the value of the binding.
            return tcbExpression(attr.value, tcb, scope);
        }
        else {
            // For regular attributes with a static string value, use the represented string literal.
            return ts$1.createStringLiteral(attr.value);
        }
    }
    const EVENT_PARAMETER = '$event';
    /**
     * Creates an arrow function to be used as handler function for event bindings. The handler
     * function has a single parameter `$event` and the bound event's handler `AST` represented as a
     * TypeScript expression as its body.
     *
     * When `eventType` is set to `Infer`, the `$event` parameter will not have an explicit type. This
     * allows for the created handler function to have its `$event` parameter's type inferred based on
     * how it's used, to enable strict type checking of event bindings. When set to `Any`, the `$event`
     * parameter will have an explicit `any` type, effectively disabling strict type checking of event
     * bindings. Alternatively, an explicit type can be passed for the `$event` parameter.
     */
    function tcbCreateEventHandler(event, tcb, scope, eventType) {
        const handler = tcbEventHandlerExpression(event.handler, tcb, scope);
        let eventParamType;
        if (eventType === 0 /* Infer */) {
            eventParamType = undefined;
        }
        else if (eventType === 1 /* Any */) {
            eventParamType = ts$1.createKeywordTypeNode(ts$1.SyntaxKind.AnyKeyword);
        }
        else {
            eventParamType = eventType;
        }
        // Obtain all guards that have been applied to the scope and its parents, as they have to be
        // repeated within the handler function for their narrowing to be in effect within the handler.
        const guards = scope.guards();
        let body = ts$1.createExpressionStatement(handler);
        if (guards !== null) {
            // Wrap the body in an `if` statement containing all guards that have to be applied.
            body = ts$1.createIf(guards, body);
        }
        const eventParam = ts$1.createParameter(
        /* decorators */ undefined, 
        /* modifiers */ undefined, 
        /* dotDotDotToken */ undefined, 
        /* name */ EVENT_PARAMETER, 
        /* questionToken */ undefined, 
        /* type */ eventParamType);
        addExpressionIdentifier(eventParam, ExpressionIdentifier.EVENT_PARAMETER);
        return ts$1.createFunctionExpression(
        /* modifier */ undefined, 
        /* asteriskToken */ undefined, 
        /* name */ undefined, 
        /* typeParameters */ undefined, 
        /* parameters */ [eventParam], 
        /* type */ ts$1.createKeywordTypeNode(ts$1.SyntaxKind.AnyKeyword), 
        /* body */ ts$1.createBlock([body]));
    }
    /**
     * Similar to `tcbExpression`, this function converts the provided `AST` expression into a
     * `ts.Expression`, with special handling of the `$event` variable that can be used within event
     * bindings.
     */
    function tcbEventHandlerExpression(ast, tcb, scope) {
        const translator = new TcbEventHandlerTranslator(tcb, scope);
        return translator.translate(ast);
    }
    function isSplitTwoWayBinding(inputName, output, inputs, tcb) {
        const input = inputs.find(input => input.name === inputName);
        if (input === undefined || input.sourceSpan !== output.sourceSpan) {
            return false;
        }
        // Input consumer should be a directive because it's claimed
        const inputConsumer = tcb.boundTarget.getConsumerOfBinding(input);
        const outputConsumer = tcb.boundTarget.getConsumerOfBinding(output);
        if (outputConsumer === null || inputConsumer.ref === undefined ||
            outputConsumer instanceof Template) {
            return false;
        }
        if (outputConsumer instanceof Element) {
            tcb.oobRecorder.splitTwoWayBinding(tcb.id, input, output, inputConsumer.ref.node, outputConsumer);
            return true;
        }
        else if (outputConsumer.ref !== inputConsumer.ref) {
            tcb.oobRecorder.splitTwoWayBinding(tcb.id, input, output, inputConsumer.ref.node, outputConsumer.ref.node);
            return true;
        }
        return false;
    }
    class TcbEventHandlerTranslator extends TcbExpressionTranslator {
        resolve(ast) {
            // Recognize a property read on the implicit receiver corresponding with the event parameter
            // that is available in event bindings. Since this variable is a parameter of the handler
            // function that the converted expression becomes a child of, just create a reference to the
            // parameter by its name.
            if (ast instanceof PropertyRead && ast.receiver instanceof ImplicitReceiver &&
                !(ast.receiver instanceof ThisReceiver) && ast.name === EVENT_PARAMETER) {
                const event = ts$1.createIdentifier(EVENT_PARAMETER);
                addParseSpanInfo(event, ast.nameSpan);
                return event;
            }
            return super.resolve(ast);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * An `Environment` representing the single type-checking file into which most (if not all) Type
     * Check Blocks (TCBs) will be generated.
     *
     * The `TypeCheckFile` hosts multiple TCBs and allows the sharing of declarations (e.g. type
     * constructors) between them. Rather than return such declarations via `getPreludeStatements()`, it
     * hoists them to the top of the generated `ts.SourceFile`.
     */
    class TypeCheckFile extends Environment {
        constructor(fileName, config, refEmitter, reflector, compilerHost) {
            super(config, new ImportManager(new NoopImportRewriter(), 'i'), refEmitter, reflector, ts$1.createSourceFile(compilerHost.getCanonicalFileName(fileName), '', ts$1.ScriptTarget.Latest, true));
            this.fileName = fileName;
            this.nextTcbId = 1;
            this.tcbStatements = [];
        }
        addTypeCheckBlock(ref, meta, domSchemaChecker, oobRecorder, genericContextBehavior) {
            const fnId = ts$1.createIdentifier(`_tcb${this.nextTcbId++}`);
            const fn = generateTypeCheckBlock(this, ref, fnId, meta, domSchemaChecker, oobRecorder, genericContextBehavior);
            this.tcbStatements.push(fn);
        }
        render(removeComments) {
            let source = this.importManager.getAllImports(this.contextFile.fileName)
                .map(i => `import * as ${i.qualifier.text} from '${i.specifier}';`)
                .join('\n') +
                '\n\n';
            const printer = ts$1.createPrinter({ removeComments });
            source += '\n';
            for (const stmt of this.pipeInstStatements) {
                source += printer.printNode(ts$1.EmitHint.Unspecified, stmt, this.contextFile) + '\n';
            }
            for (const stmt of this.typeCtorStatements) {
                source += printer.printNode(ts$1.EmitHint.Unspecified, stmt, this.contextFile) + '\n';
            }
            source += '\n';
            for (const stmt of this.tcbStatements) {
                source += printer.printNode(ts$1.EmitHint.Unspecified, stmt, this.contextFile) + '\n';
            }
            // Ensure the template type-checking file is an ES module. Otherwise, it's interpreted as some
            // kind of global namespace in TS, which forces a full re-typecheck of the user's program that
            // is somehow more expensive than the initial parse.
            source += '\nexport const IS_A_MODULE = true;\n';
            return source;
        }
        getPreludeStatements() {
            return [];
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * How a type-checking context should handle operations which would require inlining.
     */
    var InliningMode;
    (function (InliningMode) {
        /**
         * Use inlining operations when required.
         */
        InliningMode[InliningMode["InlineOps"] = 0] = "InlineOps";
        /**
         * Produce diagnostics if an operation would require inlining.
         */
        InliningMode[InliningMode["Error"] = 1] = "Error";
    })(InliningMode || (InliningMode = {}));
    /**
     * A template type checking context for a program.
     *
     * The `TypeCheckContext` allows registration of components and their templates which need to be
     * type checked.
     */
    class TypeCheckContextImpl {
        constructor(config, compilerHost, refEmitter, reflector, host, inlining, perf) {
            this.config = config;
            this.compilerHost = compilerHost;
            this.refEmitter = refEmitter;
            this.reflector = reflector;
            this.host = host;
            this.inlining = inlining;
            this.perf = perf;
            this.fileMap = new Map();
            /**
             * A `Map` of `ts.SourceFile`s that the context has seen to the operations (additions of methods
             * or type-check blocks) that need to be eventually performed on that file.
             */
            this.opMap = new Map();
            /**
             * Tracks when an a particular class has a pending type constructor patching operation already
             * queued.
             */
            this.typeCtorPending = new Set();
            if (inlining === InliningMode.Error && config.useInlineTypeConstructors) {
                // We cannot use inlining for type checking since this environment does not support it.
                throw new Error(`AssertionError: invalid inlining configuration.`);
            }
        }
        /**
         * Register a template to potentially be type-checked.
         *
         * Implements `TypeCheckContext.addTemplate`.
         */
        addTemplate(ref, binder, template, pipes, schemas, sourceMapping, file, parseErrors) {
            if (!this.host.shouldCheckComponent(ref.node)) {
                return;
            }
            const fileData = this.dataForFile(ref.node.getSourceFile());
            const shimData = this.pendingShimForComponent(ref.node);
            const templateId = fileData.sourceManager.getTemplateId(ref.node);
            const templateDiagnostics = [];
            if (parseErrors !== null) {
                templateDiagnostics.push(...this.getTemplateDiagnostics(parseErrors, templateId, sourceMapping));
            }
            const boundTarget = binder.bind({ template });
            if (this.inlining === InliningMode.InlineOps) {
                // Get all of the directives used in the template and record inline type constructors when
                // required.
                for (const dir of boundTarget.getUsedDirectives()) {
                    const dirRef = dir.ref;
                    const dirNode = dirRef.node;
                    if (!dir.isGeneric || !requiresInlineTypeCtor(dirNode, this.reflector)) {
                        // inlining not required
                        continue;
                    }
                    // Add an inline type constructor operation for the directive.
                    this.addInlineTypeCtor(fileData, dirNode.getSourceFile(), dirRef, {
                        fnName: 'ngTypeCtor',
                        // The constructor should have a body if the directive comes from a .ts file, but not if
                        // it comes from a .d.ts file. .d.ts declarations don't have bodies.
                        body: !dirNode.getSourceFile().isDeclarationFile,
                        fields: {
                            inputs: dir.inputs.classPropertyNames,
                            outputs: dir.outputs.classPropertyNames,
                            // TODO(alxhub): support queries
                            queries: dir.queries,
                        },
                        coercedInputFields: dir.coercedInputFields,
                    });
                }
            }
            shimData.templates.set(templateId, {
                template,
                boundTarget,
                templateDiagnostics,
            });
            const inliningRequirement = requiresInlineTypeCheckBlock(ref.node, pipes, this.reflector);
            // If inlining is not supported, but is required for either the TCB or one of its directive
            // dependencies, then exit here with an error.
            if (this.inlining === InliningMode.Error &&
                inliningRequirement === TcbInliningRequirement.MustInline) {
                // This template cannot be supported because the underlying strategy does not support inlining
                // and inlining would be required.
                // Record diagnostics to indicate the issues with this template.
                shimData.oobRecorder.requiresInlineTcb(templateId, ref.node);
                // Checking this template would be unsupported, so don't try.
                this.perf.eventCount(PerfEvent.SkipGenerateTcbNoInline);
                return;
            }
            const meta = {
                id: fileData.sourceManager.captureSource(ref.node, sourceMapping, file),
                boundTarget,
                pipes,
                schemas,
            };
            this.perf.eventCount(PerfEvent.GenerateTcb);
            if (inliningRequirement !== TcbInliningRequirement.None &&
                this.inlining === InliningMode.InlineOps) {
                // This class didn't meet the requirements for external type checking, so generate an inline
                // TCB for the class.
                this.addInlineTypeCheckBlock(fileData, shimData, ref, meta);
            }
            else if (inliningRequirement === TcbInliningRequirement.ShouldInlineForGenericBounds &&
                this.inlining === InliningMode.Error) {
                // It's suggested that this TCB should be generated inline due to the component's generic
                // bounds, but inlining is not supported by the current environment. Use a non-inline type
                // check block, but fall back to `any` generic parameters since the generic bounds can't be
                // referenced in that context. This will infer a less useful type for the component, but allow
                // for type-checking it in an environment where that would not be possible otherwise.
                shimData.file.addTypeCheckBlock(ref, meta, shimData.domSchemaChecker, shimData.oobRecorder, TcbGenericContextBehavior.FallbackToAny);
            }
            else {
                shimData.file.addTypeCheckBlock(ref, meta, shimData.domSchemaChecker, shimData.oobRecorder, TcbGenericContextBehavior.UseEmitter);
            }
        }
        /**
         * Record a type constructor for the given `node` with the given `ctorMetadata`.
         */
        addInlineTypeCtor(fileData, sf, ref, ctorMeta) {
            if (this.typeCtorPending.has(ref.node)) {
                return;
            }
            this.typeCtorPending.add(ref.node);
            // Lazily construct the operation map.
            if (!this.opMap.has(sf)) {
                this.opMap.set(sf, []);
            }
            const ops = this.opMap.get(sf);
            // Push a `TypeCtorOp` into the operation queue for the source file.
            ops.push(new TypeCtorOp(ref, ctorMeta));
            fileData.hasInlines = true;
        }
        /**
         * Transform a `ts.SourceFile` into a version that includes type checking code.
         *
         * If this particular `ts.SourceFile` requires changes, the text representing its new contents
         * will be returned. Otherwise, a `null` return indicates no changes were necessary.
         */
        transform(sf) {
            // If there are no operations pending for this particular file, return `null` to indicate no
            // changes.
            if (!this.opMap.has(sf)) {
                return null;
            }
            // Imports may need to be added to the file to support type-checking of directives used in the
            // template within it.
            const importManager = new ImportManager(new NoopImportRewriter(), '_i');
            // Each Op has a splitPoint index into the text where it needs to be inserted. Split the
            // original source text into chunks at these split points, where code will be inserted between
            // the chunks.
            const ops = this.opMap.get(sf).sort(orderOps);
            const textParts = splitStringAtPoints(sf.text, ops.map(op => op.splitPoint));
            // Use a `ts.Printer` to generate source code.
            const printer = ts$1.createPrinter({ omitTrailingSemicolon: true });
            // Begin with the intial section of the code text.
            let code = textParts[0];
            // Process each operation and use the printer to generate source code for it, inserting it into
            // the source code in between the original chunks.
            ops.forEach((op, idx) => {
                const text = op.execute(importManager, sf, this.refEmitter, printer);
                code += '\n\n' + text + textParts[idx + 1];
            });
            // Write out the imports that need to be added to the beginning of the file.
            let imports = importManager.getAllImports(sf.fileName)
                .map(i => `import * as ${i.qualifier.text} from '${i.specifier}';`)
                .join('\n');
            code = imports + '\n' + code;
            return code;
        }
        finalize() {
            // First, build the map of updates to source files.
            const updates = new Map();
            for (const originalSf of this.opMap.keys()) {
                const newText = this.transform(originalSf);
                if (newText !== null) {
                    updates.set(absoluteFromSourceFile(originalSf), {
                        newText,
                        originalFile: originalSf,
                    });
                }
            }
            // Then go through each input file that has pending code generation operations.
            for (const [sfPath, pendingFileData] of this.fileMap) {
                // For each input file, consider generation operations for each of its shims.
                for (const pendingShimData of pendingFileData.shimData.values()) {
                    this.host.recordShimData(sfPath, {
                        genesisDiagnostics: [
                            ...pendingShimData.domSchemaChecker.diagnostics,
                            ...pendingShimData.oobRecorder.diagnostics,
                        ],
                        hasInlines: pendingFileData.hasInlines,
                        path: pendingShimData.file.fileName,
                        templates: pendingShimData.templates,
                    });
                    const sfText = pendingShimData.file.render(false /* removeComments */);
                    updates.set(pendingShimData.file.fileName, {
                        newText: sfText,
                        // Shim files do not have an associated original file.
                        originalFile: null,
                    });
                }
            }
            return updates;
        }
        addInlineTypeCheckBlock(fileData, shimData, ref, tcbMeta) {
            const sf = ref.node.getSourceFile();
            if (!this.opMap.has(sf)) {
                this.opMap.set(sf, []);
            }
            const ops = this.opMap.get(sf);
            ops.push(new InlineTcbOp(ref, tcbMeta, this.config, this.reflector, shimData.domSchemaChecker, shimData.oobRecorder));
            fileData.hasInlines = true;
        }
        pendingShimForComponent(node) {
            const fileData = this.dataForFile(node.getSourceFile());
            const shimPath = TypeCheckShimGenerator.shimFor(absoluteFromSourceFile(node.getSourceFile()));
            if (!fileData.shimData.has(shimPath)) {
                fileData.shimData.set(shimPath, {
                    domSchemaChecker: new RegistryDomSchemaChecker(fileData.sourceManager),
                    oobRecorder: new OutOfBandDiagnosticRecorderImpl(fileData.sourceManager),
                    file: new TypeCheckFile(shimPath, this.config, this.refEmitter, this.reflector, this.compilerHost),
                    templates: new Map(),
                });
            }
            return fileData.shimData.get(shimPath);
        }
        dataForFile(sf) {
            const sfPath = absoluteFromSourceFile(sf);
            if (!this.fileMap.has(sfPath)) {
                const data = {
                    hasInlines: false,
                    sourceManager: this.host.getSourceManager(sfPath),
                    shimData: new Map(),
                };
                this.fileMap.set(sfPath, data);
            }
            return this.fileMap.get(sfPath);
        }
        getTemplateDiagnostics(parseErrors, templateId, sourceMapping) {
            return parseErrors.map(error => {
                const span = error.span;
                if (span.start.offset === span.end.offset) {
                    // Template errors can contain zero-length spans, if the error occurs at a single point.
                    // However, TypeScript does not handle displaying a zero-length diagnostic very well, so
                    // increase the ending offset by 1 for such errors, to ensure the position is shown in the
                    // diagnostic.
                    span.end.offset++;
                }
                return makeTemplateDiagnostic(templateId, sourceMapping, span, ts$1.DiagnosticCategory.Error, ngErrorCode(ErrorCode.TEMPLATE_PARSE_ERROR), error.msg);
            });
        }
    }
    /**
     * A type check block operation which produces inline type check code for a particular component.
     */
    class InlineTcbOp {
        constructor(ref, meta, config, reflector, domSchemaChecker, oobRecorder) {
            this.ref = ref;
            this.meta = meta;
            this.config = config;
            this.reflector = reflector;
            this.domSchemaChecker = domSchemaChecker;
            this.oobRecorder = oobRecorder;
        }
        /**
         * Type check blocks are inserted immediately after the end of the component class.
         */
        get splitPoint() {
            return this.ref.node.end + 1;
        }
        execute(im, sf, refEmitter, printer) {
            const env = new Environment(this.config, im, refEmitter, this.reflector, sf);
            const fnName = ts$1.createIdentifier(`_tcb_${this.ref.node.pos}`);
            // Inline TCBs should copy any generic type parameter nodes directly, as the TCB code is inlined
            // into the class in a context where that will always be legal.
            const fn = generateTypeCheckBlock(env, this.ref, fnName, this.meta, this.domSchemaChecker, this.oobRecorder, TcbGenericContextBehavior.CopyClassNodes);
            return printer.printNode(ts$1.EmitHint.Unspecified, fn, sf);
        }
    }
    /**
     * A type constructor operation which produces type constructor code for a particular directive.
     */
    class TypeCtorOp {
        constructor(ref, meta) {
            this.ref = ref;
            this.meta = meta;
        }
        /**
         * Type constructor operations are inserted immediately before the end of the directive class.
         */
        get splitPoint() {
            return this.ref.node.end - 1;
        }
        execute(im, sf, refEmitter, printer) {
            const tcb = generateInlineTypeCtor(this.ref.node, this.meta);
            return printer.printNode(ts$1.EmitHint.Unspecified, tcb, sf);
        }
    }
    /**
     * Compare two operations and return their split point ordering.
     */
    function orderOps(op1, op2) {
        return op1.splitPoint - op2.splitPoint;
    }
    /**
     * Split a string into chunks at any number of split points.
     */
    function splitStringAtPoints(str, points) {
        const splits = [];
        let start = 0;
        for (let i = 0; i < points.length; i++) {
            const point = points[i];
            splits.push(str.substring(start, point));
            start = point;
        }
        splits.push(str.substring(start));
        return splits;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const LF_CHAR = 10;
    const CR_CHAR = 13;
    const LINE_SEP_CHAR = 8232;
    const PARAGRAPH_CHAR = 8233;
    /** Gets the line and character for the given position from the line starts map. */
    function getLineAndCharacterFromPosition(lineStartsMap, position) {
        const lineIndex = findClosestLineStartPosition(lineStartsMap, position);
        return { character: position - lineStartsMap[lineIndex], line: lineIndex };
    }
    /**
     * Computes the line start map of the given text. This can be used in order to
     * retrieve the line and character of a given text position index.
     */
    function computeLineStartsMap(text) {
        const result = [0];
        let pos = 0;
        while (pos < text.length) {
            const char = text.charCodeAt(pos++);
            // Handles the "CRLF" line break. In that case we peek the character
            // after the "CR" and check if it is a line feed.
            if (char === CR_CHAR) {
                if (text.charCodeAt(pos) === LF_CHAR) {
                    pos++;
                }
                result.push(pos);
            }
            else if (char === LF_CHAR || char === LINE_SEP_CHAR || char === PARAGRAPH_CHAR) {
                result.push(pos);
            }
        }
        result.push(pos);
        return result;
    }
    /** Finds the closest line start for the given position. */
    function findClosestLineStartPosition(linesMap, position, low = 0, high = linesMap.length - 1) {
        while (low <= high) {
            const pivotIdx = Math.floor((low + high) / 2);
            const pivotEl = linesMap[pivotIdx];
            if (pivotEl === position) {
                return pivotIdx;
            }
            else if (position > pivotEl) {
                low = pivotIdx + 1;
            }
            else {
                high = pivotIdx - 1;
            }
        }
        // In case there was no exact match, return the closest "lower" line index. We also
        // subtract the index by one because want the index of the previous line start.
        return low - 1;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Represents the source of a template that was processed during type-checking. This information is
     * used when translating parse offsets in diagnostics back to their original line/column location.
     */
    class TemplateSource {
        constructor(mapping, file) {
            this.mapping = mapping;
            this.file = file;
            this.lineStarts = null;
        }
        toParseSourceSpan(start, end) {
            const startLoc = this.toParseLocation(start);
            const endLoc = this.toParseLocation(end);
            return new ParseSourceSpan(startLoc, endLoc);
        }
        toParseLocation(position) {
            const lineStarts = this.acquireLineStarts();
            const { line, character } = getLineAndCharacterFromPosition(lineStarts, position);
            return new ParseLocation(this.file, position, line, character);
        }
        acquireLineStarts() {
            if (this.lineStarts === null) {
                this.lineStarts = computeLineStartsMap(this.file.content);
            }
            return this.lineStarts;
        }
    }
    /**
     * Assigns IDs to templates and keeps track of their origins.
     *
     * Implements `TemplateSourceResolver` to resolve the source of a template based on these IDs.
     */
    class TemplateSourceManager {
        constructor() {
            /**
             * This map keeps track of all template sources that have been type-checked by the id that is
             * attached to a TCB's function declaration as leading trivia. This enables translation of
             * diagnostics produced for TCB code to their source location in the template.
             */
            this.templateSources = new Map();
        }
        getTemplateId(node) {
            return getTemplateId(node);
        }
        captureSource(node, mapping, file) {
            const id = getTemplateId(node);
            this.templateSources.set(id, new TemplateSource(mapping, file));
            return id;
        }
        getSourceMapping(id) {
            if (!this.templateSources.has(id)) {
                throw new Error(`Unexpected unknown template ID: ${id}`);
            }
            return this.templateSources.get(id).mapping;
        }
        toParseSourceSpan(id, span) {
            if (!this.templateSources.has(id)) {
                return null;
            }
            const templateSource = this.templateSources.get(id);
            return templateSource.toParseSourceSpan(span.start, span.end);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Generates and caches `Symbol`s for various template structures for a given component.
     *
     * The `SymbolBuilder` internally caches the `Symbol`s it creates, and must be destroyed and
     * replaced if the component's template changes.
     */
    class SymbolBuilder {
        constructor(shimPath, typeCheckBlock, templateData, componentScopeReader, 
        // The `ts.TypeChecker` depends on the current type-checking program, and so must be requested
        // on-demand instead of cached.
        getTypeChecker) {
            this.shimPath = shimPath;
            this.typeCheckBlock = typeCheckBlock;
            this.templateData = templateData;
            this.componentScopeReader = componentScopeReader;
            this.getTypeChecker = getTypeChecker;
            this.symbolCache = new Map();
        }
        getSymbol(node) {
            if (this.symbolCache.has(node)) {
                return this.symbolCache.get(node);
            }
            let symbol = null;
            if (node instanceof BoundAttribute || node instanceof TextAttribute) {
                // TODO(atscott): input and output bindings only return the first directive match but should
                // return a list of bindings for all of them.
                symbol = this.getSymbolOfInputBinding(node);
            }
            else if (node instanceof BoundEvent) {
                symbol = this.getSymbolOfBoundEvent(node);
            }
            else if (node instanceof Element) {
                symbol = this.getSymbolOfElement(node);
            }
            else if (node instanceof Template) {
                symbol = this.getSymbolOfAstTemplate(node);
            }
            else if (node instanceof Variable) {
                symbol = this.getSymbolOfVariable(node);
            }
            else if (node instanceof Reference) {
                symbol = this.getSymbolOfReference(node);
            }
            else if (node instanceof BindingPipe) {
                symbol = this.getSymbolOfPipe(node);
            }
            else if (node instanceof AST) {
                symbol = this.getSymbolOfTemplateExpression(node);
            }
            this.symbolCache.set(node, symbol);
            return symbol;
        }
        getSymbolOfAstTemplate(template) {
            const directives = this.getDirectivesOfNode(template);
            return { kind: SymbolKind.Template, directives, templateNode: template };
        }
        getSymbolOfElement(element) {
            var _a;
            const elementSourceSpan = (_a = element.startSourceSpan) !== null && _a !== void 0 ? _a : element.sourceSpan;
            const node = findFirstMatchingNode(this.typeCheckBlock, { withSpan: elementSourceSpan, filter: ts$1.isVariableDeclaration });
            if (node === null) {
                return null;
            }
            const symbolFromDeclaration = this.getSymbolOfTsNode(node);
            if (symbolFromDeclaration === null || symbolFromDeclaration.tsSymbol === null) {
                return null;
            }
            const directives = this.getDirectivesOfNode(element);
            // All statements in the TCB are `Expression`s that optionally include more information.
            // An `ElementSymbol` uses the information returned for the variable declaration expression,
            // adds the directives for the element, and updates the `kind` to be `SymbolKind.Element`.
            return Object.assign(Object.assign({}, symbolFromDeclaration), { kind: SymbolKind.Element, directives, templateNode: element });
        }
        getDirectivesOfNode(element) {
            var _a;
            const elementSourceSpan = (_a = element.startSourceSpan) !== null && _a !== void 0 ? _a : element.sourceSpan;
            const tcbSourceFile = this.typeCheckBlock.getSourceFile();
            // directives could be either:
            // - var _t1: TestDir /*T:D*/ = (null!);
            // - var _t1 /*T:D*/ = _ctor1({});
            const isDirectiveDeclaration = (node) => (ts$1.isTypeNode(node) || ts$1.isIdentifier(node)) && ts$1.isVariableDeclaration(node.parent) &&
                hasExpressionIdentifier(tcbSourceFile, node, ExpressionIdentifier.DIRECTIVE);
            const nodes = findAllMatchingNodes(this.typeCheckBlock, { withSpan: elementSourceSpan, filter: isDirectiveDeclaration });
            return nodes
                .map(node => {
                var _a;
                const symbol = this.getSymbolOfTsNode(node.parent);
                if (symbol === null || !isSymbolWithValueDeclaration(symbol.tsSymbol) ||
                    !ts$1.isClassDeclaration(symbol.tsSymbol.valueDeclaration)) {
                    return null;
                }
                const meta = this.getDirectiveMeta(element, symbol.tsSymbol.valueDeclaration);
                if (meta === null) {
                    return null;
                }
                const ngModule = this.getDirectiveModule(symbol.tsSymbol.valueDeclaration);
                if (meta.selector === null) {
                    return null;
                }
                const isComponent = (_a = meta.isComponent) !== null && _a !== void 0 ? _a : null;
                const directiveSymbol = Object.assign(Object.assign({}, symbol), { tsSymbol: symbol.tsSymbol, selector: meta.selector, isComponent,
                    ngModule, kind: SymbolKind.Directive, isStructural: meta.isStructural });
                return directiveSymbol;
            })
                .filter((d) => d !== null);
        }
        getDirectiveMeta(host, directiveDeclaration) {
            var _a;
            let directives = this.templateData.boundTarget.getDirectivesOfNode(host);
            // `getDirectivesOfNode` will not return the directives intended for an element
            // on a microsyntax template, for example `<div *ngFor="let user of users;" dir>`,
            // the `dir` will be skipped, but it's needed in language service.
            const firstChild = host.children[0];
            if (firstChild instanceof Element) {
                const isMicrosyntaxTemplate = host instanceof Template &&
                    sourceSpanEqual(firstChild.sourceSpan, host.sourceSpan);
                if (isMicrosyntaxTemplate) {
                    const firstChildDirectives = this.templateData.boundTarget.getDirectivesOfNode(firstChild);
                    if (firstChildDirectives !== null && directives !== null) {
                        directives = directives.concat(firstChildDirectives);
                    }
                    else {
                        directives = directives !== null && directives !== void 0 ? directives : firstChildDirectives;
                    }
                }
            }
            if (directives === null) {
                return null;
            }
            return (_a = directives.find(m => m.ref.node === directiveDeclaration)) !== null && _a !== void 0 ? _a : null;
        }
        getDirectiveModule(declaration) {
            const scope = this.componentScopeReader.getScopeForComponent(declaration);
            if (scope === null) {
                return null;
            }
            return scope.ngModule;
        }
        getSymbolOfBoundEvent(eventBinding) {
            const consumer = this.templateData.boundTarget.getConsumerOfBinding(eventBinding);
            if (consumer === null) {
                return null;
            }
            // Outputs in the TCB look like one of the two:
            // * _t1["outputField"].subscribe(handler);
            // * _t1.addEventListener(handler);
            // Even with strict null checks disabled, we still produce the access as a separate statement
            // so that it can be found here.
            let expectedAccess;
            if (consumer instanceof Template || consumer instanceof Element) {
                expectedAccess = 'addEventListener';
            }
            else {
                const bindingPropertyNames = consumer.outputs.getByBindingPropertyName(eventBinding.name);
                if (bindingPropertyNames === null || bindingPropertyNames.length === 0) {
                    return null;
                }
                // Note that we only get the expectedAccess text from a single consumer of the binding. If
                // there are multiple consumers (not supported in the `boundTarget` API) and one of them has
                // an alias, it will not get matched here.
                expectedAccess = bindingPropertyNames[0].classPropertyName;
            }
            function filter(n) {
                if (!isAccessExpression(n)) {
                    return false;
                }
                if (ts$1.isPropertyAccessExpression(n)) {
                    return n.name.getText() === expectedAccess;
                }
                else {
                    return ts$1.isStringLiteral(n.argumentExpression) &&
                        n.argumentExpression.text === expectedAccess;
                }
            }
            const outputFieldAccesses = findAllMatchingNodes(this.typeCheckBlock, { withSpan: eventBinding.keySpan, filter });
            const bindings = [];
            for (const outputFieldAccess of outputFieldAccesses) {
                if (consumer instanceof Template || consumer instanceof Element) {
                    if (!ts$1.isPropertyAccessExpression(outputFieldAccess)) {
                        continue;
                    }
                    const addEventListener = outputFieldAccess.name;
                    const tsSymbol = this.getTypeChecker().getSymbolAtLocation(addEventListener);
                    const tsType = this.getTypeChecker().getTypeAtLocation(addEventListener);
                    const positionInShimFile = this.getShimPositionForNode(addEventListener);
                    const target = this.getSymbol(consumer);
                    if (target === null || tsSymbol === undefined) {
                        continue;
                    }
                    bindings.push({
                        kind: SymbolKind.Binding,
                        tsSymbol,
                        tsType,
                        target,
                        shimLocation: { shimPath: this.shimPath, positionInShimFile },
                    });
                }
                else {
                    if (!ts$1.isElementAccessExpression(outputFieldAccess)) {
                        continue;
                    }
                    const tsSymbol = this.getTypeChecker().getSymbolAtLocation(outputFieldAccess.argumentExpression);
                    if (tsSymbol === undefined) {
                        continue;
                    }
                    const target = this.getDirectiveSymbolForAccessExpression(outputFieldAccess, consumer);
                    if (target === null) {
                        continue;
                    }
                    const positionInShimFile = this.getShimPositionForNode(outputFieldAccess);
                    const tsType = this.getTypeChecker().getTypeAtLocation(outputFieldAccess);
                    bindings.push({
                        kind: SymbolKind.Binding,
                        tsSymbol,
                        tsType,
                        target,
                        shimLocation: { shimPath: this.shimPath, positionInShimFile },
                    });
                }
            }
            if (bindings.length === 0) {
                return null;
            }
            return { kind: SymbolKind.Output, bindings };
        }
        getSymbolOfInputBinding(binding) {
            const consumer = this.templateData.boundTarget.getConsumerOfBinding(binding);
            if (consumer === null) {
                return null;
            }
            if (consumer instanceof Element || consumer instanceof Template) {
                const host = this.getSymbol(consumer);
                return host !== null ? { kind: SymbolKind.DomBinding, host } : null;
            }
            const nodes = findAllMatchingNodes(this.typeCheckBlock, { withSpan: binding.sourceSpan, filter: isAssignment });
            const bindings = [];
            for (const node of nodes) {
                if (!isAccessExpression(node.left)) {
                    continue;
                }
                const symbolInfo = this.getSymbolOfTsNode(node.left);
                if (symbolInfo === null || symbolInfo.tsSymbol === null) {
                    continue;
                }
                const target = this.getDirectiveSymbolForAccessExpression(node.left, consumer);
                if (target === null) {
                    continue;
                }
                bindings.push(Object.assign(Object.assign({}, symbolInfo), { tsSymbol: symbolInfo.tsSymbol, kind: SymbolKind.Binding, target }));
            }
            if (bindings.length === 0) {
                return null;
            }
            return { kind: SymbolKind.Input, bindings };
        }
        getDirectiveSymbolForAccessExpression(node, { isComponent, selector, isStructural }) {
            var _a;
            // In either case, `_t1["index"]` or `_t1.index`, `node.expression` is _t1.
            // The retrieved symbol for _t1 will be the variable declaration.
            const tsSymbol = this.getTypeChecker().getSymbolAtLocation(node.expression);
            if ((tsSymbol === null || tsSymbol === void 0 ? void 0 : tsSymbol.declarations) === undefined || tsSymbol.declarations.length === 0 ||
                selector === null) {
                return null;
            }
            const [declaration] = tsSymbol.declarations;
            if (!ts$1.isVariableDeclaration(declaration) ||
                !hasExpressionIdentifier(
                // The expression identifier could be on the type (for regular directives) or the name
                // (for generic directives and the ctor op).
                declaration.getSourceFile(), (_a = declaration.type) !== null && _a !== void 0 ? _a : declaration.name, ExpressionIdentifier.DIRECTIVE)) {
                return null;
            }
            const symbol = this.getSymbolOfTsNode(declaration);
            if (symbol === null || !isSymbolWithValueDeclaration(symbol.tsSymbol) ||
                !ts$1.isClassDeclaration(symbol.tsSymbol.valueDeclaration)) {
                return null;
            }
            const ngModule = this.getDirectiveModule(symbol.tsSymbol.valueDeclaration);
            return {
                kind: SymbolKind.Directive,
                tsSymbol: symbol.tsSymbol,
                tsType: symbol.tsType,
                shimLocation: symbol.shimLocation,
                isComponent,
                isStructural,
                selector,
                ngModule,
            };
        }
        getSymbolOfVariable(variable) {
            const node = findFirstMatchingNode(this.typeCheckBlock, { withSpan: variable.sourceSpan, filter: ts$1.isVariableDeclaration });
            if (node === null || node.initializer === undefined) {
                return null;
            }
            const expressionSymbol = this.getSymbolOfTsNode(node.initializer);
            if (expressionSymbol === null) {
                return null;
            }
            return {
                tsType: expressionSymbol.tsType,
                tsSymbol: expressionSymbol.tsSymbol,
                initializerLocation: expressionSymbol.shimLocation,
                kind: SymbolKind.Variable,
                declaration: variable,
                localVarLocation: {
                    shimPath: this.shimPath,
                    positionInShimFile: this.getShimPositionForNode(node.name),
                }
            };
        }
        getSymbolOfReference(ref) {
            const target = this.templateData.boundTarget.getReferenceTarget(ref);
            // Find the node for the reference declaration, i.e. `var _t2 = _t1;`
            let node = findFirstMatchingNode(this.typeCheckBlock, { withSpan: ref.sourceSpan, filter: ts$1.isVariableDeclaration });
            if (node === null || target === null || node.initializer === undefined) {
                return null;
            }
            // Get the original declaration for the references variable, with the exception of template refs
            // which are of the form var _t3 = (_t2 as any as i2.TemplateRef<any>)
            // TODO(atscott): Consider adding an `ExpressionIdentifier` to tag variable declaration
            // initializers as invalid for symbol retrieval.
            const originalDeclaration = ts$1.isParenthesizedExpression(node.initializer) &&
                ts$1.isAsExpression(node.initializer.expression) ?
                this.getTypeChecker().getSymbolAtLocation(node.name) :
                this.getTypeChecker().getSymbolAtLocation(node.initializer);
            if (originalDeclaration === undefined || originalDeclaration.valueDeclaration === undefined) {
                return null;
            }
            const symbol = this.getSymbolOfTsNode(originalDeclaration.valueDeclaration);
            if (symbol === null || symbol.tsSymbol === null) {
                return null;
            }
            const referenceVarShimLocation = {
                shimPath: this.shimPath,
                positionInShimFile: this.getShimPositionForNode(node),
            };
            if (target instanceof Template || target instanceof Element) {
                return {
                    kind: SymbolKind.Reference,
                    tsSymbol: symbol.tsSymbol,
                    tsType: symbol.tsType,
                    target,
                    declaration: ref,
                    targetLocation: symbol.shimLocation,
                    referenceVarLocation: referenceVarShimLocation,
                };
            }
            else {
                if (!ts$1.isClassDeclaration(target.directive.ref.node)) {
                    return null;
                }
                return {
                    kind: SymbolKind.Reference,
                    tsSymbol: symbol.tsSymbol,
                    tsType: symbol.tsType,
                    declaration: ref,
                    target: target.directive.ref.node,
                    targetLocation: symbol.shimLocation,
                    referenceVarLocation: referenceVarShimLocation,
                };
            }
        }
        getSymbolOfPipe(expression) {
            const methodAccess = findFirstMatchingNode(this.typeCheckBlock, { withSpan: expression.nameSpan, filter: ts$1.isPropertyAccessExpression });
            if (methodAccess === null) {
                return null;
            }
            const pipeVariableNode = methodAccess.expression;
            const pipeDeclaration = this.getTypeChecker().getSymbolAtLocation(pipeVariableNode);
            if (pipeDeclaration === undefined || pipeDeclaration.valueDeclaration === undefined) {
                return null;
            }
            const pipeInstance = this.getSymbolOfTsNode(pipeDeclaration.valueDeclaration);
            // The instance should never be null, nor should the symbol lack a value declaration. This
            // is because the node used to look for the `pipeInstance` symbol info is a value
            // declaration of another symbol (i.e. the `pipeDeclaration` symbol).
            if (pipeInstance === null || !isSymbolWithValueDeclaration(pipeInstance.tsSymbol)) {
                return null;
            }
            const symbolInfo = this.getSymbolOfTsNode(methodAccess);
            if (symbolInfo === null) {
                return null;
            }
            return Object.assign(Object.assign({ kind: SymbolKind.Pipe }, symbolInfo), { classSymbol: Object.assign(Object.assign({}, pipeInstance), { tsSymbol: pipeInstance.tsSymbol }) });
        }
        getSymbolOfTemplateExpression(expression) {
            if (expression instanceof ASTWithSource) {
                expression = expression.ast;
            }
            const expressionTarget = this.templateData.boundTarget.getExpressionTarget(expression);
            if (expressionTarget !== null) {
                return this.getSymbol(expressionTarget);
            }
            // The `name` part of a `PropertyWrite` and `MethodCall` does not have its own
            // AST so there is no way to retrieve a `Symbol` for just the `name` via a specific node.
            const withSpan = (expression instanceof PropertyWrite || expression instanceof MethodCall) ?
                expression.nameSpan :
                expression.sourceSpan;
            let node = null;
            // Property reads in templates usually map to a `PropertyAccessExpression`
            // (e.g. `ctx.foo`) so try looking for one first.
            if (expression instanceof PropertyRead) {
                node = findFirstMatchingNode(this.typeCheckBlock, { withSpan, filter: ts$1.isPropertyAccessExpression });
            }
            // Otherwise fall back to searching for any AST node.
            if (node === null) {
                node = findFirstMatchingNode(this.typeCheckBlock, { withSpan, filter: anyNodeFilter });
            }
            if (node === null) {
                return null;
            }
            while (ts$1.isParenthesizedExpression(node)) {
                node = node.expression;
            }
            // - If we have safe property read ("a?.b") we want to get the Symbol for b, the `whenTrue`
            // expression.
            // - If our expression is a pipe binding ("a | test:b:c"), we want the Symbol for the
            // `transform` on the pipe.
            // - Otherwise, we retrieve the symbol for the node itself with no special considerations
            if ((expression instanceof SafePropertyRead || expression instanceof SafeMethodCall) &&
                ts$1.isConditionalExpression(node)) {
                const whenTrueSymbol = (expression instanceof SafeMethodCall && ts$1.isCallExpression(node.whenTrue)) ?
                    this.getSymbolOfTsNode(node.whenTrue.expression) :
                    this.getSymbolOfTsNode(node.whenTrue);
                if (whenTrueSymbol === null) {
                    return null;
                }
                return Object.assign(Object.assign({}, whenTrueSymbol), { kind: SymbolKind.Expression, 
                    // Rather than using the type of only the `whenTrue` part of the expression, we should
                    // still get the type of the whole conditional expression to include `|undefined`.
                    tsType: this.getTypeChecker().getTypeAtLocation(node) });
            }
            else {
                const symbolInfo = this.getSymbolOfTsNode(node);
                return symbolInfo === null ? null : Object.assign(Object.assign({}, symbolInfo), { kind: SymbolKind.Expression });
            }
        }
        getSymbolOfTsNode(node) {
            var _a;
            while (ts$1.isParenthesizedExpression(node)) {
                node = node.expression;
            }
            let tsSymbol;
            if (ts$1.isPropertyAccessExpression(node)) {
                tsSymbol = this.getTypeChecker().getSymbolAtLocation(node.name);
            }
            else if (ts$1.isElementAccessExpression(node)) {
                tsSymbol = this.getTypeChecker().getSymbolAtLocation(node.argumentExpression);
            }
            else {
                tsSymbol = this.getTypeChecker().getSymbolAtLocation(node);
            }
            const positionInShimFile = this.getShimPositionForNode(node);
            const type = this.getTypeChecker().getTypeAtLocation(node);
            return {
                // If we could not find a symbol, fall back to the symbol on the type for the node.
                // Some nodes won't have a "symbol at location" but will have a symbol for the type.
                // Examples of this would be literals and `document.createElement('div')`.
                tsSymbol: (_a = tsSymbol !== null && tsSymbol !== void 0 ? tsSymbol : type.symbol) !== null && _a !== void 0 ? _a : null,
                tsType: type,
                shimLocation: { shimPath: this.shimPath, positionInShimFile },
            };
        }
        getShimPositionForNode(node) {
            if (ts$1.isTypeReferenceNode(node)) {
                return this.getShimPositionForNode(node.typeName);
            }
            else if (ts$1.isQualifiedName(node)) {
                return node.right.getStart();
            }
            else if (ts$1.isPropertyAccessExpression(node)) {
                return node.name.getStart();
            }
            else if (ts$1.isElementAccessExpression(node)) {
                return node.argumentExpression.getStart();
            }
            else {
                return node.getStart();
            }
        }
    }
    /** Filter predicate function that matches any AST node. */
    function anyNodeFilter(n) {
        return true;
    }
    function sourceSpanEqual(a, b) {
        return a.start.offset === b.start.offset && a.end.offset === b.end.offset;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const REGISTRY$1 = new DomElementSchemaRegistry();
    /**
     * Primary template type-checking engine, which performs type-checking using a
     * `TypeCheckingProgramStrategy` for type-checking program maintenance, and the
     * `ProgramTypeCheckAdapter` for generation of template type-checking code.
     */
    class TemplateTypeCheckerImpl {
        constructor(originalProgram, programDriver, typeCheckAdapter, config, refEmitter, reflector, compilerHost, priorBuild, componentScopeReader, typeCheckScopeRegistry, perf) {
            this.originalProgram = originalProgram;
            this.programDriver = programDriver;
            this.typeCheckAdapter = typeCheckAdapter;
            this.config = config;
            this.refEmitter = refEmitter;
            this.reflector = reflector;
            this.compilerHost = compilerHost;
            this.priorBuild = priorBuild;
            this.componentScopeReader = componentScopeReader;
            this.typeCheckScopeRegistry = typeCheckScopeRegistry;
            this.perf = perf;
            this.state = new Map();
            /**
             * Stores the `CompletionEngine` which powers autocompletion for each component class.
             *
             * Must be invalidated whenever the component's template or the `ts.Program` changes. Invalidation
             * on template changes is performed within this `TemplateTypeCheckerImpl` instance. When the
             * `ts.Program` changes, the `TemplateTypeCheckerImpl` as a whole is destroyed and replaced.
             */
            this.completionCache = new Map();
            /**
             * Stores the `SymbolBuilder` which creates symbols for each component class.
             *
             * Must be invalidated whenever the component's template or the `ts.Program` changes. Invalidation
             * on template changes is performed within this `TemplateTypeCheckerImpl` instance. When the
             * `ts.Program` changes, the `TemplateTypeCheckerImpl` as a whole is destroyed and replaced.
             */
            this.symbolBuilderCache = new Map();
            /**
             * Stores directives and pipes that are in scope for each component.
             *
             * Unlike other caches, the scope of a component is not affected by its template. It will be
             * destroyed when the `ts.Program` changes and the `TemplateTypeCheckerImpl` as a whole is
             * destroyed and replaced.
             */
            this.scopeCache = new Map();
            /**
             * Stores potential element tags for each component (a union of DOM tags as well as directive
             * tags).
             *
             * Unlike other caches, the scope of a component is not affected by its template. It will be
             * destroyed when the `ts.Program` changes and the `TemplateTypeCheckerImpl` as a whole is
             * destroyed and replaced.
             */
            this.elementTagCache = new Map();
            this.isComplete = false;
        }
        getTemplate(component) {
            const { data } = this.getLatestComponentState(component);
            if (data === null) {
                return null;
            }
            return data.template;
        }
        getLatestComponentState(component) {
            this.ensureShimForComponent(component);
            const sf = component.getSourceFile();
            const sfPath = absoluteFromSourceFile(sf);
            const shimPath = TypeCheckShimGenerator.shimFor(sfPath);
            const fileRecord = this.getFileData(sfPath);
            if (!fileRecord.shimData.has(shimPath)) {
                return { data: null, tcb: null, shimPath };
            }
            const templateId = fileRecord.sourceManager.getTemplateId(component);
            const shimRecord = fileRecord.shimData.get(shimPath);
            const id = fileRecord.sourceManager.getTemplateId(component);
            const program = this.programDriver.getProgram();
            const shimSf = getSourceFileOrNull(program, shimPath);
            if (shimSf === null || !fileRecord.shimData.has(shimPath)) {
                throw new Error(`Error: no shim file in program: ${shimPath}`);
            }
            let tcb = findTypeCheckBlock(shimSf, id, /*isDiagnosticsRequest*/ false);
            if (tcb === null) {
                // Try for an inline block.
                const inlineSf = getSourceFileOrError(program, sfPath);
                tcb = findTypeCheckBlock(inlineSf, id, /*isDiagnosticsRequest*/ false);
            }
            let data = null;
            if (shimRecord.templates.has(templateId)) {
                data = shimRecord.templates.get(templateId);
            }
            return { data, tcb, shimPath };
        }
        isTrackedTypeCheckFile(filePath) {
            return this.getFileAndShimRecordsForPath(filePath) !== null;
        }
        getFileAndShimRecordsForPath(shimPath) {
            for (const fileRecord of this.state.values()) {
                if (fileRecord.shimData.has(shimPath)) {
                    return { fileRecord, shimRecord: fileRecord.shimData.get(shimPath) };
                }
            }
            return null;
        }
        getTemplateMappingAtShimLocation({ shimPath, positionInShimFile }) {
            const records = this.getFileAndShimRecordsForPath(absoluteFrom(shimPath));
            if (records === null) {
                return null;
            }
            const { fileRecord } = records;
            const shimSf = this.programDriver.getProgram().getSourceFile(absoluteFrom(shimPath));
            if (shimSf === undefined) {
                return null;
            }
            return getTemplateMapping(shimSf, positionInShimFile, fileRecord.sourceManager, /*isDiagnosticsRequest*/ false);
        }
        generateAllTypeCheckBlocks() {
            this.ensureAllShimsForAllFiles();
        }
        /**
         * Retrieve type-checking and template parse diagnostics from the given `ts.SourceFile` using the
         * most recent type-checking program.
         */
        getDiagnosticsForFile(sf, optimizeFor) {
            switch (optimizeFor) {
                case OptimizeFor.WholeProgram:
                    this.ensureAllShimsForAllFiles();
                    break;
                case OptimizeFor.SingleFile:
                    this.ensureAllShimsForOneFile(sf);
                    break;
            }
            return this.perf.inPhase(PerfPhase.TtcDiagnostics, () => {
                const sfPath = absoluteFromSourceFile(sf);
                const fileRecord = this.state.get(sfPath);
                const typeCheckProgram = this.programDriver.getProgram();
                const diagnostics = [];
                if (fileRecord.hasInlines) {
                    const inlineSf = getSourceFileOrError(typeCheckProgram, sfPath);
                    diagnostics.push(...typeCheckProgram.getSemanticDiagnostics(inlineSf).map(diag => convertDiagnostic(diag, fileRecord.sourceManager)));
                }
                for (const [shimPath, shimRecord] of fileRecord.shimData) {
                    const shimSf = getSourceFileOrError(typeCheckProgram, shimPath);
                    diagnostics.push(...typeCheckProgram.getSemanticDiagnostics(shimSf).map(diag => convertDiagnostic(diag, fileRecord.sourceManager)));
                    diagnostics.push(...shimRecord.genesisDiagnostics);
                    for (const templateData of shimRecord.templates.values()) {
                        diagnostics.push(...templateData.templateDiagnostics);
                    }
                }
                return diagnostics.filter((diag) => diag !== null);
            });
        }
        getDiagnosticsForComponent(component) {
            this.ensureShimForComponent(component);
            return this.perf.inPhase(PerfPhase.TtcDiagnostics, () => {
                const sf = component.getSourceFile();
                const sfPath = absoluteFromSourceFile(sf);
                const shimPath = TypeCheckShimGenerator.shimFor(sfPath);
                const fileRecord = this.getFileData(sfPath);
                if (!fileRecord.shimData.has(shimPath)) {
                    return [];
                }
                const templateId = fileRecord.sourceManager.getTemplateId(component);
                const shimRecord = fileRecord.shimData.get(shimPath);
                const typeCheckProgram = this.programDriver.getProgram();
                const diagnostics = [];
                if (shimRecord.hasInlines) {
                    const inlineSf = getSourceFileOrError(typeCheckProgram, sfPath);
                    diagnostics.push(...typeCheckProgram.getSemanticDiagnostics(inlineSf).map(diag => convertDiagnostic(diag, fileRecord.sourceManager)));
                }
                const shimSf = getSourceFileOrError(typeCheckProgram, shimPath);
                diagnostics.push(...typeCheckProgram.getSemanticDiagnostics(shimSf).map(diag => convertDiagnostic(diag, fileRecord.sourceManager)));
                diagnostics.push(...shimRecord.genesisDiagnostics);
                for (const templateData of shimRecord.templates.values()) {
                    diagnostics.push(...templateData.templateDiagnostics);
                }
                return diagnostics.filter((diag) => diag !== null && diag.templateId === templateId);
            });
        }
        getTypeCheckBlock(component) {
            return this.getLatestComponentState(component).tcb;
        }
        getGlobalCompletions(context, component, node) {
            const engine = this.getOrCreateCompletionEngine(component);
            if (engine === null) {
                return null;
            }
            return this.perf.inPhase(PerfPhase.TtcAutocompletion, () => engine.getGlobalCompletions(context, node));
        }
        getExpressionCompletionLocation(ast, component) {
            const engine = this.getOrCreateCompletionEngine(component);
            if (engine === null) {
                return null;
            }
            return this.perf.inPhase(PerfPhase.TtcAutocompletion, () => engine.getExpressionCompletionLocation(ast));
        }
        getLiteralCompletionLocation(node, component) {
            const engine = this.getOrCreateCompletionEngine(component);
            if (engine === null) {
                return null;
            }
            return this.perf.inPhase(PerfPhase.TtcAutocompletion, () => engine.getLiteralCompletionLocation(node));
        }
        invalidateClass(clazz) {
            this.completionCache.delete(clazz);
            this.symbolBuilderCache.delete(clazz);
            this.scopeCache.delete(clazz);
            this.elementTagCache.delete(clazz);
            const sf = clazz.getSourceFile();
            const sfPath = absoluteFromSourceFile(sf);
            const shimPath = TypeCheckShimGenerator.shimFor(sfPath);
            const fileData = this.getFileData(sfPath);
            const templateId = fileData.sourceManager.getTemplateId(clazz);
            fileData.shimData.delete(shimPath);
            fileData.isComplete = false;
            this.isComplete = false;
        }
        makeTemplateDiagnostic(clazz, sourceSpan, category, errorCode, message, relatedInformation) {
            const sfPath = absoluteFromSourceFile(clazz.getSourceFile());
            const fileRecord = this.state.get(sfPath);
            const templateId = fileRecord.sourceManager.getTemplateId(clazz);
            const mapping = fileRecord.sourceManager.getSourceMapping(templateId);
            return Object.assign(Object.assign({}, makeTemplateDiagnostic(templateId, mapping, sourceSpan, category, ngErrorCode(errorCode), message, relatedInformation)), { __ngCode: errorCode });
        }
        getOrCreateCompletionEngine(component) {
            if (this.completionCache.has(component)) {
                return this.completionCache.get(component);
            }
            const { tcb, data, shimPath } = this.getLatestComponentState(component);
            if (tcb === null || data === null) {
                return null;
            }
            const engine = new CompletionEngine(tcb, data, shimPath);
            this.completionCache.set(component, engine);
            return engine;
        }
        maybeAdoptPriorResultsForFile(sf) {
            const sfPath = absoluteFromSourceFile(sf);
            if (this.state.has(sfPath)) {
                const existingResults = this.state.get(sfPath);
                if (existingResults.isComplete) {
                    // All data for this file has already been generated, so no need to adopt anything.
                    return;
                }
            }
            const previousResults = this.priorBuild.priorTypeCheckingResultsFor(sf);
            if (previousResults === null || !previousResults.isComplete) {
                return;
            }
            this.perf.eventCount(PerfEvent.ReuseTypeCheckFile);
            this.state.set(sfPath, previousResults);
        }
        ensureAllShimsForAllFiles() {
            if (this.isComplete) {
                return;
            }
            this.perf.inPhase(PerfPhase.TcbGeneration, () => {
                const host = new WholeProgramTypeCheckingHost(this);
                const ctx = this.newContext(host);
                for (const sf of this.originalProgram.getSourceFiles()) {
                    if (sf.isDeclarationFile || isShim(sf)) {
                        continue;
                    }
                    this.maybeAdoptPriorResultsForFile(sf);
                    const sfPath = absoluteFromSourceFile(sf);
                    const fileData = this.getFileData(sfPath);
                    if (fileData.isComplete) {
                        continue;
                    }
                    this.typeCheckAdapter.typeCheck(sf, ctx);
                    fileData.isComplete = true;
                }
                this.updateFromContext(ctx);
                this.isComplete = true;
            });
        }
        ensureAllShimsForOneFile(sf) {
            this.perf.inPhase(PerfPhase.TcbGeneration, () => {
                this.maybeAdoptPriorResultsForFile(sf);
                const sfPath = absoluteFromSourceFile(sf);
                const fileData = this.getFileData(sfPath);
                if (fileData.isComplete) {
                    // All data for this file is present and accounted for already.
                    return;
                }
                const host = new SingleFileTypeCheckingHost(sfPath, fileData, this);
                const ctx = this.newContext(host);
                this.typeCheckAdapter.typeCheck(sf, ctx);
                fileData.isComplete = true;
                this.updateFromContext(ctx);
            });
        }
        ensureShimForComponent(component) {
            const sf = component.getSourceFile();
            const sfPath = absoluteFromSourceFile(sf);
            const shimPath = TypeCheckShimGenerator.shimFor(sfPath);
            this.maybeAdoptPriorResultsForFile(sf);
            const fileData = this.getFileData(sfPath);
            if (fileData.shimData.has(shimPath)) {
                // All data for this component is available.
                return;
            }
            const host = new SingleShimTypeCheckingHost(sfPath, fileData, this, shimPath);
            const ctx = this.newContext(host);
            this.typeCheckAdapter.typeCheck(sf, ctx);
            this.updateFromContext(ctx);
        }
        newContext(host) {
            const inlining = this.programDriver.supportsInlineOperations ? InliningMode.InlineOps : InliningMode.Error;
            return new TypeCheckContextImpl(this.config, this.compilerHost, this.refEmitter, this.reflector, host, inlining, this.perf);
        }
        /**
         * Remove any shim data that depends on inline operations applied to the type-checking program.
         *
         * This can be useful if new inlines need to be applied, and it's not possible to guarantee that
         * they won't overwrite or corrupt existing inlines that are used by such shims.
         */
        clearAllShimDataUsingInlines() {
            for (const fileData of this.state.values()) {
                if (!fileData.hasInlines) {
                    continue;
                }
                for (const [shimFile, shimData] of fileData.shimData.entries()) {
                    if (shimData.hasInlines) {
                        fileData.shimData.delete(shimFile);
                    }
                }
                fileData.hasInlines = false;
                fileData.isComplete = false;
                this.isComplete = false;
            }
        }
        updateFromContext(ctx) {
            const updates = ctx.finalize();
            return this.perf.inPhase(PerfPhase.TcbUpdateProgram, () => {
                if (updates.size > 0) {
                    this.perf.eventCount(PerfEvent.UpdateTypeCheckProgram);
                }
                this.programDriver.updateFiles(updates, UpdateMode.Incremental);
                this.priorBuild.recordSuccessfulTypeCheck(this.state);
                this.perf.memory(PerfCheckpoint.TtcUpdateProgram);
            });
        }
        getFileData(path) {
            if (!this.state.has(path)) {
                this.state.set(path, {
                    hasInlines: false,
                    sourceManager: new TemplateSourceManager(),
                    isComplete: false,
                    shimData: new Map(),
                });
            }
            return this.state.get(path);
        }
        getSymbolOfNode(node, component) {
            const builder = this.getOrCreateSymbolBuilder(component);
            if (builder === null) {
                return null;
            }
            return this.perf.inPhase(PerfPhase.TtcSymbol, () => builder.getSymbol(node));
        }
        getOrCreateSymbolBuilder(component) {
            if (this.symbolBuilderCache.has(component)) {
                return this.symbolBuilderCache.get(component);
            }
            const { tcb, data, shimPath } = this.getLatestComponentState(component);
            if (tcb === null || data === null) {
                return null;
            }
            const builder = new SymbolBuilder(shimPath, tcb, data, this.componentScopeReader, () => this.programDriver.getProgram().getTypeChecker());
            this.symbolBuilderCache.set(component, builder);
            return builder;
        }
        getDirectivesInScope(component) {
            const data = this.getScopeData(component);
            if (data === null) {
                return null;
            }
            return data.directives;
        }
        getPipesInScope(component) {
            const data = this.getScopeData(component);
            if (data === null) {
                return null;
            }
            return data.pipes;
        }
        getDirectiveMetadata(dir) {
            if (!isNamedClassDeclaration(dir)) {
                return null;
            }
            return this.typeCheckScopeRegistry.getTypeCheckDirectiveMetadata(new Reference$1(dir));
        }
        getPotentialElementTags(component) {
            if (this.elementTagCache.has(component)) {
                return this.elementTagCache.get(component);
            }
            const tagMap = new Map();
            for (const tag of REGISTRY$1.allKnownElementNames()) {
                tagMap.set(tag, null);
            }
            const scope = this.getScopeData(component);
            if (scope !== null) {
                for (const directive of scope.directives) {
                    for (const selector of CssSelector.parse(directive.selector)) {
                        if (selector.element === null || tagMap.has(selector.element)) {
                            // Skip this directive if it doesn't match an element tag, or if another directive has
                            // already been included with the same element name.
                            continue;
                        }
                        tagMap.set(selector.element, directive);
                    }
                }
            }
            this.elementTagCache.set(component, tagMap);
            return tagMap;
        }
        getPotentialDomBindings(tagName) {
            const attributes = REGISTRY$1.allKnownAttributesOfElement(tagName);
            return attributes.map(attribute => ({
                attribute,
                property: REGISTRY$1.getMappedPropName(attribute),
            }));
        }
        getScopeData(component) {
            if (this.scopeCache.has(component)) {
                return this.scopeCache.get(component);
            }
            if (!isNamedClassDeclaration(component)) {
                throw new Error(`AssertionError: components must have names`);
            }
            const scope = this.componentScopeReader.getScopeForComponent(component);
            if (scope === null) {
                return null;
            }
            const data = {
                directives: [],
                pipes: [],
                isPoisoned: scope.compilation.isPoisoned,
            };
            const typeChecker = this.programDriver.getProgram().getTypeChecker();
            for (const dir of scope.compilation.directives) {
                if (dir.selector === null) {
                    // Skip this directive, it can't be added to a template anyway.
                    continue;
                }
                const tsSymbol = typeChecker.getSymbolAtLocation(dir.ref.node.name);
                if (!isSymbolWithValueDeclaration(tsSymbol)) {
                    continue;
                }
                let ngModule = null;
                const moduleScopeOfDir = this.componentScopeReader.getScopeForComponent(dir.ref.node);
                if (moduleScopeOfDir !== null) {
                    ngModule = moduleScopeOfDir.ngModule;
                }
                data.directives.push({
                    isComponent: dir.isComponent,
                    isStructural: dir.isStructural,
                    selector: dir.selector,
                    tsSymbol,
                    ngModule,
                });
            }
            for (const pipe of scope.compilation.pipes) {
                const tsSymbol = typeChecker.getSymbolAtLocation(pipe.ref.node.name);
                if (tsSymbol === undefined) {
                    continue;
                }
                data.pipes.push({
                    name: pipe.name,
                    tsSymbol,
                });
            }
            this.scopeCache.set(component, data);
            return data;
        }
    }
    function convertDiagnostic(diag, sourceResolver) {
        if (!shouldReportDiagnostic(diag)) {
            return null;
        }
        return translateDiagnostic(diag, sourceResolver);
    }
    /**
     * Drives a `TypeCheckContext` to generate type-checking code for every component in the program.
     */
    class WholeProgramTypeCheckingHost {
        constructor(impl) {
            this.impl = impl;
        }
        getSourceManager(sfPath) {
            return this.impl.getFileData(sfPath).sourceManager;
        }
        shouldCheckComponent(node) {
            const sfPath = absoluteFromSourceFile(node.getSourceFile());
            const shimPath = TypeCheckShimGenerator.shimFor(sfPath);
            const fileData = this.impl.getFileData(sfPath);
            // The component needs to be checked unless the shim which would contain it already exists.
            return !fileData.shimData.has(shimPath);
        }
        recordShimData(sfPath, data) {
            const fileData = this.impl.getFileData(sfPath);
            fileData.shimData.set(data.path, data);
            if (data.hasInlines) {
                fileData.hasInlines = true;
            }
        }
        recordComplete(sfPath) {
            this.impl.getFileData(sfPath).isComplete = true;
        }
    }
    /**
     * Drives a `TypeCheckContext` to generate type-checking code efficiently for a single input file.
     */
    class SingleFileTypeCheckingHost {
        constructor(sfPath, fileData, impl) {
            this.sfPath = sfPath;
            this.fileData = fileData;
            this.impl = impl;
            this.seenInlines = false;
        }
        assertPath(sfPath) {
            if (this.sfPath !== sfPath) {
                throw new Error(`AssertionError: querying TypeCheckingHost outside of assigned file`);
            }
        }
        getSourceManager(sfPath) {
            this.assertPath(sfPath);
            return this.fileData.sourceManager;
        }
        shouldCheckComponent(node) {
            if (this.sfPath !== absoluteFromSourceFile(node.getSourceFile())) {
                return false;
            }
            const shimPath = TypeCheckShimGenerator.shimFor(this.sfPath);
            // Only need to generate a TCB for the class if no shim exists for it currently.
            return !this.fileData.shimData.has(shimPath);
        }
        recordShimData(sfPath, data) {
            this.assertPath(sfPath);
            // Previous type-checking state may have required the use of inlines (assuming they were
            // supported). If the current operation also requires inlines, this presents a problem:
            // generating new inlines may invalidate any old inlines that old state depends on.
            //
            // Rather than resolve this issue by tracking specific dependencies on inlines, if the new state
            // relies on inlines, any old state that relied on them is simply cleared. This happens when the
            // first new state that uses inlines is encountered.
            if (data.hasInlines && !this.seenInlines) {
                this.impl.clearAllShimDataUsingInlines();
                this.seenInlines = true;
            }
            this.fileData.shimData.set(data.path, data);
            if (data.hasInlines) {
                this.fileData.hasInlines = true;
            }
        }
        recordComplete(sfPath) {
            this.assertPath(sfPath);
            this.fileData.isComplete = true;
        }
    }
    /**
     * Drives a `TypeCheckContext` to generate type-checking code efficiently for only those components
     * which map to a single shim of a single input file.
     */
    class SingleShimTypeCheckingHost extends SingleFileTypeCheckingHost {
        constructor(sfPath, fileData, impl, shimPath) {
            super(sfPath, fileData, impl);
            this.shimPath = shimPath;
        }
        shouldCheckNode(node) {
            if (this.sfPath !== absoluteFromSourceFile(node.getSourceFile())) {
                return false;
            }
            // Only generate a TCB for the component if it maps to the requested shim file.
            const shimPath = TypeCheckShimGenerator.shimFor(this.sfPath);
            if (shimPath !== this.shimPath) {
                return false;
            }
            // Only need to generate a TCB for the class if no shim exists for it currently.
            return !this.fileData.shimData.has(shimPath);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class ExtendedTemplateCheckerImpl {
        constructor(templateTypeChecker, typeChecker, templateChecks) {
            this.templateChecks = templateChecks;
            this.ctx = { templateTypeChecker: templateTypeChecker, typeChecker: typeChecker };
        }
        getDiagnosticsForComponent(component) {
            const template = this.ctx.templateTypeChecker.getTemplate(component);
            // Skip checks if component has no template. This can happen if the user writes a
            // `@Component()` but doesn't add the template, could happen in the language service
            // when users are in the middle of typing code.
            if (template === null) {
                return [];
            }
            const diagnostics = [];
            for (const check of this.templateChecks) {
                diagnostics.push(...check.run(this.ctx, component, template));
            }
            return diagnostics;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * This abstract class provides a base implementation for the run method.
     */
    class TemplateCheckWithVisitor {
        /**
         * Base implementation for run function, visits all nodes in template and calls
         * `visitNode()` for each one.
         */
        run(ctx, component, template) {
            const visitor = new TemplateVisitor$1(ctx, component, this);
            return visitor.getDiagnostics(template);
        }
    }
    /**
     * Visits all nodes in a template (TmplAstNode and AST) and calls `visitNode` for each one.
     */
    class TemplateVisitor$1 extends RecursiveAstVisitor {
        constructor(ctx, component, check) {
            super();
            this.ctx = ctx;
            this.component = component;
            this.check = check;
            this.diagnostics = [];
        }
        visit(node, context) {
            this.diagnostics.push(...this.check.visitNode(this.ctx, this.component, node));
            node.visit(this);
        }
        visitAllNodes(nodes) {
            for (const node of nodes) {
                this.visit(node);
            }
        }
        visitAst(ast) {
            if (ast instanceof ASTWithSource) {
                ast = ast.ast;
            }
            this.visit(ast);
        }
        visitElement(element) {
            this.visitAllNodes(element.attributes);
            this.visitAllNodes(element.inputs);
            this.visitAllNodes(element.outputs);
            this.visitAllNodes(element.references);
            this.visitAllNodes(element.children);
        }
        visitTemplate(template) {
            this.visitAllNodes(template.attributes);
            if (template.tagName === 'ng-template') {
                // Only visit input/outputs/templateAttrs if this isn't an inline template node
                // generated for a structural directive (like `<div *ngIf></div>`). These nodes
                // would be visited when the underlying element of an inline template node is processed.
                this.visitAllNodes(template.inputs);
                this.visitAllNodes(template.outputs);
                this.visitAllNodes(template.templateAttrs);
            }
            this.visitAllNodes(template.variables);
            this.visitAllNodes(template.references);
            this.visitAllNodes(template.children);
        }
        visitContent(content) { }
        visitVariable(variable) { }
        visitReference(reference) { }
        visitTextAttribute(attribute) { }
        visitBoundAttribute(attribute) {
            this.visitAst(attribute.value);
        }
        visitBoundEvent(attribute) {
            this.visitAst(attribute.handler);
        }
        visitText(text) { }
        visitBoundText(text) {
            this.visitAst(text.value);
        }
        visitIcu(icu) { }
        getDiagnostics(template) {
            this.diagnostics = [];
            this.visitAllNodes(template);
            return this.diagnostics;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Ensures the two-way binding syntax is correct.
     * Parentheses should be inside the brackets "[()]".
     * Will return diagnostic information when "([])" is found.
     */
    class InvalidBananaInBoxCheck extends TemplateCheckWithVisitor {
        constructor() {
            super(...arguments);
            this.code = ErrorCode.INVALID_BANANA_IN_BOX;
        }
        visitNode(ctx, component, node) {
            if (!(node instanceof BoundEvent))
                return [];
            const name = node.name;
            if (!name.startsWith('[') || !name.endsWith(']'))
                return [];
            const boundSyntax = node.sourceSpan.toString();
            const expectedBoundSyntax = boundSyntax.replace(`(${name})`, `[(${name.slice(1, -1)})]`);
            const diagnostic = ctx.templateTypeChecker.makeTemplateDiagnostic(component, node.sourceSpan, ts$1.DiagnosticCategory.Warning, ErrorCode.INVALID_BANANA_IN_BOX, `In the two-way binding syntax the parentheses should be inside the brackets, ex. '${expectedBoundSyntax}'. 
        Find more at https://angular.io/guide/two-way-binding`);
            return [diagnostic];
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Ensures the left side of a nullish coalescing operation is nullable.
     * Returns diagnostics for the cases where the operator is useless.
     * This check should only be use if `strictNullChecks` is enabled,
     * otherwise it would produce inaccurate results.
     */
    class NullishCoalescingNotNullableCheck extends TemplateCheckWithVisitor {
        constructor() {
            super(...arguments);
            this.code = ErrorCode.NULLISH_COALESCING_NOT_NULLABLE;
        }
        visitNode(ctx, component, node) {
            if (!(node instanceof Binary) || node.operation !== '??')
                return [];
            const symbolLeft = ctx.templateTypeChecker.getSymbolOfNode(node.left, component);
            if (symbolLeft === null || symbolLeft.kind !== SymbolKind.Expression) {
                return [];
            }
            const typeLeft = symbolLeft.tsType;
            // If the left operand's type is different from its non-nullable self, then it must
            // contain a null or undefined so this nullish coalescing operator is useful. No diagnostic to
            // report.
            if (typeLeft.getNonNullableType() !== typeLeft)
                return [];
            const symbol = ctx.templateTypeChecker.getSymbolOfNode(node, component);
            if (symbol.kind !== SymbolKind.Expression) {
                return [];
            }
            const span = ctx.templateTypeChecker.getTemplateMappingAtShimLocation(symbol.shimLocation).span;
            const diagnostic = ctx.templateTypeChecker.makeTemplateDiagnostic(component, span, ts$1.DiagnosticCategory.Warning, ErrorCode.NULLISH_COALESCING_NOT_NULLABLE, `The left side of this nullish coalescing operation does not include 'null' or 'undefined' in its type, therefore the '??' operator can be safely removed.`);
            return [diagnostic];
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Discriminant type for a `CompilationTicket`.
     */
    var CompilationTicketKind;
    (function (CompilationTicketKind) {
        CompilationTicketKind[CompilationTicketKind["Fresh"] = 0] = "Fresh";
        CompilationTicketKind[CompilationTicketKind["IncrementalTypeScript"] = 1] = "IncrementalTypeScript";
        CompilationTicketKind[CompilationTicketKind["IncrementalResource"] = 2] = "IncrementalResource";
    })(CompilationTicketKind || (CompilationTicketKind = {}));
    /**
     * Create a `CompilationTicket` for a brand new compilation, using no prior state.
     */
    function freshCompilationTicket(tsProgram, options, incrementalBuildStrategy, programDriver, perfRecorder, enableTemplateTypeChecker, usePoisonedData) {
        return {
            kind: CompilationTicketKind.Fresh,
            tsProgram,
            options,
            incrementalBuildStrategy,
            programDriver,
            enableTemplateTypeChecker,
            usePoisonedData,
            perfRecorder: perfRecorder !== null && perfRecorder !== void 0 ? perfRecorder : ActivePerfRecorder.zeroedToNow(),
        };
    }
    /**
     * Create a `CompilationTicket` as efficiently as possible, based on a previous `NgCompiler`
     * instance and a new `ts.Program`.
     */
    function incrementalFromCompilerTicket(oldCompiler, newProgram, incrementalBuildStrategy, programDriver, modifiedResourceFiles, perfRecorder) {
        const oldProgram = oldCompiler.getCurrentProgram();
        const oldState = oldCompiler.incrementalStrategy.getIncrementalState(oldProgram);
        if (oldState === null) {
            // No incremental step is possible here, since no IncrementalDriver was found for the old
            // program.
            return freshCompilationTicket(newProgram, oldCompiler.options, incrementalBuildStrategy, programDriver, perfRecorder, oldCompiler.enableTemplateTypeChecker, oldCompiler.usePoisonedData);
        }
        if (perfRecorder === null) {
            perfRecorder = ActivePerfRecorder.zeroedToNow();
        }
        const incrementalCompilation = IncrementalCompilation.incremental(newProgram, versionMapFromProgram(newProgram, programDriver), oldProgram, oldState, modifiedResourceFiles, perfRecorder);
        return {
            kind: CompilationTicketKind.IncrementalTypeScript,
            enableTemplateTypeChecker: oldCompiler.enableTemplateTypeChecker,
            usePoisonedData: oldCompiler.usePoisonedData,
            options: oldCompiler.options,
            incrementalBuildStrategy,
            incrementalCompilation,
            programDriver,
            newProgram,
            perfRecorder,
        };
    }
    function resourceChangeTicket(compiler, modifiedResourceFiles) {
        return {
            kind: CompilationTicketKind.IncrementalResource,
            compiler,
            modifiedResourceFiles,
            perfRecorder: ActivePerfRecorder.zeroedToNow(),
        };
    }
    /**
     * The heart of the Angular Ivy compiler.
     *
     * The `NgCompiler` provides an API for performing Angular compilation within a custom TypeScript
     * compiler. Each instance of `NgCompiler` supports a single compilation, which might be
     * incremental.
     *
     * `NgCompiler` is lazy, and does not perform any of the work of the compilation until one of its
     * output methods (e.g. `getDiagnostics`) is called.
     *
     * See the README.md for more information.
     */
    class NgCompiler {
        constructor(adapter, options, inputProgram, programDriver, incrementalStrategy, incrementalCompilation, enableTemplateTypeChecker, usePoisonedData, livePerfRecorder) {
            this.adapter = adapter;
            this.options = options;
            this.inputProgram = inputProgram;
            this.programDriver = programDriver;
            this.incrementalStrategy = incrementalStrategy;
            this.incrementalCompilation = incrementalCompilation;
            this.enableTemplateTypeChecker = enableTemplateTypeChecker;
            this.usePoisonedData = usePoisonedData;
            this.livePerfRecorder = livePerfRecorder;
            /**
             * Lazily evaluated state of the compilation.
             *
             * This is created on demand by calling `ensureAnalyzed`.
             */
            this.compilation = null;
            /**
             * Any diagnostics related to the construction of the compilation.
             *
             * These are diagnostics which arose during setup of the host and/or program.
             */
            this.constructionDiagnostics = [];
            /**
             * Non-template diagnostics related to the program itself. Does not include template
             * diagnostics because the template type checker memoizes them itself.
             *
             * This is set by (and memoizes) `getNonTemplateDiagnostics`.
             */
            this.nonTemplateDiagnostics = null;
            /**
             * `NgCompiler` can be reused for multiple compilations (for resource-only changes), and each
             * new compilation uses a fresh `PerfRecorder`. Thus, classes created with a lifespan of the
             * `NgCompiler` use a `DelegatingPerfRecorder` so the `PerfRecorder` they write to can be updated
             * with each fresh compilation.
             */
            this.delegatingPerfRecorder = new DelegatingPerfRecorder(this.perfRecorder);
            if (this.options._extendedTemplateDiagnostics === true &&
                this.options.strictTemplates === false) {
                throw new Error('The \'_extendedTemplateDiagnostics\' option requires \'strictTemplates\' to also be enabled.');
            }
            this.constructionDiagnostics.push(...this.adapter.constructionDiagnostics);
            const incompatibleTypeCheckOptionsDiagnostic = verifyCompatibleTypeCheckOptions(this.options);
            if (incompatibleTypeCheckOptionsDiagnostic !== null) {
                this.constructionDiagnostics.push(incompatibleTypeCheckOptionsDiagnostic);
            }
            this.currentProgram = inputProgram;
            this.closureCompilerEnabled = !!this.options.annotateForClosureCompiler;
            this.entryPoint =
                adapter.entryPoint !== null ? getSourceFileOrNull(inputProgram, adapter.entryPoint) : null;
            const moduleResolutionCache = ts$1.createModuleResolutionCache(this.adapter.getCurrentDirectory(), 
            // doen't retain a reference to `this`, if other closures in the constructor here reference
            // `this` internally then a closure created here would retain them. This can cause major
            // memory leak issues since the `moduleResolutionCache` is a long-lived object and finds its
            // way into all kinds of places inside TS internal objects.
            this.adapter.getCanonicalFileName.bind(this.adapter));
            this.moduleResolver =
                new ModuleResolver(inputProgram, this.options, this.adapter, moduleResolutionCache);
            this.resourceManager = new AdapterResourceLoader(adapter, this.options);
            this.cycleAnalyzer = new CycleAnalyzer(new ImportGraph(inputProgram.getTypeChecker(), this.delegatingPerfRecorder));
            this.incrementalStrategy.setIncrementalState(this.incrementalCompilation.state, inputProgram);
            this.ignoreForDiagnostics =
                new Set(inputProgram.getSourceFiles().filter(sf => this.adapter.isShim(sf)));
            this.ignoreForEmit = this.adapter.ignoreForEmit;
            let dtsFileCount = 0;
            let nonDtsFileCount = 0;
            for (const sf of inputProgram.getSourceFiles()) {
                if (sf.isDeclarationFile) {
                    dtsFileCount++;
                }
                else {
                    nonDtsFileCount++;
                }
            }
            livePerfRecorder.eventCount(PerfEvent.InputDtsFile, dtsFileCount);
            livePerfRecorder.eventCount(PerfEvent.InputTsFile, nonDtsFileCount);
        }
        /**
         * Convert a `CompilationTicket` into an `NgCompiler` instance for the requested compilation.
         *
         * Depending on the nature of the compilation request, the `NgCompiler` instance may be reused
         * from a previous compilation and updated with any changes, it may be a new instance which
         * incrementally reuses state from a previous compilation, or it may represent a fresh
         * compilation entirely.
         */
        static fromTicket(ticket, adapter) {
            switch (ticket.kind) {
                case CompilationTicketKind.Fresh:
                    return new NgCompiler(adapter, ticket.options, ticket.tsProgram, ticket.programDriver, ticket.incrementalBuildStrategy, IncrementalCompilation.fresh(ticket.tsProgram, versionMapFromProgram(ticket.tsProgram, ticket.programDriver)), ticket.enableTemplateTypeChecker, ticket.usePoisonedData, ticket.perfRecorder);
                case CompilationTicketKind.IncrementalTypeScript:
                    return new NgCompiler(adapter, ticket.options, ticket.newProgram, ticket.programDriver, ticket.incrementalBuildStrategy, ticket.incrementalCompilation, ticket.enableTemplateTypeChecker, ticket.usePoisonedData, ticket.perfRecorder);
                case CompilationTicketKind.IncrementalResource:
                    const compiler = ticket.compiler;
                    compiler.updateWithChangedResources(ticket.modifiedResourceFiles, ticket.perfRecorder);
                    return compiler;
            }
        }
        get perfRecorder() {
            return this.livePerfRecorder;
        }
        /**
         * Exposes the `IncrementalCompilation` under an old property name that the CLI uses, avoiding a
         * chicken-and-egg problem with the rename to `incrementalCompilation`.
         *
         * TODO(alxhub): remove when the CLI uses the new name.
         */
        get incrementalDriver() {
            return this.incrementalCompilation;
        }
        updateWithChangedResources(changedResources, perfRecorder) {
            this.livePerfRecorder = perfRecorder;
            this.delegatingPerfRecorder.target = perfRecorder;
            perfRecorder.inPhase(PerfPhase.ResourceUpdate, () => {
                if (this.compilation === null) {
                    // Analysis hasn't happened yet, so no update is necessary - any changes to resources will
                    // be captured by the inital analysis pass itself.
                    return;
                }
                this.resourceManager.invalidate();
                const classesToUpdate = new Set();
                for (const resourceFile of changedResources) {
                    for (const templateClass of this.getComponentsWithTemplateFile(resourceFile)) {
                        classesToUpdate.add(templateClass);
                    }
                    for (const styleClass of this.getComponentsWithStyleFile(resourceFile)) {
                        classesToUpdate.add(styleClass);
                    }
                }
                for (const clazz of classesToUpdate) {
                    this.compilation.traitCompiler.updateResources(clazz);
                    if (!ts$1.isClassDeclaration(clazz)) {
                        continue;
                    }
                    this.compilation.templateTypeChecker.invalidateClass(clazz);
                }
            });
        }
        /**
         * Get the resource dependencies of a file.
         *
         * If the file is not part of the compilation, an empty array will be returned.
         */
        getResourceDependencies(file) {
            this.ensureAnalyzed();
            return this.incrementalCompilation.depGraph.getResourceDependencies(file);
        }
        /**
         * Get all Angular-related diagnostics for this compilation.
         */
        getDiagnostics() {
            const diagnostics = [];
            diagnostics.push(...this.getNonTemplateDiagnostics(), ...this.getTemplateDiagnostics());
            if (this.options._extendedTemplateDiagnostics) {
                diagnostics.push(...this.getExtendedTemplateDiagnostics());
            }
            return this.addMessageTextDetails(diagnostics);
        }
        /**
         * Get all Angular-related diagnostics for this compilation.
         *
         * If a `ts.SourceFile` is passed, only diagnostics related to that file are returned.
         */
        getDiagnosticsForFile(file, optimizeFor) {
            const diagnostics = [];
            diagnostics.push(...this.getNonTemplateDiagnostics().filter(diag => diag.file === file), ...this.getTemplateDiagnosticsForFile(file, optimizeFor));
            if (this.options._extendedTemplateDiagnostics) {
                diagnostics.push(...this.getExtendedTemplateDiagnostics(file));
            }
            return this.addMessageTextDetails(diagnostics);
        }
        /**
         * Get all `ts.Diagnostic`s currently available that pertain to the given component.
         */
        getDiagnosticsForComponent(component) {
            const compilation = this.ensureAnalyzed();
            const ttc = compilation.templateTypeChecker;
            const diagnostics = [];
            diagnostics.push(...ttc.getDiagnosticsForComponent(component));
            if (this.options._extendedTemplateDiagnostics) {
                const extendedTemplateChecker = compilation.extendedTemplateChecker;
                diagnostics.push(...extendedTemplateChecker.getDiagnosticsForComponent(component));
            }
            return this.addMessageTextDetails(diagnostics);
        }
        /**
         * Add Angular.io error guide links to diagnostics for this compilation.
         */
        addMessageTextDetails(diagnostics) {
            return diagnostics.map(diag => {
                if (diag.code && COMPILER_ERRORS_WITH_GUIDES.has(ngErrorCode(diag.code))) {
                    return Object.assign(Object.assign({}, diag), { messageText: diag.messageText +
                            `. Find more at ${ERROR_DETAILS_PAGE_BASE_URL}/NG${ngErrorCode(diag.code)}` });
                }
                return diag;
            });
        }
        /**
         * Get all setup-related diagnostics for this compilation.
         */
        getOptionDiagnostics() {
            return this.constructionDiagnostics;
        }
        /**
         * Get the current `ts.Program` known to this `NgCompiler`.
         *
         * Compilation begins with an input `ts.Program`, and during template type-checking operations new
         * `ts.Program`s may be produced using the `ProgramDriver`. The most recent such `ts.Program` to
         * be produced is available here.
         *
         * This `ts.Program` serves two key purposes:
         *
         * * As an incremental starting point for creating the next `ts.Program` based on files that the
         *   user has changed (for clients using the TS compiler program APIs).
         *
         * * As the "before" point for an incremental compilation invocation, to determine what's changed
         *   between the old and new programs (for all compilations).
         */
        getCurrentProgram() {
            return this.currentProgram;
        }
        getTemplateTypeChecker() {
            if (!this.enableTemplateTypeChecker) {
                throw new Error('The `TemplateTypeChecker` does not work without `enableTemplateTypeChecker`.');
            }
            return this.ensureAnalyzed().templateTypeChecker;
        }
        /**
         * Retrieves the `ts.Declaration`s for any component(s) which use the given template file.
         */
        getComponentsWithTemplateFile(templateFilePath) {
            const { resourceRegistry } = this.ensureAnalyzed();
            return resourceRegistry.getComponentsWithTemplate(resolve(templateFilePath));
        }
        /**
         * Retrieves the `ts.Declaration`s for any component(s) which use the given template file.
         */
        getComponentsWithStyleFile(styleFilePath) {
            const { resourceRegistry } = this.ensureAnalyzed();
            return resourceRegistry.getComponentsWithStyle(resolve(styleFilePath));
        }
        /**
         * Retrieves external resources for the given component.
         */
        getComponentResources(classDecl) {
            if (!isNamedClassDeclaration(classDecl)) {
                return null;
            }
            const { resourceRegistry } = this.ensureAnalyzed();
            const styles = resourceRegistry.getStyles(classDecl);
            const template = resourceRegistry.getTemplate(classDecl);
            if (template === null) {
                return null;
            }
            return { styles, template };
        }
        getMeta(classDecl) {
            var _a;
            if (!isNamedClassDeclaration(classDecl)) {
                return null;
            }
            const ref = new Reference$1(classDecl);
            const { metaReader } = this.ensureAnalyzed();
            const meta = (_a = metaReader.getPipeMetadata(ref)) !== null && _a !== void 0 ? _a : metaReader.getDirectiveMetadata(ref);
            if (meta === null) {
                return null;
            }
            return meta;
        }
        /**
         * Perform Angular's analysis step (as a precursor to `getDiagnostics` or `prepareEmit`)
         * asynchronously.
         *
         * Normally, this operation happens lazily whenever `getDiagnostics` or `prepareEmit` are called.
         * However, certain consumers may wish to allow for an asynchronous phase of analysis, where
         * resources such as `styleUrls` are resolved asynchonously. In these cases `analyzeAsync` must be
         * called first, and its `Promise` awaited prior to calling any other APIs of `NgCompiler`.
         */
        analyzeAsync() {
            return __awaiter(this, void 0, void 0, function* () {
                if (this.compilation !== null) {
                    return;
                }
                yield this.perfRecorder.inPhase(PerfPhase.Analysis, () => __awaiter(this, void 0, void 0, function* () {
                    this.compilation = this.makeCompilation();
                    const promises = [];
                    for (const sf of this.inputProgram.getSourceFiles()) {
                        if (sf.isDeclarationFile) {
                            continue;
                        }
                        let analysisPromise = this.compilation.traitCompiler.analyzeAsync(sf);
                        if (analysisPromise !== undefined) {
                            promises.push(analysisPromise);
                        }
                    }
                    yield Promise.all(promises);
                    this.perfRecorder.memory(PerfCheckpoint.Analysis);
                    this.resolveCompilation(this.compilation.traitCompiler);
                }));
            });
        }
        /**
         * List lazy routes detected during analysis.
         *
         * This can be called for one specific route, or to retrieve all top-level routes.
         */
        listLazyRoutes(entryRoute) {
            if (entryRoute) {
                // htts://github.com/angular/angular/blob/50732e156/packages/compiler-cli/src/transformers/compiler_host.ts#L175-L188).
                //
                // `@angular/cli` will always call this API with an absolute path, so the resolution step is
                // not necessary, but keeping it backwards compatible in case someone else is using the API.
                // Relative entry paths are disallowed.
                if (entryRoute.startsWith('.')) {
                    throw new Error(`Failed to list lazy routes: Resolution of relative paths (${entryRoute}) is not supported.`);
                }
                // Non-relative entry paths fall into one of the following categories:
                // - Absolute system paths (e.g. `/foo/bar/my-project/my-module`), which are unaffected by the
                //   logic below.
                // - Paths to enternal modules (e.g. `some-lib`).
                // - Paths mapped to directories in `tsconfig.json` (e.g. `shared/my-module`).
                //   (See https://www.typescriptlang.org/docs/handbook/module-resolution.html#path-mapping.)
                //
                // In all cases above, the `containingFile` argument is ignored, so we can just take the first
                // of the root files.
                const containingFile = this.inputProgram.getRootFileNames()[0];
                const [entryPath, moduleName] = entryRoute.split('#');
                const resolvedModule = resolveModuleName(entryPath, containingFile, this.options, this.adapter, null);
                if (resolvedModule) {
                    entryRoute = entryPointKeyFor(resolvedModule.resolvedFileName, moduleName);
                }
            }
            const compilation = this.ensureAnalyzed();
            return compilation.routeAnalyzer.listLazyRoutes(entryRoute);
        }
        /**
         * Fetch transformers and other information which is necessary for a consumer to `emit` the
         * program with Angular-added definitions.
         */
        prepareEmit() {
            const compilation = this.ensureAnalyzed();
            const coreImportsFrom = compilation.isCore ? getR3SymbolsFile(this.inputProgram) : null;
            let importRewriter;
            if (coreImportsFrom !== null) {
                importRewriter = new R3SymbolsImportRewriter(coreImportsFrom.fileName);
            }
            else {
                importRewriter = new NoopImportRewriter();
            }
            const defaultImportTracker = new DefaultImportTracker();
            const before = [
                ivyTransformFactory(compilation.traitCompiler, compilation.reflector, importRewriter, defaultImportTracker, this.delegatingPerfRecorder, compilation.isCore, this.closureCompilerEnabled),
                aliasTransformFactory(compilation.traitCompiler.exportStatements),
                defaultImportTracker.importPreservingTransformer(),
            ];
            const afterDeclarations = [];
            if (compilation.dtsTransforms !== null) {
                afterDeclarations.push(declarationTransformFactory(compilation.dtsTransforms, importRewriter));
            }
            // Only add aliasing re-exports to the .d.ts output if the `AliasingHost` requests it.
            if (compilation.aliasingHost !== null && compilation.aliasingHost.aliasExportsInDts) {
                afterDeclarations.push(aliasTransformFactory(compilation.traitCompiler.exportStatements));
            }
            if (this.adapter.factoryTracker !== null) {
                before.push(generatedFactoryTransform(this.adapter.factoryTracker.sourceInfo, importRewriter));
            }
            before.push(ivySwitchTransform);
            return { transformers: { before, afterDeclarations } };
        }
        /**
         * Run the indexing process and return a `Map` of all indexed components.
         *
         * See the `indexing` package for more details.
         */
        getIndexedComponents() {
            const compilation = this.ensureAnalyzed();
            const context = new IndexingContext();
            compilation.traitCompiler.index(context);
            return generateAnalysis(context);
        }
        /**
         * Collect i18n messages into the `Xi18nContext`.
         */
        xi18n(ctx) {
            // Note that the 'resolve' phase is not strictly necessary for xi18n, but this is not currently
            // optimized.
            const compilation = this.ensureAnalyzed();
            compilation.traitCompiler.xi18n(ctx);
        }
        ensureAnalyzed() {
            if (this.compilation === null) {
                this.analyzeSync();
            }
            return this.compilation;
        }
        analyzeSync() {
            this.perfRecorder.inPhase(PerfPhase.Analysis, () => {
                this.compilation = this.makeCompilation();
                for (const sf of this.inputProgram.getSourceFiles()) {
                    if (sf.isDeclarationFile) {
                        continue;
                    }
                    this.compilation.traitCompiler.analyzeSync(sf);
                }
                this.perfRecorder.memory(PerfCheckpoint.Analysis);
                this.resolveCompilation(this.compilation.traitCompiler);
            });
        }
        resolveCompilation(traitCompiler) {
            this.perfRecorder.inPhase(PerfPhase.Resolve, () => {
                traitCompiler.resolve();
                // At this point, analysis is complete and the compiler can now calculate which files need to
                // be emitted, so do that.
                this.incrementalCompilation.recordSuccessfulAnalysis(traitCompiler);
                this.perfRecorder.memory(PerfCheckpoint.Resolve);
            });
        }
        get fullTemplateTypeCheck() {
            // Determine the strictness level of type checking based on compiler options. As
            // `strictTemplates` is a superset of `fullTemplateTypeCheck`, the former implies the latter.
            // Also see `verifyCompatibleTypeCheckOptions` where it is verified that `fullTemplateTypeCheck`
            // is not disabled when `strictTemplates` is enabled.
            const strictTemplates = !!this.options.strictTemplates;
            return strictTemplates || !!this.options.fullTemplateTypeCheck;
        }
        getTypeCheckingConfig() {
            // Determine the strictness level of type checking based on compiler options. As
            // `strictTemplates` is a superset of `fullTemplateTypeCheck`, the former implies the latter.
            // Also see `verifyCompatibleTypeCheckOptions` where it is verified that `fullTemplateTypeCheck`
            // is not disabled when `strictTemplates` is enabled.
            const strictTemplates = !!this.options.strictTemplates;
            const useInlineTypeConstructors = this.programDriver.supportsInlineOperations;
            // First select a type-checking configuration, based on whether full template type-checking is
            // requested.
            let typeCheckingConfig;
            if (this.fullTemplateTypeCheck) {
                typeCheckingConfig = {
                    applyTemplateContextGuards: strictTemplates,
                    checkQueries: false,
                    checkTemplateBodies: true,
                    alwaysCheckSchemaInTemplateBodies: true,
                    checkTypeOfInputBindings: strictTemplates,
                    honorAccessModifiersForInputBindings: false,
                    strictNullInputBindings: strictTemplates,
                    checkTypeOfAttributes: strictTemplates,
                    // Even in full template type-checking mode, DOM binding checks are not quite ready yet.
                    checkTypeOfDomBindings: false,
                    checkTypeOfOutputEvents: strictTemplates,
                    checkTypeOfAnimationEvents: strictTemplates,
                    // Checking of DOM events currently has an adverse effect on developer experience,
                    // e.g. for `<input (blur)="update($event.target.value)">` enabling this check results in:
                    // - error TS2531: Object is possibly 'null'.
                    // - error TS2339: Property 'value' does not exist on type 'EventTarget'.
                    checkTypeOfDomEvents: strictTemplates,
                    checkTypeOfDomReferences: strictTemplates,
                    // Non-DOM references have the correct type in View Engine so there is no strictness flag.
                    checkTypeOfNonDomReferences: true,
                    // Pipes are checked in View Engine so there is no strictness flag.
                    checkTypeOfPipes: true,
                    strictSafeNavigationTypes: strictTemplates,
                    useContextGenericType: strictTemplates,
                    strictLiteralTypes: true,
                    enableTemplateTypeChecker: this.enableTemplateTypeChecker,
                    useInlineTypeConstructors,
                    // Warnings for suboptimal type inference are only enabled if in Language Service mode
                    // (providing the full TemplateTypeChecker API) and if strict mode is not enabled. In strict
                    // mode, the user is in full control of type inference.
                    suggestionsForSuboptimalTypeInference: this.enableTemplateTypeChecker && !strictTemplates,
                };
            }
            else {
                typeCheckingConfig = {
                    applyTemplateContextGuards: false,
                    checkQueries: false,
                    checkTemplateBodies: false,
                    // Enable deep schema checking in "basic" template type-checking mode only if Closure
                    // compilation is requested, which is a good proxy for "only in google3".
                    alwaysCheckSchemaInTemplateBodies: this.closureCompilerEnabled,
                    checkTypeOfInputBindings: false,
                    strictNullInputBindings: false,
                    honorAccessModifiersForInputBindings: false,
                    checkTypeOfAttributes: false,
                    checkTypeOfDomBindings: false,
                    checkTypeOfOutputEvents: false,
                    checkTypeOfAnimationEvents: false,
                    checkTypeOfDomEvents: false,
                    checkTypeOfDomReferences: false,
                    checkTypeOfNonDomReferences: false,
                    checkTypeOfPipes: false,
                    strictSafeNavigationTypes: false,
                    useContextGenericType: false,
                    strictLiteralTypes: false,
                    enableTemplateTypeChecker: this.enableTemplateTypeChecker,
                    useInlineTypeConstructors,
                    // In "basic" template type-checking mode, no warnings are produced since most things are
                    // not checked anyways.
                    suggestionsForSuboptimalTypeInference: false,
                };
            }
            // Apply explicitly configured strictness flags on top of the default configuration
            // based on "fullTemplateTypeCheck".
            if (this.options.strictInputTypes !== undefined) {
                typeCheckingConfig.checkTypeOfInputBindings = this.options.strictInputTypes;
                typeCheckingConfig.applyTemplateContextGuards = this.options.strictInputTypes;
            }
            if (this.options.strictInputAccessModifiers !== undefined) {
                typeCheckingConfig.honorAccessModifiersForInputBindings =
                    this.options.strictInputAccessModifiers;
            }
            if (this.options.strictNullInputTypes !== undefined) {
                typeCheckingConfig.strictNullInputBindings = this.options.strictNullInputTypes;
            }
            if (this.options.strictOutputEventTypes !== undefined) {
                typeCheckingConfig.checkTypeOfOutputEvents = this.options.strictOutputEventTypes;
                typeCheckingConfig.checkTypeOfAnimationEvents = this.options.strictOutputEventTypes;
            }
            if (this.options.strictDomEventTypes !== undefined) {
                typeCheckingConfig.checkTypeOfDomEvents = this.options.strictDomEventTypes;
            }
            if (this.options.strictSafeNavigationTypes !== undefined) {
                typeCheckingConfig.strictSafeNavigationTypes = this.options.strictSafeNavigationTypes;
            }
            if (this.options.strictDomLocalRefTypes !== undefined) {
                typeCheckingConfig.checkTypeOfDomReferences = this.options.strictDomLocalRefTypes;
            }
            if (this.options.strictAttributeTypes !== undefined) {
                typeCheckingConfig.checkTypeOfAttributes = this.options.strictAttributeTypes;
            }
            if (this.options.strictContextGenerics !== undefined) {
                typeCheckingConfig.useContextGenericType = this.options.strictContextGenerics;
            }
            if (this.options.strictLiteralTypes !== undefined) {
                typeCheckingConfig.strictLiteralTypes = this.options.strictLiteralTypes;
            }
            return typeCheckingConfig;
        }
        getTemplateDiagnostics() {
            const compilation = this.ensureAnalyzed();
            // Get the diagnostics.
            const diagnostics = [];
            for (const sf of this.inputProgram.getSourceFiles()) {
                if (sf.isDeclarationFile || this.adapter.isShim(sf)) {
                    continue;
                }
                diagnostics.push(...compilation.templateTypeChecker.getDiagnosticsForFile(sf, OptimizeFor.WholeProgram));
            }
            const program = this.programDriver.getProgram();
            this.incrementalStrategy.setIncrementalState(this.incrementalCompilation.state, program);
            this.currentProgram = program;
            return diagnostics;
        }
        getTemplateDiagnosticsForFile(sf, optimizeFor) {
            const compilation = this.ensureAnalyzed();
            // Get the diagnostics.
            const diagnostics = [];
            if (!sf.isDeclarationFile && !this.adapter.isShim(sf)) {
                diagnostics.push(...compilation.templateTypeChecker.getDiagnosticsForFile(sf, optimizeFor));
            }
            const program = this.programDriver.getProgram();
            this.incrementalStrategy.setIncrementalState(this.incrementalCompilation.state, program);
            this.currentProgram = program;
            return diagnostics;
        }
        getNonTemplateDiagnostics() {
            if (this.nonTemplateDiagnostics === null) {
                const compilation = this.ensureAnalyzed();
                this.nonTemplateDiagnostics = [...compilation.traitCompiler.diagnostics];
                if (this.entryPoint !== null && compilation.exportReferenceGraph !== null) {
                    this.nonTemplateDiagnostics.push(...checkForPrivateExports(this.entryPoint, this.inputProgram.getTypeChecker(), compilation.exportReferenceGraph));
                }
            }
            return this.nonTemplateDiagnostics;
        }
        /**
         * Calls the `extendedTemplateCheck` phase of the trait compiler
         * @param sf optional parameter to get diagnostics for a certain file
         *     or all files in the program if `sf` is undefined
         * @returns generated extended template diagnostics
         */
        getExtendedTemplateDiagnostics(sf) {
            const diagnostics = [];
            const compilation = this.ensureAnalyzed();
            const extendedTemplateChecker = compilation.extendedTemplateChecker;
            if (sf !== undefined) {
                return compilation.traitCompiler.extendedTemplateCheck(sf, extendedTemplateChecker);
            }
            for (const sf of this.inputProgram.getSourceFiles()) {
                diagnostics.push(...compilation.traitCompiler.extendedTemplateCheck(sf, extendedTemplateChecker));
            }
            return diagnostics;
        }
        makeCompilation() {
            const checker = this.inputProgram.getTypeChecker();
            const reflector = new TypeScriptReflectionHost(checker);
            // Construct the ReferenceEmitter.
            let refEmitter;
            let aliasingHost = null;
            if (this.adapter.unifiedModulesHost === null || !this.options._useHostForImportGeneration) {
                let localImportStrategy;
                // The strategy used for local, in-project imports depends on whether TS has been configured
                // with rootDirs. If so, then multiple directories may be mapped in the same "module
                // namespace" and the logic of `LogicalProjectStrategy` is required to generate correct
                // imports which may cross these multiple directories. Otherwise, plain relative imports are
                // sufficient.
                if (this.options.rootDir !== undefined ||
                    (this.options.rootDirs !== undefined && this.options.rootDirs.length > 0)) {
                    // rootDirs logic is in effect - use the `LogicalProjectStrategy` for in-project relative
                    // imports.
                    localImportStrategy = new LogicalProjectStrategy(reflector, new LogicalFileSystem([...this.adapter.rootDirs], this.adapter));
                }
                else {
                    // Plain relative imports are all that's needed.
                    localImportStrategy = new RelativePathStrategy(reflector);
                }
                // The CompilerHost doesn't have fileNameToModuleName, so build an NPM-centric reference
                // resolution strategy.
                refEmitter = new ReferenceEmitter([
                    // First, try to use local identifiers if available.
                    new LocalIdentifierStrategy(),
                    // Next, attempt to use an absolute import.
                    new AbsoluteModuleStrategy(this.inputProgram, checker, this.moduleResolver, reflector),
                    // Finally, check if the reference is being written into a file within the project's .ts
                    // sources, and use a relative import if so. If this fails, ReferenceEmitter will throw
                    // an error.
                    localImportStrategy,
                ]);
                // If an entrypoint is present, then all user imports should be directed through the
                // entrypoint and private exports are not needed. The compiler will validate that all publicly
                // visible directives/pipes are importable via this entrypoint.
                if (this.entryPoint === null && this.options.generateDeepReexports === true) {
                    // No entrypoint is present and deep re-exports were requested, so configure the aliasing
                    // system to generate them.
                    aliasingHost = new PrivateExportAliasingHost(reflector);
                }
            }
            else {
                // The CompilerHost supports fileNameToModuleName, so use that to emit imports.
                refEmitter = new ReferenceEmitter([
                    // First, try to use local identifiers if available.
                    new LocalIdentifierStrategy(),
                    // Then use aliased references (this is a workaround to StrictDeps checks).
                    new AliasStrategy(),
                    // Then use fileNameToModuleName to emit imports.
                    new UnifiedModulesStrategy(reflector, this.adapter.unifiedModulesHost),
                ]);
                aliasingHost = new UnifiedModulesAliasingHost(this.adapter.unifiedModulesHost);
            }
            const evaluator = new PartialEvaluator(reflector, checker, this.incrementalCompilation.depGraph);
            const dtsReader = new DtsMetadataReader(checker, reflector);
            const localMetaRegistry = new LocalMetadataRegistry();
            const localMetaReader = localMetaRegistry;
            const depScopeReader = new MetadataDtsModuleScopeResolver(dtsReader, aliasingHost);
            const scopeRegistry = new LocalModuleScopeRegistry(localMetaReader, depScopeReader, refEmitter, aliasingHost);
            const scopeReader = scopeRegistry;
            const semanticDepGraphUpdater = this.incrementalCompilation.semanticDepGraphUpdater;
            const metaRegistry = new CompoundMetadataRegistry([localMetaRegistry, scopeRegistry]);
            const injectableRegistry = new InjectableClassRegistry(reflector);
            const metaReader = new CompoundMetadataReader([localMetaReader, dtsReader]);
            const typeCheckScopeRegistry = new TypeCheckScopeRegistry(scopeReader, metaReader);
            // If a flat module entrypoint was specified, then track references via a `ReferenceGraph` in
            // order to produce proper diagnostics for incorrectly exported directives/pipes/etc. If there
            // is no flat module entrypoint then don't pay the cost of tracking references.
            let referencesRegistry;
            let exportReferenceGraph = null;
            if (this.entryPoint !== null) {
                exportReferenceGraph = new ReferenceGraph();
                referencesRegistry = new ReferenceGraphAdapter(exportReferenceGraph);
            }
            else {
                referencesRegistry = new NoopReferencesRegistry();
            }
            const routeAnalyzer = new NgModuleRouteAnalyzer(this.moduleResolver, evaluator);
            const dtsTransforms = new DtsTransformRegistry();
            const isCore = isAngularCorePackage(this.inputProgram);
            const resourceRegistry = new ResourceRegistry();
            const compilationMode = this.options.compilationMode === 'partial' ? CompilationMode.PARTIAL : CompilationMode.FULL;
            // Cycles are handled in full compilation mode by "remote scoping".
            // "Remote scoping" does not work well with tree shaking for libraries.
            // So in partial compilation mode, when building a library, a cycle will cause an error.
            const cycleHandlingStrategy = compilationMode === CompilationMode.FULL ?
                0 /* UseRemoteScoping */ :
                1 /* Error */;
            // Set up the IvyCompilation, which manages state for the Ivy transformer.
            const handlers = [
                new ComponentDecoratorHandler(reflector, evaluator, metaRegistry, metaReader, scopeReader, scopeRegistry, typeCheckScopeRegistry, resourceRegistry, isCore, this.resourceManager, this.adapter.rootDirs, this.options.preserveWhitespaces || false, this.options.i18nUseExternalIds !== false, this.options.enableI18nLegacyMessageIdFormat !== false, this.usePoisonedData, this.options.i18nNormalizeLineEndingsInICUs, this.moduleResolver, this.cycleAnalyzer, cycleHandlingStrategy, refEmitter, this.incrementalCompilation.depGraph, injectableRegistry, semanticDepGraphUpdater, this.closureCompilerEnabled, this.delegatingPerfRecorder),
                // TODO(alxhub): understand why the cast here is necessary (something to do with `null`
                // not being assignable to `unknown` when wrapped in `Readonly`).
                // clang-format off
                new DirectiveDecoratorHandler(reflector, evaluator, metaRegistry, scopeRegistry, metaReader, injectableRegistry, isCore, semanticDepGraphUpdater, this.closureCompilerEnabled, /** compileUndecoratedClassesWithAngularFeatures */ false, this.delegatingPerfRecorder),
                // clang-format on
                // Pipe handler must be before injectable handler in list so pipe factories are printed
                // before injectable factories (so injectable factories can delegate to them)
                new PipeDecoratorHandler(reflector, evaluator, metaRegistry, scopeRegistry, injectableRegistry, isCore, this.delegatingPerfRecorder),
                new InjectableDecoratorHandler(reflector, isCore, this.options.strictInjectionParameters || false, injectableRegistry, this.delegatingPerfRecorder),
                new NgModuleDecoratorHandler(reflector, evaluator, metaReader, metaRegistry, scopeRegistry, referencesRegistry, isCore, routeAnalyzer, refEmitter, this.adapter.factoryTracker, this.closureCompilerEnabled, injectableRegistry, this.delegatingPerfRecorder, this.options.i18nInLocale),
            ];
            const traitCompiler = new TraitCompiler(handlers, reflector, this.delegatingPerfRecorder, this.incrementalCompilation, this.options.compileNonExportedClasses !== false, compilationMode, dtsTransforms, semanticDepGraphUpdater);
            // Template type-checking may use the `ProgramDriver` to produce new `ts.Program`(s). If this
            // happens, they need to be tracked by the `NgCompiler`.
            const notifyingDriver = new NotifyingProgramDriverWrapper(this.programDriver, (program) => {
                this.incrementalStrategy.setIncrementalState(this.incrementalCompilation.state, program);
                this.currentProgram = program;
            });
            const templateTypeChecker = new TemplateTypeCheckerImpl(this.inputProgram, notifyingDriver, traitCompiler, this.getTypeCheckingConfig(), refEmitter, reflector, this.adapter, this.incrementalCompilation, scopeRegistry, typeCheckScopeRegistry, this.delegatingPerfRecorder);
            const templateChecks = [new InvalidBananaInBoxCheck()];
            if (this.options.strictNullChecks) {
                templateChecks.push(new NullishCoalescingNotNullableCheck());
            }
            const extendedTemplateChecker = new ExtendedTemplateCheckerImpl(templateTypeChecker, checker, templateChecks);
            return {
                isCore,
                traitCompiler,
                reflector,
                scopeRegistry,
                dtsTransforms,
                exportReferenceGraph,
                routeAnalyzer,
                metaReader,
                typeCheckScopeRegistry,
                aliasingHost,
                refEmitter,
                templateTypeChecker,
                resourceRegistry,
                extendedTemplateChecker
            };
        }
    }
    /**
     * Determine if the given `Program` is @angular/core.
     */
    function isAngularCorePackage(program) {
        // Look for its_just_angular.ts somewhere in the program.
        const r3Symbols = getR3SymbolsFile(program);
        if (r3Symbols === null) {
            return false;
        }
        // Look for the constant ITS_JUST_ANGULAR in that file.
        return r3Symbols.statements.some(stmt => {
            // The statement must be a variable declaration statement.
            if (!ts$1.isVariableStatement(stmt)) {
                return false;
            }
            // It must be exported.
            if (stmt.modifiers === undefined ||
                !stmt.modifiers.some(mod => mod.kind === ts$1.SyntaxKind.ExportKeyword)) {
                return false;
            }
            // It must declare ITS_JUST_ANGULAR.
            return stmt.declarationList.declarations.some(decl => {
                // The declaration must match the name.
                if (!ts$1.isIdentifier(decl.name) || decl.name.text !== 'ITS_JUST_ANGULAR') {
                    return false;
                }
                // It must initialize the variable to true.
                if (decl.initializer === undefined || decl.initializer.kind !== ts$1.SyntaxKind.TrueKeyword) {
                    return false;
                }
                // This definition matches.
                return true;
            });
        });
    }
    /**
     * Find the 'r3_symbols.ts' file in the given `Program`, or return `null` if it wasn't there.
     */
    function getR3SymbolsFile(program) {
        return program.getSourceFiles().find(file => file.fileName.indexOf('r3_symbols.ts') >= 0) || null;
    }
    /**
     * Since "strictTemplates" is a true superset of type checking capabilities compared to
     * "fullTemplateTypeCheck", it is required that the latter is not explicitly disabled if the
     * former is enabled.
     */
    function verifyCompatibleTypeCheckOptions(options) {
        if (options.fullTemplateTypeCheck === false && options.strictTemplates === true) {
            return {
                category: ts$1.DiagnosticCategory.Error,
                code: ngErrorCode(ErrorCode.CONFIG_STRICT_TEMPLATES_IMPLIES_FULL_TEMPLATE_TYPECHECK),
                file: undefined,
                start: undefined,
                length: undefined,
                messageText: `Angular compiler option "strictTemplates" is enabled, however "fullTemplateTypeCheck" is disabled.

Having the "strictTemplates" flag enabled implies that "fullTemplateTypeCheck" is also enabled, so
the latter can not be explicitly disabled.

One of the following actions is required:
1. Remove the "fullTemplateTypeCheck" option.
2. Remove "strictTemplates" or set it to 'false'.

More information about the template type checking compiler options can be found in the documentation:
https://v9.angular.io/guide/template-typecheck#template-type-checking`,
            };
        }
        return null;
    }
    class ReferenceGraphAdapter {
        constructor(graph) {
            this.graph = graph;
        }
        add(source, ...references) {
            for (const { node } of references) {
                let sourceFile = node.getSourceFile();
                if (sourceFile === undefined) {
                    sourceFile = ts$1.getOriginalNode(node).getSourceFile();
                }
                // Only record local references (not references into .d.ts files).
                if (sourceFile === undefined || !isDtsPath(sourceFile.fileName)) {
                    this.graph.add(source, node);
                }
            }
        }
    }
    class NotifyingProgramDriverWrapper {
        constructor(delegate, notifyNewProgram) {
            var _a;
            this.delegate = delegate;
            this.notifyNewProgram = notifyNewProgram;
            this.getSourceFileVersion = (_a = this.delegate.getSourceFileVersion) === null || _a === void 0 ? void 0 : _a.bind(this);
        }
        get supportsInlineOperations() {
            return this.delegate.supportsInlineOperations;
        }
        getProgram() {
            return this.delegate.getProgram();
        }
        updateFiles(contents, updateMode) {
            this.delegate.updateFiles(contents, updateMode);
            this.notifyNewProgram(this.delegate.getProgram());
        }
    }
    function versionMapFromProgram(program, driver) {
        if (driver.getSourceFileVersion === undefined) {
            return null;
        }
        const versions = new Map();
        for (const possiblyRedirectedSourceFile of program.getSourceFiles()) {
            const sf = toUnredirectedSourceFile(possiblyRedirectedSourceFile);
            versions.set(absoluteFromSourceFile(sf), driver.getSourceFileVersion(sf));
        }
        return versions;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function calcProjectFileAndBasePath(project, host = getFileSystem()) {
        const absProject = host.resolve(project);
        const projectIsDir = host.lstat(absProject).isDirectory();
        const projectFile = projectIsDir ? host.join(absProject, 'tsconfig.json') : absProject;
        const projectDir = projectIsDir ? absProject : host.dirname(absProject);
        const basePath = host.resolve(projectDir);
        return { projectFile, basePath };
    }
    function readConfiguration(project, existingOptions, host = getFileSystem()) {
        var _a;
        try {
            const fs = getFileSystem();
            const readConfigFile = (configFile) => ts$1.readConfigFile(configFile, file => host.readFile(host.resolve(file)));
            const readAngularCompilerOptions = (configFile, parentOptions = {}) => {
                const { config, error } = readConfigFile(configFile);
                if (error) {
                    // Errors are handled later on by 'parseJsonConfigFileContent'
                    return parentOptions;
                }
                // we are only interested into merging 'angularCompilerOptions' as
                // other options like 'compilerOptions' are merged by TS
                const existingNgCompilerOptions = Object.assign(Object.assign({}, config.angularCompilerOptions), parentOptions);
                if (config.extends && typeof config.extends === 'string') {
                    const extendedConfigPath = getExtendedConfigPath(configFile, config.extends, host, fs);
                    if (extendedConfigPath !== null) {
                        // Call readAngularCompilerOptions recursively to merge NG Compiler options
                        return readAngularCompilerOptions(extendedConfigPath, existingNgCompilerOptions);
                    }
                }
                return existingNgCompilerOptions;
            };
            const { projectFile, basePath } = calcProjectFileAndBasePath(project, host);
            const configFileName = host.resolve(host.pwd(), projectFile);
            const { config, error } = readConfigFile(projectFile);
            if (error) {
                return {
                    project,
                    errors: [error],
                    rootNames: [],
                    options: {},
                    emitFlags: EmitFlags.Default
                };
            }
            const existingCompilerOptions = Object.assign(Object.assign({ genDir: basePath, basePath }, readAngularCompilerOptions(configFileName)), existingOptions);
            const parseConfigHost = createParseConfigHost(host, fs);
            const { options, errors, fileNames: rootNames, projectReferences } = ts$1.parseJsonConfigFileContent(config, parseConfigHost, basePath, existingCompilerOptions, configFileName);
            // Coerce to boolean as `enableIvy` can be `ngtsc|true|false|undefined` here.
            options.enableIvy = !!((_a = options.enableIvy) !== null && _a !== void 0 ? _a : true);
            let emitFlags = EmitFlags.Default;
            if (!(options.skipMetadataEmit || options.flatModuleOutFile)) {
                emitFlags |= EmitFlags.Metadata;
            }
            if (options.skipTemplateCodegen) {
                emitFlags = emitFlags & ~EmitFlags.Codegen;
            }
            return { project: projectFile, rootNames, projectReferences, options, errors, emitFlags };
        }
        catch (e) {
            const errors = [{
                    category: ts$1.DiagnosticCategory.Error,
                    messageText: e.stack,
                    file: undefined,
                    start: undefined,
                    length: undefined,
                    source: 'angular',
                    code: UNKNOWN_ERROR_CODE,
                }];
            return { project: '', errors, rootNames: [], options: {}, emitFlags: EmitFlags.Default };
        }
    }
    function createParseConfigHost(host, fs = getFileSystem()) {
        return {
            fileExists: host.exists.bind(host),
            readDirectory: ts$1.sys.readDirectory,
            readFile: host.readFile.bind(host),
            useCaseSensitiveFileNames: fs.isCaseSensitive(),
        };
    }
    function getExtendedConfigPath(configFile, extendsValue, host, fs) {
        const result = getExtendedConfigPathWorker(configFile, extendsValue, host, fs);
        if (result !== null) {
            return result;
        }
        // Try to resolve the paths with a json extension append a json extension to the file in case if
        // it is missing and the resolution failed. This is to replicate TypeScript behaviour, see:
        // https://github.com/microsoft/TypeScript/blob/294a5a7d784a5a95a8048ee990400979a6bc3a1c/src/compiler/commandLineParser.ts#L2806
        return getExtendedConfigPathWorker(configFile, `${extendsValue}.json`, host, fs);
    }
    function getExtendedConfigPathWorker(configFile, extendsValue, host, fs) {
        if (extendsValue.startsWith('.') || fs.isRooted(extendsValue)) {
            const extendedConfigPath = host.resolve(host.dirname(configFile), extendsValue);
            if (host.exists(extendedConfigPath)) {
                return extendedConfigPath;
            }
        }
        else {
            const parseConfigHost = createParseConfigHost(host, fs);
            // Path isn't a rooted or relative path, resolve like a module.
            const { resolvedModule, } = ts$1.nodeModuleNameResolver(extendsValue, configFile, { moduleResolution: ts$1.ModuleResolutionKind.NodeJs, resolveJsonModule: true }, parseConfigHost);
            if (resolvedModule) {
                return absoluteFrom(resolvedModule.resolvedFileName);
            }
        }
        return null;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Known values for global variables in `@angular/core` that Terser should set using
     * https://github.com/terser-js/terser#conditional-compilation
     */
    const GLOBAL_DEFS_FOR_TERSER = {
        ngDevMode: false,
        ngI18nClosureMode: false,
    };
    const GLOBAL_DEFS_FOR_TERSER_WITH_AOT = Object.assign(Object.assign({}, GLOBAL_DEFS_FOR_TERSER), { ngJitMode: false });

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    setFileSystem(new NodeJSFileSystem());

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    // Reverse mappings of enum would generate strings
    const ALIAS_NAME = ts$1.SymbolDisplayPartKind[ts$1.SymbolDisplayPartKind.aliasName];
    const SYMBOL_INTERFACE = ts$1.SymbolDisplayPartKind[ts$1.SymbolDisplayPartKind.interfaceName];
    const SYMBOL_PUNC = ts$1.SymbolDisplayPartKind[ts$1.SymbolDisplayPartKind.punctuation];
    const SYMBOL_SPACE = ts$1.SymbolDisplayPartKind[ts$1.SymbolDisplayPartKind.space];
    const SYMBOL_TEXT = ts$1.SymbolDisplayPartKind[ts$1.SymbolDisplayPartKind.text];
    /**
     * Label for various kinds of Angular entities for TS display info.
     */
    var DisplayInfoKind;
    (function (DisplayInfoKind) {
        DisplayInfoKind["ATTRIBUTE"] = "attribute";
        DisplayInfoKind["COMPONENT"] = "component";
        DisplayInfoKind["DIRECTIVE"] = "directive";
        DisplayInfoKind["EVENT"] = "event";
        DisplayInfoKind["REFERENCE"] = "reference";
        DisplayInfoKind["ELEMENT"] = "element";
        DisplayInfoKind["VARIABLE"] = "variable";
        DisplayInfoKind["PIPE"] = "pipe";
        DisplayInfoKind["PROPERTY"] = "property";
        DisplayInfoKind["METHOD"] = "method";
        DisplayInfoKind["TEMPLATE"] = "template";
    })(DisplayInfoKind || (DisplayInfoKind = {}));
    function getSymbolDisplayInfo(tsLS, typeChecker, symbol) {
        let kind;
        if (symbol.kind === SymbolKind.Reference) {
            kind = DisplayInfoKind.REFERENCE;
        }
        else if (symbol.kind === SymbolKind.Variable) {
            kind = DisplayInfoKind.VARIABLE;
        }
        else {
            throw new Error(`AssertionError: unexpected symbol kind ${SymbolKind[symbol.kind]}`);
        }
        const displayParts = createDisplayParts(symbol.declaration.name, kind, /* containerName */ undefined, typeChecker.typeToString(symbol.tsType));
        const documentation = symbol.kind === SymbolKind.Reference ?
            getDocumentationFromTypeDefAtLocation(tsLS, symbol.targetLocation) :
            getDocumentationFromTypeDefAtLocation(tsLS, symbol.initializerLocation);
        return {
            kind,
            displayParts,
            documentation,
        };
    }
    /**
     * Construct a compound `ts.SymbolDisplayPart[]` which incorporates the container and type of a
     * target declaration.
     * @param name Name of the target
     * @param kind component, directive, pipe, etc.
     * @param containerName either the Symbol's container or the NgModule that contains the directive
     * @param type user-friendly name of the type
     * @param documentation docstring or comment
     */
    function createDisplayParts(name, kind, containerName, type) {
        const containerDisplayParts = containerName !== undefined ?
            [
                { text: containerName, kind: SYMBOL_INTERFACE },
                { text: '.', kind: SYMBOL_PUNC },
            ] :
            [];
        const typeDisplayParts = type !== undefined ?
            [
                { text: ':', kind: SYMBOL_PUNC },
                { text: ' ', kind: SYMBOL_SPACE },
                { text: type, kind: SYMBOL_INTERFACE },
            ] :
            [];
        return [
            { text: '(', kind: SYMBOL_PUNC },
            { text: kind, kind: SYMBOL_TEXT },
            { text: ')', kind: SYMBOL_PUNC },
            { text: ' ', kind: SYMBOL_SPACE },
            ...containerDisplayParts,
            { text: name, kind: SYMBOL_INTERFACE },
            ...typeDisplayParts,
        ];
    }
    /**
     * Convert a `SymbolDisplayInfoKind` to a `ts.ScriptElementKind` type, allowing it to pass through
     * TypeScript APIs.
     *
     * In practice, this is an "illegal" type cast. Since `ts.ScriptElementKind` is a string, this is
     * safe to do if TypeScript only uses the value in a string context. Consumers of this conversion
     * function are responsible for ensuring this is the case.
     */
    function unsafeCastDisplayInfoKindToScriptElementKind(kind) {
        return kind;
    }
    function getDocumentationFromTypeDefAtLocation(tsLS, shimLocation) {
        var _a;
        const typeDefs = tsLS.getTypeDefinitionAtPosition(shimLocation.shimPath, shimLocation.positionInShimFile);
        if (typeDefs === undefined || typeDefs.length === 0) {
            return undefined;
        }
        return (_a = tsLS.getQuickInfoAtPosition(typeDefs[0].fileName, typeDefs[0].textSpan.start)) === null || _a === void 0 ? void 0 : _a.documentation;
    }
    function getDirectiveDisplayInfo(tsLS, dir) {
        var _a, _b;
        const kind = dir.isComponent ? DisplayInfoKind.COMPONENT : DisplayInfoKind.DIRECTIVE;
        const decl = dir.tsSymbol.declarations.find(ts$1.isClassDeclaration);
        if (decl === undefined || decl.name === undefined) {
            return { kind, displayParts: [], documentation: [] };
        }
        const res = tsLS.getQuickInfoAtPosition(decl.getSourceFile().fileName, decl.name.getStart());
        if (res === undefined) {
            return { kind, displayParts: [], documentation: [] };
        }
        const displayParts = createDisplayParts(dir.tsSymbol.name, kind, (_b = (_a = dir.ngModule) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.text, undefined);
        return {
            kind,
            displayParts,
            documentation: res.documentation,
        };
    }
    function getTsSymbolDisplayInfo(tsLS, checker, symbol, kind, ownerName) {
        const decl = symbol.valueDeclaration;
        if (decl === undefined ||
            (!ts$1.isPropertyDeclaration(decl) && !ts$1.isMethodDeclaration(decl) &&
                !isNamedClassDeclaration(decl)) ||
            !ts$1.isIdentifier(decl.name)) {
            return null;
        }
        const res = tsLS.getQuickInfoAtPosition(decl.getSourceFile().fileName, decl.name.getStart());
        if (res === undefined) {
            return { kind, displayParts: [], documentation: [] };
        }
        const type = checker.getDeclaredTypeOfSymbol(symbol);
        const typeString = checker.typeToString(type);
        const displayParts = createDisplayParts(symbol.name, kind, ownerName !== null && ownerName !== void 0 ? ownerName : undefined, typeString);
        return {
            kind,
            displayParts,
            documentation: res.documentation,
        };
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Return the node that most tightly encompasses the specified `position`.
     * @param node The starting node to start the top-down search.
     * @param position The target position within the `node`.
     */
    function findTightestNode(node, position) {
        var _a;
        if (node.getStart() <= position && position < node.getEnd()) {
            return (_a = node.forEachChild(c => findTightestNode(c, position))) !== null && _a !== void 0 ? _a : node;
        }
        return undefined;
    }
    function getParentClassDeclaration(startNode) {
        while (startNode) {
            if (ts$1.isClassDeclaration(startNode)) {
                return startNode;
            }
            startNode = startNode.parent;
        }
        return undefined;
    }
    /**
     * Returns a property assignment from the assignment value if the property name
     * matches the specified `key`, or `null` if there is no match.
     */
    function getPropertyAssignmentFromValue(value, key) {
        const propAssignment = value.parent;
        if (!propAssignment || !ts$1.isPropertyAssignment(propAssignment) ||
            propAssignment.name.getText() !== key) {
            return null;
        }
        return propAssignment;
    }
    /**
     * Given a decorator property assignment, return the ClassDeclaration node that corresponds to the
     * directive class the property applies to.
     * If the property assignment is not on a class decorator, no declaration is returned.
     *
     * For example,
     *
     * @Component({
     *   template: '<div></div>'
     *   ^^^^^^^^^^^^^^^^^^^^^^^---- property assignment
     * })
     * class AppComponent {}
     *           ^---- class declaration node
     *
     * @param propAsgnNode property assignment
     */
    function getClassDeclFromDecoratorProp(propAsgnNode) {
        if (!propAsgnNode.parent || !ts$1.isObjectLiteralExpression(propAsgnNode.parent)) {
            return;
        }
        const objLitExprNode = propAsgnNode.parent;
        if (!objLitExprNode.parent || !ts$1.isCallExpression(objLitExprNode.parent)) {
            return;
        }
        const callExprNode = objLitExprNode.parent;
        if (!callExprNode.parent || !ts$1.isDecorator(callExprNode.parent)) {
            return;
        }
        const decorator = callExprNode.parent;
        if (!decorator.parent || !ts$1.isClassDeclaration(decorator.parent)) {
            return;
        }
        const classDeclNode = decorator.parent;
        return classDeclNode;
    }
    /**
     * Collects all member methods, including those from base classes.
     */
    function collectMemberMethods(clazz, typeChecker) {
        const members = [];
        const apparentProps = typeChecker.getTypeAtLocation(clazz).getApparentProperties();
        for (const prop of apparentProps) {
            if (prop.valueDeclaration && ts$1.isMethodDeclaration(prop.valueDeclaration)) {
                members.push(prop.valueDeclaration);
            }
        }
        return members;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function getTextSpanOfNode(node) {
        if (isTemplateNodeWithKeyAndValue(node)) {
            return toTextSpan(node.keySpan);
        }
        else if (node instanceof PropertyWrite || node instanceof MethodCall ||
            node instanceof BindingPipe || node instanceof PropertyRead) {
            // The `name` part of a `PropertyWrite`, `MethodCall`, and `BindingPipe` does not
            // have its own AST so there is no way to retrieve a `Symbol` for just the `name` via a specific
            // node.
            return toTextSpan(node.nameSpan);
        }
        else {
            return toTextSpan(node.sourceSpan);
        }
    }
    function toTextSpan(span) {
        let start, end;
        if (span instanceof AbsoluteSourceSpan || span instanceof ParseSpan) {
            start = span.start;
            end = span.end;
        }
        else {
            start = span.start.offset;
            end = span.end.offset;
        }
        return { start, length: end - start };
    }
    function isTemplateNodeWithKeyAndValue(node) {
        return isTemplateNode(node) && node.hasOwnProperty('keySpan');
    }
    function isWithinKeyValue(position, node) {
        let { keySpan, valueSpan } = node;
        if (valueSpan === undefined && node instanceof BoundEvent) {
            valueSpan = node.handlerSpan;
        }
        const isWithinKeyValue = isWithin(position, keySpan) || !!(valueSpan && isWithin(position, valueSpan));
        return isWithinKeyValue;
    }
    function isTemplateNode(node) {
        // Template node implements the Node interface so we cannot use instanceof.
        return node.sourceSpan instanceof ParseSourceSpan;
    }
    function getInlineTemplateInfoAtPosition(sf, position, compiler) {
        const expression = findTightestNode(sf, position);
        if (expression === undefined) {
            return undefined;
        }
        const classDecl = getParentClassDeclaration(expression);
        if (classDecl === undefined) {
            return undefined;
        }
        // Return `undefined` if the position is not on the template expression or the template resource
        // is not inline.
        const resources = compiler.getComponentResources(classDecl);
        if (resources === null || isExternalResource(resources.template) ||
            expression !== resources.template.expression) {
            return undefined;
        }
        const template = compiler.getTemplateTypeChecker().getTemplate(classDecl);
        if (template === null) {
            return undefined;
        }
        return { template, component: classDecl };
    }
    /**
     * Retrieves the `ts.ClassDeclaration` at a location along with its template nodes.
     */
    function getTemplateInfoAtPosition(fileName, position, compiler) {
        if (isTypeScriptFile(fileName)) {
            const sf = compiler.getCurrentProgram().getSourceFile(fileName);
            if (sf === undefined) {
                return undefined;
            }
            return getInlineTemplateInfoAtPosition(sf, position, compiler);
        }
        else {
            return getFirstComponentForTemplateFile(fileName, compiler);
        }
    }
    /**
     * First, attempt to sort component declarations by file name.
     * If the files are the same, sort by start location of the declaration.
     */
    function tsDeclarationSortComparator(a, b) {
        const aFile = a.getSourceFile().fileName;
        const bFile = b.getSourceFile().fileName;
        if (aFile < bFile) {
            return -1;
        }
        else if (aFile > bFile) {
            return 1;
        }
        else {
            return b.getFullStart() - a.getFullStart();
        }
    }
    function getFirstComponentForTemplateFile(fileName, compiler) {
        const templateTypeChecker = compiler.getTemplateTypeChecker();
        const components = compiler.getComponentsWithTemplateFile(fileName);
        const sortedComponents = Array.from(components).sort(tsDeclarationSortComparator);
        for (const component of sortedComponents) {
            if (!ts$1.isClassDeclaration(component)) {
                continue;
            }
            const template = templateTypeChecker.getTemplate(component);
            if (template === null) {
                continue;
            }
            return { template, component };
        }
        return undefined;
    }
    /**
     * Given an attribute node, converts it to string form.
     */
    function toAttributeString(attribute) {
        var _a, _b;
        if (attribute instanceof BoundEvent || attribute instanceof BoundAttribute) {
            return `[${attribute.name}]`;
        }
        else {
            return `[${attribute.name}=${(_b = (_a = attribute.valueSpan) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : ''}]`;
        }
    }
    function getNodeName(node) {
        return node instanceof Template ? node.tagName : node.name;
    }
    /**
     * Given a template or element node, returns all attributes on the node.
     */
    function getAttributes(node) {
        const attributes = [...node.attributes, ...node.inputs, ...node.outputs];
        if (node instanceof Template) {
            attributes.push(...node.templateAttrs);
        }
        return attributes;
    }
    /**
     * Given two `Set`s, returns all items in the `left` which do not appear in the `right`.
     */
    function difference(left, right) {
        const result = new Set();
        for (const dir of left) {
            if (!right.has(dir)) {
                result.add(dir);
            }
        }
        return result;
    }
    /**
     * Given an element or template, determines which directives match because the tag is present. For
     * example, if a directive selector is `div[myAttr]`, this would match div elements but would not if
     * the selector were just `[myAttr]`. We find which directives are applied because of this tag by
     * elimination: compare the directive matches with the tag present against the directive matches
     * without it. The difference would be the directives which match because the tag is present.
     *
     * @param element The element or template node that the attribute/tag is part of.
     * @param directives The list of directives to match against.
     * @returns The list of directives matching the tag name via the strategy described above.
     */
    // TODO(atscott): Add unit tests for this and the one for attributes
    function getDirectiveMatchesForElementTag(element, directives) {
        const attributes = getAttributes(element);
        const allAttrs = attributes.map(toAttributeString);
        const allDirectiveMatches = getDirectiveMatchesForSelector(directives, getNodeName(element) + allAttrs.join(''));
        const matchesWithoutElement = getDirectiveMatchesForSelector(directives, allAttrs.join(''));
        return difference(allDirectiveMatches, matchesWithoutElement);
    }
    function makeElementSelector(element) {
        const attributes = getAttributes(element);
        const allAttrs = attributes.map(toAttributeString);
        return getNodeName(element) + allAttrs.join('');
    }
    /**
     * Given an attribute name, determines which directives match because the attribute is present. We
     * find which directives are applied because of this attribute by elimination: compare the directive
     * matches with the attribute present against the directive matches without it. The difference would
     * be the directives which match because the attribute is present.
     *
     * @param name The name of the attribute
     * @param hostNode The node which the attribute appears on
     * @param directives The list of directives to match against.
     * @returns The list of directives matching the tag name via the strategy described above.
     */
    function getDirectiveMatchesForAttribute(name, hostNode, directives) {
        const attributes = getAttributes(hostNode);
        const allAttrs = attributes.map(toAttributeString);
        const allDirectiveMatches = getDirectiveMatchesForSelector(directives, getNodeName(hostNode) + allAttrs.join(''));
        const attrsExcludingName = attributes.filter(a => a.name !== name).map(toAttributeString);
        const matchesWithoutAttr = getDirectiveMatchesForSelector(directives, getNodeName(hostNode) + attrsExcludingName.join(''));
        return difference(allDirectiveMatches, matchesWithoutAttr);
    }
    /**
     * Given a list of directives and a text to use as a selector, returns the directives which match
     * for the selector.
     */
    function getDirectiveMatchesForSelector(directives, selector) {
        const selectors = CssSelector.parse(selector);
        if (selectors.length === 0) {
            return new Set();
        }
        return new Set(directives.filter((dir) => {
            if (dir.selector === null) {
                return false;
            }
            const matcher = new SelectorMatcher();
            matcher.addSelectables(CssSelector.parse(dir.selector));
            return selectors.some(selector => matcher.match(selector, null));
        }));
    }
    /**
     * Returns a new `ts.SymbolDisplayPart` array which has the alias imports from the tcb filtered
     * out, i.e. `i0.NgForOf`.
     */
    function filterAliasImports(displayParts) {
        const tcbAliasImportRegex = /i\d+/;
        function isImportAlias(part) {
            return part.kind === ALIAS_NAME && tcbAliasImportRegex.test(part.text);
        }
        function isDotPunctuation(part) {
            return part.kind === SYMBOL_PUNC && part.text === '.';
        }
        return displayParts.filter((part, i) => {
            const previousPart = displayParts[i - 1];
            const nextPart = displayParts[i + 1];
            const aliasNameFollowedByDot = isImportAlias(part) && nextPart !== undefined && isDotPunctuation(nextPart);
            const dotPrecededByAlias = isDotPunctuation(part) && previousPart !== undefined && isImportAlias(previousPart);
            return !aliasNameFollowedByDot && !dotPrecededByAlias;
        });
    }
    function isDollarEvent(n) {
        return n instanceof PropertyRead && n.name === '$event' &&
            n.receiver instanceof ImplicitReceiver && !(n.receiver instanceof ThisReceiver);
    }
    /**
     * Returns a new array formed by applying a given callback function to each element of the array,
     * and then flattening the result by one level.
     */
    function flatMap(items, f) {
        const results = [];
        for (const x of items) {
            results.push(...f(x));
        }
        return results;
    }
    function isTypeScriptFile(fileName) {
        return fileName.endsWith('.ts');
    }
    function isWithin(position, span) {
        let start, end;
        if (span instanceof ParseSourceSpan) {
            start = span.start.offset;
            end = span.end.offset;
        }
        else {
            start = span.start;
            end = span.end;
        }
        // Note both start and end are inclusive because we want to match conditions
        // like start and end where  is the cursor.
        return start <= position && position <= end;
    }
    /**
     * For a given location in a shim file, retrieves the corresponding file url for the template and
     * the span in the template.
     */
    function getTemplateLocationFromShimLocation(templateTypeChecker, shimPath, positionInShimFile) {
        const mapping = templateTypeChecker.getTemplateMappingAtShimLocation({ shimPath, positionInShimFile });
        if (mapping === null) {
            return null;
        }
        const { templateSourceMapping, span } = mapping;
        let templateUrl;
        if (templateSourceMapping.type === 'direct') {
            templateUrl = absoluteFromSourceFile(templateSourceMapping.node.getSourceFile());
        }
        else if (templateSourceMapping.type === 'external') {
            templateUrl = absoluteFrom(templateSourceMapping.templateUrl);
        }
        else {
            // This includes indirect mappings, which are difficult to map directly to the code
            // location. Diagnostics similarly return a synthetic template string for this case rather
            // than a real location.
            return null;
        }
        return { templateUrl, span };
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const PRE_COMPILED_STYLE_EXTENSIONS = ['.scss', '.sass', '.less', '.styl'];
    class LanguageServiceAdapter {
        constructor(project) {
            this.project = project;
            this.entryPoint = null;
            this.constructionDiagnostics = [];
            this.ignoreForEmit = new Set();
            this.factoryTracker = null; // no .ngfactory shims
            this.unifiedModulesHost = null; // only used in Bazel
            /**
             * Map of resource filenames to the version of the file last read via `readResource`.
             *
             * Used to implement `getModifiedResourceFiles`.
             */
            this.lastReadResourceVersion = new Map();
            this.rootDirs = getRootDirs(this, project.getCompilationSettings());
        }
        resourceNameToFileName(url, fromFile, fallbackResolve) {
            var _a;
            // If we are trying to resolve a `.css` file, see if we can find a pre-compiled file with the
            // same name instead. That way, we can provide go-to-definition for the pre-compiled files which
            // would generally be the desired behavior.
            if (url.endsWith('.css')) {
                const styleUrl = path.resolve(fromFile, '..', url);
                for (const ext of PRE_COMPILED_STYLE_EXTENSIONS) {
                    const precompiledFileUrl = styleUrl.replace(/\.css$/, ext);
                    if (this.fileExists(precompiledFileUrl)) {
                        return precompiledFileUrl;
                    }
                }
            }
            return (_a = fallbackResolve === null || fallbackResolve === void 0 ? void 0 : fallbackResolve(url, fromFile)) !== null && _a !== void 0 ? _a : null;
        }
        isShim(sf) {
            return isShim(sf);
        }
        fileExists(fileName) {
            return this.project.fileExists(fileName);
        }
        readFile(fileName) {
            return this.project.readFile(fileName);
        }
        getCurrentDirectory() {
            return this.project.getCurrentDirectory();
        }
        getCanonicalFileName(fileName) {
            return this.project.projectService.toCanonicalFileName(fileName);
        }
        /**
         * Return the real path of a symlink. This method is required in order to
         * resolve symlinks in node_modules.
         */
        realpath(path) {
            var _a, _b, _c;
            return (_c = (_b = (_a = this.project).realpath) === null || _b === void 0 ? void 0 : _b.call(_a, path)) !== null && _c !== void 0 ? _c : path;
        }
        /**
         * readResource() is an Angular-specific method for reading files that are not
         * managed by the TS compiler host, namely templates and stylesheets.
         * It is a method on ExtendedTsCompilerHost, see
         * packages/compiler-cli/src/ngtsc/core/api/src/interfaces.ts
         */
        readResource(fileName) {
            if (isTypeScriptFile(fileName)) {
                throw new Error(`readResource() should not be called on TS file: ${fileName}`);
            }
            // Calling getScriptSnapshot() will actually create a ScriptInfo if it does
            // not exist! The same applies for getScriptVersion().
            // getScriptInfo() will not create one if it does not exist.
            // In this case, we *want* a script info to be created so that we could
            // keep track of its version.
            const snapshot = this.project.getScriptSnapshot(fileName);
            if (!snapshot) {
                // This would fail if the file does not exist, or readFile() fails for
                // whatever reasons.
                throw new Error(`Failed to get script snapshot while trying to read ${fileName}`);
            }
            const version = this.project.getScriptVersion(fileName);
            this.lastReadResourceVersion.set(fileName, version);
            return snapshot.getText(0, snapshot.getLength());
        }
        getModifiedResourceFiles() {
            const modifiedFiles = new Set();
            for (const [fileName, oldVersion] of this.lastReadResourceVersion) {
                if (this.project.getScriptVersion(fileName) !== oldVersion) {
                    modifiedFiles.add(fileName);
                }
            }
            return modifiedFiles.size > 0 ? modifiedFiles : undefined;
        }
    }
    /**
     * Used to read configuration files.
     *
     * A language service parse configuration host is independent of the adapter
     * because signatures of calls like `FileSystem#readFile` are a bit stricter
     * than those on the adapter.
     */
    class LSParseConfigHost {
        constructor(serverHost) {
            this.serverHost = serverHost;
        }
        exists(path) {
            return this.serverHost.fileExists(path) || this.serverHost.directoryExists(path);
        }
        readFile(path) {
            const content = this.serverHost.readFile(path);
            if (content === undefined) {
                throw new Error(`LanguageServiceFS#readFile called on unavailable file ${path}`);
            }
            return content;
        }
        lstat(path) {
            return {
                isFile: () => {
                    return this.serverHost.fileExists(path);
                },
                isDirectory: () => {
                    return this.serverHost.directoryExists(path);
                },
                isSymbolicLink: () => {
                    throw new Error(`LanguageServiceFS#lstat#isSymbolicLink not implemented`);
                },
            };
        }
        pwd() {
            return this.serverHost.getCurrentDirectory();
        }
        extname(path$1) {
            return path.extname(path$1);
        }
        resolve(...paths) {
            return path.resolve(...paths);
        }
        dirname(file) {
            return path.dirname(file);
        }
        join(basePath, ...paths) {
            return path.join(basePath, ...paths);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Manages the `NgCompiler` instance which backs the language service, updating or replacing it as
     * needed to produce an up-to-date understanding of the current program.
     *
     * TODO(alxhub): currently the options used for the compiler are specified at `CompilerFactory`
     * construction, and are not changable. In a real project, users can update `tsconfig.json`. We need
     * to properly handle a change in the compiler options, either by having an API to update the
     * `CompilerFactory` to use new options, or by replacing it entirely.
     */
    class CompilerFactory {
        constructor(adapter, programStrategy, options) {
            this.adapter = adapter;
            this.programStrategy = programStrategy;
            this.options = options;
            this.incrementalStrategy = new TrackedIncrementalBuildStrategy();
            this.compiler = null;
        }
        getOrCreate() {
            var _a;
            const program = this.programStrategy.getProgram();
            const modifiedResourceFiles = new Set();
            for (const fileName of (_a = this.adapter.getModifiedResourceFiles()) !== null && _a !== void 0 ? _a : []) {
                modifiedResourceFiles.add(resolve(fileName));
            }
            if (this.compiler !== null && program === this.compiler.getCurrentProgram()) {
                if (modifiedResourceFiles.size > 0) {
                    // Only resource files have changed since the last NgCompiler was created.
                    const ticket = resourceChangeTicket(this.compiler, modifiedResourceFiles);
                    this.compiler = NgCompiler.fromTicket(ticket, this.adapter);
                }
                else {
                    // The previous NgCompiler is being reused, but we still want to reset its performance
                    // tracker to capture only the operations that are needed to service the current request.
                    this.compiler.perfRecorder.reset();
                }
                return this.compiler;
            }
            let ticket;
            if (this.compiler === null) {
                ticket = freshCompilationTicket(program, this.options, this.incrementalStrategy, this.programStrategy, 
                /* perfRecorder */ null, true, true);
            }
            else {
                ticket = incrementalFromCompilerTicket(this.compiler, program, this.incrementalStrategy, this.programStrategy, modifiedResourceFiles, /* perfRecorder */ null);
            }
            this.compiler = NgCompiler.fromTicket(ticket, this.adapter);
            return this.compiler;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Differentiates different kinds of `AttributeCompletion`s.
     */
    var AttributeCompletionKind;
    (function (AttributeCompletionKind) {
        /**
         * Completion of an attribute from the HTML schema.
         *
         * Attributes often have a corresponding DOM property of the same name.
         */
        AttributeCompletionKind[AttributeCompletionKind["DomAttribute"] = 0] = "DomAttribute";
        /**
         * Completion of a property from the DOM schema.
         *
         * `DomProperty` completions are generated only for properties which don't share their name with
         * an HTML attribute.
         */
        AttributeCompletionKind[AttributeCompletionKind["DomProperty"] = 1] = "DomProperty";
        /**
         * Completion of an attribute that results in a new directive being matched on an element.
         */
        AttributeCompletionKind[AttributeCompletionKind["DirectiveAttribute"] = 2] = "DirectiveAttribute";
        /**
         * Completion of an attribute that results in a new structural directive being matched on an
         * element.
         */
        AttributeCompletionKind[AttributeCompletionKind["StructuralDirectiveAttribute"] = 3] = "StructuralDirectiveAttribute";
        /**
         * Completion of an input from a directive which is either present on the element, or becomes
         * present after the addition of this attribute.
         */
        AttributeCompletionKind[AttributeCompletionKind["DirectiveInput"] = 4] = "DirectiveInput";
        /**
         * Completion of an output from a directive which is either present on the element, or becomes
         * present after the addition of this attribute.
         */
        AttributeCompletionKind[AttributeCompletionKind["DirectiveOutput"] = 5] = "DirectiveOutput";
    })(AttributeCompletionKind || (AttributeCompletionKind = {}));
    /**
     * Given an element and its context, produce a `Map` of all possible attribute completions.
     *
     * 3 kinds of attributes are considered for completion, from highest to lowest priority:
     *
     * 1. Inputs/outputs of directives present on the element already.
     * 2. Inputs/outputs of directives that are not present on the element, but which would become
     *    present if such a binding is added.
     * 3. Attributes from the DOM schema for the element.
     *
     * The priority of these options determines which completions are added to the `Map`. If a directive
     * input shares the same name as a DOM attribute, the `Map` will reflect the directive input
     * completion, not the DOM completion for that name.
     */
    function buildAttributeCompletionTable(component, element, checker) {
        const table = new Map();
        // Use the `ElementSymbol` or `TemplateSymbol` to iterate over directives present on the node, and
        // their inputs/outputs. These have the highest priority of completion results.
        const symbol = checker.getSymbolOfNode(element, component);
        const presentDirectives = new Set();
        if (symbol !== null) {
            // An `ElementSymbol` was available. This means inputs and outputs for directives on the
            // element can be added to the completion table.
            for (const dirSymbol of symbol.directives) {
                const directive = dirSymbol.tsSymbol.valueDeclaration;
                if (!ts$1.isClassDeclaration(directive)) {
                    continue;
                }
                presentDirectives.add(directive);
                const meta = checker.getDirectiveMetadata(directive);
                if (meta === null) {
                    continue;
                }
                for (const [classPropertyName, propertyName] of meta.inputs) {
                    if (table.has(propertyName)) {
                        continue;
                    }
                    table.set(propertyName, {
                        kind: AttributeCompletionKind.DirectiveInput,
                        propertyName,
                        directive: dirSymbol,
                        classPropertyName,
                        twoWayBindingSupported: meta.outputs.hasBindingPropertyName(propertyName + 'Change'),
                    });
                }
                for (const [classPropertyName, propertyName] of meta.outputs) {
                    if (table.has(propertyName)) {
                        continue;
                    }
                    table.set(propertyName, {
                        kind: AttributeCompletionKind.DirectiveOutput,
                        eventName: propertyName,
                        directive: dirSymbol,
                        classPropertyName,
                    });
                }
            }
        }
        // Next, explore hypothetical directives and determine if the addition of any single attributes
        // can cause the directive to match the element.
        const directivesInScope = checker.getDirectivesInScope(component);
        if (directivesInScope !== null) {
            const elementSelector = makeElementSelector(element);
            for (const dirInScope of directivesInScope) {
                const directive = dirInScope.tsSymbol.valueDeclaration;
                // Skip directives that are present on the element.
                if (!ts$1.isClassDeclaration(directive) || presentDirectives.has(directive)) {
                    continue;
                }
                const meta = checker.getDirectiveMetadata(directive);
                if (meta === null || meta.selector === null) {
                    continue;
                }
                if (!meta.isStructural) {
                    // For non-structural directives, the directive's attribute selector(s) are matched against
                    // a hypothetical version of the element with those attributes. A match indicates that
                    // adding that attribute/input/output binding would cause the directive to become present,
                    // meaning that such a binding is a valid completion.
                    const selectors = CssSelector.parse(meta.selector);
                    const matcher = new SelectorMatcher();
                    matcher.addSelectables(selectors);
                    for (const selector of selectors) {
                        for (const [attrName, attrValue] of selectorAttributes(selector)) {
                            if (attrValue !== '') {
                                // This attribute selector requires a value, which is not supported in completion.
                                continue;
                            }
                            if (table.has(attrName)) {
                                // Skip this attribute as there's already a binding for it.
                                continue;
                            }
                            // Check whether adding this attribute would cause the directive to start matching.
                            const newElementSelector = elementSelector + `[${attrName}]`;
                            if (!matcher.match(CssSelector.parse(newElementSelector)[0], null)) {
                                // Nope, move on with our lives.
                                continue;
                            }
                            // Adding this attribute causes a new directive to be matched. Decide how to categorize
                            // it based on the directive's inputs and outputs.
                            if (meta.inputs.hasBindingPropertyName(attrName)) {
                                // This attribute corresponds to an input binding.
                                table.set(attrName, {
                                    kind: AttributeCompletionKind.DirectiveInput,
                                    directive: dirInScope,
                                    propertyName: attrName,
                                    classPropertyName: meta.inputs.getByBindingPropertyName(attrName)[0].classPropertyName,
                                    twoWayBindingSupported: meta.outputs.hasBindingPropertyName(attrName + 'Change'),
                                });
                            }
                            else if (meta.outputs.hasBindingPropertyName(attrName)) {
                                // This attribute corresponds to an output binding.
                                table.set(attrName, {
                                    kind: AttributeCompletionKind.DirectiveOutput,
                                    directive: dirInScope,
                                    eventName: attrName,
                                    classPropertyName: meta.outputs.getByBindingPropertyName(attrName)[0].classPropertyName,
                                });
                            }
                            else {
                                // This attribute causes a new directive to be matched, but does not also correspond
                                // to an input or output binding.
                                table.set(attrName, {
                                    kind: AttributeCompletionKind.DirectiveAttribute,
                                    attribute: attrName,
                                    directive: dirInScope,
                                });
                            }
                        }
                    }
                }
                else {
                    // Hypothetically matching a structural directive is a litle different than a plain
                    // directive. Use of the '*' structural directive syntactic sugar means that the actual
                    // directive is applied to a plain <ng-template> node, not the existing element with any
                    // other attributes it might already have.
                    // Additionally, more than one attribute/input might need to be present in order for the
                    // directive to match (e.g. `ngFor` has a selector of `[ngFor][ngForOf]`). This gets a
                    // little tricky.
                    const structuralAttributes = getStructuralAttributes(meta);
                    for (const attrName of structuralAttributes) {
                        table.set(attrName, {
                            kind: AttributeCompletionKind.StructuralDirectiveAttribute,
                            attribute: attrName,
                            directive: dirInScope,
                        });
                    }
                }
            }
        }
        // Finally, add any DOM attributes not already covered by inputs.
        if (element instanceof Element) {
            for (const { attribute, property } of checker.getPotentialDomBindings(element.name)) {
                const isAlsoProperty = attribute === property;
                if (!table.has(attribute) && isAlsoProperty) {
                    table.set(attribute, {
                        kind: AttributeCompletionKind.DomAttribute,
                        attribute,
                        isAlsoProperty,
                    });
                }
            }
        }
        return table;
    }
    /**
     * Given an `AttributeCompletion`, add any available completions to a `ts.CompletionEntry` array of
     * results.
     *
     * The kind of completions generated depends on whether the current context is an attribute context
     * or not. For example, completing on `<element attr|>` will generate two results: `attribute` and
     * `[attribute]` - either a static attribute can be generated, or a property binding. However,
     * `<element [attr|]>` is not an attribute context, and so only the property completion `attribute`
     * is generated. Note that this completion does not have the `[]` property binding sugar as its
     * implicitly present in a property binding context (we're already completing within an `[attr|]`
     * expression).
     */
    function addAttributeCompletionEntries(entries, completion, isAttributeContext, isElementContext, replacementSpan) {
        switch (completion.kind) {
            case AttributeCompletionKind.DirectiveAttribute: {
                entries.push({
                    kind: unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.DIRECTIVE),
                    name: completion.attribute,
                    sortText: completion.attribute,
                    replacementSpan,
                });
                break;
            }
            case AttributeCompletionKind.StructuralDirectiveAttribute: {
                // In an element, the completion is offered with a leading '*' to activate the structural
                // directive. Once present, the structural attribute will be parsed as a template and not an
                // element, and the prefix is no longer necessary.
                const prefix = isElementContext ? '*' : '';
                entries.push({
                    kind: unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.DIRECTIVE),
                    name: prefix + completion.attribute,
                    sortText: prefix + completion.attribute,
                    replacementSpan,
                });
                break;
            }
            case AttributeCompletionKind.DirectiveInput: {
                if (isAttributeContext) {
                    // Offer a completion of a property binding.
                    entries.push({
                        kind: unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.PROPERTY),
                        name: `[${completion.propertyName}]`,
                        sortText: completion.propertyName,
                        replacementSpan,
                    });
                    // If the directive supports banana-in-a-box for this input, offer that as well.
                    if (completion.twoWayBindingSupported) {
                        entries.push({
                            kind: unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.PROPERTY),
                            name: `[(${completion.propertyName})]`,
                            // This completion should sort after the property binding.
                            sortText: completion.propertyName + '_1',
                            replacementSpan,
                        });
                    }
                    // Offer a completion of the input binding as an attribute.
                    entries.push({
                        kind: unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.ATTRIBUTE),
                        name: completion.propertyName,
                        // This completion should sort after both property binding options (one-way and two-way).
                        sortText: completion.propertyName + '_2',
                        replacementSpan,
                    });
                }
                else {
                    entries.push({
                        kind: unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.PROPERTY),
                        name: completion.propertyName,
                        sortText: completion.propertyName,
                        replacementSpan,
                    });
                }
                break;
            }
            case AttributeCompletionKind.DirectiveOutput: {
                if (isAttributeContext) {
                    entries.push({
                        kind: unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.EVENT),
                        name: `(${completion.eventName})`,
                        sortText: completion.eventName,
                        replacementSpan,
                    });
                }
                else {
                    entries.push({
                        kind: unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.EVENT),
                        name: completion.eventName,
                        sortText: completion.eventName,
                        replacementSpan,
                    });
                }
                break;
            }
            case AttributeCompletionKind.DomAttribute: {
                if (isAttributeContext && completion.isAlsoProperty) {
                    // Offer a completion of a property binding to the DOM property.
                    entries.push({
                        kind: unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.PROPERTY),
                        name: `[${completion.attribute}]`,
                        // In the case of DOM attributes, the property binding should sort after the attribute
                        // binding.
                        sortText: completion.attribute + '_1',
                        replacementSpan,
                    });
                }
                break;
            }
            case AttributeCompletionKind.DomProperty: {
                if (!isAttributeContext) {
                    entries.push({
                        kind: unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.PROPERTY),
                        name: completion.property,
                        sortText: completion.property,
                        replacementSpan,
                    });
                }
            }
        }
    }
    function getAttributeCompletionSymbol(completion, checker) {
        var _a;
        switch (completion.kind) {
            case AttributeCompletionKind.DomAttribute:
            case AttributeCompletionKind.DomProperty:
                return null;
            case AttributeCompletionKind.DirectiveAttribute:
            case AttributeCompletionKind.StructuralDirectiveAttribute:
                return completion.directive.tsSymbol;
            case AttributeCompletionKind.DirectiveInput:
            case AttributeCompletionKind.DirectiveOutput:
                return (_a = checker.getDeclaredTypeOfSymbol(completion.directive.tsSymbol)
                    .getProperty(completion.classPropertyName)) !== null && _a !== void 0 ? _a : null;
        }
    }
    /**
     * Iterates over `CssSelector` attributes, which are internally represented in a zipped array style
     * which is not conducive to straightforward iteration.
     */
    function* selectorAttributes(selector) {
        for (let i = 0; i < selector.attrs.length; i += 2) {
            yield [selector.attrs[0], selector.attrs[1]];
        }
    }
    function getStructuralAttributes(meta) {
        if (meta.selector === null) {
            return [];
        }
        const structuralAttributes = [];
        const selectors = CssSelector.parse(meta.selector);
        for (const selector of selectors) {
            if (selector.element !== null && selector.element !== 'ng-template') {
                // This particular selector does not apply under structural directive syntax.
                continue;
            }
            // Every attribute of this selector must be name-only - no required values.
            const attributeSelectors = Array.from(selectorAttributes(selector));
            if (!attributeSelectors.every(([_, attrValue]) => attrValue === '')) {
                continue;
            }
            // Get every named selector.
            const attributes = attributeSelectors.map(([attrName, _]) => attrName);
            // Find the shortest attribute. This is the structural directive "base", and all potential
            // input bindings must begin with the base. E.g. in `*ngFor="let a of b"`, `ngFor` is the
            // base attribute, and the `of` binding key corresponds to an input of `ngForOf`.
            const baseAttr = attributes.reduce((prev, curr) => prev === null || curr.length < prev.length ? curr : prev, null);
            if (baseAttr === null) {
                // No attributes in this selector?
                continue;
            }
            // Validate that the attributes are compatible with use as a structural directive.
            const isValid = (attr) => {
                // The base attribute is valid by default.
                if (attr === baseAttr) {
                    return true;
                }
                // Non-base attributes must all be prefixed with the base attribute.
                if (!attr.startsWith(baseAttr)) {
                    return false;
                }
                // Non-base attributes must also correspond to directive inputs.
                if (!meta.inputs.hasBindingPropertyName(attr)) {
                    return false;
                }
                // This attribute is compatible.
                return true;
            };
            if (!attributes.every(isValid)) {
                continue;
            }
            // This attribute is valid as a structural attribute for this directive.
            structuralAttributes.push(baseAttr);
        }
        return structuralAttributes;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Differentiates the various kinds of `TargetNode`s.
     */
    var TargetNodeKind;
    (function (TargetNodeKind) {
        TargetNodeKind[TargetNodeKind["RawExpression"] = 0] = "RawExpression";
        TargetNodeKind[TargetNodeKind["MethodCallExpressionInArgContext"] = 1] = "MethodCallExpressionInArgContext";
        TargetNodeKind[TargetNodeKind["RawTemplateNode"] = 2] = "RawTemplateNode";
        TargetNodeKind[TargetNodeKind["ElementInTagContext"] = 3] = "ElementInTagContext";
        TargetNodeKind[TargetNodeKind["ElementInBodyContext"] = 4] = "ElementInBodyContext";
        TargetNodeKind[TargetNodeKind["AttributeInKeyContext"] = 5] = "AttributeInKeyContext";
        TargetNodeKind[TargetNodeKind["AttributeInValueContext"] = 6] = "AttributeInValueContext";
        TargetNodeKind[TargetNodeKind["TwoWayBindingContext"] = 7] = "TwoWayBindingContext";
    })(TargetNodeKind || (TargetNodeKind = {}));
    /**
     * Special marker AST that can be used when the cursor is within the `sourceSpan` but not
     * the key or value span of a node with key/value spans.
     */
    class OutsideKeyValueMarkerAst extends AST {
        visit() {
            return null;
        }
    }
    /**
     * This special marker is added to the path when the cursor is within the sourceSpan but not the key
     * or value span of a node with key/value spans.
     */
    const OUTSIDE_K_V_MARKER = new OutsideKeyValueMarkerAst(new ParseSpan(-1, -1), new AbsoluteSourceSpan(-1, -1));
    /**
     * Return the template AST node or expression AST node that most accurately
     * represents the node at the specified cursor `position`.
     *
     * @param template AST tree of the template
     * @param position target cursor position
     */
    function getTargetAtPosition(template, position) {
        const path = TemplateTargetVisitor.visitTemplate(template, position);
        if (path.length === 0) {
            return null;
        }
        const candidate = path[path.length - 1];
        // Walk up the result nodes to find the nearest `t.Template` which contains the targeted node.
        let context = null;
        for (let i = path.length - 2; i >= 0; i--) {
            const node = path[i];
            if (node instanceof Template) {
                context = node;
                break;
            }
        }
        // Given the candidate node, determine the full targeted context.
        let nodeInContext;
        if ((candidate instanceof MethodCall || candidate instanceof SafeMethodCall) &&
            isWithin(position, candidate.argumentSpan)) {
            nodeInContext = {
                kind: TargetNodeKind.MethodCallExpressionInArgContext,
                node: candidate,
            };
        }
        else if (candidate instanceof AST) {
            const parents = path.filter((value) => value instanceof AST);
            // Remove the current node from the parents list.
            parents.pop();
            nodeInContext = {
                kind: TargetNodeKind.RawExpression,
                node: candidate,
                parents,
            };
        }
        else if (candidate instanceof Element) {
            // Elements have two contexts: the tag context (position is within the element tag) or the
            // element body context (position is outside of the tag name, but still in the element).
            // Calculate the end of the element tag name. Any position beyond this is in the element body.
            const tagEndPos = candidate.sourceSpan.start.offset + 1 /* '<' element open */ + candidate.name.length;
            if (position > tagEndPos) {
                // Position is within the element body
                nodeInContext = {
                    kind: TargetNodeKind.ElementInBodyContext,
                    node: candidate,
                };
            }
            else {
                nodeInContext = {
                    kind: TargetNodeKind.ElementInTagContext,
                    node: candidate,
                };
            }
        }
        else if ((candidate instanceof BoundAttribute || candidate instanceof BoundEvent ||
            candidate instanceof TextAttribute) &&
            candidate.keySpan !== undefined) {
            const previousCandidate = path[path.length - 2];
            if (candidate instanceof BoundEvent && previousCandidate instanceof BoundAttribute &&
                candidate.name === previousCandidate.name + 'Change') {
                const boundAttribute = previousCandidate;
                const boundEvent = candidate;
                nodeInContext = {
                    kind: TargetNodeKind.TwoWayBindingContext,
                    nodes: [boundAttribute, boundEvent],
                };
            }
            else if (isWithin(position, candidate.keySpan)) {
                nodeInContext = {
                    kind: TargetNodeKind.AttributeInKeyContext,
                    node: candidate,
                };
            }
            else {
                nodeInContext = {
                    kind: TargetNodeKind.AttributeInValueContext,
                    node: candidate,
                };
            }
        }
        else {
            nodeInContext = {
                kind: TargetNodeKind.RawTemplateNode,
                node: candidate,
            };
        }
        let parent = null;
        if (nodeInContext.kind === TargetNodeKind.TwoWayBindingContext && path.length >= 3) {
            parent = path[path.length - 3];
        }
        else if (path.length >= 2) {
            parent = path[path.length - 2];
        }
        return { position, context: nodeInContext, template: context, parent };
    }
    /**
     * Visitor which, given a position and a template, identifies the node within the template at that
     * position, as well as records the path of increasingly nested nodes that were traversed to reach
     * that position.
     */
    class TemplateTargetVisitor {
        // Position must be absolute in the source file.
        constructor(position) {
            this.position = position;
            // We need to keep a path instead of the last node because we might need more
            // context for the last node, for example what is the parent node?
            this.path = [];
        }
        static visitTemplate(template, position) {
            const visitor = new TemplateTargetVisitor(position);
            visitor.visitAll(template);
            const { path } = visitor;
            const strictPath = path.filter(v => v !== OUTSIDE_K_V_MARKER);
            const candidate = strictPath[strictPath.length - 1];
            const matchedASourceSpanButNotAKvSpan = path.some(v => v === OUTSIDE_K_V_MARKER);
            if (matchedASourceSpanButNotAKvSpan &&
                (candidate instanceof Template || candidate instanceof Element)) {
                // Template nodes with key and value spans are always defined on a `t.Template` or
                // `t.Element`. If we found a node on a template with a `sourceSpan` that includes the cursor,
                // it is possible that we are outside the k/v spans (i.e. in-between them). If this is the
                // case and we do not have any other candidate matches on the `t.Element` or `t.Template`, we
                // want to return no results. Otherwise, the `t.Element`/`t.Template` result is incorrect for
                // that cursor position.
                return [];
            }
            return strictPath;
        }
        visit(node) {
            const { start, end } = getSpanIncludingEndTag(node);
            if (end !== null && !isWithin(this.position, { start, end })) {
                return;
            }
            const last = this.path[this.path.length - 1];
            const withinKeySpanOfLastNode = last && isTemplateNodeWithKeyAndValue(last) && isWithin(this.position, last.keySpan);
            const withinKeySpanOfCurrentNode = isTemplateNodeWithKeyAndValue(node) && isWithin(this.position, node.keySpan);
            if (withinKeySpanOfLastNode && !withinKeySpanOfCurrentNode) {
                // We've already identified that we are within a `keySpan` of a node.
                // Unless we are _also_ in the `keySpan` of the current node (happens with two way bindings),
                // we should stop processing nodes at this point to prevent matching any other nodes. This can
                // happen when the end span of a different node touches the start of the keySpan for the
                // candidate node. Because our `isWithin` logic is inclusive on both ends, we can match both
                // nodes.
                return;
            }
            if (isTemplateNodeWithKeyAndValue(node) && !isWithinKeyValue(this.position, node)) {
                // If cursor is within source span but not within key span or value span,
                // do not return the node.
                this.path.push(OUTSIDE_K_V_MARKER);
            }
            else {
                this.path.push(node);
                node.visit(this);
            }
        }
        visitElement(element) {
            this.visitElementOrTemplate(element);
        }
        visitTemplate(template) {
            this.visitElementOrTemplate(template);
        }
        visitElementOrTemplate(element) {
            this.visitAll(element.attributes);
            this.visitAll(element.inputs);
            this.visitAll(element.outputs);
            if (element instanceof Template) {
                this.visitAll(element.templateAttrs);
            }
            this.visitAll(element.references);
            if (element instanceof Template) {
                this.visitAll(element.variables);
            }
            // If we get here and have not found a candidate node on the element itself, proceed with
            // looking for a more specific node on the element children.
            if (this.path[this.path.length - 1] !== element) {
                return;
            }
            this.visitAll(element.children);
        }
        visitContent(content) {
            visitAll(this, content.attributes);
        }
        visitVariable(variable) {
            // Variable has no template nodes or expression nodes.
        }
        visitReference(reference) {
            // Reference has no template nodes or expression nodes.
        }
        visitTextAttribute(attribute) {
            // Text attribute has no template nodes or expression nodes.
        }
        visitBoundAttribute(attribute) {
            const visitor = new ExpressionVisitor$1(this.position);
            visitor.visit(attribute.value, this.path);
        }
        visitBoundEvent(event) {
            // An event binding with no value (e.g. `(event|)`) parses to a `BoundEvent` with a
            // `LiteralPrimitive` handler with value `'ERROR'`, as opposed to a property binding with no
            // value which has an `EmptyExpr` as its value. This is a synthetic node created by the binding
            // parser, and is not suitable to use for Language Service analysis. Skip it.
            //
            // TODO(alxhub): modify the parser to generate an `EmptyExpr` instead.
            let handler = event.handler;
            if (handler instanceof ASTWithSource) {
                handler = handler.ast;
            }
            if (handler instanceof LiteralPrimitive && handler.value === 'ERROR') {
                return;
            }
            const visitor = new ExpressionVisitor$1(this.position);
            visitor.visit(event.handler, this.path);
        }
        visitText(text) {
            // Text has no template nodes or expression nodes.
        }
        visitBoundText(text) {
            const visitor = new ExpressionVisitor$1(this.position);
            visitor.visit(text.value, this.path);
        }
        visitIcu(icu) {
            for (const boundText of Object.values(icu.vars)) {
                this.visit(boundText);
            }
            for (const boundTextOrText of Object.values(icu.placeholders)) {
                this.visit(boundTextOrText);
            }
        }
        visitAll(nodes) {
            for (const node of nodes) {
                this.visit(node);
            }
        }
    }
    class ExpressionVisitor$1 extends RecursiveAstVisitor {
        // Position must be absolute in the source file.
        constructor(position) {
            super();
            this.position = position;
        }
        visit(node, path) {
            if (node instanceof ASTWithSource) {
                // In order to reduce noise, do not include `ASTWithSource` in the path.
                // For the purpose of source spans, there is no difference between
                // `ASTWithSource` and and underlying node that it wraps.
                node = node.ast;
            }
            // The third condition is to account for the implicit receiver, which should
            // not be visited.
            if (isWithin(this.position, node.sourceSpan) && !(node instanceof ImplicitReceiver)) {
                path.push(node);
                node.visit(this, path);
            }
        }
    }
    function getSpanIncludingEndTag(ast) {
        const result = {
            start: ast.sourceSpan.start.offset,
            end: ast.sourceSpan.end.offset,
        };
        // For Element and Template node, sourceSpan.end is the end of the opening
        // tag. For the purpose of language service, we need to actually recognize
        // the end of the closing tag. Otherwise, for situation like
        // <my-component></my-component> where the cursor is in the closing tag
        // we will not be able to return any information.
        if (ast instanceof Element || ast instanceof Template) {
            if (ast.endSourceSpan) {
                result.end = ast.endSourceSpan.end.offset;
            }
            else if (ast.children.length > 0) {
                // If the AST has children but no end source span, then it is an unclosed element with an end
                // that should be the end of the last child.
                result.end = getSpanIncludingEndTag(ast.children[ast.children.length - 1]).end;
            }
        }
        return result;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var CompletionNodeContext;
    (function (CompletionNodeContext) {
        CompletionNodeContext[CompletionNodeContext["None"] = 0] = "None";
        CompletionNodeContext[CompletionNodeContext["ElementTag"] = 1] = "ElementTag";
        CompletionNodeContext[CompletionNodeContext["ElementAttributeKey"] = 2] = "ElementAttributeKey";
        CompletionNodeContext[CompletionNodeContext["ElementAttributeValue"] = 3] = "ElementAttributeValue";
        CompletionNodeContext[CompletionNodeContext["EventValue"] = 4] = "EventValue";
        CompletionNodeContext[CompletionNodeContext["TwoWayBinding"] = 5] = "TwoWayBinding";
    })(CompletionNodeContext || (CompletionNodeContext = {}));
    /**
     * Performs autocompletion operations on a given node in the template.
     *
     * This class acts as a closure around all of the context required to perform the 3 autocompletion
     * operations (completions, get details, and get symbol) at a specific node.
     *
     * The generic `N` type for the template node is narrowed internally for certain operations, as the
     * compiler operations required to implement completion may be different for different node types.
     *
     * @param N type of the template node in question, narrowed accordingly.
     */
    class CompletionBuilder {
        constructor(tsLS, compiler, component, node, targetDetails) {
            this.tsLS = tsLS;
            this.compiler = compiler;
            this.component = component;
            this.node = node;
            this.targetDetails = targetDetails;
            this.typeChecker = this.compiler.getCurrentProgram().getTypeChecker();
            this.templateTypeChecker = this.compiler.getTemplateTypeChecker();
            this.nodeParent = this.targetDetails.parent;
            this.nodeContext = nodeContextFromTarget(this.targetDetails.context);
            this.template = this.targetDetails.template;
            this.position = this.targetDetails.position;
        }
        /**
         * Analogue for `ts.LanguageService.getCompletionsAtPosition`.
         */
        getCompletionsAtPosition(options) {
            if (this.isPropertyExpressionCompletion()) {
                return this.getPropertyExpressionCompletion(options);
            }
            else if (this.isElementTagCompletion()) {
                return this.getElementTagCompletion();
            }
            else if (this.isElementAttributeCompletion()) {
                return this.getElementAttributeCompletions();
            }
            else if (this.isPipeCompletion()) {
                return this.getPipeCompletions();
            }
            else if (this.isLiteralCompletion()) {
                return this.getLiteralCompletions(options);
            }
            else {
                return undefined;
            }
        }
        isLiteralCompletion() {
            return this.node instanceof LiteralPrimitive ||
                (this.node instanceof TextAttribute &&
                    this.nodeContext === CompletionNodeContext.ElementAttributeValue);
        }
        getLiteralCompletions(options) {
            const location = this.compiler.getTemplateTypeChecker().getLiteralCompletionLocation(this.node, this.component);
            if (location === null) {
                return undefined;
            }
            const tsResults = this.tsLS.getCompletionsAtPosition(location.shimPath, location.positionInShimFile, options);
            if (tsResults === undefined) {
                return undefined;
            }
            let replacementSpan;
            if (this.node instanceof TextAttribute && this.node.value.length > 0 && this.node.valueSpan) {
                replacementSpan = {
                    start: this.node.valueSpan.start.offset,
                    length: this.node.value.length,
                };
            }
            if (this.node instanceof LiteralPrimitive) {
                if (typeof this.node.value === 'string' && this.node.value.length > 0) {
                    replacementSpan = {
                        // The sourceSpan of `LiteralPrimitive` includes the open quote and the completion entries
                        // don't, so skip the open quote here.
                        start: this.node.sourceSpan.start + 1,
                        length: this.node.value.length,
                    };
                }
                else if (typeof this.node.value === 'number') {
                    replacementSpan = {
                        start: this.node.sourceSpan.start,
                        length: this.node.value.toString().length,
                    };
                }
            }
            let ngResults = [];
            for (const result of tsResults.entries) {
                if (this.isValidNodeContextCompletion(result)) {
                    ngResults.push(Object.assign(Object.assign({}, result), { replacementSpan }));
                }
            }
            return Object.assign(Object.assign({}, tsResults), { entries: ngResults });
        }
        /**
         * Analogue for `ts.LanguageService.getCompletionEntryDetails`.
         */
        getCompletionEntryDetails(entryName, formatOptions, preferences, data) {
            if (this.isPropertyExpressionCompletion()) {
                return this.getPropertyExpressionCompletionDetails(entryName, formatOptions, preferences, data);
            }
            else if (this.isElementTagCompletion()) {
                return this.getElementTagCompletionDetails(entryName);
            }
            else if (this.isElementAttributeCompletion()) {
                return this.getElementAttributeCompletionDetails(entryName);
            }
        }
        /**
         * Analogue for `ts.LanguageService.getCompletionEntrySymbol`.
         */
        getCompletionEntrySymbol(name) {
            if (this.isPropertyExpressionCompletion()) {
                return this.getPropertyExpressionCompletionSymbol(name);
            }
            else if (this.isElementTagCompletion()) {
                return this.getElementTagCompletionSymbol(name);
            }
            else if (this.isElementAttributeCompletion()) {
                return this.getElementAttributeCompletionSymbol(name);
            }
            else {
                return undefined;
            }
        }
        /**
         * Determine if the current node is the completion of a property expression, and narrow the type
         * of `this.node` if so.
         *
         * This narrowing gives access to additional methods related to completion of property
         * expressions.
         */
        isPropertyExpressionCompletion() {
            return this.node instanceof PropertyRead || this.node instanceof MethodCall ||
                this.node instanceof SafePropertyRead || this.node instanceof SafeMethodCall ||
                this.node instanceof PropertyWrite || this.node instanceof EmptyExpr ||
                // BoundEvent nodes only count as property completions if in an EventValue context.
                (this.node instanceof BoundEvent && this.nodeContext === CompletionNodeContext.EventValue);
        }
        /**
         * Get completions for property expressions.
         */
        getPropertyExpressionCompletion(options) {
            if (this.node instanceof EmptyExpr || this.node instanceof BoundEvent ||
                this.node.receiver instanceof ImplicitReceiver) {
                return this.getGlobalPropertyExpressionCompletion(options);
            }
            else {
                const location = this.compiler.getTemplateTypeChecker().getExpressionCompletionLocation(this.node, this.component);
                if (location === null) {
                    return undefined;
                }
                const tsResults = this.tsLS.getCompletionsAtPosition(location.shimPath, location.positionInShimFile, options);
                if (tsResults === undefined) {
                    return undefined;
                }
                const replacementSpan = makeReplacementSpanFromAst(this.node);
                let ngResults = [];
                for (const result of tsResults.entries) {
                    ngResults.push(Object.assign(Object.assign({}, result), { replacementSpan }));
                }
                return Object.assign(Object.assign({}, tsResults), { entries: ngResults });
            }
        }
        /**
         * Get the details of a specific completion for a property expression.
         */
        getPropertyExpressionCompletionDetails(entryName, formatOptions, preferences, data) {
            let details = undefined;
            if (this.node instanceof EmptyExpr || this.node instanceof BoundEvent ||
                this.node.receiver instanceof ImplicitReceiver) {
                details = this.getGlobalPropertyExpressionCompletionDetails(entryName, formatOptions, preferences, data);
            }
            else {
                const location = this.compiler.getTemplateTypeChecker().getExpressionCompletionLocation(this.node, this.component);
                if (location === null) {
                    return undefined;
                }
                details = this.tsLS.getCompletionEntryDetails(location.shimPath, location.positionInShimFile, entryName, formatOptions, 
                /* source */ undefined, preferences, data);
            }
            if (details !== undefined) {
                details.displayParts = filterAliasImports(details.displayParts);
            }
            return details;
        }
        /**
         * Get the `ts.Symbol` for a specific completion for a property expression.
         */
        getPropertyExpressionCompletionSymbol(name) {
            if (this.node instanceof EmptyExpr || this.node instanceof LiteralPrimitive ||
                this.node instanceof BoundEvent || this.node.receiver instanceof ImplicitReceiver) {
                return this.getGlobalPropertyExpressionCompletionSymbol(name);
            }
            else {
                const location = this.compiler.getTemplateTypeChecker().getExpressionCompletionLocation(this.node, this.component);
                if (location === null) {
                    return undefined;
                }
                return this.tsLS.getCompletionEntrySymbol(location.shimPath, location.positionInShimFile, name, /* source */ undefined);
            }
        }
        /**
         * Get completions for a property expression in a global context (e.g. `{{y|}}`).
         */
        getGlobalPropertyExpressionCompletion(options) {
            const completions = this.templateTypeChecker.getGlobalCompletions(this.template, this.component, this.node);
            if (completions === null) {
                return undefined;
            }
            const { componentContext, templateContext, nodeContext: astContext } = completions;
            const replacementSpan = makeReplacementSpanFromAst(this.node);
            // Merge TS completion results with results from the template scope.
            let entries = [];
            const componentCompletions = this.tsLS.getCompletionsAtPosition(componentContext.shimPath, componentContext.positionInShimFile, options);
            if (componentCompletions !== undefined) {
                for (const tsCompletion of componentCompletions.entries) {
                    // Skip completions that are shadowed by a template entity definition.
                    if (templateContext.has(tsCompletion.name)) {
                        continue;
                    }
                    entries.push(Object.assign(Object.assign({}, tsCompletion), { 
                        // Substitute the TS completion's `replacementSpan` (which uses offsets within the TCB)
                        // with the `replacementSpan` within the template source.
                        replacementSpan }));
                }
            }
            // Merge TS completion results with results from the ast context.
            if (astContext !== null) {
                const nodeCompletions = this.tsLS.getCompletionsAtPosition(astContext.shimPath, astContext.positionInShimFile, options);
                if (nodeCompletions !== undefined) {
                    for (const tsCompletion of nodeCompletions.entries) {
                        if (this.isValidNodeContextCompletion(tsCompletion)) {
                            entries.push(Object.assign(Object.assign({}, tsCompletion), { 
                                // Substitute the TS completion's `replacementSpan` (which uses offsets within the
                                // TCB) with the `replacementSpan` within the template source.
                                replacementSpan }));
                        }
                    }
                }
            }
            for (const [name, entity] of templateContext) {
                entries.push({
                    name,
                    sortText: name,
                    replacementSpan,
                    kindModifiers: ts$1.ScriptElementKindModifier.none,
                    kind: unsafeCastDisplayInfoKindToScriptElementKind(entity.kind === CompletionKind.Reference ? DisplayInfoKind.REFERENCE :
                        DisplayInfoKind.VARIABLE),
                });
            }
            return {
                entries,
                // Although this completion is "global" in the sense of an Angular expression (there is no
                // explicit receiver), it is not "global" in a TypeScript sense since Angular expressions have
                // the component as an implicit receiver.
                isGlobalCompletion: false,
                isMemberCompletion: true,
                isNewIdentifierLocation: false,
            };
        }
        /**
         * Get the details of a specific completion for a property expression in a global context (e.g.
         * `{{y|}}`).
         */
        getGlobalPropertyExpressionCompletionDetails(entryName, formatOptions, preferences, data) {
            const completions = this.templateTypeChecker.getGlobalCompletions(this.template, this.component, this.node);
            if (completions === null) {
                return undefined;
            }
            const { componentContext, templateContext } = completions;
            if (templateContext.has(entryName)) {
                const entry = templateContext.get(entryName);
                // Entries that reference a symbol in the template context refer either to local references or
                // variables.
                const symbol = this.templateTypeChecker.getSymbolOfNode(entry.node, this.component);
                if (symbol === null) {
                    return undefined;
                }
                const { kind, displayParts, documentation } = getSymbolDisplayInfo(this.tsLS, this.typeChecker, symbol);
                return {
                    kind: unsafeCastDisplayInfoKindToScriptElementKind(kind),
                    name: entryName,
                    kindModifiers: ts$1.ScriptElementKindModifier.none,
                    displayParts,
                    documentation,
                };
            }
            else {
                return this.tsLS.getCompletionEntryDetails(componentContext.shimPath, componentContext.positionInShimFile, entryName, formatOptions, 
                /* source */ undefined, preferences, data);
            }
        }
        /**
         * Get the `ts.Symbol` of a specific completion for a property expression in a global context
         * (e.g.
         * `{{y|}}`).
         */
        getGlobalPropertyExpressionCompletionSymbol(entryName) {
            const completions = this.templateTypeChecker.getGlobalCompletions(this.template, this.component, this.node);
            if (completions === null) {
                return undefined;
            }
            const { componentContext, templateContext } = completions;
            if (templateContext.has(entryName)) {
                const node = templateContext.get(entryName).node;
                const symbol = this.templateTypeChecker.getSymbolOfNode(node, this.component);
                if (symbol === null || symbol.tsSymbol === null) {
                    return undefined;
                }
                return symbol.tsSymbol;
            }
            else {
                return this.tsLS.getCompletionEntrySymbol(componentContext.shimPath, componentContext.positionInShimFile, entryName, 
                /* source */ undefined);
            }
        }
        isElementTagCompletion() {
            if (this.node instanceof Text) {
                const positionInTextNode = this.position - this.node.sourceSpan.start.offset;
                // We only provide element completions in a text node when there is an open tag immediately to
                // the left of the position.
                return this.node.value.substring(0, positionInTextNode).endsWith('<');
            }
            else if (this.node instanceof Element) {
                return this.nodeContext === CompletionNodeContext.ElementTag;
            }
            return false;
        }
        getElementTagCompletion() {
            const templateTypeChecker = this.compiler.getTemplateTypeChecker();
            let start;
            let length;
            if (this.node instanceof Element) {
                // The replacementSpan is the tag name.
                start = this.node.sourceSpan.start.offset + 1; // account for leading '<'
                length = this.node.name.length;
            }
            else {
                const positionInTextNode = this.position - this.node.sourceSpan.start.offset;
                const textToLeftOfPosition = this.node.value.substring(0, positionInTextNode);
                start = this.node.sourceSpan.start.offset + textToLeftOfPosition.lastIndexOf('<') + 1;
                // We only autocomplete immediately after the < so we don't replace any existing text
                length = 0;
            }
            const replacementSpan = { start, length };
            let potentialTags = Array.from(templateTypeChecker.getPotentialElementTags(this.component));
            // Don't provide non-Angular tags (directive === null) because we expect other extensions (i.e.
            // Emmet) to provide those for HTML files.
            potentialTags = potentialTags.filter(([_, directive]) => directive !== null);
            const entries = potentialTags.map(([tag, directive]) => ({
                kind: tagCompletionKind(directive),
                name: tag,
                sortText: tag,
                replacementSpan,
            }));
            return {
                entries,
                isGlobalCompletion: false,
                isMemberCompletion: false,
                isNewIdentifierLocation: false,
            };
        }
        getElementTagCompletionDetails(entryName) {
            const templateTypeChecker = this.compiler.getTemplateTypeChecker();
            const tagMap = templateTypeChecker.getPotentialElementTags(this.component);
            if (!tagMap.has(entryName)) {
                return undefined;
            }
            const directive = tagMap.get(entryName);
            let displayParts;
            let documentation = undefined;
            if (directive === null) {
                displayParts = [];
            }
            else {
                const displayInfo = getDirectiveDisplayInfo(this.tsLS, directive);
                displayParts = displayInfo.displayParts;
                documentation = displayInfo.documentation;
            }
            return {
                kind: tagCompletionKind(directive),
                name: entryName,
                kindModifiers: ts$1.ScriptElementKindModifier.none,
                displayParts,
                documentation,
            };
        }
        getElementTagCompletionSymbol(entryName) {
            const templateTypeChecker = this.compiler.getTemplateTypeChecker();
            const tagMap = templateTypeChecker.getPotentialElementTags(this.component);
            if (!tagMap.has(entryName)) {
                return undefined;
            }
            const directive = tagMap.get(entryName);
            return directive === null || directive === void 0 ? void 0 : directive.tsSymbol;
        }
        isElementAttributeCompletion() {
            return (this.nodeContext === CompletionNodeContext.ElementAttributeKey ||
                this.nodeContext === CompletionNodeContext.TwoWayBinding) &&
                (this.node instanceof Element || this.node instanceof BoundAttribute ||
                    this.node instanceof TextAttribute || this.node instanceof BoundEvent);
        }
        getElementAttributeCompletions() {
            let element;
            if (this.node instanceof Element) {
                element = this.node;
            }
            else if (this.nodeParent instanceof Element || this.nodeParent instanceof Template) {
                element = this.nodeParent;
            }
            else {
                // Nothing to do without an element to process.
                return undefined;
            }
            let replacementSpan = undefined;
            if ((this.node instanceof BoundAttribute || this.node instanceof BoundEvent ||
                this.node instanceof TextAttribute) &&
                this.node.keySpan !== undefined) {
                replacementSpan = makeReplacementSpanFromParseSourceSpan(this.node.keySpan);
            }
            const attrTable = buildAttributeCompletionTable(this.component, element, this.compiler.getTemplateTypeChecker());
            let entries = [];
            for (const completion of attrTable.values()) {
                // First, filter out completions that don't make sense for the current node. For example, if
                // the user is completing on a property binding `[foo|]`, don't offer output event
                // completions.
                switch (completion.kind) {
                    case AttributeCompletionKind.DomAttribute:
                    case AttributeCompletionKind.DomProperty:
                        if (this.node instanceof BoundEvent) {
                            continue;
                        }
                        break;
                    case AttributeCompletionKind.DirectiveInput:
                        if (this.node instanceof BoundEvent) {
                            continue;
                        }
                        if (!completion.twoWayBindingSupported &&
                            this.nodeContext === CompletionNodeContext.TwoWayBinding) {
                            continue;
                        }
                        break;
                    case AttributeCompletionKind.DirectiveOutput:
                        if (this.node instanceof BoundAttribute) {
                            continue;
                        }
                        break;
                    case AttributeCompletionKind.DirectiveAttribute:
                        if (this.node instanceof BoundAttribute ||
                            this.node instanceof BoundEvent) {
                            continue;
                        }
                        break;
                }
                // Is the completion in an attribute context (instead of a property context)?
                const isAttributeContext = (this.node instanceof Element || this.node instanceof TextAttribute);
                // Is the completion for an element (not an <ng-template>)?
                const isElementContext = this.node instanceof Element || this.nodeParent instanceof Element;
                addAttributeCompletionEntries(entries, completion, isAttributeContext, isElementContext, replacementSpan);
            }
            return {
                entries,
                isGlobalCompletion: false,
                isMemberCompletion: false,
                isNewIdentifierLocation: true,
            };
        }
        getElementAttributeCompletionDetails(entryName) {
            // `entryName` here may be `foo` or `[foo]`, depending on which suggested completion the user
            // chose. Strip off any binding syntax to get the real attribute name.
            const { name, kind } = stripBindingSugar(entryName);
            let element;
            if (this.node instanceof Element || this.node instanceof Template) {
                element = this.node;
            }
            else if (this.nodeParent instanceof Element || this.nodeParent instanceof Template) {
                element = this.nodeParent;
            }
            else {
                // Nothing to do without an element to process.
                return undefined;
            }
            const attrTable = buildAttributeCompletionTable(this.component, element, this.compiler.getTemplateTypeChecker());
            if (!attrTable.has(name)) {
                return undefined;
            }
            const completion = attrTable.get(name);
            let displayParts;
            let documentation = undefined;
            let info;
            switch (completion.kind) {
                case AttributeCompletionKind.DomAttribute:
                case AttributeCompletionKind.DomProperty:
                    // TODO(alxhub): ideally we would show the same documentation as quick info here. However,
                    // since these bindings don't exist in the TCB, there is no straightforward way to retrieve
                    // a `ts.Symbol` for the field in the TS DOM definition.
                    displayParts = [];
                    break;
                case AttributeCompletionKind.DirectiveAttribute:
                    info = getDirectiveDisplayInfo(this.tsLS, completion.directive);
                    displayParts = info.displayParts;
                    documentation = info.documentation;
                    break;
                case AttributeCompletionKind.StructuralDirectiveAttribute:
                case AttributeCompletionKind.DirectiveInput:
                case AttributeCompletionKind.DirectiveOutput:
                    const propertySymbol = getAttributeCompletionSymbol(completion, this.typeChecker);
                    if (propertySymbol === null) {
                        return undefined;
                    }
                    let kind;
                    if (completion.kind === AttributeCompletionKind.DirectiveInput) {
                        kind = DisplayInfoKind.PROPERTY;
                    }
                    else if (completion.kind === AttributeCompletionKind.DirectiveOutput) {
                        kind = DisplayInfoKind.EVENT;
                    }
                    else {
                        kind = DisplayInfoKind.DIRECTIVE;
                    }
                    info = getTsSymbolDisplayInfo(this.tsLS, this.typeChecker, propertySymbol, kind, completion.directive.tsSymbol.name);
                    if (info === null) {
                        return undefined;
                    }
                    displayParts = info.displayParts;
                    documentation = info.documentation;
            }
            return {
                name: entryName,
                kind: unsafeCastDisplayInfoKindToScriptElementKind(kind),
                kindModifiers: ts$1.ScriptElementKindModifier.none,
                displayParts,
                documentation,
            };
        }
        getElementAttributeCompletionSymbol(attribute) {
            var _a;
            const { name } = stripBindingSugar(attribute);
            let element;
            if (this.node instanceof Element || this.node instanceof Template) {
                element = this.node;
            }
            else if (this.nodeParent instanceof Element || this.nodeParent instanceof Template) {
                element = this.nodeParent;
            }
            else {
                // Nothing to do without an element to process.
                return undefined;
            }
            const attrTable = buildAttributeCompletionTable(this.component, element, this.compiler.getTemplateTypeChecker());
            if (!attrTable.has(name)) {
                return undefined;
            }
            const completion = attrTable.get(name);
            return (_a = getAttributeCompletionSymbol(completion, this.typeChecker)) !== null && _a !== void 0 ? _a : undefined;
        }
        isPipeCompletion() {
            return this.node instanceof BindingPipe;
        }
        getPipeCompletions() {
            const pipes = this.templateTypeChecker.getPipesInScope(this.component);
            if (pipes === null) {
                return undefined;
            }
            const replacementSpan = makeReplacementSpanFromAst(this.node);
            const entries = pipes.map(pipe => ({
                name: pipe.name,
                sortText: pipe.name,
                kind: unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.PIPE),
                replacementSpan,
            }));
            return {
                entries,
                isGlobalCompletion: false,
                isMemberCompletion: false,
                isNewIdentifierLocation: false,
            };
        }
        /**
         * From the AST node of the cursor position, include completion of string literals, number
         * literals, `true`, `false`, `null`, and `undefined`.
         */
        isValidNodeContextCompletion(completion) {
            if (completion.kind === ts$1.ScriptElementKind.string) {
                // 'string' kind includes both string literals and number literals
                return true;
            }
            if (completion.kind === ts$1.ScriptElementKind.keyword) {
                return completion.name === 'true' || completion.name === 'false' ||
                    completion.name === 'null';
            }
            if (completion.kind === ts$1.ScriptElementKind.variableElement) {
                return completion.name === 'undefined';
            }
            return false;
        }
    }
    function makeReplacementSpanFromParseSourceSpan(span) {
        return {
            start: span.start.offset,
            length: span.end.offset - span.start.offset,
        };
    }
    function makeReplacementSpanFromAst(node) {
        if ((node instanceof EmptyExpr || node instanceof LiteralPrimitive ||
            node instanceof BoundEvent)) {
            // empty nodes do not replace any existing text
            return undefined;
        }
        return {
            start: node.nameSpan.start,
            length: node.nameSpan.end - node.nameSpan.start,
        };
    }
    function tagCompletionKind(directive) {
        let kind;
        if (directive === null) {
            kind = DisplayInfoKind.ELEMENT;
        }
        else if (directive.isComponent) {
            kind = DisplayInfoKind.COMPONENT;
        }
        else {
            kind = DisplayInfoKind.DIRECTIVE;
        }
        return unsafeCastDisplayInfoKindToScriptElementKind(kind);
    }
    const BINDING_SUGAR = /[\[\(\)\]]/g;
    function stripBindingSugar(binding) {
        const name = binding.replace(BINDING_SUGAR, '');
        if (binding.startsWith('[')) {
            return { name, kind: DisplayInfoKind.PROPERTY };
        }
        else if (binding.startsWith('(')) {
            return { name, kind: DisplayInfoKind.EVENT };
        }
        else {
            return { name, kind: DisplayInfoKind.ATTRIBUTE };
        }
    }
    function nodeContextFromTarget(target) {
        switch (target.kind) {
            case TargetNodeKind.ElementInTagContext:
                return CompletionNodeContext.ElementTag;
            case TargetNodeKind.ElementInBodyContext:
                // Completions in element bodies are for new attributes.
                return CompletionNodeContext.ElementAttributeKey;
            case TargetNodeKind.TwoWayBindingContext:
                return CompletionNodeContext.TwoWayBinding;
            case TargetNodeKind.AttributeInKeyContext:
                return CompletionNodeContext.ElementAttributeKey;
            case TargetNodeKind.AttributeInValueContext:
                if (target.node instanceof BoundEvent) {
                    return CompletionNodeContext.EventValue;
                }
                else if (target.node instanceof TextAttribute) {
                    return CompletionNodeContext.ElementAttributeValue;
                }
                else {
                    return CompletionNodeContext.None;
                }
            default:
                // No special context is available.
                return CompletionNodeContext.None;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Converts a `ShimLocation` to a more genericly named `FilePosition`.
     */
    function toFilePosition(shimLocation) {
        return { fileName: shimLocation.shimPath, position: shimLocation.positionInShimFile };
    }
    /**
     * Takes a position in a template and finds equivalent targets in TS files as well as details about
     * the targeted template node.
     */
    function getTargetDetailsAtTemplatePosition({ template, component }, position, templateTypeChecker) {
        // Find the AST node in the template at the position.
        const positionDetails = getTargetAtPosition(template, position);
        if (positionDetails === null) {
            return null;
        }
        const nodes = positionDetails.context.kind === TargetNodeKind.TwoWayBindingContext ?
            positionDetails.context.nodes :
            [positionDetails.context.node];
        const details = [];
        for (const node of nodes) {
            // Get the information about the TCB at the template position.
            const symbol = templateTypeChecker.getSymbolOfNode(node, component);
            if (symbol === null) {
                continue;
            }
            const templateTarget = node;
            switch (symbol.kind) {
                case SymbolKind.Directive:
                case SymbolKind.Template:
                    // References to elements, templates, and directives will be through template references
                    // (#ref). They shouldn't be used directly for a Language Service reference request.
                    break;
                case SymbolKind.Element: {
                    const matches = getDirectiveMatchesForElementTag(symbol.templateNode, symbol.directives);
                    details.push({
                        typescriptLocations: getPositionsForDirectives(matches),
                        templateTarget,
                        symbol,
                    });
                    break;
                }
                case SymbolKind.DomBinding: {
                    // Dom bindings aren't currently type-checked (see `checkTypeOfDomBindings`) so they don't
                    // have a shim location. This means we can't match dom bindings to their lib.dom
                    // reference, but we can still see if they match to a directive.
                    if (!(node instanceof TextAttribute) && !(node instanceof BoundAttribute)) {
                        return null;
                    }
                    const directives = getDirectiveMatchesForAttribute(node.name, symbol.host.templateNode, symbol.host.directives);
                    details.push({
                        typescriptLocations: getPositionsForDirectives(directives),
                        templateTarget,
                        symbol,
                    });
                    break;
                }
                case SymbolKind.Reference: {
                    details.push({
                        typescriptLocations: [toFilePosition(symbol.referenceVarLocation)],
                        templateTarget,
                        symbol,
                    });
                    break;
                }
                case SymbolKind.Variable: {
                    if ((templateTarget instanceof Variable)) {
                        if (templateTarget.valueSpan !== undefined &&
                            isWithin(position, templateTarget.valueSpan)) {
                            // In the valueSpan of the variable, we want to get the reference of the initializer.
                            details.push({
                                typescriptLocations: [toFilePosition(symbol.initializerLocation)],
                                templateTarget,
                                symbol,
                            });
                        }
                        else if (isWithin(position, templateTarget.keySpan)) {
                            // In the keySpan of the variable, we want to get the reference of the local variable.
                            details.push({
                                typescriptLocations: [toFilePosition(symbol.localVarLocation)],
                                templateTarget,
                                symbol,
                            });
                        }
                    }
                    else {
                        // If the templateNode is not the `TmplAstVariable`, it must be a usage of the
                        // variable somewhere in the template.
                        details.push({
                            typescriptLocations: [toFilePosition(symbol.localVarLocation)],
                            templateTarget,
                            symbol,
                        });
                    }
                    break;
                }
                case SymbolKind.Input:
                case SymbolKind.Output: {
                    details.push({
                        typescriptLocations: symbol.bindings.map(binding => toFilePosition(binding.shimLocation)),
                        templateTarget,
                        symbol,
                    });
                    break;
                }
                case SymbolKind.Pipe:
                case SymbolKind.Expression: {
                    details.push({
                        typescriptLocations: [toFilePosition(symbol.shimLocation)],
                        templateTarget,
                        symbol,
                    });
                    break;
                }
            }
        }
        return details.length > 0 ? details : null;
    }
    /**
     * Given a set of `DirectiveSymbol`s, finds the equivalent `FilePosition` of the class declaration.
     */
    function getPositionsForDirectives(directives) {
        const allDirectives = [];
        for (const dir of directives.values()) {
            const dirClass = dir.tsSymbol.valueDeclaration;
            if (dirClass === undefined || !ts$1.isClassDeclaration(dirClass) || dirClass.name === undefined) {
                continue;
            }
            const { fileName } = dirClass.getSourceFile();
            const position = dirClass.name.getStart();
            allDirectives.push({ fileName, position });
        }
        return allDirectives;
    }
    /**
     * Creates a "key" for a rename/reference location by concatenating file name, span start, and span
     * length. This allows us to de-duplicate template results when an item may appear several times
     * in the TCB but map back to the same template location.
     */
    function createLocationKey(ds) {
        return ds.fileName + ds.textSpan.start + ds.textSpan.length;
    }
    /**
     * Converts a given `ts.DocumentSpan` in a shim file to its equivalent `ts.DocumentSpan` in the
     * template.
     *
     * You can optionally provide a `requiredNodeText` that ensures the equivalent template node's text
     * matches. If it does not, this function will return `null`.
     */
    function convertToTemplateDocumentSpan(shimDocumentSpan, templateTypeChecker, program, requiredNodeText) {
        const sf = program.getSourceFile(shimDocumentSpan.fileName);
        if (sf === undefined) {
            return null;
        }
        const tcbNode = findTightestNode(sf, shimDocumentSpan.textSpan.start);
        if (tcbNode === undefined ||
            hasExpressionIdentifier(sf, tcbNode, ExpressionIdentifier.EVENT_PARAMETER)) {
            // If the reference result is the $event parameter in the subscribe/addEventListener
            // function in the TCB, we want to filter this result out of the references. We really only
            // want to return references to the parameter in the template itself.
            return null;
        }
        // TODO(atscott): Determine how to consistently resolve paths. i.e. with the project
        // serverHost or LSParseConfigHost in the adapter. We should have a better defined way to
        // normalize paths.
        const mapping = getTemplateLocationFromShimLocation(templateTypeChecker, absoluteFrom(shimDocumentSpan.fileName), shimDocumentSpan.textSpan.start);
        if (mapping === null) {
            return null;
        }
        const { span, templateUrl } = mapping;
        if (requiredNodeText !== undefined && span.toString() !== requiredNodeText) {
            return null;
        }
        return Object.assign(Object.assign({}, shimDocumentSpan), { fileName: templateUrl, textSpan: toTextSpan(span), 
            // Specifically clear other text span values because we do not have enough knowledge to
            // convert these to spans in the template.
            contextSpan: undefined, originalContextSpan: undefined, originalTextSpan: undefined });
    }
    /**
     * Finds the text and `ts.TextSpan` for the node at a position in a template.
     */
    function getRenameTextAndSpanAtPosition(node, position) {
        if (node instanceof BoundAttribute || node instanceof TextAttribute ||
            node instanceof BoundEvent) {
            if (node.keySpan === undefined) {
                return null;
            }
            return { text: node.name, span: toTextSpan(node.keySpan) };
        }
        else if (node instanceof Variable || node instanceof Reference) {
            if (isWithin(position, node.keySpan)) {
                return { text: node.keySpan.toString(), span: toTextSpan(node.keySpan) };
            }
            else if (node.valueSpan && isWithin(position, node.valueSpan)) {
                return { text: node.valueSpan.toString(), span: toTextSpan(node.valueSpan) };
            }
        }
        if (node instanceof PropertyRead || node instanceof MethodCall || node instanceof PropertyWrite ||
            node instanceof SafePropertyRead || node instanceof SafeMethodCall ||
            node instanceof BindingPipe) {
            return { text: node.name, span: toTextSpan(node.nameSpan) };
        }
        else if (node instanceof LiteralPrimitive) {
            const span = toTextSpan(node.sourceSpan);
            const text = node.value;
            if (typeof text === 'string') {
                // The span of a string literal includes the quotes but they should be removed for renaming.
                span.start += 1;
                span.length -= 2;
            }
            return { text, span };
        }
        return null;
    }
    /**
     * Retrives the `PipeMeta` or `DirectiveMeta` of the given `ts.Node`'s parent class.
     *
     * Returns `null` if the node has no parent class or there is no meta associated with the class.
     */
    function getParentClassMeta(requestNode, compiler) {
        const parentClass = getParentClassDeclaration(requestNode);
        if (parentClass === undefined) {
            return null;
        }
        return compiler.getMeta(parentClass);
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class DefinitionBuilder {
        constructor(tsLS, compiler, driver) {
            this.tsLS = tsLS;
            this.compiler = compiler;
            this.driver = driver;
            this.ttc = this.compiler.getTemplateTypeChecker();
        }
        getDefinitionAndBoundSpan(fileName, position) {
            var _a;
            const templateInfo = getTemplateInfoAtPosition(fileName, position, this.compiler);
            if (templateInfo === undefined) {
                // We were unable to get a template at the given position. If we are in a TS file, instead
                // attempt to get an Angular definition at the location inside a TS file (examples of this
                // would be templateUrl or a url in styleUrls).
                if (!isTypeScriptFile(fileName)) {
                    return;
                }
                return getDefinitionForExpressionAtPosition(fileName, position, this.compiler);
            }
            const definitionMetas = this.getDefinitionMetaAtPosition(templateInfo, position);
            if (definitionMetas === undefined) {
                return undefined;
            }
            const definitions = [];
            for (const definitionMeta of definitionMetas) {
                // The `$event` of event handlers would point to the $event parameter in the shim file, as in
                // `_t3["x"].subscribe(function ($event): any { $event }) ;`
                // If we wanted to return something for this, it would be more appropriate for something like
                // `getTypeDefinition`.
                if (isDollarEvent(definitionMeta.node)) {
                    continue;
                }
                definitions.push(...((_a = this.getDefinitionsForSymbol(Object.assign(Object.assign({}, definitionMeta), templateInfo))) !== null && _a !== void 0 ? _a : []));
            }
            if (definitions.length === 0) {
                return undefined;
            }
            return { definitions, textSpan: getTextSpanOfNode(definitionMetas[0].node) };
        }
        getDefinitionsForSymbol({ symbol, node, parent, component }) {
            switch (symbol.kind) {
                case SymbolKind.Directive:
                case SymbolKind.Element:
                case SymbolKind.Template:
                case SymbolKind.DomBinding:
                    // Though it is generally more appropriate for the above symbol definitions to be
                    // associated with "type definitions" since the location in the template is the
                    // actual definition location, the better user experience would be to allow
                    // LS users to "go to definition" on an item in the template that maps to a class and be
                    // taken to the directive or HTML class.
                    return this.getTypeDefinitionsForTemplateInstance(symbol, node);
                case SymbolKind.Pipe: {
                    if (symbol.tsSymbol !== null) {
                        return this.getDefinitionsForSymbols(symbol);
                    }
                    else {
                        // If there is no `ts.Symbol` for the pipe transform, we want to return the
                        // type definition (the pipe class).
                        return this.getTypeDefinitionsForSymbols(symbol.classSymbol);
                    }
                }
                case SymbolKind.Output:
                case SymbolKind.Input: {
                    const bindingDefs = this.getDefinitionsForSymbols(...symbol.bindings);
                    // Also attempt to get directive matches for the input name. If there is a directive that
                    // has the input name as part of the selector, we want to return that as well.
                    const directiveDefs = this.getDirectiveTypeDefsForBindingNode(node, parent, component);
                    return [...bindingDefs, ...directiveDefs];
                }
                case SymbolKind.Variable:
                case SymbolKind.Reference: {
                    const definitions = [];
                    if (symbol.declaration !== node) {
                        const shimLocation = symbol.kind === SymbolKind.Variable ? symbol.localVarLocation :
                            symbol.referenceVarLocation;
                        const mapping = getTemplateLocationFromShimLocation(this.compiler.getTemplateTypeChecker(), shimLocation.shimPath, shimLocation.positionInShimFile);
                        if (mapping !== null) {
                            definitions.push({
                                name: symbol.declaration.name,
                                containerName: '',
                                containerKind: ts$1.ScriptElementKind.unknown,
                                kind: ts$1.ScriptElementKind.variableElement,
                                textSpan: getTextSpanOfNode(symbol.declaration),
                                contextSpan: toTextSpan(symbol.declaration.sourceSpan),
                                fileName: mapping.templateUrl,
                            });
                        }
                    }
                    if (symbol.kind === SymbolKind.Variable) {
                        definitions.push(...this.getDefinitionsForSymbols({ shimLocation: symbol.initializerLocation }));
                    }
                    return definitions;
                }
                case SymbolKind.Expression: {
                    return this.getDefinitionsForSymbols(symbol);
                }
            }
        }
        getDefinitionsForSymbols(...symbols) {
            return flatMap(symbols, ({ shimLocation }) => {
                const { shimPath, positionInShimFile } = shimLocation;
                const definitionInfos = this.tsLS.getDefinitionAtPosition(shimPath, positionInShimFile);
                if (definitionInfos === undefined) {
                    return [];
                }
                return this.mapShimResultsToTemplates(definitionInfos);
            });
        }
        /**
         * Converts and definition info result that points to a template typecheck file to a reference to
         * the corresponding location in the template.
         */
        mapShimResultsToTemplates(definitionInfos) {
            const result = [];
            for (const info of definitionInfos) {
                if (this.ttc.isTrackedTypeCheckFile(absoluteFrom(info.fileName))) {
                    const templateDefinitionInfo = convertToTemplateDocumentSpan(info, this.ttc, this.driver.getProgram());
                    if (templateDefinitionInfo === null) {
                        continue;
                    }
                    result.push(templateDefinitionInfo);
                }
                else {
                    result.push(info);
                }
            }
            return result;
        }
        getTypeDefinitionsAtPosition(fileName, position) {
            const templateInfo = getTemplateInfoAtPosition(fileName, position, this.compiler);
            if (templateInfo === undefined) {
                return;
            }
            const definitionMetas = this.getDefinitionMetaAtPosition(templateInfo, position);
            if (definitionMetas === undefined) {
                return undefined;
            }
            const definitions = [];
            for (const { symbol, node, parent } of definitionMetas) {
                switch (symbol.kind) {
                    case SymbolKind.Directive:
                    case SymbolKind.DomBinding:
                    case SymbolKind.Element:
                    case SymbolKind.Template:
                        definitions.push(...this.getTypeDefinitionsForTemplateInstance(symbol, node));
                        break;
                    case SymbolKind.Output:
                    case SymbolKind.Input: {
                        const bindingDefs = this.getTypeDefinitionsForSymbols(...symbol.bindings);
                        definitions.push(...bindingDefs);
                        // Also attempt to get directive matches for the input name. If there is a directive that
                        // has the input name as part of the selector, we want to return that as well.
                        const directiveDefs = this.getDirectiveTypeDefsForBindingNode(node, parent, templateInfo.component);
                        definitions.push(...directiveDefs);
                        break;
                    }
                    case SymbolKind.Pipe: {
                        if (symbol.tsSymbol !== null) {
                            definitions.push(...this.getTypeDefinitionsForSymbols(symbol));
                        }
                        else {
                            // If there is no `ts.Symbol` for the pipe transform, we want to return the
                            // type definition (the pipe class).
                            definitions.push(...this.getTypeDefinitionsForSymbols(symbol.classSymbol));
                        }
                        break;
                    }
                    case SymbolKind.Reference:
                        definitions.push(...this.getTypeDefinitionsForSymbols({ shimLocation: symbol.targetLocation }));
                        break;
                    case SymbolKind.Expression:
                        definitions.push(...this.getTypeDefinitionsForSymbols(symbol));
                        break;
                    case SymbolKind.Variable: {
                        definitions.push(...this.getTypeDefinitionsForSymbols({ shimLocation: symbol.initializerLocation }));
                        break;
                    }
                }
                return definitions;
            }
        }
        getTypeDefinitionsForTemplateInstance(symbol, node) {
            switch (symbol.kind) {
                case SymbolKind.Template: {
                    const matches = getDirectiveMatchesForElementTag(symbol.templateNode, symbol.directives);
                    return this.getTypeDefinitionsForSymbols(...matches);
                }
                case SymbolKind.Element: {
                    const matches = getDirectiveMatchesForElementTag(symbol.templateNode, symbol.directives);
                    // If one of the directive matches is a component, we should not include the native element
                    // in the results because it is replaced by the component.
                    return Array.from(matches).some(dir => dir.isComponent) ?
                        this.getTypeDefinitionsForSymbols(...matches) :
                        this.getTypeDefinitionsForSymbols(...matches, symbol);
                }
                case SymbolKind.DomBinding: {
                    if (!(node instanceof TextAttribute)) {
                        return [];
                    }
                    const dirs = getDirectiveMatchesForAttribute(node.name, symbol.host.templateNode, symbol.host.directives);
                    return this.getTypeDefinitionsForSymbols(...dirs);
                }
                case SymbolKind.Directive:
                    return this.getTypeDefinitionsForSymbols(symbol);
            }
        }
        getDirectiveTypeDefsForBindingNode(node, parent, component) {
            if (!(node instanceof BoundAttribute) && !(node instanceof TextAttribute) &&
                !(node instanceof BoundEvent)) {
                return [];
            }
            if (parent === null ||
                !(parent instanceof Template || parent instanceof Element)) {
                return [];
            }
            const templateOrElementSymbol = this.compiler.getTemplateTypeChecker().getSymbolOfNode(parent, component);
            if (templateOrElementSymbol === null ||
                (templateOrElementSymbol.kind !== SymbolKind.Template &&
                    templateOrElementSymbol.kind !== SymbolKind.Element)) {
                return [];
            }
            const dirs = getDirectiveMatchesForAttribute(node.name, parent, templateOrElementSymbol.directives);
            return this.getTypeDefinitionsForSymbols(...dirs);
        }
        getTypeDefinitionsForSymbols(...symbols) {
            return flatMap(symbols, ({ shimLocation }) => {
                var _a;
                const { shimPath, positionInShimFile } = shimLocation;
                return (_a = this.tsLS.getTypeDefinitionAtPosition(shimPath, positionInShimFile)) !== null && _a !== void 0 ? _a : [];
            });
        }
        getDefinitionMetaAtPosition({ template, component }, position) {
            const target = getTargetAtPosition(template, position);
            if (target === null) {
                return undefined;
            }
            const { context, parent } = target;
            const nodes = context.kind === TargetNodeKind.TwoWayBindingContext ? context.nodes : [context.node];
            const definitionMetas = [];
            for (const node of nodes) {
                const symbol = this.compiler.getTemplateTypeChecker().getSymbolOfNode(node, component);
                if (symbol === null) {
                    continue;
                }
                definitionMetas.push({ node, parent, symbol });
            }
            return definitionMetas.length > 0 ? definitionMetas : undefined;
        }
    }
    /**
     * Gets an Angular-specific definition in a TypeScript source file.
     */
    function getDefinitionForExpressionAtPosition(fileName, position, compiler) {
        const sf = compiler.getCurrentProgram().getSourceFile(fileName);
        if (sf === undefined) {
            return;
        }
        const expression = findTightestNode(sf, position);
        if (expression === undefined) {
            return;
        }
        const classDeclaration = getParentClassDeclaration(expression);
        if (classDeclaration === undefined) {
            return;
        }
        const componentResources = compiler.getComponentResources(classDeclaration);
        if (componentResources === null) {
            return;
        }
        const allResources = [...componentResources.styles, componentResources.template];
        const resourceForExpression = allResources.find(resource => resource.expression === expression);
        if (resourceForExpression === undefined || !isExternalResource(resourceForExpression)) {
            return;
        }
        const templateDefinitions = [{
                kind: ts$1.ScriptElementKind.externalModuleName,
                name: resourceForExpression.path,
                containerKind: ts$1.ScriptElementKind.unknown,
                containerName: '',
                // Reading the template is expensive, so don't provide a preview.
                // TODO(ayazhafiz): Consider providing an actual span:
                //  1. We're likely to read the template anyway
                //  2. We could show just the first 100 chars or so
                textSpan: { start: 0, length: 0 },
                fileName: resourceForExpression.path,
            }];
        return {
            definitions: templateDefinitions,
            textSpan: {
                // Exclude opening and closing quotes in the url span.
                start: expression.getStart() + 1,
                length: expression.getWidth() - 2,
            },
        };
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class QuickInfoBuilder {
        constructor(tsLS, compiler, component, node) {
            this.tsLS = tsLS;
            this.compiler = compiler;
            this.component = component;
            this.node = node;
            this.typeChecker = this.compiler.getCurrentProgram().getTypeChecker();
        }
        get() {
            const symbol = this.compiler.getTemplateTypeChecker().getSymbolOfNode(this.node, this.component);
            if (symbol === null) {
                return isDollarAny(this.node) ? createDollarAnyQuickInfo(this.node) : undefined;
            }
            return this.getQuickInfoForSymbol(symbol);
        }
        getQuickInfoForSymbol(symbol) {
            switch (symbol.kind) {
                case SymbolKind.Input:
                case SymbolKind.Output:
                    return this.getQuickInfoForBindingSymbol(symbol);
                case SymbolKind.Template:
                    return createNgTemplateQuickInfo(this.node);
                case SymbolKind.Element:
                    return this.getQuickInfoForElementSymbol(symbol);
                case SymbolKind.Variable:
                    return this.getQuickInfoForVariableSymbol(symbol);
                case SymbolKind.Reference:
                    return this.getQuickInfoForReferenceSymbol(symbol);
                case SymbolKind.DomBinding:
                    return this.getQuickInfoForDomBinding(symbol);
                case SymbolKind.Directive:
                    return this.getQuickInfoAtShimLocation(symbol.shimLocation);
                case SymbolKind.Pipe:
                    return this.getQuickInfoForPipeSymbol(symbol);
                case SymbolKind.Expression:
                    return this.getQuickInfoAtShimLocation(symbol.shimLocation);
            }
        }
        getQuickInfoForBindingSymbol(symbol) {
            if (symbol.bindings.length === 0) {
                return undefined;
            }
            const kind = symbol.kind === SymbolKind.Input ? DisplayInfoKind.PROPERTY : DisplayInfoKind.EVENT;
            const quickInfo = this.getQuickInfoAtShimLocation(symbol.bindings[0].shimLocation);
            return quickInfo === undefined ? undefined : updateQuickInfoKind(quickInfo, kind);
        }
        getQuickInfoForElementSymbol(symbol) {
            const { templateNode } = symbol;
            const matches = getDirectiveMatchesForElementTag(templateNode, symbol.directives);
            if (matches.size > 0) {
                return this.getQuickInfoForDirectiveSymbol(matches.values().next().value, templateNode);
            }
            return createQuickInfo(templateNode.name, DisplayInfoKind.ELEMENT, getTextSpanOfNode(templateNode), undefined /* containerName */, this.typeChecker.typeToString(symbol.tsType));
        }
        getQuickInfoForVariableSymbol(symbol) {
            const documentation = this.getDocumentationFromTypeDefAtLocation(symbol.initializerLocation);
            return createQuickInfo(symbol.declaration.name, DisplayInfoKind.VARIABLE, getTextSpanOfNode(this.node), undefined /* containerName */, this.typeChecker.typeToString(symbol.tsType), documentation);
        }
        getQuickInfoForReferenceSymbol(symbol) {
            const documentation = this.getDocumentationFromTypeDefAtLocation(symbol.targetLocation);
            return createQuickInfo(symbol.declaration.name, DisplayInfoKind.REFERENCE, getTextSpanOfNode(this.node), undefined /* containerName */, this.typeChecker.typeToString(symbol.tsType), documentation);
        }
        getQuickInfoForPipeSymbol(symbol) {
            if (symbol.tsSymbol !== null) {
                const quickInfo = this.getQuickInfoAtShimLocation(symbol.shimLocation);
                return quickInfo === undefined ? undefined :
                    updateQuickInfoKind(quickInfo, DisplayInfoKind.PIPE);
            }
            else {
                return createQuickInfo(this.typeChecker.typeToString(symbol.classSymbol.tsType), DisplayInfoKind.PIPE, getTextSpanOfNode(this.node));
            }
        }
        getQuickInfoForDomBinding(symbol) {
            if (!(this.node instanceof TextAttribute) &&
                !(this.node instanceof BoundAttribute)) {
                return undefined;
            }
            const directives = getDirectiveMatchesForAttribute(this.node.name, symbol.host.templateNode, symbol.host.directives);
            if (directives.size === 0) {
                return undefined;
            }
            return this.getQuickInfoForDirectiveSymbol(directives.values().next().value);
        }
        getQuickInfoForDirectiveSymbol(dir, node = this.node) {
            const kind = dir.isComponent ? DisplayInfoKind.COMPONENT : DisplayInfoKind.DIRECTIVE;
            const documentation = this.getDocumentationFromTypeDefAtLocation(dir.shimLocation);
            let containerName;
            if (ts$1.isClassDeclaration(dir.tsSymbol.valueDeclaration) && dir.ngModule !== null) {
                containerName = dir.ngModule.name.getText();
            }
            return createQuickInfo(this.typeChecker.typeToString(dir.tsType), kind, getTextSpanOfNode(this.node), containerName, undefined, documentation);
        }
        getDocumentationFromTypeDefAtLocation(shimLocation) {
            var _a;
            const typeDefs = this.tsLS.getTypeDefinitionAtPosition(shimLocation.shimPath, shimLocation.positionInShimFile);
            if (typeDefs === undefined || typeDefs.length === 0) {
                return undefined;
            }
            return (_a = this.tsLS.getQuickInfoAtPosition(typeDefs[0].fileName, typeDefs[0].textSpan.start)) === null || _a === void 0 ? void 0 : _a.documentation;
        }
        getQuickInfoAtShimLocation(location) {
            const quickInfo = this.tsLS.getQuickInfoAtPosition(location.shimPath, location.positionInShimFile);
            if (quickInfo === undefined || quickInfo.displayParts === undefined) {
                return quickInfo;
            }
            quickInfo.displayParts = filterAliasImports(quickInfo.displayParts);
            const textSpan = getTextSpanOfNode(this.node);
            return Object.assign(Object.assign({}, quickInfo), { textSpan });
        }
    }
    function updateQuickInfoKind(quickInfo, kind) {
        if (quickInfo.displayParts === undefined) {
            return quickInfo;
        }
        const startsWithKind = quickInfo.displayParts.length >= 3 &&
            displayPartsEqual(quickInfo.displayParts[0], { text: '(', kind: SYMBOL_PUNC }) &&
            quickInfo.displayParts[1].kind === SYMBOL_TEXT &&
            displayPartsEqual(quickInfo.displayParts[2], { text: ')', kind: SYMBOL_PUNC });
        if (startsWithKind) {
            quickInfo.displayParts[1].text = kind;
        }
        else {
            quickInfo.displayParts = [
                { text: '(', kind: SYMBOL_PUNC },
                { text: kind, kind: SYMBOL_TEXT },
                { text: ')', kind: SYMBOL_PUNC },
                { text: ' ', kind: SYMBOL_SPACE },
                ...quickInfo.displayParts,
            ];
        }
        return quickInfo;
    }
    function displayPartsEqual(a, b) {
        return a.text === b.text && a.kind === b.kind;
    }
    function isDollarAny(node) {
        return node instanceof MethodCall && node.receiver instanceof ImplicitReceiver &&
            !(node.receiver instanceof ThisReceiver) && node.name === '$any' && node.args.length === 1;
    }
    function createDollarAnyQuickInfo(node) {
        return createQuickInfo('$any', DisplayInfoKind.METHOD, getTextSpanOfNode(node), 
        /** containerName */ undefined, 'any', [{
                kind: SYMBOL_TEXT,
                text: 'function to cast an expression to the `any` type',
            }]);
    }
    // TODO(atscott): Create special `ts.QuickInfo` for `ng-template` and `ng-container` as well.
    function createNgTemplateQuickInfo(node) {
        return createQuickInfo('ng-template', DisplayInfoKind.TEMPLATE, getTextSpanOfNode(node), 
        /** containerName */ undefined, 
        /** type */ undefined, [{
                kind: SYMBOL_TEXT,
                text: 'The `<ng-template>` is an Angular element for rendering HTML. It is never displayed directly.',
            }]);
    }
    /**
     * Construct a QuickInfo object taking into account its container and type.
     * @param name Name of the QuickInfo target
     * @param kind component, directive, pipe, etc.
     * @param textSpan span of the target
     * @param containerName either the Symbol's container or the NgModule that contains the directive
     * @param type user-friendly name of the type
     * @param documentation docstring or comment
     */
    function createQuickInfo(name, kind, textSpan, containerName, type, documentation) {
        const displayParts = createDisplayParts(name, kind, containerName, type);
        return {
            kind: unsafeCastDisplayInfoKindToScriptElementKind(kind),
            kindModifiers: ts$1.ScriptElementKindModifier.none,
            textSpan: textSpan,
            displayParts,
            documentation,
        };
    }

    class ReferencesBuilder {
        constructor(driver, tsLS, compiler) {
            this.driver = driver;
            this.tsLS = tsLS;
            this.compiler = compiler;
            this.ttc = this.compiler.getTemplateTypeChecker();
        }
        getReferencesAtPosition(filePath, position) {
            this.ttc.generateAllTypeCheckBlocks();
            const templateInfo = getTemplateInfoAtPosition(filePath, position, this.compiler);
            if (templateInfo === undefined) {
                return this.getReferencesAtTypescriptPosition(filePath, position);
            }
            return this.getReferencesAtTemplatePosition(templateInfo, position);
        }
        getReferencesAtTemplatePosition(templateInfo, position) {
            const allTargetDetails = getTargetDetailsAtTemplatePosition(templateInfo, position, this.ttc);
            if (allTargetDetails === null) {
                return undefined;
            }
            const allReferences = [];
            for (const targetDetails of allTargetDetails) {
                for (const location of targetDetails.typescriptLocations) {
                    const refs = this.getReferencesAtTypescriptPosition(location.fileName, location.position);
                    if (refs !== undefined) {
                        allReferences.push(...refs);
                    }
                }
            }
            return allReferences.length > 0 ? allReferences : undefined;
        }
        getReferencesAtTypescriptPosition(fileName, position) {
            const refs = this.tsLS.getReferencesAtPosition(fileName, position);
            if (refs === undefined) {
                return undefined;
            }
            const entries = [];
            for (const ref of refs) {
                if (this.ttc.isTrackedTypeCheckFile(absoluteFrom(ref.fileName))) {
                    const entry = convertToTemplateDocumentSpan(ref, this.ttc, this.driver.getProgram());
                    if (entry !== null) {
                        entries.push(entry);
                    }
                }
                else {
                    entries.push(ref);
                }
            }
            return entries;
        }
    }
    var RequestKind;
    (function (RequestKind) {
        RequestKind[RequestKind["DirectFromTemplate"] = 0] = "DirectFromTemplate";
        RequestKind[RequestKind["DirectFromTypeScript"] = 1] = "DirectFromTypeScript";
        RequestKind[RequestKind["PipeName"] = 2] = "PipeName";
        RequestKind[RequestKind["Selector"] = 3] = "Selector";
    })(RequestKind || (RequestKind = {}));
    function isDirectRenameContext(context) {
        return context.type === RequestKind.DirectFromTemplate ||
            context.type === RequestKind.DirectFromTypeScript;
    }
    class RenameBuilder {
        constructor(driver, tsLS, compiler) {
            this.driver = driver;
            this.tsLS = tsLS;
            this.compiler = compiler;
            this.ttc = this.compiler.getTemplateTypeChecker();
        }
        getRenameInfo(filePath, position) {
            return this.compiler.perfRecorder.inPhase(PerfPhase.LsReferencesAndRenames, () => {
                const templateInfo = getTemplateInfoAtPosition(filePath, position, this.compiler);
                // We could not get a template at position so we assume the request came from outside the
                // template.
                if (templateInfo === undefined) {
                    const renameRequest = this.buildRenameRequestAtTypescriptPosition(filePath, position);
                    if (renameRequest === null) {
                        return {
                            canRename: false,
                            localizedErrorMessage: 'Could not determine rename info at typescript position.',
                        };
                    }
                    if (renameRequest.type === RequestKind.PipeName) {
                        const pipeName = renameRequest.pipeNameExpr.text;
                        return {
                            canRename: true,
                            displayName: pipeName,
                            fullDisplayName: pipeName,
                            triggerSpan: {
                                length: pipeName.length,
                                // Offset the pipe name by 1 to account for start of string '/`/"
                                start: renameRequest.pipeNameExpr.getStart() + 1,
                            },
                        };
                    }
                    else {
                        // TODO(atscott): Add support for other special indirect renames from typescript files.
                        return this.tsLS.getRenameInfo(filePath, position);
                    }
                }
                const allTargetDetails = getTargetDetailsAtTemplatePosition(templateInfo, position, this.ttc);
                if (allTargetDetails === null) {
                    return {
                        canRename: false,
                        localizedErrorMessage: 'Could not find template node at position.'
                    };
                }
                const { templateTarget } = allTargetDetails[0];
                const templateTextAndSpan = getRenameTextAndSpanAtPosition(templateTarget, position);
                if (templateTextAndSpan === null) {
                    return { canRename: false, localizedErrorMessage: 'Could not determine template node text.' };
                }
                const { text, span } = templateTextAndSpan;
                return {
                    canRename: true,
                    displayName: text,
                    fullDisplayName: text,
                    triggerSpan: span,
                };
            });
        }
        findRenameLocations(filePath, position) {
            this.ttc.generateAllTypeCheckBlocks();
            return this.compiler.perfRecorder.inPhase(PerfPhase.LsReferencesAndRenames, () => {
                const templateInfo = getTemplateInfoAtPosition(filePath, position, this.compiler);
                // We could not get a template at position so we assume the request came from outside the
                // template.
                if (templateInfo === undefined) {
                    const renameRequest = this.buildRenameRequestAtTypescriptPosition(filePath, position);
                    if (renameRequest === null) {
                        return null;
                    }
                    return this.findRenameLocationsAtTypescriptPosition(renameRequest);
                }
                return this.findRenameLocationsAtTemplatePosition(templateInfo, position);
            });
        }
        findRenameLocationsAtTemplatePosition(templateInfo, position) {
            const allTargetDetails = getTargetDetailsAtTemplatePosition(templateInfo, position, this.ttc);
            if (allTargetDetails === null) {
                return null;
            }
            const renameRequests = this.buildRenameRequestsFromTemplateDetails(allTargetDetails, position);
            if (renameRequests === null) {
                return null;
            }
            const allRenameLocations = [];
            for (const renameRequest of renameRequests) {
                const locations = this.findRenameLocationsAtTypescriptPosition(renameRequest);
                // If we couldn't find rename locations for _any_ result, we should not allow renaming to
                // proceed instead of having a partially complete rename.
                if (locations === null) {
                    return null;
                }
                allRenameLocations.push(...locations);
            }
            return allRenameLocations.length > 0 ? allRenameLocations : null;
        }
        findRenameLocationsAtTypescriptPosition(renameRequest) {
            return this.compiler.perfRecorder.inPhase(PerfPhase.LsReferencesAndRenames, () => {
                const renameInfo = getExpectedRenameTextAndInitalRenameEntries(renameRequest);
                if (renameInfo === null) {
                    return null;
                }
                const { entries, expectedRenameText } = renameInfo;
                const { fileName, position } = getRenameRequestPosition(renameRequest);
                const findInStrings = false;
                const findInComments = false;
                const locations = this.tsLS.findRenameLocations(fileName, position, findInStrings, findInComments);
                if (locations === undefined) {
                    return null;
                }
                for (const location of locations) {
                    if (this.ttc.isTrackedTypeCheckFile(absoluteFrom(location.fileName))) {
                        const entry = convertToTemplateDocumentSpan(location, this.ttc, this.driver.getProgram(), expectedRenameText);
                        // There is no template node whose text matches the original rename request. Bail on
                        // renaming completely rather than providing incomplete results.
                        if (entry === null) {
                            return null;
                        }
                        entries.push(entry);
                    }
                    else {
                        if (!isDirectRenameContext(renameRequest)) {
                            // Discard any non-template results for non-direct renames. We should only rename
                            // template results + the name/selector/alias `ts.Expression`. The other results
                            // will be the the `ts.Identifier` of the transform method (pipe rename) or the
                            // directive class (selector rename).
                            continue;
                        }
                        // Ensure we only allow renaming a TS result with matching text
                        const refNode = this.getTsNodeAtPosition(location.fileName, location.textSpan.start);
                        if (refNode === null || refNode.getText() !== expectedRenameText) {
                            return null;
                        }
                        entries.push(location);
                    }
                }
                return entries;
            });
        }
        getTsNodeAtPosition(filePath, position) {
            var _a;
            const sf = this.driver.getProgram().getSourceFile(filePath);
            if (!sf) {
                return null;
            }
            return (_a = findTightestNode(sf, position)) !== null && _a !== void 0 ? _a : null;
        }
        buildRenameRequestsFromTemplateDetails(allTargetDetails, templatePosition) {
            const renameRequests = [];
            for (const targetDetails of allTargetDetails) {
                for (const location of targetDetails.typescriptLocations) {
                    if (targetDetails.symbol.kind === SymbolKind.Pipe) {
                        const meta = this.compiler.getMeta(targetDetails.symbol.classSymbol.tsSymbol.valueDeclaration);
                        if (meta === null || meta.type !== MetaType.Pipe) {
                            return null;
                        }
                        const renameRequest = this.buildPipeRenameRequest(meta);
                        if (renameRequest === null) {
                            return null;
                        }
                        renameRequests.push(renameRequest);
                    }
                    else {
                        const renameRequest = {
                            type: RequestKind.DirectFromTemplate,
                            templatePosition,
                            requestNode: targetDetails.templateTarget,
                            renamePosition: location
                        };
                        renameRequests.push(renameRequest);
                    }
                }
            }
            return renameRequests;
        }
        buildRenameRequestAtTypescriptPosition(filePath, position) {
            const requestNode = this.getTsNodeAtPosition(filePath, position);
            if (requestNode === null) {
                return null;
            }
            const meta = getParentClassMeta(requestNode, this.compiler);
            if (meta !== null && meta.type === MetaType.Pipe && meta.nameExpr === requestNode) {
                return this.buildPipeRenameRequest(meta);
            }
            else {
                return { type: RequestKind.DirectFromTypeScript, requestNode };
            }
        }
        buildPipeRenameRequest(meta) {
            var _a;
            if (!ts$1.isClassDeclaration(meta.ref.node) || meta.nameExpr === null ||
                !ts$1.isStringLiteral(meta.nameExpr)) {
                return null;
            }
            const typeChecker = this.driver.getProgram().getTypeChecker();
            const memberMethods = (_a = collectMemberMethods(meta.ref.node, typeChecker)) !== null && _a !== void 0 ? _a : [];
            const pipeTransformNode = memberMethods.find(m => m.name.getText() === 'transform');
            if (pipeTransformNode === undefined) {
                return null;
            }
            return {
                type: RequestKind.PipeName,
                pipeNameExpr: meta.nameExpr,
                renamePosition: {
                    fileName: pipeTransformNode.getSourceFile().fileName,
                    position: pipeTransformNode.getStart(),
                }
            };
        }
    }
    /**
     * From the provided `RenameRequest`, determines what text we should expect all produced
     * `ts.RenameLocation`s to have and creates an initial entry for indirect renames (one which is
     * required for the rename operation, but cannot be found by the native TS LS).
     */
    function getExpectedRenameTextAndInitalRenameEntries(renameRequest) {
        let expectedRenameText;
        const entries = [];
        if (renameRequest.type === RequestKind.DirectFromTypeScript) {
            expectedRenameText = renameRequest.requestNode.getText();
        }
        else if (renameRequest.type === RequestKind.DirectFromTemplate) {
            const templateNodeText = getRenameTextAndSpanAtPosition(renameRequest.requestNode, renameRequest.templatePosition);
            if (templateNodeText === null) {
                return null;
            }
            expectedRenameText = templateNodeText.text;
        }
        else if (renameRequest.type === RequestKind.PipeName) {
            const { pipeNameExpr } = renameRequest;
            expectedRenameText = pipeNameExpr.text;
            const entry = {
                fileName: renameRequest.pipeNameExpr.getSourceFile().fileName,
                textSpan: { start: pipeNameExpr.getStart() + 1, length: pipeNameExpr.getText().length - 2 },
            };
            entries.push(entry);
        }
        else {
            // TODO(atscott): Implement other types of special renames
            return null;
        }
        return { entries, expectedRenameText };
    }
    /**
     * Given a `RenameRequest`, determines the `FilePosition` to use asking the native TS LS for rename
     * locations.
     */
    function getRenameRequestPosition(renameRequest) {
        const fileName = renameRequest.type === RequestKind.DirectFromTypeScript ?
            renameRequest.requestNode.getSourceFile().fileName :
            renameRequest.renamePosition.fileName;
        const position = renameRequest.type === RequestKind.DirectFromTypeScript ?
            renameRequest.requestNode.getStart() :
            renameRequest.renamePosition.position;
        return { fileName, position };
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Queries the TypeScript Language Service to get signature help for a template position.
     */
    function getSignatureHelp(compiler, tsLS, fileName, position, options) {
        var _a, _b;
        const templateInfo = getTemplateInfoAtPosition(fileName, position, compiler);
        if (templateInfo === undefined) {
            return undefined;
        }
        const targetInfo = getTargetAtPosition(templateInfo.template, position);
        if (targetInfo === null) {
            return undefined;
        }
        if (targetInfo.context.kind !== TargetNodeKind.RawExpression &&
            targetInfo.context.kind !== TargetNodeKind.MethodCallExpressionInArgContext) {
            // Signature completions are only available in expressions.
            return undefined;
        }
        const symbol = compiler.getTemplateTypeChecker().getSymbolOfNode(targetInfo.context.node, templateInfo.component);
        if (symbol === null || symbol.kind !== SymbolKind.Expression) {
            return undefined;
        }
        // Determine a shim position to use in the request to the TypeScript Language Service.
        // Additionally, extract the `MethodCall` or `SafeMethodCall` node for which signature help is
        // being queried, as this is needed to construct the correct span for the results later.
        let shimPosition;
        let expr;
        switch (targetInfo.context.kind) {
            case TargetNodeKind.RawExpression:
                // For normal expressions, just use the primary TCB position of the expression.
                shimPosition = symbol.shimLocation.positionInShimFile;
                // Walk up the parents of this expression and try to find a `MethodCall` or `SafeMethodCall`
                // for which signature information is being fetched.
                let callExpr = null;
                const parents = targetInfo.context.parents;
                for (let i = parents.length - 1; i >= 0; i--) {
                    const parent = parents[i];
                    if (parent instanceof MethodCall || parent instanceof SafeMethodCall) {
                        callExpr = parent;
                        break;
                    }
                }
                // If no MethodCall or SafeMethodCall node could be found, then this query cannot be safely
                // answered as a correct span for the results will not be obtainable.
                if (callExpr === null) {
                    return undefined;
                }
                expr = callExpr;
                break;
            case TargetNodeKind.MethodCallExpressionInArgContext:
                // The `Symbol` points to a `MethodCall` or `SafeMethodCall` expression in the TCB (where it
                // will be represented as a `ts.CallExpression`) *and* the template position was within the
                // argument list of the method call. This happens when there was no narrower expression inside
                // the argument list that matched the template position, such as when the call has no
                // arguments: `foo(|)`.
                //
                // The `Symbol`'s shim position is to the start of the call expression (`|foo()`) and
                // therefore wouldn't return accurate signature help from the TS language service. For that, a
                // position within the argument list for the `ts.CallExpression` in the TCB will need to be
                // determined. This is done by finding that call expression and extracting a viable position
                // from it directly.
                //
                // First, use `findTightestNode` to locate the `ts.Node` at `symbol`'s location.
                const shimSf = getSourceFileOrError(compiler.getCurrentProgram(), symbol.shimLocation.shimPath);
                let shimNode = (_a = findTightestNode(shimSf, symbol.shimLocation.positionInShimFile)) !== null && _a !== void 0 ? _a : null;
                // This node should be somewhere inside a `ts.CallExpression`. Walk up the AST to find it.
                while (shimNode !== null) {
                    if (ts.isCallExpression(shimNode)) {
                        break;
                    }
                    shimNode = (_b = shimNode.parent) !== null && _b !== void 0 ? _b : null;
                }
                // If one couldn't be found, something is wrong, so bail rather than report incorrect results.
                if (shimNode === null || !ts.isCallExpression(shimNode)) {
                    return undefined;
                }
                // Position the cursor in the TCB at the start of the argument list for the
                // `ts.CallExpression`. This will allow us to get the correct signature help, even though the
                // template itself doesn't have an expression inside the argument list.
                shimPosition = shimNode.arguments.pos;
                // In this case, getting the right call AST node is easy.
                expr = targetInfo.context.node;
                break;
        }
        const res = tsLS.getSignatureHelpItems(symbol.shimLocation.shimPath, shimPosition, options);
        if (res === undefined) {
            return undefined;
        }
        // The TS language service results are almost returnable as-is. However, they contain an
        // `applicableSpan` which marks the entire argument list, and that span is in the context of the
        // TCB's `ts.CallExpression`. It needs to be replaced with the span for the `MethodCall` (or
        // `SafeMethodCall`) argument list.
        return Object.assign(Object.assign({}, res), { applicableSpan: {
                start: expr.argumentSpan.start,
                length: expr.argumentSpan.end - expr.argumentSpan.start,
            } });
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class LanguageService {
        constructor(project, tsLS, config) {
            this.project = project;
            this.tsLS = tsLS;
            this.config = config;
            this.parseConfigHost = new LSParseConfigHost(project.projectService.host);
            this.options = parseNgCompilerOptions(project, this.parseConfigHost, config);
            logCompilerOptions(project, this.options);
            this.programDriver = createProgramDriver(project);
            this.adapter = new LanguageServiceAdapter(project);
            this.compilerFactory = new CompilerFactory(this.adapter, this.programDriver, this.options);
            this.watchConfigFile(project);
        }
        getCompilerOptions() {
            return this.options;
        }
        getSemanticDiagnostics(fileName) {
            return this.withCompilerAndPerfTracing(PerfPhase.LsDiagnostics, (compiler) => {
                const diagnostics = [];
                if (isTypeScriptFile(fileName)) {
                    const program = compiler.getCurrentProgram();
                    const sourceFile = program.getSourceFile(fileName);
                    if (sourceFile) {
                        const ngDiagnostics = compiler.getDiagnosticsForFile(sourceFile, OptimizeFor.SingleFile);
                        // There are several kinds of diagnostics returned by `NgCompiler` for a source file:
                        //
                        // 1. Angular-related non-template diagnostics from decorated classes within that
                        // file.
                        // 2. Template diagnostics for components with direct inline templates (a string
                        // literal).
                        // 3. Template diagnostics for components with indirect inline templates (templates
                        // computed
                        //    by expression).
                        // 4. Template diagnostics for components with external templates.
                        //
                        // When showing diagnostics for a TS source file, we want to only include kinds 1 and
                        // 2 - those diagnostics which are reported at a location within the TS file itself.
                        // Diagnostics for external templates will be shown when editing that template file
                        // (the `else` block) below.
                        //
                        // Currently, indirect inline template diagnostics (kind 3) are not shown at all by
                        // the Language Service, because there is no sensible location in the user's code for
                        // them. Such templates are an edge case, though, and should not be common.
                        //
                        // TODO(alxhub): figure out a good user experience for indirect template diagnostics
                        // and show them from within the Language Service.
                        diagnostics.push(...ngDiagnostics.filter(diag => diag.file !== undefined && diag.file.fileName === sourceFile.fileName));
                    }
                }
                else {
                    const components = compiler.getComponentsWithTemplateFile(fileName);
                    for (const component of components) {
                        if (ts.isClassDeclaration(component)) {
                            diagnostics.push(...compiler.getDiagnosticsForComponent(component));
                        }
                    }
                }
                return diagnostics;
            });
        }
        getDefinitionAndBoundSpan(fileName, position) {
            return this.withCompilerAndPerfTracing(PerfPhase.LsDefinition, (compiler) => {
                if (!isInAngularContext(compiler.getCurrentProgram(), fileName, position)) {
                    return undefined;
                }
                return new DefinitionBuilder(this.tsLS, compiler, this.programDriver)
                    .getDefinitionAndBoundSpan(fileName, position);
            });
        }
        getTypeDefinitionAtPosition(fileName, position) {
            return this.withCompilerAndPerfTracing(PerfPhase.LsDefinition, (compiler) => {
                if (!isTemplateContext(compiler.getCurrentProgram(), fileName, position)) {
                    return undefined;
                }
                return new DefinitionBuilder(this.tsLS, compiler, this.programDriver)
                    .getTypeDefinitionsAtPosition(fileName, position);
            });
        }
        getQuickInfoAtPosition(fileName, position) {
            return this.withCompilerAndPerfTracing(PerfPhase.LsQuickInfo, (compiler) => {
                return this.getQuickInfoAtPositionImpl(fileName, position, compiler);
            });
        }
        getQuickInfoAtPositionImpl(fileName, position, compiler) {
            if (!isTemplateContext(compiler.getCurrentProgram(), fileName, position)) {
                return undefined;
            }
            const templateInfo = getTemplateInfoAtPosition(fileName, position, compiler);
            if (templateInfo === undefined) {
                return undefined;
            }
            const positionDetails = getTargetAtPosition(templateInfo.template, position);
            if (positionDetails === null) {
                return undefined;
            }
            // Because we can only show 1 quick info, just use the bound attribute if the target is a two
            // way binding. We may consider concatenating additional display parts from the other target
            // nodes or representing the two way binding in some other manner in the future.
            const node = positionDetails.context.kind === TargetNodeKind.TwoWayBindingContext ?
                positionDetails.context.nodes[0] :
                positionDetails.context.node;
            return new QuickInfoBuilder(this.tsLS, compiler, templateInfo.component, node).get();
        }
        getReferencesAtPosition(fileName, position) {
            return this.withCompilerAndPerfTracing(PerfPhase.LsReferencesAndRenames, (compiler) => {
                const results = new ReferencesBuilder(this.programDriver, this.tsLS, compiler)
                    .getReferencesAtPosition(fileName, position);
                return results === undefined ? undefined : getUniqueLocations(results);
            });
        }
        getRenameInfo(fileName, position) {
            return this.withCompilerAndPerfTracing(PerfPhase.LsReferencesAndRenames, (compiler) => {
                var _a, _b, _c;
                const renameInfo = new RenameBuilder(this.programDriver, this.tsLS, compiler)
                    .getRenameInfo(absoluteFrom(fileName), position);
                if (!renameInfo.canRename) {
                    return renameInfo;
                }
                const quickInfo = (_a = this.getQuickInfoAtPositionImpl(fileName, position, compiler)) !== null && _a !== void 0 ? _a : this.tsLS.getQuickInfoAtPosition(fileName, position);
                const kind = (_b = quickInfo === null || quickInfo === void 0 ? void 0 : quickInfo.kind) !== null && _b !== void 0 ? _b : ts.ScriptElementKind.unknown;
                const kindModifiers = (_c = quickInfo === null || quickInfo === void 0 ? void 0 : quickInfo.kindModifiers) !== null && _c !== void 0 ? _c : ts.ScriptElementKind.unknown;
                return Object.assign(Object.assign({}, renameInfo), { kind, kindModifiers });
            });
        }
        findRenameLocations(fileName, position) {
            return this.withCompilerAndPerfTracing(PerfPhase.LsReferencesAndRenames, (compiler) => {
                const results = new RenameBuilder(this.programDriver, this.tsLS, compiler)
                    .findRenameLocations(fileName, position);
                return results === null ? undefined : getUniqueLocations(results);
            });
        }
        getCompletionBuilder(fileName, position, compiler) {
            const templateInfo = getTemplateInfoAtPosition(fileName, position, compiler);
            if (templateInfo === undefined) {
                return null;
            }
            const positionDetails = getTargetAtPosition(templateInfo.template, position);
            if (positionDetails === null) {
                return null;
            }
            // For two-way bindings, we actually only need to be concerned with the bound attribute because
            // the bindings in the template are written with the attribute name, not the event name.
            const node = positionDetails.context.kind === TargetNodeKind.TwoWayBindingContext ?
                positionDetails.context.nodes[0] :
                positionDetails.context.node;
            return new CompletionBuilder(this.tsLS, compiler, templateInfo.component, node, positionDetails);
        }
        getCompletionsAtPosition(fileName, position, options) {
            return this.withCompilerAndPerfTracing(PerfPhase.LsCompletions, (compiler) => {
                return this.getCompletionsAtPositionImpl(fileName, position, options, compiler);
            });
        }
        getCompletionsAtPositionImpl(fileName, position, options, compiler) {
            if (!isTemplateContext(compiler.getCurrentProgram(), fileName, position)) {
                return undefined;
            }
            const builder = this.getCompletionBuilder(fileName, position, compiler);
            if (builder === null) {
                return undefined;
            }
            return builder.getCompletionsAtPosition(options);
        }
        getCompletionEntryDetails(fileName, position, entryName, formatOptions, preferences, data) {
            return this.withCompilerAndPerfTracing(PerfPhase.LsCompletions, (compiler) => {
                if (!isTemplateContext(compiler.getCurrentProgram(), fileName, position)) {
                    return undefined;
                }
                const builder = this.getCompletionBuilder(fileName, position, compiler);
                if (builder === null) {
                    return undefined;
                }
                return builder.getCompletionEntryDetails(entryName, formatOptions, preferences, data);
            });
        }
        getSignatureHelpItems(fileName, position, options) {
            return this.withCompilerAndPerfTracing(PerfPhase.LsSignatureHelp, compiler => {
                if (!isTemplateContext(compiler.getCurrentProgram(), fileName, position)) {
                    return undefined;
                }
                return getSignatureHelp(compiler, this.tsLS, fileName, position, options);
            });
        }
        getCompletionEntrySymbol(fileName, position, entryName) {
            return this.withCompilerAndPerfTracing(PerfPhase.LsCompletions, (compiler) => {
                if (!isTemplateContext(compiler.getCurrentProgram(), fileName, position)) {
                    return undefined;
                }
                const builder = this.getCompletionBuilder(fileName, position, compiler);
                if (builder === null) {
                    return undefined;
                }
                const result = builder.getCompletionEntrySymbol(entryName);
                return result;
            });
        }
        getComponentLocationsForTemplate(fileName) {
            return this.withCompilerAndPerfTracing(PerfPhase.LsComponentLocations, (compiler) => {
                const components = compiler.getComponentsWithTemplateFile(fileName);
                const componentDeclarationLocations = Array.from(components.values()).map(c => {
                    let contextSpan = undefined;
                    let textSpan;
                    if (isNamedClassDeclaration(c)) {
                        textSpan = ts.createTextSpanFromBounds(c.name.getStart(), c.name.getEnd());
                        contextSpan = ts.createTextSpanFromBounds(c.getStart(), c.getEnd());
                    }
                    else {
                        textSpan = ts.createTextSpanFromBounds(c.getStart(), c.getEnd());
                    }
                    return {
                        fileName: c.getSourceFile().fileName,
                        textSpan,
                        contextSpan,
                    };
                });
                return componentDeclarationLocations;
            });
        }
        getTcb(fileName, position) {
            return this.withCompilerAndPerfTracing(PerfPhase.LsTcb, compiler => {
                const templateInfo = getTemplateInfoAtPosition(fileName, position, compiler);
                if (templateInfo === undefined) {
                    return undefined;
                }
                const tcb = compiler.getTemplateTypeChecker().getTypeCheckBlock(templateInfo.component);
                if (tcb === null) {
                    return undefined;
                }
                const sf = tcb.getSourceFile();
                let selections = [];
                const target = getTargetAtPosition(templateInfo.template, position);
                if (target !== null) {
                    let selectionSpans;
                    if ('nodes' in target.context) {
                        selectionSpans = target.context.nodes.map(n => n.sourceSpan);
                    }
                    else {
                        selectionSpans = [target.context.node.sourceSpan];
                    }
                    const selectionNodes = selectionSpans
                        .map(s => findFirstMatchingNode(tcb, {
                        withSpan: s,
                        filter: (node) => true,
                    }))
                        .filter((n) => n !== null);
                    selections = selectionNodes.map(n => {
                        return {
                            start: n.getStart(sf),
                            length: n.getEnd() - n.getStart(sf),
                        };
                    });
                }
                return {
                    fileName: sf.fileName,
                    content: sf.getFullText(),
                    selections,
                };
            });
        }
        /**
         * Provides an instance of the `NgCompiler` and traces perf results. Perf results are logged only
         * if the log level is verbose or higher. This method is intended to be called once per public
         * method call.
         *
         * Here is an example of the log output.
         *
         * Perf 245  [16:16:39.353] LanguageService#getQuickInfoAtPosition(): {"events":{},"phases":{
         * "Unaccounted":379,"TtcSymbol":4},"memory":{}}
         *
         * Passing name of caller instead of using `arguments.caller` because 'caller', 'callee', and
         * 'arguments' properties may not be accessed in strict mode.
         *
         * @param phase the `PerfPhase` to execute the `p` callback in
         * @param p callback to be run synchronously with an instance of the `NgCompiler` as argument
         * @return the result of running the `p` callback
         */
        withCompilerAndPerfTracing(phase, p) {
            const compiler = this.compilerFactory.getOrCreate();
            const result = compiler.perfRecorder.inPhase(phase, () => p(compiler));
            const logger = this.project.projectService.logger;
            if (logger.hasLevel(ts.server.LogLevel.verbose)) {
                logger.perftrc(`LanguageService#${PerfPhase[phase]}: ${JSON.stringify(compiler.perfRecorder.finalize())}`);
            }
            return result;
        }
        getCompilerOptionsDiagnostics() {
            const project = this.project;
            if (!(project instanceof ts.server.ConfiguredProject)) {
                return [];
            }
            return this.withCompilerAndPerfTracing(PerfPhase.LsDiagnostics, (compiler) => {
                const diagnostics = [];
                const configSourceFile = ts.readJsonConfigFile(project.getConfigFilePath(), (path) => project.readFile(path));
                if (!this.options.strictTemplates && !this.options.fullTemplateTypeCheck) {
                    diagnostics.push({
                        messageText: 'Some language features are not available. ' +
                            'To access all features, enable `strictTemplates` in `angularCompilerOptions`.',
                        category: ts.DiagnosticCategory.Suggestion,
                        code: ngErrorCode(ErrorCode.SUGGEST_STRICT_TEMPLATES),
                        file: configSourceFile,
                        start: undefined,
                        length: undefined,
                    });
                }
                diagnostics.push(...compiler.getOptionDiagnostics());
                return diagnostics;
            });
        }
        watchConfigFile(project) {
            // TODO: Check the case when the project is disposed. An InferredProject
            // could be disposed when a tsconfig.json is added to the workspace,
            // in which case it becomes a ConfiguredProject (or vice-versa).
            // We need to make sure that the FileWatcher is closed.
            if (!(project instanceof ts.server.ConfiguredProject)) {
                return;
            }
            const { host } = project.projectService;
            host.watchFile(project.getConfigFilePath(), (fileName, eventKind) => {
                project.log(`Config file changed: ${fileName}`);
                if (eventKind === ts.FileWatcherEventKind.Changed) {
                    this.options = parseNgCompilerOptions(project, this.parseConfigHost, this.config);
                    logCompilerOptions(project, this.options);
                }
            });
        }
    }
    function logCompilerOptions(project, options) {
        const { logger } = project.projectService;
        const projectName = project.getProjectName();
        logger.info(`Angular compiler options for ${projectName}: ` + JSON.stringify(options, null, 2));
    }
    function parseNgCompilerOptions(project, host, config) {
        if (!(project instanceof ts.server.ConfiguredProject)) {
            return {};
        }
        const { options, errors } = readConfiguration(project.getConfigFilePath(), /* existingOptions */ undefined, host);
        if (errors.length > 0) {
            project.setProjectErrors(errors);
        }
        // Projects loaded into the Language Service often include test files which are not part of the
        // app's main compilation unit, and these test files often include inline NgModules that declare
        // components from the app. These declarations conflict with the main declarations of such
        // components in the app's NgModules. This conflict is not normally present during regular
        // compilation because the app and the tests are part of separate compilation units.
        //
        // As a temporary mitigation of this problem, we instruct the compiler to ignore classes which
        // are not exported. In many cases, this ensures the test NgModules are ignored by the compiler
        // and only the real component declaration is used.
        options.compileNonExportedClasses = false;
        // If `forceStrictTemplates` is true, always enable `strictTemplates`
        // regardless of its value in tsconfig.json.
        if (config.forceStrictTemplates === true) {
            options.strictTemplates = true;
        }
        return options;
    }
    function createProgramDriver(project) {
        return {
            supportsInlineOperations: false,
            getProgram() {
                const program = project.getLanguageService().getProgram();
                if (!program) {
                    throw new Error('Language service does not have a program!');
                }
                return program;
            },
            updateFiles(contents) {
                for (const [fileName, { newText }] of contents) {
                    const scriptInfo = getOrCreateTypeCheckScriptInfo(project, fileName);
                    const snapshot = scriptInfo.getSnapshot();
                    const length = snapshot.getLength();
                    scriptInfo.editContent(0, length, newText);
                }
            },
            getSourceFileVersion(sf) {
                return project.getScriptVersion(sf.fileName);
            }
        };
    }
    function getOrCreateTypeCheckScriptInfo(project, tcf) {
        // First check if there is already a ScriptInfo for the tcf
        const { projectService } = project;
        let scriptInfo = projectService.getScriptInfo(tcf);
        if (!scriptInfo) {
            // ScriptInfo needs to be opened by client to be able to set its user-defined
            // content. We must also provide file content, otherwise the service will
            // attempt to fetch the content from disk and fail.
            scriptInfo = projectService.getOrCreateScriptInfoForNormalizedPath(ts.server.toNormalizedPath(tcf), true, // openedByClient
            '', // fileContent
            // script info added by plugins should be marked as external, see
            // https://github.com/microsoft/TypeScript/blob/b217f22e798c781f55d17da72ed099a9dee5c650/src/compiler/program.ts#L1897-L1899
            ts.ScriptKind.External);
            if (!scriptInfo) {
                throw new Error(`Failed to create script info for ${tcf}`);
            }
        }
        // Add ScriptInfo to project if it's missing. A ScriptInfo needs to be part of
        // the project so that it becomes part of the program.
        if (!project.containsScriptInfo(scriptInfo)) {
            project.addRoot(scriptInfo);
        }
        return scriptInfo;
    }
    function isTemplateContext(program, fileName, position) {
        if (!isTypeScriptFile(fileName)) {
            // If we aren't in a TS file, we must be in an HTML file, which we treat as template context
            return true;
        }
        const node = findTightestNodeAtPosition(program, fileName, position);
        if (node === undefined) {
            return false;
        }
        let asgn = getPropertyAssignmentFromValue(node, 'template');
        if (asgn === null) {
            return false;
        }
        return getClassDeclFromDecoratorProp(asgn) !== null;
    }
    function isInAngularContext(program, fileName, position) {
        var _a, _b;
        if (!isTypeScriptFile(fileName)) {
            return true;
        }
        const node = findTightestNodeAtPosition(program, fileName, position);
        if (node === undefined) {
            return false;
        }
        const asgn = (_b = (_a = getPropertyAssignmentFromValue(node, 'template')) !== null && _a !== void 0 ? _a : getPropertyAssignmentFromValue(node, 'templateUrl')) !== null && _b !== void 0 ? _b : getPropertyAssignmentFromValue(node.parent, 'styleUrls');
        return asgn !== null && getClassDeclFromDecoratorProp(asgn) !== null;
    }
    function findTightestNodeAtPosition(program, fileName, position) {
        const sourceFile = program.getSourceFile(fileName);
        if (sourceFile === undefined) {
            return undefined;
        }
        return findTightestNode(sourceFile, position);
    }
    function getUniqueLocations(locations) {
        const uniqueLocations = new Map();
        for (const location of locations) {
            uniqueLocations.set(createLocationKey(location), location);
        }
        return Array.from(uniqueLocations.values());
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function create(info) {
        const { project, languageService: tsLS, config } = info;
        const angularOnly = (config === null || config === void 0 ? void 0 : config.angularOnly) === true;
        const ngLS = new LanguageService(project, tsLS, config);
        function getSemanticDiagnostics(fileName) {
            const diagnostics = [];
            if (!angularOnly) {
                diagnostics.push(...tsLS.getSemanticDiagnostics(fileName));
            }
            diagnostics.push(...ngLS.getSemanticDiagnostics(fileName));
            return diagnostics;
        }
        function getQuickInfoAtPosition(fileName, position) {
            var _a;
            if (angularOnly) {
                return ngLS.getQuickInfoAtPosition(fileName, position);
            }
            else {
                // If TS could answer the query, then return that result. Otherwise, return from Angular LS.
                return (_a = tsLS.getQuickInfoAtPosition(fileName, position)) !== null && _a !== void 0 ? _a : ngLS.getQuickInfoAtPosition(fileName, position);
            }
        }
        function getTypeDefinitionAtPosition(fileName, position) {
            var _a;
            if (angularOnly) {
                return ngLS.getTypeDefinitionAtPosition(fileName, position);
            }
            else {
                // If TS could answer the query, then return that result. Otherwise, return from Angular LS.
                return (_a = tsLS.getTypeDefinitionAtPosition(fileName, position)) !== null && _a !== void 0 ? _a : ngLS.getTypeDefinitionAtPosition(fileName, position);
            }
        }
        function getDefinitionAndBoundSpan(fileName, position) {
            var _a;
            if (angularOnly) {
                return ngLS.getDefinitionAndBoundSpan(fileName, position);
            }
            else {
                // If TS could answer the query, then return that result. Otherwise, return from Angular LS.
                return (_a = tsLS.getDefinitionAndBoundSpan(fileName, position)) !== null && _a !== void 0 ? _a : ngLS.getDefinitionAndBoundSpan(fileName, position);
            }
        }
        function getReferencesAtPosition(fileName, position) {
            return ngLS.getReferencesAtPosition(fileName, position);
        }
        function findRenameLocations(fileName, position, findInStrings, findInComments, providePrefixAndSuffixTextForRename) {
            // Most operations combine results from all extensions. However, rename locations are exclusive
            // (results from only one extension are used) so our rename locations are a superset of the TS
            // rename locations. As a result, we do not check the `angularOnly` flag here because we always
            // want to include results at TS locations as well as locations in templates.
            return ngLS.findRenameLocations(fileName, position);
        }
        function getRenameInfo(fileName, position) {
            // See the comment in `findRenameLocations` explaining why we don't check the `angularOnly`
            // flag.
            return ngLS.getRenameInfo(fileName, position);
        }
        function getCompletionsAtPosition(fileName, position, options) {
            var _a;
            if (angularOnly) {
                return ngLS.getCompletionsAtPosition(fileName, position, options);
            }
            else {
                // If TS could answer the query, then return that result. Otherwise, return from Angular LS.
                return (_a = tsLS.getCompletionsAtPosition(fileName, position, options)) !== null && _a !== void 0 ? _a : ngLS.getCompletionsAtPosition(fileName, position, options);
            }
        }
        function getCompletionEntryDetails(fileName, position, entryName, formatOptions, source, preferences, data) {
            var _a;
            if (angularOnly) {
                return ngLS.getCompletionEntryDetails(fileName, position, entryName, formatOptions, preferences, data);
            }
            else {
                // If TS could answer the query, then return that result. Otherwise, return from Angular LS.
                return (_a = tsLS.getCompletionEntryDetails(fileName, position, entryName, formatOptions, source, preferences, data)) !== null && _a !== void 0 ? _a : ngLS.getCompletionEntryDetails(fileName, position, entryName, formatOptions, preferences, data);
            }
        }
        function getCompletionEntrySymbol(fileName, position, name, source) {
            var _a;
            if (angularOnly) {
                return ngLS.getCompletionEntrySymbol(fileName, position, name);
            }
            else {
                // If TS could answer the query, then return that result. Otherwise, return from Angular LS.
                return (_a = tsLS.getCompletionEntrySymbol(fileName, position, name, source)) !== null && _a !== void 0 ? _a : ngLS.getCompletionEntrySymbol(fileName, position, name);
            }
        }
        /**
         * Gets global diagnostics related to the program configuration and compiler options.
         */
        function getCompilerOptionsDiagnostics() {
            const diagnostics = [];
            if (!angularOnly) {
                diagnostics.push(...tsLS.getCompilerOptionsDiagnostics());
            }
            diagnostics.push(...ngLS.getCompilerOptionsDiagnostics());
            return diagnostics;
        }
        function getSignatureHelpItems(fileName, position, options) {
            var _a;
            if (angularOnly) {
                return ngLS.getSignatureHelpItems(fileName, position, options);
            }
            else {
                return (_a = tsLS.getSignatureHelpItems(fileName, position, options)) !== null && _a !== void 0 ? _a : ngLS.getSignatureHelpItems(fileName, position, options);
            }
        }
        function getTcb(fileName, position) {
            return ngLS.getTcb(fileName, position);
        }
        /**
         * Given an external template, finds the associated components that use it as a `templateUrl`.
         */
        function getComponentLocationsForTemplate(fileName) {
            return ngLS.getComponentLocationsForTemplate(fileName);
        }
        return Object.assign(Object.assign({}, tsLS), { getSemanticDiagnostics,
            getTypeDefinitionAtPosition,
            getQuickInfoAtPosition,
            getDefinitionAndBoundSpan,
            getReferencesAtPosition,
            findRenameLocations,
            getRenameInfo,
            getCompletionsAtPosition,
            getCompletionEntryDetails,
            getCompletionEntrySymbol,
            getTcb,
            getCompilerOptionsDiagnostics,
            getComponentLocationsForTemplate,
            getSignatureHelpItems });
    }
    function getExternalFiles(project) {
        if (!project.hasRoots()) {
            return []; // project has not been initialized
        }
        const typecheckFiles = [];
        for (const scriptInfo of project.getScriptInfos()) {
            if (scriptInfo.scriptKind === ts.ScriptKind.External) {
                // script info for typecheck file is marked as external, see
                // getOrCreateTypeCheckScriptInfo() in
                // packages/language-service/ivy/language_service.ts
                typecheckFiles.push(scriptInfo.fileName);
            }
        }
        return typecheckFiles;
    }

    exports.create = create;
    exports.getExternalFiles = getExternalFiles;

    Object.defineProperty(exports, '__esModule', { value: true });

});
//# sourceMappingURL=ivy.js.map

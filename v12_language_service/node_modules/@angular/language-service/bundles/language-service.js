/**
 * @license Angular v12.2.12
 * Copyright Google LLC All Rights Reserved.
 * License: MIT
 */

let $deferred;
function define(modules, callback) {
  $deferred = {modules, callback};
}
module.exports = function(provided) {
  const ts = provided['typescript'];
  if (!ts) {
    throw new Error('Caller does not provide typescript module');
  }
  const results = {};
  const resolvedModules = $deferred.modules.map(m => {
    if (m === 'exports') {
      return results;
    }
    if (m === 'typescript' || m === 'typescript/lib/tsserverlibrary') {
      return ts;
    }
    return require(m);
  });
  $deferred.callback(...resolvedModules);
  return results;
};

define(['exports', 'typescript/lib/tsserverlibrary', 'typescript', 'path'], function (exports, tss, ts, path) { 'use strict';

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var TagContentType;
    (function (TagContentType) {
        TagContentType[TagContentType["RAW_TEXT"] = 0] = "RAW_TEXT";
        TagContentType[TagContentType["ESCAPABLE_RAW_TEXT"] = 1] = "ESCAPABLE_RAW_TEXT";
        TagContentType[TagContentType["PARSABLE_DATA"] = 2] = "PARSABLE_DATA";
    })(TagContentType || (TagContentType = {}));
    function splitNsName(elementName) {
        if (elementName[0] != ':') {
            return [null, elementName];
        }
        const colonIndex = elementName.indexOf(':', 1);
        if (colonIndex === -1) {
            throw new Error(`Unsupported format "${elementName}" expecting ":namespace:name"`);
        }
        return [elementName.slice(1, colonIndex), elementName.slice(colonIndex + 1)];
    }
    // `<ng-container>` tags work the same regardless the namespace
    function isNgContainer(tagName) {
        return splitNsName(tagName)[1] === 'ng-container';
    }
    // `<ng-content>` tags work the same regardless the namespace
    function isNgContent(tagName) {
        return splitNsName(tagName)[1] === 'ng-content';
    }
    // `<ng-template>` tags work the same regardless the namespace
    function isNgTemplate(tagName) {
        return splitNsName(tagName)[1] === 'ng-template';
    }
    function getNsPrefix(fullName) {
        return fullName === null ? null : splitNsName(fullName)[0];
    }
    function mergeNsAndName(prefix, localName) {
        return prefix ? `:${prefix}:${localName}` : localName;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class HtmlTagDefinition {
        constructor({ closedByChildren, implicitNamespacePrefix, contentType = TagContentType.PARSABLE_DATA, closedByParent = false, isVoid = false, ignoreFirstLf = false, preventNamespaceInheritance = false } = {}) {
            this.closedByChildren = {};
            this.closedByParent = false;
            this.canSelfClose = false;
            if (closedByChildren && closedByChildren.length > 0) {
                closedByChildren.forEach(tagName => this.closedByChildren[tagName] = true);
            }
            this.isVoid = isVoid;
            this.closedByParent = closedByParent || isVoid;
            this.implicitNamespacePrefix = implicitNamespacePrefix || null;
            this.contentType = contentType;
            this.ignoreFirstLf = ignoreFirstLf;
            this.preventNamespaceInheritance = preventNamespaceInheritance;
        }
        isClosedByChild(name) {
            return this.isVoid || name.toLowerCase() in this.closedByChildren;
        }
        getContentType(prefix) {
            if (typeof this.contentType === 'object') {
                const overrideType = prefix === undefined ? undefined : this.contentType[prefix];
                return overrideType !== null && overrideType !== void 0 ? overrideType : this.contentType.default;
            }
            return this.contentType;
        }
    }
    let _DEFAULT_TAG_DEFINITION;
    // see https://www.w3.org/TR/html51/syntax.html#optional-tags
    // This implementation does not fully conform to the HTML5 spec.
    let TAG_DEFINITIONS;
    function getHtmlTagDefinition(tagName) {
        var _a, _b;
        if (!TAG_DEFINITIONS) {
            _DEFAULT_TAG_DEFINITION = new HtmlTagDefinition();
            TAG_DEFINITIONS = {
                'base': new HtmlTagDefinition({ isVoid: true }),
                'meta': new HtmlTagDefinition({ isVoid: true }),
                'area': new HtmlTagDefinition({ isVoid: true }),
                'embed': new HtmlTagDefinition({ isVoid: true }),
                'link': new HtmlTagDefinition({ isVoid: true }),
                'img': new HtmlTagDefinition({ isVoid: true }),
                'input': new HtmlTagDefinition({ isVoid: true }),
                'param': new HtmlTagDefinition({ isVoid: true }),
                'hr': new HtmlTagDefinition({ isVoid: true }),
                'br': new HtmlTagDefinition({ isVoid: true }),
                'source': new HtmlTagDefinition({ isVoid: true }),
                'track': new HtmlTagDefinition({ isVoid: true }),
                'wbr': new HtmlTagDefinition({ isVoid: true }),
                'p': new HtmlTagDefinition({
                    closedByChildren: [
                        'address', 'article', 'aside', 'blockquote', 'div', 'dl', 'fieldset',
                        'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5',
                        'h6', 'header', 'hgroup', 'hr', 'main', 'nav', 'ol',
                        'p', 'pre', 'section', 'table', 'ul'
                    ],
                    closedByParent: true
                }),
                'thead': new HtmlTagDefinition({ closedByChildren: ['tbody', 'tfoot'] }),
                'tbody': new HtmlTagDefinition({ closedByChildren: ['tbody', 'tfoot'], closedByParent: true }),
                'tfoot': new HtmlTagDefinition({ closedByChildren: ['tbody'], closedByParent: true }),
                'tr': new HtmlTagDefinition({ closedByChildren: ['tr'], closedByParent: true }),
                'td': new HtmlTagDefinition({ closedByChildren: ['td', 'th'], closedByParent: true }),
                'th': new HtmlTagDefinition({ closedByChildren: ['td', 'th'], closedByParent: true }),
                'col': new HtmlTagDefinition({ isVoid: true }),
                'svg': new HtmlTagDefinition({ implicitNamespacePrefix: 'svg' }),
                'foreignObject': new HtmlTagDefinition({
                    // Usually the implicit namespace here would be redundant since it will be inherited from
                    // the parent `svg`, but we have to do it for `foreignObject`, because the way the parser
                    // works is that the parent node of an end tag is its own start tag which means that
                    // the `preventNamespaceInheritance` on `foreignObject` would have it default to the
                    // implicit namespace which is `html`, unless specified otherwise.
                    implicitNamespacePrefix: 'svg',
                    // We want to prevent children of foreignObject from inheriting its namespace, because
                    // the point of the element is to allow nodes from other namespaces to be inserted.
                    preventNamespaceInheritance: true,
                }),
                'math': new HtmlTagDefinition({ implicitNamespacePrefix: 'math' }),
                'li': new HtmlTagDefinition({ closedByChildren: ['li'], closedByParent: true }),
                'dt': new HtmlTagDefinition({ closedByChildren: ['dt', 'dd'] }),
                'dd': new HtmlTagDefinition({ closedByChildren: ['dt', 'dd'], closedByParent: true }),
                'rb': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),
                'rt': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),
                'rtc': new HtmlTagDefinition({ closedByChildren: ['rb', 'rtc', 'rp'], closedByParent: true }),
                'rp': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),
                'optgroup': new HtmlTagDefinition({ closedByChildren: ['optgroup'], closedByParent: true }),
                'option': new HtmlTagDefinition({ closedByChildren: ['option', 'optgroup'], closedByParent: true }),
                'pre': new HtmlTagDefinition({ ignoreFirstLf: true }),
                'listing': new HtmlTagDefinition({ ignoreFirstLf: true }),
                'style': new HtmlTagDefinition({ contentType: TagContentType.RAW_TEXT }),
                'script': new HtmlTagDefinition({ contentType: TagContentType.RAW_TEXT }),
                'title': new HtmlTagDefinition({
                    // The browser supports two separate `title` tags which have to use
                    // a different content type: `HTMLTitleElement` and `SVGTitleElement`
                    contentType: { default: TagContentType.ESCAPABLE_RAW_TEXT, svg: TagContentType.PARSABLE_DATA }
                }),
                'textarea': new HtmlTagDefinition({ contentType: TagContentType.ESCAPABLE_RAW_TEXT, ignoreFirstLf: true }),
            };
        }
        // We have to make both a case-sensitive and a case-insesitive lookup, because
        // HTML tag names are case insensitive, whereas some SVG tags are case sensitive.
        return (_b = (_a = TAG_DEFINITIONS[tagName]) !== null && _a !== void 0 ? _a : TAG_DEFINITIONS[tagName.toLowerCase()]) !== null && _b !== void 0 ? _b : _DEFAULT_TAG_DEFINITION;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const _SELECTOR_REGEXP = new RegExp('(\\:not\\()|' + // 1: ":not("
        '(([\\.\\#]?)[-\\w]+)|' + // 2: "tag"; 3: "."/"#";
        // "-" should appear first in the regexp below as FF31 parses "[.-\w]" as a range
        // 4: attribute; 5: attribute_string; 6: attribute_value
        '(?:\\[([-.\\w*\\\\$]+)(?:=([\"\']?)([^\\]\"\']*)\\5)?\\])|' + // "[name]", "[name=value]",
        // "[name="value"]",
        // "[name='value']"
        '(\\))|' + // 7: ")"
        '(\\s*,\\s*)', // 8: ","
    'g');
    /**
     * A css selector contains an element name,
     * css classes and attribute/value pairs with the purpose
     * of selecting subsets out of them.
     */
    class CssSelector {
        constructor() {
            this.element = null;
            this.classNames = [];
            /**
             * The selectors are encoded in pairs where:
             * - even locations are attribute names
             * - odd locations are attribute values.
             *
             * Example:
             * Selector: `[key1=value1][key2]` would parse to:
             * ```
             * ['key1', 'value1', 'key2', '']
             * ```
             */
            this.attrs = [];
            this.notSelectors = [];
        }
        static parse(selector) {
            const results = [];
            const _addResult = (res, cssSel) => {
                if (cssSel.notSelectors.length > 0 && !cssSel.element && cssSel.classNames.length == 0 &&
                    cssSel.attrs.length == 0) {
                    cssSel.element = '*';
                }
                res.push(cssSel);
            };
            let cssSelector = new CssSelector();
            let match;
            let current = cssSelector;
            let inNot = false;
            _SELECTOR_REGEXP.lastIndex = 0;
            while (match = _SELECTOR_REGEXP.exec(selector)) {
                if (match[1 /* NOT */]) {
                    if (inNot) {
                        throw new Error('Nesting :not in a selector is not allowed');
                    }
                    inNot = true;
                    current = new CssSelector();
                    cssSelector.notSelectors.push(current);
                }
                const tag = match[2 /* TAG */];
                if (tag) {
                    const prefix = match[3 /* PREFIX */];
                    if (prefix === '#') {
                        // #hash
                        current.addAttribute('id', tag.substr(1));
                    }
                    else if (prefix === '.') {
                        // Class
                        current.addClassName(tag.substr(1));
                    }
                    else {
                        // Element
                        current.setElement(tag);
                    }
                }
                const attribute = match[4 /* ATTRIBUTE */];
                if (attribute) {
                    current.addAttribute(current.unescapeAttribute(attribute), match[6 /* ATTRIBUTE_VALUE */]);
                }
                if (match[7 /* NOT_END */]) {
                    inNot = false;
                    current = cssSelector;
                }
                if (match[8 /* SEPARATOR */]) {
                    if (inNot) {
                        throw new Error('Multiple selectors in :not are not supported');
                    }
                    _addResult(results, cssSelector);
                    cssSelector = current = new CssSelector();
                }
            }
            _addResult(results, cssSelector);
            return results;
        }
        /**
         * Unescape `\$` sequences from the CSS attribute selector.
         *
         * This is needed because `$` can have a special meaning in CSS selectors,
         * but we might want to match an attribute that contains `$`.
         * [MDN web link for more
         * info](https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors).
         * @param attr the attribute to unescape.
         * @returns the unescaped string.
         */
        unescapeAttribute(attr) {
            let result = '';
            let escaping = false;
            for (let i = 0; i < attr.length; i++) {
                const char = attr.charAt(i);
                if (char === '\\') {
                    escaping = true;
                    continue;
                }
                if (char === '$' && !escaping) {
                    throw new Error(`Error in attribute selector "${attr}". ` +
                        `Unescaped "$" is not supported. Please escape with "\\$".`);
                }
                escaping = false;
                result += char;
            }
            return result;
        }
        /**
         * Escape `$` sequences from the CSS attribute selector.
         *
         * This is needed because `$` can have a special meaning in CSS selectors,
         * with this method we are escaping `$` with `\$'.
         * [MDN web link for more
         * info](https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors).
         * @param attr the attribute to escape.
         * @returns the escaped string.
         */
        escapeAttribute(attr) {
            return attr.replace(/\\/g, '\\\\').replace(/\$/g, '\\$');
        }
        isElementSelector() {
            return this.hasElementSelector() && this.classNames.length == 0 && this.attrs.length == 0 &&
                this.notSelectors.length === 0;
        }
        hasElementSelector() {
            return !!this.element;
        }
        setElement(element = null) {
            this.element = element;
        }
        /** Gets a template string for an element that matches the selector. */
        getMatchingElementTemplate() {
            const tagName = this.element || 'div';
            const classAttr = this.classNames.length > 0 ? ` class="${this.classNames.join(' ')}"` : '';
            let attrs = '';
            for (let i = 0; i < this.attrs.length; i += 2) {
                const attrName = this.attrs[i];
                const attrValue = this.attrs[i + 1] !== '' ? `="${this.attrs[i + 1]}"` : '';
                attrs += ` ${attrName}${attrValue}`;
            }
            return getHtmlTagDefinition(tagName).isVoid ? `<${tagName}${classAttr}${attrs}/>` :
                `<${tagName}${classAttr}${attrs}></${tagName}>`;
        }
        getAttrs() {
            const result = [];
            if (this.classNames.length > 0) {
                result.push('class', this.classNames.join(' '));
            }
            return result.concat(this.attrs);
        }
        addAttribute(name, value = '') {
            this.attrs.push(name, value && value.toLowerCase() || '');
        }
        addClassName(name) {
            this.classNames.push(name.toLowerCase());
        }
        toString() {
            let res = this.element || '';
            if (this.classNames) {
                this.classNames.forEach(klass => res += `.${klass}`);
            }
            if (this.attrs) {
                for (let i = 0; i < this.attrs.length; i += 2) {
                    const name = this.escapeAttribute(this.attrs[i]);
                    const value = this.attrs[i + 1];
                    res += `[${name}${value ? '=' + value : ''}]`;
                }
            }
            this.notSelectors.forEach(notSelector => res += `:not(${notSelector})`);
            return res;
        }
    }
    /**
     * Reads a list of CssSelectors and allows to calculate which ones
     * are contained in a given CssSelector.
     */
    class SelectorMatcher {
        constructor() {
            this._elementMap = new Map();
            this._elementPartialMap = new Map();
            this._classMap = new Map();
            this._classPartialMap = new Map();
            this._attrValueMap = new Map();
            this._attrValuePartialMap = new Map();
            this._listContexts = [];
        }
        static createNotMatcher(notSelectors) {
            const notMatcher = new SelectorMatcher();
            notMatcher.addSelectables(notSelectors, null);
            return notMatcher;
        }
        addSelectables(cssSelectors, callbackCtxt) {
            let listContext = null;
            if (cssSelectors.length > 1) {
                listContext = new SelectorListContext(cssSelectors);
                this._listContexts.push(listContext);
            }
            for (let i = 0; i < cssSelectors.length; i++) {
                this._addSelectable(cssSelectors[i], callbackCtxt, listContext);
            }
        }
        /**
         * Add an object that can be found later on by calling `match`.
         * @param cssSelector A css selector
         * @param callbackCtxt An opaque object that will be given to the callback of the `match` function
         */
        _addSelectable(cssSelector, callbackCtxt, listContext) {
            let matcher = this;
            const element = cssSelector.element;
            const classNames = cssSelector.classNames;
            const attrs = cssSelector.attrs;
            const selectable = new SelectorContext(cssSelector, callbackCtxt, listContext);
            if (element) {
                const isTerminal = attrs.length === 0 && classNames.length === 0;
                if (isTerminal) {
                    this._addTerminal(matcher._elementMap, element, selectable);
                }
                else {
                    matcher = this._addPartial(matcher._elementPartialMap, element);
                }
            }
            if (classNames) {
                for (let i = 0; i < classNames.length; i++) {
                    const isTerminal = attrs.length === 0 && i === classNames.length - 1;
                    const className = classNames[i];
                    if (isTerminal) {
                        this._addTerminal(matcher._classMap, className, selectable);
                    }
                    else {
                        matcher = this._addPartial(matcher._classPartialMap, className);
                    }
                }
            }
            if (attrs) {
                for (let i = 0; i < attrs.length; i += 2) {
                    const isTerminal = i === attrs.length - 2;
                    const name = attrs[i];
                    const value = attrs[i + 1];
                    if (isTerminal) {
                        const terminalMap = matcher._attrValueMap;
                        let terminalValuesMap = terminalMap.get(name);
                        if (!terminalValuesMap) {
                            terminalValuesMap = new Map();
                            terminalMap.set(name, terminalValuesMap);
                        }
                        this._addTerminal(terminalValuesMap, value, selectable);
                    }
                    else {
                        const partialMap = matcher._attrValuePartialMap;
                        let partialValuesMap = partialMap.get(name);
                        if (!partialValuesMap) {
                            partialValuesMap = new Map();
                            partialMap.set(name, partialValuesMap);
                        }
                        matcher = this._addPartial(partialValuesMap, value);
                    }
                }
            }
        }
        _addTerminal(map, name, selectable) {
            let terminalList = map.get(name);
            if (!terminalList) {
                terminalList = [];
                map.set(name, terminalList);
            }
            terminalList.push(selectable);
        }
        _addPartial(map, name) {
            let matcher = map.get(name);
            if (!matcher) {
                matcher = new SelectorMatcher();
                map.set(name, matcher);
            }
            return matcher;
        }
        /**
         * Find the objects that have been added via `addSelectable`
         * whose css selector is contained in the given css selector.
         * @param cssSelector A css selector
         * @param matchedCallback This callback will be called with the object handed into `addSelectable`
         * @return boolean true if a match was found
         */
        match(cssSelector, matchedCallback) {
            let result = false;
            const element = cssSelector.element;
            const classNames = cssSelector.classNames;
            const attrs = cssSelector.attrs;
            for (let i = 0; i < this._listContexts.length; i++) {
                this._listContexts[i].alreadyMatched = false;
            }
            result = this._matchTerminal(this._elementMap, element, cssSelector, matchedCallback) || result;
            result = this._matchPartial(this._elementPartialMap, element, cssSelector, matchedCallback) ||
                result;
            if (classNames) {
                for (let i = 0; i < classNames.length; i++) {
                    const className = classNames[i];
                    result =
                        this._matchTerminal(this._classMap, className, cssSelector, matchedCallback) || result;
                    result =
                        this._matchPartial(this._classPartialMap, className, cssSelector, matchedCallback) ||
                            result;
                }
            }
            if (attrs) {
                for (let i = 0; i < attrs.length; i += 2) {
                    const name = attrs[i];
                    const value = attrs[i + 1];
                    const terminalValuesMap = this._attrValueMap.get(name);
                    if (value) {
                        result =
                            this._matchTerminal(terminalValuesMap, '', cssSelector, matchedCallback) || result;
                    }
                    result =
                        this._matchTerminal(terminalValuesMap, value, cssSelector, matchedCallback) || result;
                    const partialValuesMap = this._attrValuePartialMap.get(name);
                    if (value) {
                        result = this._matchPartial(partialValuesMap, '', cssSelector, matchedCallback) || result;
                    }
                    result =
                        this._matchPartial(partialValuesMap, value, cssSelector, matchedCallback) || result;
                }
            }
            return result;
        }
        /** @internal */
        _matchTerminal(map, name, cssSelector, matchedCallback) {
            if (!map || typeof name !== 'string') {
                return false;
            }
            let selectables = map.get(name) || [];
            const starSelectables = map.get('*');
            if (starSelectables) {
                selectables = selectables.concat(starSelectables);
            }
            if (selectables.length === 0) {
                return false;
            }
            let selectable;
            let result = false;
            for (let i = 0; i < selectables.length; i++) {
                selectable = selectables[i];
                result = selectable.finalize(cssSelector, matchedCallback) || result;
            }
            return result;
        }
        /** @internal */
        _matchPartial(map, name, cssSelector, matchedCallback) {
            if (!map || typeof name !== 'string') {
                return false;
            }
            const nestedSelector = map.get(name);
            if (!nestedSelector) {
                return false;
            }
            // TODO(perf): get rid of recursion and measure again
            // TODO(perf): don't pass the whole selector into the recursion,
            // but only the not processed parts
            return nestedSelector.match(cssSelector, matchedCallback);
        }
    }
    class SelectorListContext {
        constructor(selectors) {
            this.selectors = selectors;
            this.alreadyMatched = false;
        }
    }
    // Store context to pass back selector and context when a selector is matched
    class SelectorContext {
        constructor(selector, cbContext, listContext) {
            this.selector = selector;
            this.cbContext = cbContext;
            this.listContext = listContext;
            this.notSelectors = selector.notSelectors;
        }
        finalize(cssSelector, callback) {
            let result = true;
            if (this.notSelectors.length > 0 && (!this.listContext || !this.listContext.alreadyMatched)) {
                const notMatcher = SelectorMatcher.createNotMatcher(this.notSelectors);
                result = !notMatcher.match(cssSelector, null);
            }
            if (result && callback && (!this.listContext || !this.listContext.alreadyMatched)) {
                if (this.listContext) {
                    this.listContext.alreadyMatched = true;
                }
                callback(this.selector, this.cbContext);
            }
            return result;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const createInject = makeMetadataFactory('Inject', (token) => ({ token }));
    const createInjectionToken = makeMetadataFactory('InjectionToken', (desc) => ({ _desc: desc, Éµprov: undefined }));
    const createAttribute = makeMetadataFactory('Attribute', (attributeName) => ({ attributeName }));
    // Stores the default value of `emitDistinctChangesOnly` when the `emitDistinctChangesOnly` is not
    // explicitly set.
    const emitDistinctChangesOnlyDefaultValue = true;
    const createContentChildren = makeMetadataFactory('ContentChildren', (selector, data = {}) => (Object.assign({ selector, first: false, isViewQuery: false, descendants: false, emitDistinctChangesOnly: emitDistinctChangesOnlyDefaultValue }, data)));
    const createContentChild = makeMetadataFactory('ContentChild', (selector, data = {}) => (Object.assign({ selector, first: true, isViewQuery: false, descendants: true }, data)));
    const createViewChildren = makeMetadataFactory('ViewChildren', (selector, data = {}) => (Object.assign({ selector, first: false, isViewQuery: true, descendants: true, emitDistinctChangesOnly: emitDistinctChangesOnlyDefaultValue }, data)));
    const createViewChild = makeMetadataFactory('ViewChild', (selector, data) => (Object.assign({ selector, first: true, isViewQuery: true, descendants: true }, data)));
    const createDirective = makeMetadataFactory('Directive', (dir = {}) => dir);
    var ViewEncapsulation;
    (function (ViewEncapsulation) {
        ViewEncapsulation[ViewEncapsulation["Emulated"] = 0] = "Emulated";
        // Historically the 1 value was for `Native` encapsulation which has been removed as of v11.
        ViewEncapsulation[ViewEncapsulation["None"] = 2] = "None";
        ViewEncapsulation[ViewEncapsulation["ShadowDom"] = 3] = "ShadowDom";
    })(ViewEncapsulation || (ViewEncapsulation = {}));
    var ChangeDetectionStrategy;
    (function (ChangeDetectionStrategy) {
        ChangeDetectionStrategy[ChangeDetectionStrategy["OnPush"] = 0] = "OnPush";
        ChangeDetectionStrategy[ChangeDetectionStrategy["Default"] = 1] = "Default";
    })(ChangeDetectionStrategy || (ChangeDetectionStrategy = {}));
    const createComponent = makeMetadataFactory('Component', (c = {}) => (Object.assign({ changeDetection: ChangeDetectionStrategy.Default }, c)));
    const createPipe = makeMetadataFactory('Pipe', (p) => (Object.assign({ pure: true }, p)));
    const createInput = makeMetadataFactory('Input', (bindingPropertyName) => ({ bindingPropertyName }));
    const createOutput = makeMetadataFactory('Output', (bindingPropertyName) => ({ bindingPropertyName }));
    const createHostBinding = makeMetadataFactory('HostBinding', (hostPropertyName) => ({ hostPropertyName }));
    const createHostListener = makeMetadataFactory('HostListener', (eventName, args) => ({ eventName, args }));
    const createNgModule = makeMetadataFactory('NgModule', (ngModule) => ngModule);
    const createInjectable = makeMetadataFactory('Injectable', (injectable = {}) => injectable);
    const CUSTOM_ELEMENTS_SCHEMA = {
        name: 'custom-elements'
    };
    const NO_ERRORS_SCHEMA = {
        name: 'no-errors-schema'
    };
    const createOptional = makeMetadataFactory('Optional');
    const createSelf = makeMetadataFactory('Self');
    const createSkipSelf = makeMetadataFactory('SkipSelf');
    const createHost = makeMetadataFactory('Host');
    const Type = Function;
    var SecurityContext;
    (function (SecurityContext) {
        SecurityContext[SecurityContext["NONE"] = 0] = "NONE";
        SecurityContext[SecurityContext["HTML"] = 1] = "HTML";
        SecurityContext[SecurityContext["STYLE"] = 2] = "STYLE";
        SecurityContext[SecurityContext["SCRIPT"] = 3] = "SCRIPT";
        SecurityContext[SecurityContext["URL"] = 4] = "URL";
        SecurityContext[SecurityContext["RESOURCE_URL"] = 5] = "RESOURCE_URL";
    })(SecurityContext || (SecurityContext = {}));
    var MissingTranslationStrategy;
    (function (MissingTranslationStrategy) {
        MissingTranslationStrategy[MissingTranslationStrategy["Error"] = 0] = "Error";
        MissingTranslationStrategy[MissingTranslationStrategy["Warning"] = 1] = "Warning";
        MissingTranslationStrategy[MissingTranslationStrategy["Ignore"] = 2] = "Ignore";
    })(MissingTranslationStrategy || (MissingTranslationStrategy = {}));
    function makeMetadataFactory(name, props) {
        // This must be declared as a function, not a fat arrow, so that ES2015 devmode produces code
        // that works with the static_reflector.ts in the ViewEngine compiler.
        // In particular, `_registerDecoratorOrConstructor` assumes that the value returned here can be
        // new'ed.
        function factory(...args) {
            const values = props ? props(...args) : {};
            return Object.assign({ ngMetadataName: name }, values);
        }
        factory.isTypeOf = (obj) => obj && obj.ngMetadataName === name;
        factory.ngMetadataName = name;
        return factory;
    }
    function parserSelectorToSimpleSelector(selector) {
        const classes = selector.classNames && selector.classNames.length ?
            [8 /* CLASS */, ...selector.classNames] :
            [];
        const elementName = selector.element && selector.element !== '*' ? selector.element : '';
        return [elementName, ...selector.attrs, ...classes];
    }
    function parserSelectorToNegativeSelector(selector) {
        const classes = selector.classNames && selector.classNames.length ?
            [8 /* CLASS */, ...selector.classNames] :
            [];
        if (selector.element) {
            return [
                1 /* NOT */ | 4 /* ELEMENT */, selector.element, ...selector.attrs, ...classes
            ];
        }
        else if (selector.attrs.length) {
            return [1 /* NOT */ | 2 /* ATTRIBUTE */, ...selector.attrs, ...classes];
        }
        else {
            return selector.classNames && selector.classNames.length ?
                [1 /* NOT */ | 8 /* CLASS */, ...selector.classNames] :
                [];
        }
    }
    function parserSelectorToR3Selector(selector) {
        const positive = parserSelectorToSimpleSelector(selector);
        const negative = selector.notSelectors && selector.notSelectors.length ?
            selector.notSelectors.map(notSelector => parserSelectorToNegativeSelector(notSelector)) :
            [];
        return positive.concat(...negative);
    }
    function parseSelectorToR3Selector(selector) {
        return selector ? CssSelector.parse(selector).map(parserSelectorToR3Selector) : [];
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    //// Types
    var TypeModifier;
    (function (TypeModifier) {
        TypeModifier[TypeModifier["Const"] = 0] = "Const";
    })(TypeModifier || (TypeModifier = {}));
    class Type$1 {
        constructor(modifiers = []) {
            this.modifiers = modifiers;
        }
        hasModifier(modifier) {
            return this.modifiers.indexOf(modifier) !== -1;
        }
    }
    var BuiltinTypeName;
    (function (BuiltinTypeName) {
        BuiltinTypeName[BuiltinTypeName["Dynamic"] = 0] = "Dynamic";
        BuiltinTypeName[BuiltinTypeName["Bool"] = 1] = "Bool";
        BuiltinTypeName[BuiltinTypeName["String"] = 2] = "String";
        BuiltinTypeName[BuiltinTypeName["Int"] = 3] = "Int";
        BuiltinTypeName[BuiltinTypeName["Number"] = 4] = "Number";
        BuiltinTypeName[BuiltinTypeName["Function"] = 5] = "Function";
        BuiltinTypeName[BuiltinTypeName["Inferred"] = 6] = "Inferred";
        BuiltinTypeName[BuiltinTypeName["None"] = 7] = "None";
    })(BuiltinTypeName || (BuiltinTypeName = {}));
    class BuiltinType extends Type$1 {
        constructor(name, modifiers) {
            super(modifiers);
            this.name = name;
        }
        visitType(visitor, context) {
            return visitor.visitBuiltinType(this, context);
        }
    }
    class ExpressionType extends Type$1 {
        constructor(value, modifiers, typeParams = null) {
            super(modifiers);
            this.value = value;
            this.typeParams = typeParams;
        }
        visitType(visitor, context) {
            return visitor.visitExpressionType(this, context);
        }
    }
    const DYNAMIC_TYPE = new BuiltinType(BuiltinTypeName.Dynamic);
    const INFERRED_TYPE = new BuiltinType(BuiltinTypeName.Inferred);
    const BOOL_TYPE = new BuiltinType(BuiltinTypeName.Bool);
    const INT_TYPE = new BuiltinType(BuiltinTypeName.Int);
    const NUMBER_TYPE = new BuiltinType(BuiltinTypeName.Number);
    const STRING_TYPE = new BuiltinType(BuiltinTypeName.String);
    const FUNCTION_TYPE = new BuiltinType(BuiltinTypeName.Function);
    const NONE_TYPE = new BuiltinType(BuiltinTypeName.None);
    ///// Expressions
    var UnaryOperator;
    (function (UnaryOperator) {
        UnaryOperator[UnaryOperator["Minus"] = 0] = "Minus";
        UnaryOperator[UnaryOperator["Plus"] = 1] = "Plus";
    })(UnaryOperator || (UnaryOperator = {}));
    var BinaryOperator;
    (function (BinaryOperator) {
        BinaryOperator[BinaryOperator["Equals"] = 0] = "Equals";
        BinaryOperator[BinaryOperator["NotEquals"] = 1] = "NotEquals";
        BinaryOperator[BinaryOperator["Identical"] = 2] = "Identical";
        BinaryOperator[BinaryOperator["NotIdentical"] = 3] = "NotIdentical";
        BinaryOperator[BinaryOperator["Minus"] = 4] = "Minus";
        BinaryOperator[BinaryOperator["Plus"] = 5] = "Plus";
        BinaryOperator[BinaryOperator["Divide"] = 6] = "Divide";
        BinaryOperator[BinaryOperator["Multiply"] = 7] = "Multiply";
        BinaryOperator[BinaryOperator["Modulo"] = 8] = "Modulo";
        BinaryOperator[BinaryOperator["And"] = 9] = "And";
        BinaryOperator[BinaryOperator["Or"] = 10] = "Or";
        BinaryOperator[BinaryOperator["BitwiseAnd"] = 11] = "BitwiseAnd";
        BinaryOperator[BinaryOperator["Lower"] = 12] = "Lower";
        BinaryOperator[BinaryOperator["LowerEquals"] = 13] = "LowerEquals";
        BinaryOperator[BinaryOperator["Bigger"] = 14] = "Bigger";
        BinaryOperator[BinaryOperator["BiggerEquals"] = 15] = "BiggerEquals";
        BinaryOperator[BinaryOperator["NullishCoalesce"] = 16] = "NullishCoalesce";
    })(BinaryOperator || (BinaryOperator = {}));
    function nullSafeIsEquivalent(base, other) {
        if (base == null || other == null) {
            return base == other;
        }
        return base.isEquivalent(other);
    }
    function areAllEquivalentPredicate(base, other, equivalentPredicate) {
        const len = base.length;
        if (len !== other.length) {
            return false;
        }
        for (let i = 0; i < len; i++) {
            if (!equivalentPredicate(base[i], other[i])) {
                return false;
            }
        }
        return true;
    }
    function areAllEquivalent(base, other) {
        return areAllEquivalentPredicate(base, other, (baseElement, otherElement) => baseElement.isEquivalent(otherElement));
    }
    class Expression {
        constructor(type, sourceSpan) {
            this.type = type || null;
            this.sourceSpan = sourceSpan || null;
        }
        prop(name, sourceSpan) {
            return new ReadPropExpr(this, name, null, sourceSpan);
        }
        key(index, type, sourceSpan) {
            return new ReadKeyExpr(this, index, type, sourceSpan);
        }
        callMethod(name, params, sourceSpan) {
            return new InvokeMethodExpr(this, name, params, null, sourceSpan);
        }
        callFn(params, sourceSpan, pure) {
            return new InvokeFunctionExpr(this, params, null, sourceSpan, pure);
        }
        instantiate(params, type, sourceSpan) {
            return new InstantiateExpr(this, params, type, sourceSpan);
        }
        conditional(trueCase, falseCase = null, sourceSpan) {
            return new ConditionalExpr(this, trueCase, falseCase, null, sourceSpan);
        }
        equals(rhs, sourceSpan) {
            return new BinaryOperatorExpr(BinaryOperator.Equals, this, rhs, null, sourceSpan);
        }
        notEquals(rhs, sourceSpan) {
            return new BinaryOperatorExpr(BinaryOperator.NotEquals, this, rhs, null, sourceSpan);
        }
        identical(rhs, sourceSpan) {
            return new BinaryOperatorExpr(BinaryOperator.Identical, this, rhs, null, sourceSpan);
        }
        notIdentical(rhs, sourceSpan) {
            return new BinaryOperatorExpr(BinaryOperator.NotIdentical, this, rhs, null, sourceSpan);
        }
        minus(rhs, sourceSpan) {
            return new BinaryOperatorExpr(BinaryOperator.Minus, this, rhs, null, sourceSpan);
        }
        plus(rhs, sourceSpan) {
            return new BinaryOperatorExpr(BinaryOperator.Plus, this, rhs, null, sourceSpan);
        }
        divide(rhs, sourceSpan) {
            return new BinaryOperatorExpr(BinaryOperator.Divide, this, rhs, null, sourceSpan);
        }
        multiply(rhs, sourceSpan) {
            return new BinaryOperatorExpr(BinaryOperator.Multiply, this, rhs, null, sourceSpan);
        }
        modulo(rhs, sourceSpan) {
            return new BinaryOperatorExpr(BinaryOperator.Modulo, this, rhs, null, sourceSpan);
        }
        and(rhs, sourceSpan) {
            return new BinaryOperatorExpr(BinaryOperator.And, this, rhs, null, sourceSpan);
        }
        bitwiseAnd(rhs, sourceSpan, parens = true) {
            return new BinaryOperatorExpr(BinaryOperator.BitwiseAnd, this, rhs, null, sourceSpan, parens);
        }
        or(rhs, sourceSpan) {
            return new BinaryOperatorExpr(BinaryOperator.Or, this, rhs, null, sourceSpan);
        }
        lower(rhs, sourceSpan) {
            return new BinaryOperatorExpr(BinaryOperator.Lower, this, rhs, null, sourceSpan);
        }
        lowerEquals(rhs, sourceSpan) {
            return new BinaryOperatorExpr(BinaryOperator.LowerEquals, this, rhs, null, sourceSpan);
        }
        bigger(rhs, sourceSpan) {
            return new BinaryOperatorExpr(BinaryOperator.Bigger, this, rhs, null, sourceSpan);
        }
        biggerEquals(rhs, sourceSpan) {
            return new BinaryOperatorExpr(BinaryOperator.BiggerEquals, this, rhs, null, sourceSpan);
        }
        isBlank(sourceSpan) {
            // Note: We use equals by purpose here to compare to null and undefined in JS.
            // We use the typed null to allow strictNullChecks to narrow types.
            return this.equals(TYPED_NULL_EXPR, sourceSpan);
        }
        cast(type, sourceSpan) {
            return new CastExpr(this, type, sourceSpan);
        }
        nullishCoalesce(rhs, sourceSpan) {
            return new BinaryOperatorExpr(BinaryOperator.NullishCoalesce, this, rhs, null, sourceSpan);
        }
        toStmt() {
            return new ExpressionStatement(this, null);
        }
    }
    var BuiltinVar;
    (function (BuiltinVar) {
        BuiltinVar[BuiltinVar["This"] = 0] = "This";
        BuiltinVar[BuiltinVar["Super"] = 1] = "Super";
        BuiltinVar[BuiltinVar["CatchError"] = 2] = "CatchError";
        BuiltinVar[BuiltinVar["CatchStack"] = 3] = "CatchStack";
    })(BuiltinVar || (BuiltinVar = {}));
    class ReadVarExpr extends Expression {
        constructor(name, type, sourceSpan) {
            super(type, sourceSpan);
            if (typeof name === 'string') {
                this.name = name;
                this.builtin = null;
            }
            else {
                this.name = null;
                this.builtin = name;
            }
        }
        isEquivalent(e) {
            return e instanceof ReadVarExpr && this.name === e.name && this.builtin === e.builtin;
        }
        isConstant() {
            return false;
        }
        visitExpression(visitor, context) {
            return visitor.visitReadVarExpr(this, context);
        }
        set(value) {
            if (!this.name) {
                throw new Error(`Built in variable ${this.builtin} can not be assigned to.`);
            }
            return new WriteVarExpr(this.name, value, null, this.sourceSpan);
        }
    }
    class TypeofExpr extends Expression {
        constructor(expr, type, sourceSpan) {
            super(type, sourceSpan);
            this.expr = expr;
        }
        visitExpression(visitor, context) {
            return visitor.visitTypeofExpr(this, context);
        }
        isEquivalent(e) {
            return e instanceof TypeofExpr && e.expr.isEquivalent(this.expr);
        }
        isConstant() {
            return this.expr.isConstant();
        }
    }
    class WrappedNodeExpr extends Expression {
        constructor(node, type, sourceSpan) {
            super(type, sourceSpan);
            this.node = node;
        }
        isEquivalent(e) {
            return e instanceof WrappedNodeExpr && this.node === e.node;
        }
        isConstant() {
            return false;
        }
        visitExpression(visitor, context) {
            return visitor.visitWrappedNodeExpr(this, context);
        }
    }
    class WriteVarExpr extends Expression {
        constructor(name, value, type, sourceSpan) {
            super(type || value.type, sourceSpan);
            this.name = name;
            this.value = value;
        }
        isEquivalent(e) {
            return e instanceof WriteVarExpr && this.name === e.name && this.value.isEquivalent(e.value);
        }
        isConstant() {
            return false;
        }
        visitExpression(visitor, context) {
            return visitor.visitWriteVarExpr(this, context);
        }
        toDeclStmt(type, modifiers) {
            return new DeclareVarStmt(this.name, this.value, type, modifiers, this.sourceSpan);
        }
        toConstDecl() {
            return this.toDeclStmt(INFERRED_TYPE, [StmtModifier.Final]);
        }
    }
    class WriteKeyExpr extends Expression {
        constructor(receiver, index, value, type, sourceSpan) {
            super(type || value.type, sourceSpan);
            this.receiver = receiver;
            this.index = index;
            this.value = value;
        }
        isEquivalent(e) {
            return e instanceof WriteKeyExpr && this.receiver.isEquivalent(e.receiver) &&
                this.index.isEquivalent(e.index) && this.value.isEquivalent(e.value);
        }
        isConstant() {
            return false;
        }
        visitExpression(visitor, context) {
            return visitor.visitWriteKeyExpr(this, context);
        }
    }
    class WritePropExpr extends Expression {
        constructor(receiver, name, value, type, sourceSpan) {
            super(type || value.type, sourceSpan);
            this.receiver = receiver;
            this.name = name;
            this.value = value;
        }
        isEquivalent(e) {
            return e instanceof WritePropExpr && this.receiver.isEquivalent(e.receiver) &&
                this.name === e.name && this.value.isEquivalent(e.value);
        }
        isConstant() {
            return false;
        }
        visitExpression(visitor, context) {
            return visitor.visitWritePropExpr(this, context);
        }
    }
    var BuiltinMethod;
    (function (BuiltinMethod) {
        BuiltinMethod[BuiltinMethod["ConcatArray"] = 0] = "ConcatArray";
        BuiltinMethod[BuiltinMethod["SubscribeObservable"] = 1] = "SubscribeObservable";
        BuiltinMethod[BuiltinMethod["Bind"] = 2] = "Bind";
    })(BuiltinMethod || (BuiltinMethod = {}));
    class InvokeMethodExpr extends Expression {
        constructor(receiver, method, args, type, sourceSpan) {
            super(type, sourceSpan);
            this.receiver = receiver;
            this.args = args;
            if (typeof method === 'string') {
                this.name = method;
                this.builtin = null;
            }
            else {
                this.name = null;
                this.builtin = method;
            }
        }
        isEquivalent(e) {
            return e instanceof InvokeMethodExpr && this.receiver.isEquivalent(e.receiver) &&
                this.name === e.name && this.builtin === e.builtin && areAllEquivalent(this.args, e.args);
        }
        isConstant() {
            return false;
        }
        visitExpression(visitor, context) {
            return visitor.visitInvokeMethodExpr(this, context);
        }
    }
    class InvokeFunctionExpr extends Expression {
        constructor(fn, args, type, sourceSpan, pure = false) {
            super(type, sourceSpan);
            this.fn = fn;
            this.args = args;
            this.pure = pure;
        }
        isEquivalent(e) {
            return e instanceof InvokeFunctionExpr && this.fn.isEquivalent(e.fn) &&
                areAllEquivalent(this.args, e.args) && this.pure === e.pure;
        }
        isConstant() {
            return false;
        }
        visitExpression(visitor, context) {
            return visitor.visitInvokeFunctionExpr(this, context);
        }
    }
    class TaggedTemplateExpr extends Expression {
        constructor(tag, template, type, sourceSpan) {
            super(type, sourceSpan);
            this.tag = tag;
            this.template = template;
        }
        isEquivalent(e) {
            return e instanceof TaggedTemplateExpr && this.tag.isEquivalent(e.tag) &&
                areAllEquivalentPredicate(this.template.elements, e.template.elements, (a, b) => a.text === b.text) &&
                areAllEquivalent(this.template.expressions, e.template.expressions);
        }
        isConstant() {
            return false;
        }
        visitExpression(visitor, context) {
            return visitor.visitTaggedTemplateExpr(this, context);
        }
    }
    class InstantiateExpr extends Expression {
        constructor(classExpr, args, type, sourceSpan) {
            super(type, sourceSpan);
            this.classExpr = classExpr;
            this.args = args;
        }
        isEquivalent(e) {
            return e instanceof InstantiateExpr && this.classExpr.isEquivalent(e.classExpr) &&
                areAllEquivalent(this.args, e.args);
        }
        isConstant() {
            return false;
        }
        visitExpression(visitor, context) {
            return visitor.visitInstantiateExpr(this, context);
        }
    }
    class LiteralExpr extends Expression {
        constructor(value, type, sourceSpan) {
            super(type, sourceSpan);
            this.value = value;
        }
        isEquivalent(e) {
            return e instanceof LiteralExpr && this.value === e.value;
        }
        isConstant() {
            return true;
        }
        visitExpression(visitor, context) {
            return visitor.visitLiteralExpr(this, context);
        }
    }
    class TemplateLiteral {
        constructor(elements, expressions) {
            this.elements = elements;
            this.expressions = expressions;
        }
    }
    class TemplateLiteralElement {
        constructor(text, sourceSpan, rawText) {
            var _a;
            this.text = text;
            this.sourceSpan = sourceSpan;
            // If `rawText` is not provided, try to extract the raw string from its
            // associated `sourceSpan`. If that is also not available, "fake" the raw
            // string instead by escaping the following control sequences:
            // - "\" would otherwise indicate that the next character is a control character.
            // - "`" and "${" are template string control sequences that would otherwise prematurely
            // indicate the end of the template literal element.
            this.rawText =
                (_a = rawText !== null && rawText !== void 0 ? rawText : sourceSpan === null || sourceSpan === void 0 ? void 0 : sourceSpan.toString()) !== null && _a !== void 0 ? _a : escapeForTemplateLiteral(escapeSlashes(text));
        }
    }
    class MessagePiece {
        constructor(text, sourceSpan) {
            this.text = text;
            this.sourceSpan = sourceSpan;
        }
    }
    class LiteralPiece extends MessagePiece {
    }
    class PlaceholderPiece extends MessagePiece {
    }
    class LocalizedString extends Expression {
        constructor(metaBlock, messageParts, placeHolderNames, expressions, sourceSpan) {
            super(STRING_TYPE, sourceSpan);
            this.metaBlock = metaBlock;
            this.messageParts = messageParts;
            this.placeHolderNames = placeHolderNames;
            this.expressions = expressions;
        }
        isEquivalent(e) {
            // return e instanceof LocalizedString && this.message === e.message;
            return false;
        }
        isConstant() {
            return false;
        }
        visitExpression(visitor, context) {
            return visitor.visitLocalizedString(this, context);
        }
        /**
         * Serialize the given `meta` and `messagePart` into "cooked" and "raw" strings that can be used
         * in a `$localize` tagged string. The format of the metadata is the same as that parsed by
         * `parseI18nMeta()`.
         *
         * @param meta The metadata to serialize
         * @param messagePart The first part of the tagged string
         */
        serializeI18nHead() {
            const MEANING_SEPARATOR = '|';
            const ID_SEPARATOR = '@@';
            const LEGACY_ID_INDICATOR = 'â';
            let metaBlock = this.metaBlock.description || '';
            if (this.metaBlock.meaning) {
                metaBlock = `${this.metaBlock.meaning}${MEANING_SEPARATOR}${metaBlock}`;
            }
            if (this.metaBlock.customId) {
                metaBlock = `${metaBlock}${ID_SEPARATOR}${this.metaBlock.customId}`;
            }
            if (this.metaBlock.legacyIds) {
                this.metaBlock.legacyIds.forEach(legacyId => {
                    metaBlock = `${metaBlock}${LEGACY_ID_INDICATOR}${legacyId}`;
                });
            }
            return createCookedRawString(metaBlock, this.messageParts[0].text, this.getMessagePartSourceSpan(0));
        }
        getMessagePartSourceSpan(i) {
            var _a, _b;
            return (_b = (_a = this.messageParts[i]) === null || _a === void 0 ? void 0 : _a.sourceSpan) !== null && _b !== void 0 ? _b : this.sourceSpan;
        }
        getPlaceholderSourceSpan(i) {
            var _a, _b, _c, _d;
            return (_d = (_b = (_a = this.placeHolderNames[i]) === null || _a === void 0 ? void 0 : _a.sourceSpan) !== null && _b !== void 0 ? _b : (_c = this.expressions[i]) === null || _c === void 0 ? void 0 : _c.sourceSpan) !== null && _d !== void 0 ? _d : this.sourceSpan;
        }
        /**
         * Serialize the given `placeholderName` and `messagePart` into "cooked" and "raw" strings that
         * can be used in a `$localize` tagged string.
         *
         * @param placeholderName The placeholder name to serialize
         * @param messagePart The following message string after this placeholder
         */
        serializeI18nTemplatePart(partIndex) {
            const placeholderName = this.placeHolderNames[partIndex - 1].text;
            const messagePart = this.messageParts[partIndex];
            return createCookedRawString(placeholderName, messagePart.text, this.getMessagePartSourceSpan(partIndex));
        }
    }
    const escapeSlashes = (str) => str.replace(/\\/g, '\\\\');
    const escapeStartingColon = (str) => str.replace(/^:/, '\\:');
    const escapeColons = (str) => str.replace(/:/g, '\\:');
    const escapeForTemplateLiteral = (str) => str.replace(/`/g, '\\`').replace(/\${/g, '$\\{');
    /**
     * Creates a `{cooked, raw}` object from the `metaBlock` and `messagePart`.
     *
     * The `raw` text must have various character sequences escaped:
     * * "\" would otherwise indicate that the next character is a control character.
     * * "`" and "${" are template string control sequences that would otherwise prematurely indicate
     *   the end of a message part.
     * * ":" inside a metablock would prematurely indicate the end of the metablock.
     * * ":" at the start of a messagePart with no metablock would erroneously indicate the start of a
     *   metablock.
     *
     * @param metaBlock Any metadata that should be prepended to the string
     * @param messagePart The message part of the string
     */
    function createCookedRawString(metaBlock, messagePart, range) {
        if (metaBlock === '') {
            return {
                cooked: messagePart,
                raw: escapeForTemplateLiteral(escapeStartingColon(escapeSlashes(messagePart))),
                range,
            };
        }
        else {
            return {
                cooked: `:${metaBlock}:${messagePart}`,
                raw: escapeForTemplateLiteral(`:${escapeColons(escapeSlashes(metaBlock))}:${escapeSlashes(messagePart)}`),
                range,
            };
        }
    }
    class ExternalExpr extends Expression {
        constructor(value, type, typeParams = null, sourceSpan) {
            super(type, sourceSpan);
            this.value = value;
            this.typeParams = typeParams;
        }
        isEquivalent(e) {
            return e instanceof ExternalExpr && this.value.name === e.value.name &&
                this.value.moduleName === e.value.moduleName && this.value.runtime === e.value.runtime;
        }
        isConstant() {
            return false;
        }
        visitExpression(visitor, context) {
            return visitor.visitExternalExpr(this, context);
        }
    }
    class ConditionalExpr extends Expression {
        constructor(condition, trueCase, falseCase = null, type, sourceSpan) {
            super(type || trueCase.type, sourceSpan);
            this.condition = condition;
            this.falseCase = falseCase;
            this.trueCase = trueCase;
        }
        isEquivalent(e) {
            return e instanceof ConditionalExpr && this.condition.isEquivalent(e.condition) &&
                this.trueCase.isEquivalent(e.trueCase) && nullSafeIsEquivalent(this.falseCase, e.falseCase);
        }
        isConstant() {
            return false;
        }
        visitExpression(visitor, context) {
            return visitor.visitConditionalExpr(this, context);
        }
    }
    class NotExpr extends Expression {
        constructor(condition, sourceSpan) {
            super(BOOL_TYPE, sourceSpan);
            this.condition = condition;
        }
        isEquivalent(e) {
            return e instanceof NotExpr && this.condition.isEquivalent(e.condition);
        }
        isConstant() {
            return false;
        }
        visitExpression(visitor, context) {
            return visitor.visitNotExpr(this, context);
        }
    }
    class AssertNotNull extends Expression {
        constructor(condition, sourceSpan) {
            super(condition.type, sourceSpan);
            this.condition = condition;
        }
        isEquivalent(e) {
            return e instanceof AssertNotNull && this.condition.isEquivalent(e.condition);
        }
        isConstant() {
            return false;
        }
        visitExpression(visitor, context) {
            return visitor.visitAssertNotNullExpr(this, context);
        }
    }
    class CastExpr extends Expression {
        constructor(value, type, sourceSpan) {
            super(type, sourceSpan);
            this.value = value;
        }
        isEquivalent(e) {
            return e instanceof CastExpr && this.value.isEquivalent(e.value);
        }
        isConstant() {
            return false;
        }
        visitExpression(visitor, context) {
            return visitor.visitCastExpr(this, context);
        }
    }
    class FnParam {
        constructor(name, type = null) {
            this.name = name;
            this.type = type;
        }
        isEquivalent(param) {
            return this.name === param.name;
        }
    }
    class FunctionExpr extends Expression {
        constructor(params, statements, type, sourceSpan, name) {
            super(type, sourceSpan);
            this.params = params;
            this.statements = statements;
            this.name = name;
        }
        isEquivalent(e) {
            return e instanceof FunctionExpr && areAllEquivalent(this.params, e.params) &&
                areAllEquivalent(this.statements, e.statements);
        }
        isConstant() {
            return false;
        }
        visitExpression(visitor, context) {
            return visitor.visitFunctionExpr(this, context);
        }
        toDeclStmt(name, modifiers) {
            return new DeclareFunctionStmt(name, this.params, this.statements, this.type, modifiers, this.sourceSpan);
        }
    }
    class UnaryOperatorExpr extends Expression {
        constructor(operator, expr, type, sourceSpan, parens = true) {
            super(type || NUMBER_TYPE, sourceSpan);
            this.operator = operator;
            this.expr = expr;
            this.parens = parens;
        }
        isEquivalent(e) {
            return e instanceof UnaryOperatorExpr && this.operator === e.operator &&
                this.expr.isEquivalent(e.expr);
        }
        isConstant() {
            return false;
        }
        visitExpression(visitor, context) {
            return visitor.visitUnaryOperatorExpr(this, context);
        }
    }
    class BinaryOperatorExpr extends Expression {
        constructor(operator, lhs, rhs, type, sourceSpan, parens = true) {
            super(type || lhs.type, sourceSpan);
            this.operator = operator;
            this.rhs = rhs;
            this.parens = parens;
            this.lhs = lhs;
        }
        isEquivalent(e) {
            return e instanceof BinaryOperatorExpr && this.operator === e.operator &&
                this.lhs.isEquivalent(e.lhs) && this.rhs.isEquivalent(e.rhs);
        }
        isConstant() {
            return false;
        }
        visitExpression(visitor, context) {
            return visitor.visitBinaryOperatorExpr(this, context);
        }
    }
    class ReadPropExpr extends Expression {
        constructor(receiver, name, type, sourceSpan) {
            super(type, sourceSpan);
            this.receiver = receiver;
            this.name = name;
        }
        isEquivalent(e) {
            return e instanceof ReadPropExpr && this.receiver.isEquivalent(e.receiver) &&
                this.name === e.name;
        }
        isConstant() {
            return false;
        }
        visitExpression(visitor, context) {
            return visitor.visitReadPropExpr(this, context);
        }
        set(value) {
            return new WritePropExpr(this.receiver, this.name, value, null, this.sourceSpan);
        }
    }
    class ReadKeyExpr extends Expression {
        constructor(receiver, index, type, sourceSpan) {
            super(type, sourceSpan);
            this.receiver = receiver;
            this.index = index;
        }
        isEquivalent(e) {
            return e instanceof ReadKeyExpr && this.receiver.isEquivalent(e.receiver) &&
                this.index.isEquivalent(e.index);
        }
        isConstant() {
            return false;
        }
        visitExpression(visitor, context) {
            return visitor.visitReadKeyExpr(this, context);
        }
        set(value) {
            return new WriteKeyExpr(this.receiver, this.index, value, null, this.sourceSpan);
        }
    }
    class LiteralArrayExpr extends Expression {
        constructor(entries, type, sourceSpan) {
            super(type, sourceSpan);
            this.entries = entries;
        }
        isConstant() {
            return this.entries.every(e => e.isConstant());
        }
        isEquivalent(e) {
            return e instanceof LiteralArrayExpr && areAllEquivalent(this.entries, e.entries);
        }
        visitExpression(visitor, context) {
            return visitor.visitLiteralArrayExpr(this, context);
        }
    }
    class LiteralMapEntry {
        constructor(key, value, quoted) {
            this.key = key;
            this.value = value;
            this.quoted = quoted;
        }
        isEquivalent(e) {
            return this.key === e.key && this.value.isEquivalent(e.value);
        }
    }
    class LiteralMapExpr extends Expression {
        constructor(entries, type, sourceSpan) {
            super(type, sourceSpan);
            this.entries = entries;
            this.valueType = null;
            if (type) {
                this.valueType = type.valueType;
            }
        }
        isEquivalent(e) {
            return e instanceof LiteralMapExpr && areAllEquivalent(this.entries, e.entries);
        }
        isConstant() {
            return this.entries.every(e => e.value.isConstant());
        }
        visitExpression(visitor, context) {
            return visitor.visitLiteralMapExpr(this, context);
        }
    }
    const THIS_EXPR = new ReadVarExpr(BuiltinVar.This, null, null);
    const SUPER_EXPR = new ReadVarExpr(BuiltinVar.Super, null, null);
    const CATCH_ERROR_VAR = new ReadVarExpr(BuiltinVar.CatchError, null, null);
    const CATCH_STACK_VAR = new ReadVarExpr(BuiltinVar.CatchStack, null, null);
    const NULL_EXPR = new LiteralExpr(null, null, null);
    const TYPED_NULL_EXPR = new LiteralExpr(null, INFERRED_TYPE, null);
    //// Statements
    var StmtModifier;
    (function (StmtModifier) {
        StmtModifier[StmtModifier["Final"] = 0] = "Final";
        StmtModifier[StmtModifier["Private"] = 1] = "Private";
        StmtModifier[StmtModifier["Exported"] = 2] = "Exported";
        StmtModifier[StmtModifier["Static"] = 3] = "Static";
    })(StmtModifier || (StmtModifier = {}));
    class LeadingComment {
        constructor(text, multiline, trailingNewline) {
            this.text = text;
            this.multiline = multiline;
            this.trailingNewline = trailingNewline;
        }
        toString() {
            return this.multiline ? ` ${this.text} ` : this.text;
        }
    }
    class JSDocComment extends LeadingComment {
        constructor(tags) {
            super('', /* multiline */ true, /* trailingNewline */ true);
            this.tags = tags;
        }
        toString() {
            return serializeTags(this.tags);
        }
    }
    class Statement {
        constructor(modifiers = [], sourceSpan = null, leadingComments) {
            this.modifiers = modifiers;
            this.sourceSpan = sourceSpan;
            this.leadingComments = leadingComments;
        }
        hasModifier(modifier) {
            return this.modifiers.indexOf(modifier) !== -1;
        }
        addLeadingComment(leadingComment) {
            var _a;
            this.leadingComments = (_a = this.leadingComments) !== null && _a !== void 0 ? _a : [];
            this.leadingComments.push(leadingComment);
        }
    }
    class DeclareVarStmt extends Statement {
        constructor(name, value, type, modifiers, sourceSpan, leadingComments) {
            super(modifiers, sourceSpan, leadingComments);
            this.name = name;
            this.value = value;
            this.type = type || (value && value.type) || null;
        }
        isEquivalent(stmt) {
            return stmt instanceof DeclareVarStmt && this.name === stmt.name &&
                (this.value ? !!stmt.value && this.value.isEquivalent(stmt.value) : !stmt.value);
        }
        visitStatement(visitor, context) {
            return visitor.visitDeclareVarStmt(this, context);
        }
    }
    class DeclareFunctionStmt extends Statement {
        constructor(name, params, statements, type, modifiers, sourceSpan, leadingComments) {
            super(modifiers, sourceSpan, leadingComments);
            this.name = name;
            this.params = params;
            this.statements = statements;
            this.type = type || null;
        }
        isEquivalent(stmt) {
            return stmt instanceof DeclareFunctionStmt && areAllEquivalent(this.params, stmt.params) &&
                areAllEquivalent(this.statements, stmt.statements);
        }
        visitStatement(visitor, context) {
            return visitor.visitDeclareFunctionStmt(this, context);
        }
    }
    class ExpressionStatement extends Statement {
        constructor(expr, sourceSpan, leadingComments) {
            super([], sourceSpan, leadingComments);
            this.expr = expr;
        }
        isEquivalent(stmt) {
            return stmt instanceof ExpressionStatement && this.expr.isEquivalent(stmt.expr);
        }
        visitStatement(visitor, context) {
            return visitor.visitExpressionStmt(this, context);
        }
    }
    class ReturnStatement extends Statement {
        constructor(value, sourceSpan = null, leadingComments) {
            super([], sourceSpan, leadingComments);
            this.value = value;
        }
        isEquivalent(stmt) {
            return stmt instanceof ReturnStatement && this.value.isEquivalent(stmt.value);
        }
        visitStatement(visitor, context) {
            return visitor.visitReturnStmt(this, context);
        }
    }
    class IfStmt extends Statement {
        constructor(condition, trueCase, falseCase = [], sourceSpan, leadingComments) {
            super([], sourceSpan, leadingComments);
            this.condition = condition;
            this.trueCase = trueCase;
            this.falseCase = falseCase;
        }
        isEquivalent(stmt) {
            return stmt instanceof IfStmt && this.condition.isEquivalent(stmt.condition) &&
                areAllEquivalent(this.trueCase, stmt.trueCase) &&
                areAllEquivalent(this.falseCase, stmt.falseCase);
        }
        visitStatement(visitor, context) {
            return visitor.visitIfStmt(this, context);
        }
    }
    function jsDocComment(tags = []) {
        return new JSDocComment(tags);
    }
    function variable(name, type, sourceSpan) {
        return new ReadVarExpr(name, type, sourceSpan);
    }
    function importExpr(id, typeParams = null, sourceSpan) {
        return new ExternalExpr(id, null, typeParams, sourceSpan);
    }
    function expressionType(expr, typeModifiers, typeParams) {
        return new ExpressionType(expr, typeModifiers, typeParams);
    }
    function typeofExpr(expr) {
        return new TypeofExpr(expr);
    }
    function literalArr(values, type, sourceSpan) {
        return new LiteralArrayExpr(values, type, sourceSpan);
    }
    function literalMap(values, type = null) {
        return new LiteralMapExpr(values.map(e => new LiteralMapEntry(e.key, e.value, e.quoted)), type, null);
    }
    function not(expr, sourceSpan) {
        return new NotExpr(expr, sourceSpan);
    }
    function assertNotNull(expr, sourceSpan) {
        return new AssertNotNull(expr, sourceSpan);
    }
    function fn(params, body, type, sourceSpan, name) {
        return new FunctionExpr(params, body, type, sourceSpan, name);
    }
    function ifStmt(condition, thenClause, elseClause, sourceSpan, leadingComments) {
        return new IfStmt(condition, thenClause, elseClause, sourceSpan, leadingComments);
    }
    function taggedTemplate(tag, template, type, sourceSpan) {
        return new TaggedTemplateExpr(tag, template, type, sourceSpan);
    }
    function literal(value, type, sourceSpan) {
        return new LiteralExpr(value, type, sourceSpan);
    }
    function localizedString(metaBlock, messageParts, placeholderNames, expressions, sourceSpan) {
        return new LocalizedString(metaBlock, messageParts, placeholderNames, expressions, sourceSpan);
    }
    function isNull(exp) {
        return exp instanceof LiteralExpr && exp.value === null;
    }
    /*
     * Serializes a `Tag` into a string.
     * Returns a string like " @foo {bar} baz" (note the leading whitespace before `@foo`).
     */
    function tagToString(tag) {
        let out = '';
        if (tag.tagName) {
            out += ` @${tag.tagName}`;
        }
        if (tag.text) {
            if (tag.text.match(/\/\*|\*\//)) {
                throw new Error('JSDoc text cannot contain "/*" and "*/"');
            }
            out += ' ' + tag.text.replace(/@/g, '\\@');
        }
        return out;
    }
    function serializeTags(tags) {
        if (tags.length === 0)
            return '';
        if (tags.length === 1 && tags[0].tagName && !tags[0].text) {
            // The JSDOC comment is a single simple tag: e.g `/** @tagname */`.
            return `*${tagToString(tags[0])} `;
        }
        let out = '*\n';
        for (const tag of tags) {
            out += ' *';
            // If the tagToString is multi-line, insert " * " prefixes on lines.
            out += tagToString(tag).replace(/\n/g, '\n * ');
            out += '\n';
        }
        out += ' ';
        return out;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const CONSTANT_PREFIX = '_c';
    /**
     * `ConstantPool` tries to reuse literal factories when two or more literals are identical.
     * We determine whether literals are identical by creating a key out of their AST using the
     * `KeyVisitor`. This constant is used to replace dynamic expressions which can't be safely
     * converted into a key. E.g. given an expression `{foo: bar()}`, since we don't know what
     * the result of `bar` will be, we create a key that looks like `{foo: <unknown>}`. Note
     * that we use a variable, rather than something like `null` in order to avoid collisions.
     */
    const UNKNOWN_VALUE_KEY = variable('<unknown>');
    /**
     * Context to use when producing a key.
     *
     * This ensures we see the constant not the reference variable when producing
     * a key.
     */
    const KEY_CONTEXT = {};
    /**
     * Generally all primitive values are excluded from the `ConstantPool`, but there is an exclusion
     * for strings that reach a certain length threshold. This constant defines the length threshold for
     * strings.
     */
    const POOL_INCLUSION_LENGTH_THRESHOLD_FOR_STRINGS = 50;
    /**
     * A node that is a place-holder that allows the node to be replaced when the actual
     * node is known.
     *
     * This allows the constant pool to change an expression from a direct reference to
     * a constant to a shared constant. It returns a fix-up node that is later allowed to
     * change the referenced expression.
     */
    class FixupExpression extends Expression {
        constructor(resolved) {
            super(resolved.type);
            this.resolved = resolved;
            this.original = resolved;
        }
        visitExpression(visitor, context) {
            if (context === KEY_CONTEXT) {
                // When producing a key we want to traverse the constant not the
                // variable used to refer to it.
                return this.original.visitExpression(visitor, context);
            }
            else {
                return this.resolved.visitExpression(visitor, context);
            }
        }
        isEquivalent(e) {
            return e instanceof FixupExpression && this.resolved.isEquivalent(e.resolved);
        }
        isConstant() {
            return true;
        }
        fixup(expression) {
            this.resolved = expression;
            this.shared = true;
        }
    }
    /**
     * A constant pool allows a code emitter to share constant in an output context.
     *
     * The constant pool also supports sharing access to ivy definitions references.
     */
    class ConstantPool {
        constructor(isClosureCompilerEnabled = false) {
            this.isClosureCompilerEnabled = isClosureCompilerEnabled;
            this.statements = [];
            this.literals = new Map();
            this.literalFactories = new Map();
            this.injectorDefinitions = new Map();
            this.directiveDefinitions = new Map();
            this.componentDefinitions = new Map();
            this.pipeDefinitions = new Map();
            this.nextNameIndex = 0;
        }
        getConstLiteral(literal, forceShared) {
            if ((literal instanceof LiteralExpr && !isLongStringLiteral(literal)) ||
                literal instanceof FixupExpression) {
                // Do no put simple literals into the constant pool or try to produce a constant for a
                // reference to a constant.
                return literal;
            }
            const key = this.keyOf(literal);
            let fixup = this.literals.get(key);
            let newValue = false;
            if (!fixup) {
                fixup = new FixupExpression(literal);
                this.literals.set(key, fixup);
                newValue = true;
            }
            if ((!newValue && !fixup.shared) || (newValue && forceShared)) {
                // Replace the expression with a variable
                const name = this.freshName();
                let definition;
                let usage;
                if (this.isClosureCompilerEnabled && isLongStringLiteral(literal)) {
                    // For string literals, Closure will **always** inline the string at
                    // **all** usages, duplicating it each time. For large strings, this
                    // unnecessarily bloats bundle size. To work around this restriction, we
                    // wrap the string in a function, and call that function for each usage.
                    // This tricks Closure into using inline logic for functions instead of
                    // string literals. Function calls are only inlined if the body is small
                    // enough to be worth it. By doing this, very large strings will be
                    // shared across multiple usages, rather than duplicating the string at
                    // each usage site.
                    //
                    // const myStr = function() { return "very very very long string"; };
                    // const usage1 = myStr();
                    // const usage2 = myStr();
                    definition = variable(name).set(new FunctionExpr([], // Params.
                    [
                        // Statements.
                        new ReturnStatement(literal),
                    ]));
                    usage = variable(name).callFn([]);
                }
                else {
                    // Just declare and use the variable directly, without a function call
                    // indirection. This saves a few bytes and avoids an unncessary call.
                    definition = variable(name).set(literal);
                    usage = variable(name);
                }
                this.statements.push(definition.toDeclStmt(INFERRED_TYPE, [StmtModifier.Final]));
                fixup.fixup(usage);
            }
            return fixup;
        }
        getDefinition(type, kind, ctx, forceShared = false) {
            const definitions = this.definitionsOf(kind);
            let fixup = definitions.get(type);
            let newValue = false;
            if (!fixup) {
                const property = this.propertyNameOf(kind);
                fixup = new FixupExpression(ctx.importExpr(type).prop(property));
                definitions.set(type, fixup);
                newValue = true;
            }
            if ((!newValue && !fixup.shared) || (newValue && forceShared)) {
                const name = this.freshName();
                this.statements.push(variable(name).set(fixup.resolved).toDeclStmt(INFERRED_TYPE, [StmtModifier.Final]));
                fixup.fixup(variable(name));
            }
            return fixup;
        }
        getLiteralFactory(literal) {
            // Create a pure function that builds an array of a mix of constant and variable expressions
            if (literal instanceof LiteralArrayExpr) {
                const argumentsForKey = literal.entries.map(e => e.isConstant() ? e : UNKNOWN_VALUE_KEY);
                const key = this.keyOf(literalArr(argumentsForKey));
                return this._getLiteralFactory(key, literal.entries, entries => literalArr(entries));
            }
            else {
                const expressionForKey = literalMap(literal.entries.map(e => ({
                    key: e.key,
                    value: e.value.isConstant() ? e.value : UNKNOWN_VALUE_KEY,
                    quoted: e.quoted
                })));
                const key = this.keyOf(expressionForKey);
                return this._getLiteralFactory(key, literal.entries.map(e => e.value), entries => literalMap(entries.map((value, index) => ({
                    key: literal.entries[index].key,
                    value,
                    quoted: literal.entries[index].quoted
                }))));
            }
        }
        _getLiteralFactory(key, values, resultMap) {
            let literalFactory = this.literalFactories.get(key);
            const literalFactoryArguments = values.filter((e => !e.isConstant()));
            if (!literalFactory) {
                const resultExpressions = values.map((e, index) => e.isConstant() ? this.getConstLiteral(e, true) : variable(`a${index}`));
                const parameters = resultExpressions.filter(isVariable).map(e => new FnParam(e.name, DYNAMIC_TYPE));
                const pureFunctionDeclaration = fn(parameters, [new ReturnStatement(resultMap(resultExpressions))], INFERRED_TYPE);
                const name = this.freshName();
                this.statements.push(variable(name).set(pureFunctionDeclaration).toDeclStmt(INFERRED_TYPE, [
                    StmtModifier.Final
                ]));
                literalFactory = variable(name);
                this.literalFactories.set(key, literalFactory);
            }
            return { literalFactory, literalFactoryArguments };
        }
        /**
         * Produce a unique name.
         *
         * The name might be unique among different prefixes if any of the prefixes end in
         * a digit so the prefix should be a constant string (not based on user input) and
         * must not end in a digit.
         */
        uniqueName(prefix) {
            return `${prefix}${this.nextNameIndex++}`;
        }
        definitionsOf(kind) {
            switch (kind) {
                case 2 /* Component */:
                    return this.componentDefinitions;
                case 1 /* Directive */:
                    return this.directiveDefinitions;
                case 0 /* Injector */:
                    return this.injectorDefinitions;
                case 3 /* Pipe */:
                    return this.pipeDefinitions;
            }
        }
        propertyNameOf(kind) {
            switch (kind) {
                case 2 /* Component */:
                    return 'Éµcmp';
                case 1 /* Directive */:
                    return 'Éµdir';
                case 0 /* Injector */:
                    return 'Éµinj';
                case 3 /* Pipe */:
                    return 'Éµpipe';
            }
        }
        freshName() {
            return this.uniqueName(CONSTANT_PREFIX);
        }
        keyOf(expression) {
            return expression.visitExpression(new KeyVisitor(), KEY_CONTEXT);
        }
    }
    /**
     * Visitor used to determine if 2 expressions are equivalent and can be shared in the
     * `ConstantPool`.
     *
     * When the id (string) generated by the visitor is equal, expressions are considered equivalent.
     */
    class KeyVisitor {
        constructor() {
            this.visitWrappedNodeExpr = invalid;
            this.visitWriteVarExpr = invalid;
            this.visitWriteKeyExpr = invalid;
            this.visitWritePropExpr = invalid;
            this.visitInvokeMethodExpr = invalid;
            this.visitInvokeFunctionExpr = invalid;
            this.visitTaggedTemplateExpr = invalid;
            this.visitInstantiateExpr = invalid;
            this.visitConditionalExpr = invalid;
            this.visitNotExpr = invalid;
            this.visitAssertNotNullExpr = invalid;
            this.visitCastExpr = invalid;
            this.visitFunctionExpr = invalid;
            this.visitUnaryOperatorExpr = invalid;
            this.visitBinaryOperatorExpr = invalid;
            this.visitReadPropExpr = invalid;
            this.visitReadKeyExpr = invalid;
            this.visitCommaExpr = invalid;
            this.visitLocalizedString = invalid;
        }
        visitLiteralExpr(ast) {
            return `${typeof ast.value === 'string' ? '"' + ast.value + '"' : ast.value}`;
        }
        visitLiteralArrayExpr(ast, context) {
            return `[${ast.entries.map(entry => entry.visitExpression(this, context)).join(',')}]`;
        }
        visitLiteralMapExpr(ast, context) {
            const mapKey = (entry) => {
                const quote = entry.quoted ? '"' : '';
                return `${quote}${entry.key}${quote}`;
            };
            const mapEntry = (entry) => `${mapKey(entry)}:${entry.value.visitExpression(this, context)}`;
            return `{${ast.entries.map(mapEntry).join(',')}`;
        }
        visitExternalExpr(ast) {
            return ast.value.moduleName ? `EX:${ast.value.moduleName}:${ast.value.name}` :
                `EX:${ast.value.runtime.name}`;
        }
        visitReadVarExpr(node) {
            return `VAR:${node.name}`;
        }
        visitTypeofExpr(node, context) {
            return `TYPEOF:${node.expr.visitExpression(this, context)}`;
        }
    }
    function invalid(arg) {
        throw new Error(`Invalid state: Visitor ${this.constructor.name} doesn't handle ${arg.constructor.name}`);
    }
    function isVariable(e) {
        return e instanceof ReadVarExpr;
    }
    function isLongStringLiteral(expr) {
        return expr instanceof LiteralExpr && typeof expr.value === 'string' &&
            expr.value.length >= POOL_INCLUSION_LENGTH_THRESHOLD_FOR_STRINGS;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const CORE = '@angular/core';
    class Identifiers {
    }
    /* Methods */
    Identifiers.NEW_METHOD = 'factory';
    Identifiers.TRANSFORM_METHOD = 'transform';
    Identifiers.PATCH_DEPS = 'patchedDeps';
    Identifiers.core = { name: null, moduleName: CORE };
    /* Instructions */
    Identifiers.namespaceHTML = { name: 'ÉµÉµnamespaceHTML', moduleName: CORE };
    Identifiers.namespaceMathML = { name: 'ÉµÉµnamespaceMathML', moduleName: CORE };
    Identifiers.namespaceSVG = { name: 'ÉµÉµnamespaceSVG', moduleName: CORE };
    Identifiers.element = { name: 'ÉµÉµelement', moduleName: CORE };
    Identifiers.elementStart = { name: 'ÉµÉµelementStart', moduleName: CORE };
    Identifiers.elementEnd = { name: 'ÉµÉµelementEnd', moduleName: CORE };
    Identifiers.advance = { name: 'ÉµÉµadvance', moduleName: CORE };
    Identifiers.syntheticHostProperty = { name: 'ÉµÉµsyntheticHostProperty', moduleName: CORE };
    Identifiers.syntheticHostListener = { name: 'ÉµÉµsyntheticHostListener', moduleName: CORE };
    Identifiers.attribute = { name: 'ÉµÉµattribute', moduleName: CORE };
    Identifiers.attributeInterpolate1 = { name: 'ÉµÉµattributeInterpolate1', moduleName: CORE };
    Identifiers.attributeInterpolate2 = { name: 'ÉµÉµattributeInterpolate2', moduleName: CORE };
    Identifiers.attributeInterpolate3 = { name: 'ÉµÉµattributeInterpolate3', moduleName: CORE };
    Identifiers.attributeInterpolate4 = { name: 'ÉµÉµattributeInterpolate4', moduleName: CORE };
    Identifiers.attributeInterpolate5 = { name: 'ÉµÉµattributeInterpolate5', moduleName: CORE };
    Identifiers.attributeInterpolate6 = { name: 'ÉµÉµattributeInterpolate6', moduleName: CORE };
    Identifiers.attributeInterpolate7 = { name: 'ÉµÉµattributeInterpolate7', moduleName: CORE };
    Identifiers.attributeInterpolate8 = { name: 'ÉµÉµattributeInterpolate8', moduleName: CORE };
    Identifiers.attributeInterpolateV = { name: 'ÉµÉµattributeInterpolateV', moduleName: CORE };
    Identifiers.classProp = { name: 'ÉµÉµclassProp', moduleName: CORE };
    Identifiers.elementContainerStart = { name: 'ÉµÉµelementContainerStart', moduleName: CORE };
    Identifiers.elementContainerEnd = { name: 'ÉµÉµelementContainerEnd', moduleName: CORE };
    Identifiers.elementContainer = { name: 'ÉµÉµelementContainer', moduleName: CORE };
    Identifiers.styleMap = { name: 'ÉµÉµstyleMap', moduleName: CORE };
    Identifiers.styleMapInterpolate1 = { name: 'ÉµÉµstyleMapInterpolate1', moduleName: CORE };
    Identifiers.styleMapInterpolate2 = { name: 'ÉµÉµstyleMapInterpolate2', moduleName: CORE };
    Identifiers.styleMapInterpolate3 = { name: 'ÉµÉµstyleMapInterpolate3', moduleName: CORE };
    Identifiers.styleMapInterpolate4 = { name: 'ÉµÉµstyleMapInterpolate4', moduleName: CORE };
    Identifiers.styleMapInterpolate5 = { name: 'ÉµÉµstyleMapInterpolate5', moduleName: CORE };
    Identifiers.styleMapInterpolate6 = { name: 'ÉµÉµstyleMapInterpolate6', moduleName: CORE };
    Identifiers.styleMapInterpolate7 = { name: 'ÉµÉµstyleMapInterpolate7', moduleName: CORE };
    Identifiers.styleMapInterpolate8 = { name: 'ÉµÉµstyleMapInterpolate8', moduleName: CORE };
    Identifiers.styleMapInterpolateV = { name: 'ÉµÉµstyleMapInterpolateV', moduleName: CORE };
    Identifiers.classMap = { name: 'ÉµÉµclassMap', moduleName: CORE };
    Identifiers.classMapInterpolate1 = { name: 'ÉµÉµclassMapInterpolate1', moduleName: CORE };
    Identifiers.classMapInterpolate2 = { name: 'ÉµÉµclassMapInterpolate2', moduleName: CORE };
    Identifiers.classMapInterpolate3 = { name: 'ÉµÉµclassMapInterpolate3', moduleName: CORE };
    Identifiers.classMapInterpolate4 = { name: 'ÉµÉµclassMapInterpolate4', moduleName: CORE };
    Identifiers.classMapInterpolate5 = { name: 'ÉµÉµclassMapInterpolate5', moduleName: CORE };
    Identifiers.classMapInterpolate6 = { name: 'ÉµÉµclassMapInterpolate6', moduleName: CORE };
    Identifiers.classMapInterpolate7 = { name: 'ÉµÉµclassMapInterpolate7', moduleName: CORE };
    Identifiers.classMapInterpolate8 = { name: 'ÉµÉµclassMapInterpolate8', moduleName: CORE };
    Identifiers.classMapInterpolateV = { name: 'ÉµÉµclassMapInterpolateV', moduleName: CORE };
    Identifiers.styleProp = { name: 'ÉµÉµstyleProp', moduleName: CORE };
    Identifiers.stylePropInterpolate1 = { name: 'ÉµÉµstylePropInterpolate1', moduleName: CORE };
    Identifiers.stylePropInterpolate2 = { name: 'ÉµÉµstylePropInterpolate2', moduleName: CORE };
    Identifiers.stylePropInterpolate3 = { name: 'ÉµÉµstylePropInterpolate3', moduleName: CORE };
    Identifiers.stylePropInterpolate4 = { name: 'ÉµÉµstylePropInterpolate4', moduleName: CORE };
    Identifiers.stylePropInterpolate5 = { name: 'ÉµÉµstylePropInterpolate5', moduleName: CORE };
    Identifiers.stylePropInterpolate6 = { name: 'ÉµÉµstylePropInterpolate6', moduleName: CORE };
    Identifiers.stylePropInterpolate7 = { name: 'ÉµÉµstylePropInterpolate7', moduleName: CORE };
    Identifiers.stylePropInterpolate8 = { name: 'ÉµÉµstylePropInterpolate8', moduleName: CORE };
    Identifiers.stylePropInterpolateV = { name: 'ÉµÉµstylePropInterpolateV', moduleName: CORE };
    Identifiers.nextContext = { name: 'ÉµÉµnextContext', moduleName: CORE };
    Identifiers.templateCreate = { name: 'ÉµÉµtemplate', moduleName: CORE };
    Identifiers.text = { name: 'ÉµÉµtext', moduleName: CORE };
    Identifiers.enableBindings = { name: 'ÉµÉµenableBindings', moduleName: CORE };
    Identifiers.disableBindings = { name: 'ÉµÉµdisableBindings', moduleName: CORE };
    Identifiers.getCurrentView = { name: 'ÉµÉµgetCurrentView', moduleName: CORE };
    Identifiers.textInterpolate = { name: 'ÉµÉµtextInterpolate', moduleName: CORE };
    Identifiers.textInterpolate1 = { name: 'ÉµÉµtextInterpolate1', moduleName: CORE };
    Identifiers.textInterpolate2 = { name: 'ÉµÉµtextInterpolate2', moduleName: CORE };
    Identifiers.textInterpolate3 = { name: 'ÉµÉµtextInterpolate3', moduleName: CORE };
    Identifiers.textInterpolate4 = { name: 'ÉµÉµtextInterpolate4', moduleName: CORE };
    Identifiers.textInterpolate5 = { name: 'ÉµÉµtextInterpolate5', moduleName: CORE };
    Identifiers.textInterpolate6 = { name: 'ÉµÉµtextInterpolate6', moduleName: CORE };
    Identifiers.textInterpolate7 = { name: 'ÉµÉµtextInterpolate7', moduleName: CORE };
    Identifiers.textInterpolate8 = { name: 'ÉµÉµtextInterpolate8', moduleName: CORE };
    Identifiers.textInterpolateV = { name: 'ÉµÉµtextInterpolateV', moduleName: CORE };
    Identifiers.restoreView = { name: 'ÉµÉµrestoreView', moduleName: CORE };
    Identifiers.pureFunction0 = { name: 'ÉµÉµpureFunction0', moduleName: CORE };
    Identifiers.pureFunction1 = { name: 'ÉµÉµpureFunction1', moduleName: CORE };
    Identifiers.pureFunction2 = { name: 'ÉµÉµpureFunction2', moduleName: CORE };
    Identifiers.pureFunction3 = { name: 'ÉµÉµpureFunction3', moduleName: CORE };
    Identifiers.pureFunction4 = { name: 'ÉµÉµpureFunction4', moduleName: CORE };
    Identifiers.pureFunction5 = { name: 'ÉµÉµpureFunction5', moduleName: CORE };
    Identifiers.pureFunction6 = { name: 'ÉµÉµpureFunction6', moduleName: CORE };
    Identifiers.pureFunction7 = { name: 'ÉµÉµpureFunction7', moduleName: CORE };
    Identifiers.pureFunction8 = { name: 'ÉµÉµpureFunction8', moduleName: CORE };
    Identifiers.pureFunctionV = { name: 'ÉµÉµpureFunctionV', moduleName: CORE };
    Identifiers.pipeBind1 = { name: 'ÉµÉµpipeBind1', moduleName: CORE };
    Identifiers.pipeBind2 = { name: 'ÉµÉµpipeBind2', moduleName: CORE };
    Identifiers.pipeBind3 = { name: 'ÉµÉµpipeBind3', moduleName: CORE };
    Identifiers.pipeBind4 = { name: 'ÉµÉµpipeBind4', moduleName: CORE };
    Identifiers.pipeBindV = { name: 'ÉµÉµpipeBindV', moduleName: CORE };
    Identifiers.hostProperty = { name: 'ÉµÉµhostProperty', moduleName: CORE };
    Identifiers.property = { name: 'ÉµÉµproperty', moduleName: CORE };
    Identifiers.propertyInterpolate = { name: 'ÉµÉµpropertyInterpolate', moduleName: CORE };
    Identifiers.propertyInterpolate1 = { name: 'ÉµÉµpropertyInterpolate1', moduleName: CORE };
    Identifiers.propertyInterpolate2 = { name: 'ÉµÉµpropertyInterpolate2', moduleName: CORE };
    Identifiers.propertyInterpolate3 = { name: 'ÉµÉµpropertyInterpolate3', moduleName: CORE };
    Identifiers.propertyInterpolate4 = { name: 'ÉµÉµpropertyInterpolate4', moduleName: CORE };
    Identifiers.propertyInterpolate5 = { name: 'ÉµÉµpropertyInterpolate5', moduleName: CORE };
    Identifiers.propertyInterpolate6 = { name: 'ÉµÉµpropertyInterpolate6', moduleName: CORE };
    Identifiers.propertyInterpolate7 = { name: 'ÉµÉµpropertyInterpolate7', moduleName: CORE };
    Identifiers.propertyInterpolate8 = { name: 'ÉµÉµpropertyInterpolate8', moduleName: CORE };
    Identifiers.propertyInterpolateV = { name: 'ÉµÉµpropertyInterpolateV', moduleName: CORE };
    Identifiers.i18n = { name: 'ÉµÉµi18n', moduleName: CORE };
    Identifiers.i18nAttributes = { name: 'ÉµÉµi18nAttributes', moduleName: CORE };
    Identifiers.i18nExp = { name: 'ÉµÉµi18nExp', moduleName: CORE };
    Identifiers.i18nStart = { name: 'ÉµÉµi18nStart', moduleName: CORE };
    Identifiers.i18nEnd = { name: 'ÉµÉµi18nEnd', moduleName: CORE };
    Identifiers.i18nApply = { name: 'ÉµÉµi18nApply', moduleName: CORE };
    Identifiers.i18nPostprocess = { name: 'ÉµÉµi18nPostprocess', moduleName: CORE };
    Identifiers.pipe = { name: 'ÉµÉµpipe', moduleName: CORE };
    Identifiers.projection = { name: 'ÉµÉµprojection', moduleName: CORE };
    Identifiers.projectionDef = { name: 'ÉµÉµprojectionDef', moduleName: CORE };
    Identifiers.reference = { name: 'ÉµÉµreference', moduleName: CORE };
    Identifiers.inject = { name: 'ÉµÉµinject', moduleName: CORE };
    Identifiers.injectAttribute = { name: 'ÉµÉµinjectAttribute', moduleName: CORE };
    Identifiers.directiveInject = { name: 'ÉµÉµdirectiveInject', moduleName: CORE };
    Identifiers.invalidFactory = { name: 'ÉµÉµinvalidFactory', moduleName: CORE };
    Identifiers.invalidFactoryDep = { name: 'ÉµÉµinvalidFactoryDep', moduleName: CORE };
    Identifiers.templateRefExtractor = { name: 'ÉµÉµtemplateRefExtractor', moduleName: CORE };
    Identifiers.forwardRef = { name: 'forwardRef', moduleName: CORE };
    Identifiers.resolveForwardRef = { name: 'resolveForwardRef', moduleName: CORE };
    Identifiers.ÉµÉµdefineInjectable = { name: 'ÉµÉµdefineInjectable', moduleName: CORE };
    Identifiers.declareInjectable = { name: 'ÉµÉµngDeclareInjectable', moduleName: CORE };
    Identifiers.InjectableDeclaration = { name: 'ÉµÉµInjectableDeclaration', moduleName: CORE };
    Identifiers.resolveWindow = { name: 'ÉµÉµresolveWindow', moduleName: CORE };
    Identifiers.resolveDocument = { name: 'ÉµÉµresolveDocument', moduleName: CORE };
    Identifiers.resolveBody = { name: 'ÉµÉµresolveBody', moduleName: CORE };
    Identifiers.defineComponent = { name: 'ÉµÉµdefineComponent', moduleName: CORE };
    Identifiers.declareComponent = { name: 'ÉµÉµngDeclareComponent', moduleName: CORE };
    Identifiers.setComponentScope = { name: 'ÉµÉµsetComponentScope', moduleName: CORE };
    Identifiers.ChangeDetectionStrategy = {
        name: 'ChangeDetectionStrategy',
        moduleName: CORE,
    };
    Identifiers.ViewEncapsulation = {
        name: 'ViewEncapsulation',
        moduleName: CORE,
    };
    Identifiers.ComponentDeclaration = {
        name: 'ÉµÉµComponentDeclaration',
        moduleName: CORE,
    };
    Identifiers.FactoryDeclaration = {
        name: 'ÉµÉµFactoryDeclaration',
        moduleName: CORE,
    };
    Identifiers.declareFactory = { name: 'ÉµÉµngDeclareFactory', moduleName: CORE };
    Identifiers.FactoryTarget = { name: 'ÉµÉµFactoryTarget', moduleName: CORE };
    Identifiers.defineDirective = { name: 'ÉµÉµdefineDirective', moduleName: CORE };
    Identifiers.declareDirective = { name: 'ÉµÉµngDeclareDirective', moduleName: CORE };
    Identifiers.DirectiveDeclaration = {
        name: 'ÉµÉµDirectiveDeclaration',
        moduleName: CORE,
    };
    Identifiers.InjectorDef = { name: 'ÉµÉµInjectorDef', moduleName: CORE };
    Identifiers.InjectorDeclaration = { name: 'ÉµÉµInjectorDeclaration', moduleName: CORE };
    Identifiers.defineInjector = { name: 'ÉµÉµdefineInjector', moduleName: CORE };
    Identifiers.declareInjector = { name: 'ÉµÉµngDeclareInjector', moduleName: CORE };
    Identifiers.NgModuleDeclaration = {
        name: 'ÉµÉµNgModuleDeclaration',
        moduleName: CORE,
    };
    Identifiers.ModuleWithProviders = {
        name: 'ModuleWithProviders',
        moduleName: CORE,
    };
    Identifiers.defineNgModule = { name: 'ÉµÉµdefineNgModule', moduleName: CORE };
    Identifiers.declareNgModule = { name: 'ÉµÉµngDeclareNgModule', moduleName: CORE };
    Identifiers.setNgModuleScope = { name: 'ÉµÉµsetNgModuleScope', moduleName: CORE };
    Identifiers.PipeDeclaration = { name: 'ÉµÉµPipeDeclaration', moduleName: CORE };
    Identifiers.definePipe = { name: 'ÉµÉµdefinePipe', moduleName: CORE };
    Identifiers.declarePipe = { name: 'ÉµÉµngDeclarePipe', moduleName: CORE };
    Identifiers.declareClassMetadata = { name: 'ÉµÉµngDeclareClassMetadata', moduleName: CORE };
    Identifiers.setClassMetadata = { name: 'ÉµsetClassMetadata', moduleName: CORE };
    Identifiers.queryRefresh = { name: 'ÉµÉµqueryRefresh', moduleName: CORE };
    Identifiers.viewQuery = { name: 'ÉµÉµviewQuery', moduleName: CORE };
    Identifiers.loadQuery = { name: 'ÉµÉµloadQuery', moduleName: CORE };
    Identifiers.contentQuery = { name: 'ÉµÉµcontentQuery', moduleName: CORE };
    Identifiers.NgOnChangesFeature = { name: 'ÉµÉµNgOnChangesFeature', moduleName: CORE };
    Identifiers.InheritDefinitionFeature = { name: 'ÉµÉµInheritDefinitionFeature', moduleName: CORE };
    Identifiers.CopyDefinitionFeature = { name: 'ÉµÉµCopyDefinitionFeature', moduleName: CORE };
    Identifiers.ProvidersFeature = { name: 'ÉµÉµProvidersFeature', moduleName: CORE };
    Identifiers.listener = { name: 'ÉµÉµlistener', moduleName: CORE };
    Identifiers.getInheritedFactory = {
        name: 'ÉµÉµgetInheritedFactory',
        moduleName: CORE,
    };
    // sanitization-related functions
    Identifiers.sanitizeHtml = { name: 'ÉµÉµsanitizeHtml', moduleName: CORE };
    Identifiers.sanitizeStyle = { name: 'ÉµÉµsanitizeStyle', moduleName: CORE };
    Identifiers.sanitizeResourceUrl = { name: 'ÉµÉµsanitizeResourceUrl', moduleName: CORE };
    Identifiers.sanitizeScript = { name: 'ÉµÉµsanitizeScript', moduleName: CORE };
    Identifiers.sanitizeUrl = { name: 'ÉµÉµsanitizeUrl', moduleName: CORE };
    Identifiers.sanitizeUrlOrResourceUrl = { name: 'ÉµÉµsanitizeUrlOrResourceUrl', moduleName: CORE };
    Identifiers.trustConstantHtml = { name: 'ÉµÉµtrustConstantHtml', moduleName: CORE };
    Identifiers.trustConstantResourceUrl = { name: 'ÉµÉµtrustConstantResourceUrl', moduleName: CORE };

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const DASH_CASE_REGEXP = /-+([a-z0-9])/g;
    function dashCaseToCamelCase(input) {
        return input.replace(DASH_CASE_REGEXP, (...m) => m[1].toUpperCase());
    }
    function splitAtColon(input, defaultValues) {
        return _splitAt(input, ':', defaultValues);
    }
    function splitAtPeriod(input, defaultValues) {
        return _splitAt(input, '.', defaultValues);
    }
    function _splitAt(input, character, defaultValues) {
        const characterIndex = input.indexOf(character);
        if (characterIndex == -1)
            return defaultValues;
        return [input.slice(0, characterIndex).trim(), input.slice(characterIndex + 1).trim()];
    }
    function visitValue(value, visitor, context) {
        if (Array.isArray(value)) {
            return visitor.visitArray(value, context);
        }
        if (isStrictStringMap(value)) {
            return visitor.visitStringMap(value, context);
        }
        if (value == null || typeof value == 'string' || typeof value == 'number' ||
            typeof value == 'boolean') {
            return visitor.visitPrimitive(value, context);
        }
        return visitor.visitOther(value, context);
    }
    function isDefined(val) {
        return val !== null && val !== undefined;
    }
    function noUndefined(val) {
        return val === undefined ? null : val;
    }
    class ValueTransformer {
        visitArray(arr, context) {
            return arr.map(value => visitValue(value, this, context));
        }
        visitStringMap(map, context) {
            const result = {};
            Object.keys(map).forEach(key => {
                result[key] = visitValue(map[key], this, context);
            });
            return result;
        }
        visitPrimitive(value, context) {
            return value;
        }
        visitOther(value, context) {
            return value;
        }
    }
    const SyncAsync = {
        assertSync: (value) => {
            if (isPromise(value)) {
                throw new Error(`Illegal state: value cannot be a promise`);
            }
            return value;
        },
        then: (value, cb) => {
            return isPromise(value) ? value.then(cb) : cb(value);
        },
        all: (syncAsyncValues) => {
            return syncAsyncValues.some(isPromise) ? Promise.all(syncAsyncValues) : syncAsyncValues;
        }
    };
    function error(msg) {
        throw new Error(`Internal Error: ${msg}`);
    }
    const STRING_MAP_PROTO = Object.getPrototypeOf({});
    function isStrictStringMap(obj) {
        return typeof obj === 'object' && obj !== null && Object.getPrototypeOf(obj) === STRING_MAP_PROTO;
    }
    function utf8Encode(str) {
        let encoded = [];
        for (let index = 0; index < str.length; index++) {
            let codePoint = str.charCodeAt(index);
            // decode surrogate
            // see https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
            if (codePoint >= 0xd800 && codePoint <= 0xdbff && str.length > (index + 1)) {
                const low = str.charCodeAt(index + 1);
                if (low >= 0xdc00 && low <= 0xdfff) {
                    index++;
                    codePoint = ((codePoint - 0xd800) << 10) + low - 0xdc00 + 0x10000;
                }
            }
            if (codePoint <= 0x7f) {
                encoded.push(codePoint);
            }
            else if (codePoint <= 0x7ff) {
                encoded.push(((codePoint >> 6) & 0x1F) | 0xc0, (codePoint & 0x3f) | 0x80);
            }
            else if (codePoint <= 0xffff) {
                encoded.push((codePoint >> 12) | 0xe0, ((codePoint >> 6) & 0x3f) | 0x80, (codePoint & 0x3f) | 0x80);
            }
            else if (codePoint <= 0x1fffff) {
                encoded.push(((codePoint >> 18) & 0x07) | 0xf0, ((codePoint >> 12) & 0x3f) | 0x80, ((codePoint >> 6) & 0x3f) | 0x80, (codePoint & 0x3f) | 0x80);
            }
        }
        return encoded;
    }
    function stringify(token) {
        if (typeof token === 'string') {
            return token;
        }
        if (Array.isArray(token)) {
            return '[' + token.map(stringify).join(', ') + ']';
        }
        if (token == null) {
            return '' + token;
        }
        if (token.overriddenName) {
            return `${token.overriddenName}`;
        }
        if (token.name) {
            return `${token.name}`;
        }
        if (!token.toString) {
            return 'object';
        }
        // WARNING: do not try to `JSON.stringify(token)` here
        // see https://github.com/angular/angular/issues/23440
        const res = token.toString();
        if (res == null) {
            return '' + res;
        }
        const newLineIndex = res.indexOf('\n');
        return newLineIndex === -1 ? res : res.substring(0, newLineIndex);
    }
    /**
     * Lazily retrieves the reference value from a forwardRef.
     */
    function resolveForwardRef(type) {
        if (typeof type === 'function' && type.hasOwnProperty('__forward_ref__')) {
            return type();
        }
        else {
            return type;
        }
    }
    /**
     * Determine if the argument is shaped like a Promise
     */
    function isPromise(obj) {
        // allow any Promise/A+ compliant thenable.
        // It's up to the caller to ensure that obj.then conforms to the spec
        return !!obj && typeof obj.then === 'function';
    }
    class Version {
        constructor(full) {
            this.full = full;
            const splits = full.split('.');
            this.major = splits[0];
            this.minor = splits[1];
            this.patch = splits.slice(2).join('.');
        }
    }
    const __window = typeof window !== 'undefined' && window;
    const __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&
        self instanceof WorkerGlobalScope && self;
    const __global = typeof global !== 'undefined' && global;
    // Check __global first, because in Node tests both __global and __window may be defined and _global
    // should be __global in that case.
    const _global = __global || __window || __self;
    function newArray(size, value) {
        const list = [];
        for (let i = 0; i < size; i++) {
            list.push(value);
        }
        return list;
    }
    /**
     * Partitions a given array into 2 arrays, based on a boolean value returned by the condition
     * function.
     *
     * @param arr Input array that should be partitioned
     * @param conditionFn Condition function that is called for each item in a given array and returns a
     * boolean value.
     */
    function partitionArray(arr, conditionFn) {
        const truthy = [];
        const falsy = [];
        for (const item of arr) {
            (conditionFn(item) ? truthy : falsy).push(item);
        }
        return [truthy, falsy];
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * This is an R3 `Node`-like wrapper for a raw `html.Comment` node. We do not currently
     * require the implementation of a visitor for Comments as they are only collected at
     * the top-level of the R3 AST, and only if `Render3ParseOptions['collectCommentNodes']`
     * is true.
     */
    class Comment {
        constructor(value, sourceSpan) {
            this.value = value;
            this.sourceSpan = sourceSpan;
        }
        visit(_visitor) {
            throw new Error('visit() not implemented for Comment');
        }
    }
    class Text {
        constructor(value, sourceSpan) {
            this.value = value;
            this.sourceSpan = sourceSpan;
        }
        visit(visitor) {
            return visitor.visitText(this);
        }
    }
    class BoundText {
        constructor(value, sourceSpan, i18n) {
            this.value = value;
            this.sourceSpan = sourceSpan;
            this.i18n = i18n;
        }
        visit(visitor) {
            return visitor.visitBoundText(this);
        }
    }
    /**
     * Represents a text attribute in the template.
     *
     * `valueSpan` may not be present in cases where there is no value `<div a></div>`.
     * `keySpan` may also not be present for synthetic attributes from ICU expansions.
     */
    class TextAttribute {
        constructor(name, value, sourceSpan, keySpan, valueSpan, i18n) {
            this.name = name;
            this.value = value;
            this.sourceSpan = sourceSpan;
            this.keySpan = keySpan;
            this.valueSpan = valueSpan;
            this.i18n = i18n;
        }
        visit(visitor) {
            return visitor.visitTextAttribute(this);
        }
    }
    class BoundAttribute {
        constructor(name, type, securityContext, value, unit, sourceSpan, keySpan, valueSpan, i18n) {
            this.name = name;
            this.type = type;
            this.securityContext = securityContext;
            this.value = value;
            this.unit = unit;
            this.sourceSpan = sourceSpan;
            this.keySpan = keySpan;
            this.valueSpan = valueSpan;
            this.i18n = i18n;
        }
        static fromBoundElementProperty(prop, i18n) {
            if (prop.keySpan === undefined) {
                throw new Error(`Unexpected state: keySpan must be defined for bound attributes but was not for ${prop.name}: ${prop.sourceSpan}`);
            }
            return new BoundAttribute(prop.name, prop.type, prop.securityContext, prop.value, prop.unit, prop.sourceSpan, prop.keySpan, prop.valueSpan, i18n);
        }
        visit(visitor) {
            return visitor.visitBoundAttribute(this);
        }
    }
    class BoundEvent {
        constructor(name, type, handler, target, phase, sourceSpan, handlerSpan, keySpan) {
            this.name = name;
            this.type = type;
            this.handler = handler;
            this.target = target;
            this.phase = phase;
            this.sourceSpan = sourceSpan;
            this.handlerSpan = handlerSpan;
            this.keySpan = keySpan;
        }
        static fromParsedEvent(event) {
            const target = event.type === 0 /* Regular */ ? event.targetOrPhase : null;
            const phase = event.type === 1 /* Animation */ ? event.targetOrPhase : null;
            if (event.keySpan === undefined) {
                throw new Error(`Unexpected state: keySpan must be defined for bound event but was not for ${event.name}: ${event.sourceSpan}`);
            }
            return new BoundEvent(event.name, event.type, event.handler, target, phase, event.sourceSpan, event.handlerSpan, event.keySpan);
        }
        visit(visitor) {
            return visitor.visitBoundEvent(this);
        }
    }
    class Element {
        constructor(name, attributes, inputs, outputs, children, references, sourceSpan, startSourceSpan, endSourceSpan, i18n) {
            this.name = name;
            this.attributes = attributes;
            this.inputs = inputs;
            this.outputs = outputs;
            this.children = children;
            this.references = references;
            this.sourceSpan = sourceSpan;
            this.startSourceSpan = startSourceSpan;
            this.endSourceSpan = endSourceSpan;
            this.i18n = i18n;
        }
        visit(visitor) {
            return visitor.visitElement(this);
        }
    }
    class Template {
        constructor(tagName, attributes, inputs, outputs, templateAttrs, children, references, variables, sourceSpan, startSourceSpan, endSourceSpan, i18n) {
            this.tagName = tagName;
            this.attributes = attributes;
            this.inputs = inputs;
            this.outputs = outputs;
            this.templateAttrs = templateAttrs;
            this.children = children;
            this.references = references;
            this.variables = variables;
            this.sourceSpan = sourceSpan;
            this.startSourceSpan = startSourceSpan;
            this.endSourceSpan = endSourceSpan;
            this.i18n = i18n;
        }
        visit(visitor) {
            return visitor.visitTemplate(this);
        }
    }
    class Content {
        constructor(selector, attributes, sourceSpan, i18n) {
            this.selector = selector;
            this.attributes = attributes;
            this.sourceSpan = sourceSpan;
            this.i18n = i18n;
            this.name = 'ng-content';
        }
        visit(visitor) {
            return visitor.visitContent(this);
        }
    }
    class Variable {
        constructor(name, value, sourceSpan, keySpan, valueSpan) {
            this.name = name;
            this.value = value;
            this.sourceSpan = sourceSpan;
            this.keySpan = keySpan;
            this.valueSpan = valueSpan;
        }
        visit(visitor) {
            return visitor.visitVariable(this);
        }
    }
    class Reference {
        constructor(name, value, sourceSpan, keySpan, valueSpan) {
            this.name = name;
            this.value = value;
            this.sourceSpan = sourceSpan;
            this.keySpan = keySpan;
            this.valueSpan = valueSpan;
        }
        visit(visitor) {
            return visitor.visitReference(this);
        }
    }
    class Icu {
        constructor(vars, placeholders, sourceSpan, i18n) {
            this.vars = vars;
            this.placeholders = placeholders;
            this.sourceSpan = sourceSpan;
            this.i18n = i18n;
        }
        visit(visitor) {
            return visitor.visitIcu(this);
        }
    }
    function visitAll(visitor, nodes) {
        const result = [];
        if (visitor.visit) {
            for (const node of nodes) {
                const newNode = visitor.visit(node) || node.visit(visitor);
            }
        }
        else {
            for (const node of nodes) {
                const newNode = node.visit(visitor);
                if (newNode) {
                    result.push(newNode);
                }
            }
        }
        return result;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class Message {
        /**
         * @param nodes message AST
         * @param placeholders maps placeholder names to static content and their source spans
         * @param placeholderToMessage maps placeholder names to messages (used for nested ICU messages)
         * @param meaning
         * @param description
         * @param customId
         */
        constructor(nodes, placeholders, placeholderToMessage, meaning, description, customId) {
            this.nodes = nodes;
            this.placeholders = placeholders;
            this.placeholderToMessage = placeholderToMessage;
            this.meaning = meaning;
            this.description = description;
            this.customId = customId;
            this.id = this.customId;
            /** The ids to use if there are no custom id and if `i18nLegacyMessageIdFormat` is not empty */
            this.legacyIds = [];
            if (nodes.length) {
                this.sources = [{
                        filePath: nodes[0].sourceSpan.start.file.url,
                        startLine: nodes[0].sourceSpan.start.line + 1,
                        startCol: nodes[0].sourceSpan.start.col + 1,
                        endLine: nodes[nodes.length - 1].sourceSpan.end.line + 1,
                        endCol: nodes[0].sourceSpan.start.col + 1
                    }];
            }
            else {
                this.sources = [];
            }
        }
    }
    class Text$1 {
        constructor(value, sourceSpan) {
            this.value = value;
            this.sourceSpan = sourceSpan;
        }
        visit(visitor, context) {
            return visitor.visitText(this, context);
        }
    }
    // TODO(vicb): do we really need this node (vs an array) ?
    class Container {
        constructor(children, sourceSpan) {
            this.children = children;
            this.sourceSpan = sourceSpan;
        }
        visit(visitor, context) {
            return visitor.visitContainer(this, context);
        }
    }
    class Icu$1 {
        constructor(expression, type, cases, sourceSpan) {
            this.expression = expression;
            this.type = type;
            this.cases = cases;
            this.sourceSpan = sourceSpan;
        }
        visit(visitor, context) {
            return visitor.visitIcu(this, context);
        }
    }
    class TagPlaceholder {
        constructor(tag, attrs, startName, closeName, children, isVoid, 
        // TODO sourceSpan should cover all (we need a startSourceSpan and endSourceSpan)
        sourceSpan, startSourceSpan, endSourceSpan) {
            this.tag = tag;
            this.attrs = attrs;
            this.startName = startName;
            this.closeName = closeName;
            this.children = children;
            this.isVoid = isVoid;
            this.sourceSpan = sourceSpan;
            this.startSourceSpan = startSourceSpan;
            this.endSourceSpan = endSourceSpan;
        }
        visit(visitor, context) {
            return visitor.visitTagPlaceholder(this, context);
        }
    }
    class Placeholder {
        constructor(value, name, sourceSpan) {
            this.value = value;
            this.name = name;
            this.sourceSpan = sourceSpan;
        }
        visit(visitor, context) {
            return visitor.visitPlaceholder(this, context);
        }
    }
    class IcuPlaceholder {
        constructor(value, name, sourceSpan) {
            this.value = value;
            this.name = name;
            this.sourceSpan = sourceSpan;
        }
        visit(visitor, context) {
            return visitor.visitIcuPlaceholder(this, context);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Represents a big integer using a buffer of its individual digits, with the least significant
     * digit stored at the beginning of the array (little endian).
     *
     * For performance reasons, each instance is mutable. The addition operation can be done in-place
     * to reduce memory pressure of allocation for the digits array.
     */
    class BigInteger {
        /**
         * Creates a big integer using its individual digits in little endian storage.
         */
        constructor(digits) {
            this.digits = digits;
        }
        static zero() {
            return new BigInteger([0]);
        }
        static one() {
            return new BigInteger([1]);
        }
        /**
         * Creates a clone of this instance.
         */
        clone() {
            return new BigInteger(this.digits.slice());
        }
        /**
         * Returns a new big integer with the sum of `this` and `other` as its value. This does not mutate
         * `this` but instead returns a new instance, unlike `addToSelf`.
         */
        add(other) {
            const result = this.clone();
            result.addToSelf(other);
            return result;
        }
        /**
         * Adds `other` to the instance itself, thereby mutating its value.
         */
        addToSelf(other) {
            const maxNrOfDigits = Math.max(this.digits.length, other.digits.length);
            let carry = 0;
            for (let i = 0; i < maxNrOfDigits; i++) {
                let digitSum = carry;
                if (i < this.digits.length) {
                    digitSum += this.digits[i];
                }
                if (i < other.digits.length) {
                    digitSum += other.digits[i];
                }
                if (digitSum >= 10) {
                    this.digits[i] = digitSum - 10;
                    carry = 1;
                }
                else {
                    this.digits[i] = digitSum;
                    carry = 0;
                }
            }
            // Apply a remaining carry if needed.
            if (carry > 0) {
                this.digits[maxNrOfDigits] = 1;
            }
        }
        /**
         * Builds the decimal string representation of the big integer. As this is stored in
         * little endian, the digits are concatenated in reverse order.
         */
        toString() {
            let res = '';
            for (let i = this.digits.length - 1; i >= 0; i--) {
                res += this.digits[i];
            }
            return res;
        }
    }
    /**
     * Represents a big integer which is optimized for multiplication operations, as its power-of-twos
     * are memoized. See `multiplyBy()` for details on the multiplication algorithm.
     */
    class BigIntForMultiplication {
        constructor(value) {
            this.powerOfTwos = [value];
        }
        /**
         * Returns the big integer itself.
         */
        getValue() {
            return this.powerOfTwos[0];
        }
        /**
         * Computes the value for `num * b`, where `num` is a JS number and `b` is a big integer. The
         * value for `b` is represented by a storage model that is optimized for this computation.
         *
         * This operation is implemented in N(log2(num)) by continuous halving of the number, where the
         * least-significant bit (LSB) is tested in each iteration. If the bit is set, the bit's index is
         * used as exponent into the power-of-two multiplication of `b`.
         *
         * As an example, consider the multiplication num=42, b=1337. In binary 42 is 0b00101010 and the
         * algorithm unrolls into the following iterations:
         *
         *  Iteration | num        | LSB  | b * 2^iter | Add? | product
         * -----------|------------|------|------------|------|--------
         *  0         | 0b00101010 | 0    | 1337       | No   | 0
         *  1         | 0b00010101 | 1    | 2674       | Yes  | 2674
         *  2         | 0b00001010 | 0    | 5348       | No   | 2674
         *  3         | 0b00000101 | 1    | 10696      | Yes  | 13370
         *  4         | 0b00000010 | 0    | 21392      | No   | 13370
         *  5         | 0b00000001 | 1    | 42784      | Yes  | 56154
         *  6         | 0b00000000 | 0    | 85568      | No   | 56154
         *
         * The computed product of 56154 is indeed the correct result.
         *
         * The `BigIntForMultiplication` representation for a big integer provides memoized access to the
         * power-of-two values to reduce the workload in computing those values.
         */
        multiplyBy(num) {
            const product = BigInteger.zero();
            this.multiplyByAndAddTo(num, product);
            return product;
        }
        /**
         * See `multiplyBy()` for details. This function allows for the computed product to be added
         * directly to the provided result big integer.
         */
        multiplyByAndAddTo(num, result) {
            for (let exponent = 0; num !== 0; num = num >>> 1, exponent++) {
                if (num & 1) {
                    const value = this.getMultipliedByPowerOfTwo(exponent);
                    result.addToSelf(value);
                }
            }
        }
        /**
         * Computes and memoizes the big integer value for `this.number * 2^exponent`.
         */
        getMultipliedByPowerOfTwo(exponent) {
            // Compute the powers up until the requested exponent, where each value is computed from its
            // predecessor. This is simple as `this.number * 2^(exponent - 1)` only has to be doubled (i.e.
            // added to itself) to reach `this.number * 2^exponent`.
            for (let i = this.powerOfTwos.length; i <= exponent; i++) {
                const previousPower = this.powerOfTwos[i - 1];
                this.powerOfTwos[i] = previousPower.add(previousPower);
            }
            return this.powerOfTwos[exponent];
        }
    }
    /**
     * Represents an exponentiation operation for the provided base, of which exponents are computed and
     * memoized. The results are represented by a `BigIntForMultiplication` which is tailored for
     * multiplication operations by memoizing the power-of-twos. This effectively results in a matrix
     * representation that is lazily computed upon request.
     */
    class BigIntExponentiation {
        constructor(base) {
            this.base = base;
            this.exponents = [new BigIntForMultiplication(BigInteger.one())];
        }
        /**
         * Compute the value for `this.base^exponent`, resulting in a big integer that is optimized for
         * further multiplication operations.
         */
        toThePowerOf(exponent) {
            // Compute the results up until the requested exponent, where every value is computed from its
            // predecessor. This is because `this.base^(exponent - 1)` only has to be multiplied by `base`
            // to reach `this.base^exponent`.
            for (let i = this.exponents.length; i <= exponent; i++) {
                const value = this.exponents[i - 1].multiplyBy(this.base);
                this.exponents[i] = new BigIntForMultiplication(value);
            }
            return this.exponents[exponent];
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Compute the message id using the XLIFF1 digest.
     */
    function computeDigest(message) {
        return sha1(serializeNodes(message.nodes).join('') + `[${message.meaning}]`);
    }
    /**
     * Return the message id or compute it using the XLIFF2/XMB/$localize digest.
     */
    function decimalDigest(message) {
        return message.id || computeDecimalDigest(message);
    }
    /**
     * Compute the message id using the XLIFF2/XMB/$localize digest.
     */
    function computeDecimalDigest(message) {
        const visitor = new _SerializerIgnoreIcuExpVisitor();
        const parts = message.nodes.map(a => a.visit(visitor, null));
        return computeMsgId(parts.join(''), message.meaning);
    }
    /**
     * Serialize the i18n ast to something xml-like in order to generate an UID.
     *
     * The visitor is also used in the i18n parser tests
     *
     * @internal
     */
    class _SerializerVisitor {
        visitText(text, context) {
            return text.value;
        }
        visitContainer(container, context) {
            return `[${container.children.map(child => child.visit(this)).join(', ')}]`;
        }
        visitIcu(icu, context) {
            const strCases = Object.keys(icu.cases).map((k) => `${k} {${icu.cases[k].visit(this)}}`);
            return `{${icu.expression}, ${icu.type}, ${strCases.join(', ')}}`;
        }
        visitTagPlaceholder(ph, context) {
            return ph.isVoid ?
                `<ph tag name="${ph.startName}"/>` :
                `<ph tag name="${ph.startName}">${ph.children.map(child => child.visit(this)).join(', ')}</ph name="${ph.closeName}">`;
        }
        visitPlaceholder(ph, context) {
            return ph.value ? `<ph name="${ph.name}">${ph.value}</ph>` : `<ph name="${ph.name}"/>`;
        }
        visitIcuPlaceholder(ph, context) {
            return `<ph icu name="${ph.name}">${ph.value.visit(this)}</ph>`;
        }
    }
    const serializerVisitor = new _SerializerVisitor();
    function serializeNodes(nodes) {
        return nodes.map(a => a.visit(serializerVisitor, null));
    }
    /**
     * Serialize the i18n ast to something xml-like in order to generate an UID.
     *
     * Ignore the ICU expressions so that message IDs stays identical if only the expression changes.
     *
     * @internal
     */
    class _SerializerIgnoreIcuExpVisitor extends _SerializerVisitor {
        visitIcu(icu, context) {
            let strCases = Object.keys(icu.cases).map((k) => `${k} {${icu.cases[k].visit(this)}}`);
            // Do not take the expression into account
            return `{${icu.type}, ${strCases.join(', ')}}`;
        }
    }
    /**
     * Compute the SHA1 of the given string
     *
     * see https://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf
     *
     * WARNING: this function has not been designed not tested with security in mind.
     *          DO NOT USE IT IN A SECURITY SENSITIVE CONTEXT.
     */
    function sha1(str) {
        const utf8 = utf8Encode(str);
        const words32 = bytesToWords32(utf8, Endian.Big);
        const len = utf8.length * 8;
        const w = newArray(80);
        let a = 0x67452301, b = 0xefcdab89, c = 0x98badcfe, d = 0x10325476, e = 0xc3d2e1f0;
        words32[len >> 5] |= 0x80 << (24 - len % 32);
        words32[((len + 64 >> 9) << 4) + 15] = len;
        for (let i = 0; i < words32.length; i += 16) {
            const h0 = a, h1 = b, h2 = c, h3 = d, h4 = e;
            for (let j = 0; j < 80; j++) {
                if (j < 16) {
                    w[j] = words32[i + j];
                }
                else {
                    w[j] = rol32(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);
                }
                const fkVal = fk(j, b, c, d);
                const f = fkVal[0];
                const k = fkVal[1];
                const temp = [rol32(a, 5), f, e, k, w[j]].reduce(add32);
                e = d;
                d = c;
                c = rol32(b, 30);
                b = a;
                a = temp;
            }
            a = add32(a, h0);
            b = add32(b, h1);
            c = add32(c, h2);
            d = add32(d, h3);
            e = add32(e, h4);
        }
        return bytesToHexString(words32ToByteString([a, b, c, d, e]));
    }
    function fk(index, b, c, d) {
        if (index < 20) {
            return [(b & c) | (~b & d), 0x5a827999];
        }
        if (index < 40) {
            return [b ^ c ^ d, 0x6ed9eba1];
        }
        if (index < 60) {
            return [(b & c) | (b & d) | (c & d), 0x8f1bbcdc];
        }
        return [b ^ c ^ d, 0xca62c1d6];
    }
    /**
     * Compute the fingerprint of the given string
     *
     * The output is 64 bit number encoded as a decimal string
     *
     * based on:
     * https://github.com/google/closure-compiler/blob/master/src/com/google/javascript/jscomp/GoogleJsMessageIdGenerator.java
     */
    function fingerprint(str) {
        const utf8 = utf8Encode(str);
        let hi = hash32(utf8, 0);
        let lo = hash32(utf8, 102072);
        if (hi == 0 && (lo == 0 || lo == 1)) {
            hi = hi ^ 0x130f9bef;
            lo = lo ^ -0x6b5f56d8;
        }
        return [hi, lo];
    }
    function computeMsgId(msg, meaning = '') {
        let msgFingerprint = fingerprint(msg);
        if (meaning) {
            const meaningFingerprint = fingerprint(meaning);
            msgFingerprint = add64(rol64(msgFingerprint, 1), meaningFingerprint);
        }
        const hi = msgFingerprint[0];
        const lo = msgFingerprint[1];
        return wordsToDecimalString(hi & 0x7fffffff, lo);
    }
    function hash32(bytes, c) {
        let a = 0x9e3779b9, b = 0x9e3779b9;
        let i;
        const len = bytes.length;
        for (i = 0; i + 12 <= len; i += 12) {
            a = add32(a, wordAt(bytes, i, Endian.Little));
            b = add32(b, wordAt(bytes, i + 4, Endian.Little));
            c = add32(c, wordAt(bytes, i + 8, Endian.Little));
            const res = mix(a, b, c);
            a = res[0], b = res[1], c = res[2];
        }
        a = add32(a, wordAt(bytes, i, Endian.Little));
        b = add32(b, wordAt(bytes, i + 4, Endian.Little));
        // the first byte of c is reserved for the length
        c = add32(c, len);
        c = add32(c, wordAt(bytes, i + 8, Endian.Little) << 8);
        return mix(a, b, c)[2];
    }
    // clang-format off
    function mix(a, b, c) {
        a = sub32(a, b);
        a = sub32(a, c);
        a ^= c >>> 13;
        b = sub32(b, c);
        b = sub32(b, a);
        b ^= a << 8;
        c = sub32(c, a);
        c = sub32(c, b);
        c ^= b >>> 13;
        a = sub32(a, b);
        a = sub32(a, c);
        a ^= c >>> 12;
        b = sub32(b, c);
        b = sub32(b, a);
        b ^= a << 16;
        c = sub32(c, a);
        c = sub32(c, b);
        c ^= b >>> 5;
        a = sub32(a, b);
        a = sub32(a, c);
        a ^= c >>> 3;
        b = sub32(b, c);
        b = sub32(b, a);
        b ^= a << 10;
        c = sub32(c, a);
        c = sub32(c, b);
        c ^= b >>> 15;
        return [a, b, c];
    }
    // clang-format on
    // Utils
    var Endian;
    (function (Endian) {
        Endian[Endian["Little"] = 0] = "Little";
        Endian[Endian["Big"] = 1] = "Big";
    })(Endian || (Endian = {}));
    function add32(a, b) {
        return add32to64(a, b)[1];
    }
    function add32to64(a, b) {
        const low = (a & 0xffff) + (b & 0xffff);
        const high = (a >>> 16) + (b >>> 16) + (low >>> 16);
        return [high >>> 16, (high << 16) | (low & 0xffff)];
    }
    function add64(a, b) {
        const ah = a[0], al = a[1];
        const bh = b[0], bl = b[1];
        const result = add32to64(al, bl);
        const carry = result[0];
        const l = result[1];
        const h = add32(add32(ah, bh), carry);
        return [h, l];
    }
    function sub32(a, b) {
        const low = (a & 0xffff) - (b & 0xffff);
        const high = (a >> 16) - (b >> 16) + (low >> 16);
        return (high << 16) | (low & 0xffff);
    }
    // Rotate a 32b number left `count` position
    function rol32(a, count) {
        return (a << count) | (a >>> (32 - count));
    }
    // Rotate a 64b number left `count` position
    function rol64(num, count) {
        const hi = num[0], lo = num[1];
        const h = (hi << count) | (lo >>> (32 - count));
        const l = (lo << count) | (hi >>> (32 - count));
        return [h, l];
    }
    function bytesToWords32(bytes, endian) {
        const size = (bytes.length + 3) >>> 2;
        const words32 = [];
        for (let i = 0; i < size; i++) {
            words32[i] = wordAt(bytes, i * 4, endian);
        }
        return words32;
    }
    function byteAt(bytes, index) {
        return index >= bytes.length ? 0 : bytes[index];
    }
    function wordAt(bytes, index, endian) {
        let word = 0;
        if (endian === Endian.Big) {
            for (let i = 0; i < 4; i++) {
                word += byteAt(bytes, index + i) << (24 - 8 * i);
            }
        }
        else {
            for (let i = 0; i < 4; i++) {
                word += byteAt(bytes, index + i) << 8 * i;
            }
        }
        return word;
    }
    function words32ToByteString(words32) {
        return words32.reduce((bytes, word) => bytes.concat(word32ToByteString(word)), []);
    }
    function word32ToByteString(word) {
        let bytes = [];
        for (let i = 0; i < 4; i++) {
            bytes.push((word >>> 8 * (3 - i)) & 0xff);
        }
        return bytes;
    }
    function bytesToHexString(bytes) {
        let hex = '';
        for (let i = 0; i < bytes.length; i++) {
            const b = byteAt(bytes, i);
            hex += (b >>> 4).toString(16) + (b & 0x0f).toString(16);
        }
        return hex.toLowerCase();
    }
    /**
     * Create a shared exponentiation pool for base-256 computations. This shared pool provides memoized
     * power-of-256 results with memoized power-of-two computations for efficient multiplication.
     *
     * For our purposes, this can be safely stored as a global without memory concerns. The reason is
     * that we encode two words, so only need the 0th (for the low word) and 4th (for the high word)
     * exponent.
     */
    const base256 = new BigIntExponentiation(256);
    /**
     * Represents two 32-bit words as a single decimal number. This requires a big integer storage
     * model as JS numbers are not accurate enough to represent the 64-bit number.
     *
     * Based on https://www.danvk.org/hex2dec.html
     */
    function wordsToDecimalString(hi, lo) {
        // Encode the four bytes in lo in the lower digits of the decimal number.
        // Note: the multiplication results in lo itself but represented by a big integer using its
        // decimal digits.
        const decimal = base256.toThePowerOf(0).multiplyBy(lo);
        // Encode the four bytes in hi above the four lo bytes. lo is a maximum of (2^8)^4, which is why
        // this multiplication factor is applied.
        base256.toThePowerOf(4).multiplyByAndAddTo(hi, decimal);
        return decimal.toString();
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    // XMB/XTB placeholders can only contain A-Z, 0-9 and _
    function toPublicName(internalName) {
        return internalName.toUpperCase().replace(/[^A-Z0-9_]/g, '_');
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /* Closure variables holding messages must be named `MSG_[A-Z0-9]+` */
    const CLOSURE_TRANSLATION_VAR_PREFIX = 'MSG_';
    /**
     * Prefix for non-`goog.getMsg` i18n-related vars.
     * Note: the prefix uses lowercase characters intentionally due to a Closure behavior that
     * considers variables like `I18N_0` as constants and throws an error when their value changes.
     */
    const TRANSLATION_VAR_PREFIX = 'i18n_';
    /** Name of the i18n attributes **/
    const I18N_ATTR = 'i18n';
    const I18N_ATTR_PREFIX = 'i18n-';
    /** Prefix of var expressions used in ICUs */
    const I18N_ICU_VAR_PREFIX = 'VAR_';
    /** Prefix of ICU expressions for post processing */
    const I18N_ICU_MAPPING_PREFIX = 'I18N_EXP_';
    /** Placeholder wrapper for i18n expressions **/
    const I18N_PLACEHOLDER_SYMBOL = 'ï¿½';
    function isI18nAttribute(name) {
        return name === I18N_ATTR || name.startsWith(I18N_ATTR_PREFIX);
    }
    function isI18nRootNode(meta) {
        return meta instanceof Message;
    }
    function isSingleI18nIcu(meta) {
        return isI18nRootNode(meta) && meta.nodes.length === 1 && meta.nodes[0] instanceof Icu$1;
    }
    function hasI18nMeta(node) {
        return !!node.i18n;
    }
    function hasI18nAttrs(element) {
        return element.attrs.some((attr) => isI18nAttribute(attr.name));
    }
    function icuFromI18nMessage(message) {
        return message.nodes[0];
    }
    function wrapI18nPlaceholder(content, contextId = 0) {
        const blockId = contextId > 0 ? `:${contextId}` : '';
        return `${I18N_PLACEHOLDER_SYMBOL}${content}${blockId}${I18N_PLACEHOLDER_SYMBOL}`;
    }
    function assembleI18nBoundString(strings, bindingStartIndex = 0, contextId = 0) {
        if (!strings.length)
            return '';
        let acc = '';
        const lastIdx = strings.length - 1;
        for (let i = 0; i < lastIdx; i++) {
            acc += `${strings[i]}${wrapI18nPlaceholder(bindingStartIndex + i, contextId)}`;
        }
        acc += strings[lastIdx];
        return acc;
    }
    function getSeqNumberGenerator(startsAt = 0) {
        let current = startsAt;
        return () => current++;
    }
    function placeholdersToParams(placeholders) {
        const params = {};
        placeholders.forEach((values, key) => {
            params[key] = literal(values.length > 1 ? `[${values.join('|')}]` : values[0]);
        });
        return params;
    }
    function updatePlaceholderMap(map, name, ...values) {
        const current = map.get(name) || [];
        current.push(...values);
        map.set(name, current);
    }
    function assembleBoundTextPlaceholders(meta, bindingStartIndex = 0, contextId = 0) {
        const startIdx = bindingStartIndex;
        const placeholders = new Map();
        const node = meta instanceof Message ? meta.nodes.find(node => node instanceof Container) : meta;
        if (node) {
            node
                .children
                .filter((child) => child instanceof Placeholder)
                .forEach((child, idx) => {
                const content = wrapI18nPlaceholder(startIdx + idx, contextId);
                updatePlaceholderMap(placeholders, child.name, content);
            });
        }
        return placeholders;
    }
    /**
     * Format the placeholder names in a map of placeholders to expressions.
     *
     * The placeholder names are converted from "internal" format (e.g. `START_TAG_DIV_1`) to "external"
     * format (e.g. `startTagDiv_1`).
     *
     * @param params A map of placeholder names to expressions.
     * @param useCamelCase whether to camelCase the placeholder name when formatting.
     * @returns A new map of formatted placeholder names to expressions.
     */
    function i18nFormatPlaceholderNames(params = {}, useCamelCase) {
        const _params = {};
        if (params && Object.keys(params).length) {
            Object.keys(params).forEach(key => _params[formatI18nPlaceholderName(key, useCamelCase)] = params[key]);
        }
        return _params;
    }
    /**
     * Converts internal placeholder names to public-facing format
     * (for example to use in goog.getMsg call).
     * Example: `START_TAG_DIV_1` is converted to `startTagDiv_1`.
     *
     * @param name The placeholder name that should be formatted
     * @returns Formatted placeholder name
     */
    function formatI18nPlaceholderName(name, useCamelCase = true) {
        const publicName = toPublicName(name);
        if (!useCamelCase) {
            return publicName;
        }
        const chunks = publicName.split('_');
        if (chunks.length === 1) {
            // if no "_" found - just lowercase the value
            return name.toLowerCase();
        }
        let postfix;
        // eject last element if it's a number
        if (/^\d+$/.test(chunks[chunks.length - 1])) {
            postfix = chunks.pop();
        }
        let raw = chunks.shift().toLowerCase();
        if (chunks.length) {
            raw += chunks.map(c => c.charAt(0).toUpperCase() + c.slice(1).toLowerCase()).join('');
        }
        return postfix ? `${raw}_${postfix}` : raw;
    }
    /**
     * Generates a prefix for translation const name.
     *
     * @param extra Additional local prefix that should be injected into translation var name
     * @returns Complete translation const prefix
     */
    function getTranslationConstPrefix(extra) {
        return `${CLOSURE_TRANSLATION_VAR_PREFIX}${extra}`.toUpperCase();
    }
    /**
     * Generate AST to declare a variable. E.g. `var I18N_1;`.
     * @param variable the name of the variable to declare.
     */
    function declareI18nVariable(variable) {
        return new DeclareVarStmt(variable.name, undefined, INFERRED_TYPE, undefined, variable.sourceSpan);
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Checks whether an object key contains potentially unsafe chars, thus the key should be wrapped in
     * quotes. Note: we do not wrap all keys into quotes, as it may have impact on minification and may
     * bot work in some cases when object keys are mangled by minifier.
     *
     * TODO(FW-1136): this is a temporary solution, we need to come up with a better way of working with
     * inputs that contain potentially unsafe chars.
     */
    const UNSAFE_OBJECT_KEY_NAME_REGEXP = /[-.]/;
    /** Name of the temporary to use during data binding */
    const TEMPORARY_NAME = '_t';
    /** Name of the context parameter passed into a template function */
    const CONTEXT_NAME = 'ctx';
    /** Name of the RenderFlag passed into a template function */
    const RENDER_FLAGS = 'rf';
    /** The prefix reference variables */
    const REFERENCE_PREFIX = '_r';
    /** The name of the implicit context reference */
    const IMPLICIT_REFERENCE = '$implicit';
    /** Non bindable attribute name **/
    const NON_BINDABLE_ATTR = 'ngNonBindable';
    /** Name for the variable keeping track of the context returned by `ÉµÉµrestoreView`. */
    const RESTORED_VIEW_CONTEXT_NAME = 'restoredCtx';
    /**
     * Creates an allocator for a temporary variable.
     *
     * A variable declaration is added to the statements the first time the allocator is invoked.
     */
    function temporaryAllocator(statements, name) {
        let temp = null;
        return () => {
            if (!temp) {
                statements.push(new DeclareVarStmt(TEMPORARY_NAME, undefined, DYNAMIC_TYPE));
                temp = variable(name);
            }
            return temp;
        };
    }
    function unsupported(feature) {
        if (this) {
            throw new Error(`Builder ${this.constructor.name} doesn't support ${feature} yet`);
        }
        throw new Error(`Feature ${feature} is not supported yet`);
    }
    function invalid$1(arg) {
        throw new Error(`Invalid state: Visitor ${this.constructor.name} doesn't handle ${arg.constructor.name}`);
    }
    function asLiteral(value) {
        if (Array.isArray(value)) {
            return literalArr(value.map(asLiteral));
        }
        return literal(value, INFERRED_TYPE);
    }
    function conditionallyCreateMapObjectLiteral(keys, keepDeclared) {
        if (Object.getOwnPropertyNames(keys).length > 0) {
            return mapToExpression(keys, keepDeclared);
        }
        return null;
    }
    function mapToExpression(map, keepDeclared) {
        return literalMap(Object.getOwnPropertyNames(map).map(key => {
            // canonical syntax: `dirProp: publicProp`
            // if there is no `:`, use dirProp = elProp
            const value = map[key];
            let declaredName;
            let publicName;
            let minifiedName;
            let needsDeclaredName;
            if (Array.isArray(value)) {
                [publicName, declaredName] = value;
                minifiedName = key;
                needsDeclaredName = publicName !== declaredName;
            }
            else {
                [declaredName, publicName] = splitAtColon(key, [key, value]);
                minifiedName = declaredName;
                // Only include the declared name if extracted from the key, i.e. the key contains a colon.
                // Otherwise the declared name should be omitted even if it is different from the public name,
                // as it may have already been minified.
                needsDeclaredName = publicName !== declaredName && key.includes(':');
            }
            return {
                key: minifiedName,
                // put quotes around keys that contain potentially unsafe characters
                quoted: UNSAFE_OBJECT_KEY_NAME_REGEXP.test(minifiedName),
                value: (keepDeclared && needsDeclaredName) ?
                    literalArr([asLiteral(publicName), asLiteral(declaredName)]) :
                    asLiteral(publicName)
            };
        }));
    }
    /**
     *  Remove trailing null nodes as they are implied.
     */
    function trimTrailingNulls(parameters) {
        while (isNull(parameters[parameters.length - 1])) {
            parameters.pop();
        }
        return parameters;
    }
    function getQueryPredicate(query, constantPool) {
        if (Array.isArray(query.predicate)) {
            let predicate = [];
            query.predicate.forEach((selector) => {
                // Each item in predicates array may contain strings with comma-separated refs
                // (for ex. 'ref, ref1, ..., refN'), thus we extract individual refs and store them
                // as separate array entities
                const selectors = selector.split(',').map(token => literal(token.trim()));
                predicate.push(...selectors);
            });
            return constantPool.getConstLiteral(literalArr(predicate), true);
        }
        else {
            return query.predicate;
        }
    }
    /**
     * A representation for an object literal used during codegen of definition objects. The generic
     * type `T` allows to reference a documented type of the generated structure, such that the
     * property names that are set can be resolved to their documented declaration.
     */
    class DefinitionMap {
        constructor() {
            this.values = [];
        }
        set(key, value) {
            if (value) {
                this.values.push({ key: key, value, quoted: false });
            }
        }
        toLiteralMap() {
            return literalMap(this.values);
        }
    }
    /**
     * Extract a map of properties to values for a given element or template node, which can be used
     * by the directive matching machinery.
     *
     * @param elOrTpl the element or template in question
     * @return an object set up for directive matching. For attributes on the element/template, this
     * object maps a property name to its (static) value. For any bindings, this map simply maps the
     * property name to an empty string.
     */
    function getAttrsForDirectiveMatching(elOrTpl) {
        const attributesMap = {};
        if (elOrTpl instanceof Template && elOrTpl.tagName !== 'ng-template') {
            elOrTpl.templateAttrs.forEach(a => attributesMap[a.name] = '');
        }
        else {
            elOrTpl.attributes.forEach(a => {
                if (!isI18nAttribute(a.name)) {
                    attributesMap[a.name] = a.value;
                }
            });
            elOrTpl.inputs.forEach(i => {
                attributesMap[i.name] = '';
            });
            elOrTpl.outputs.forEach(o => {
                attributesMap[o.name] = '';
            });
        }
        return attributesMap;
    }
    /** Returns a call expression to a chained instruction, e.g. `property(params[0])(params[1])`. */
    function chainedInstruction(reference, calls, span) {
        let expression = importExpr(reference, null, span);
        if (calls.length > 0) {
            for (let i = 0; i < calls.length; i++) {
                expression = expression.callFn(calls[i], span);
            }
        }
        else {
            // Add a blank invocation, in case the `calls` array is empty.
            expression = expression.callFn([], span);
        }
        return expression;
    }
    /**
     * Gets the number of arguments expected to be passed to a generated instruction in the case of
     * interpolation instructions.
     * @param interpolation An interpolation ast
     */
    function getInterpolationArgsLength(interpolation) {
        const { expressions, strings } = interpolation;
        if (expressions.length === 1 && strings.length === 2 && strings[0] === '' && strings[1] === '') {
            // If the interpolation has one interpolated value, but the prefix and suffix are both empty
            // strings, we only pass one argument, to a special instruction like `propertyInterpolate` or
            // `textInterpolate`.
            return 1;
        }
        else {
            return expressions.length + strings.length;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Generate an expression that has the given `expr` wrapped in the following form:
     *
     * ```
     * forwardRef(() => expr)
     * ```
     */
    function generateForwardRef(expr) {
        return importExpr(Identifiers.forwardRef).callFn([fn([], [new ReturnStatement(expr)])]);
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    // https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit
    const VERSION = 3;
    const JS_B64_PREFIX = '# sourceMappingURL=data:application/json;base64,';
    class SourceMapGenerator {
        constructor(file = null) {
            this.file = file;
            this.sourcesContent = new Map();
            this.lines = [];
            this.lastCol0 = 0;
            this.hasMappings = false;
        }
        // The content is `null` when the content is expected to be loaded using the URL
        addSource(url, content = null) {
            if (!this.sourcesContent.has(url)) {
                this.sourcesContent.set(url, content);
            }
            return this;
        }
        addLine() {
            this.lines.push([]);
            this.lastCol0 = 0;
            return this;
        }
        addMapping(col0, sourceUrl, sourceLine0, sourceCol0) {
            if (!this.currentLine) {
                throw new Error(`A line must be added before mappings can be added`);
            }
            if (sourceUrl != null && !this.sourcesContent.has(sourceUrl)) {
                throw new Error(`Unknown source file "${sourceUrl}"`);
            }
            if (col0 == null) {
                throw new Error(`The column in the generated code must be provided`);
            }
            if (col0 < this.lastCol0) {
                throw new Error(`Mapping should be added in output order`);
            }
            if (sourceUrl && (sourceLine0 == null || sourceCol0 == null)) {
                throw new Error(`The source location must be provided when a source url is provided`);
            }
            this.hasMappings = true;
            this.lastCol0 = col0;
            this.currentLine.push({ col0, sourceUrl, sourceLine0, sourceCol0 });
            return this;
        }
        /**
         * @internal strip this from published d.ts files due to
         * https://github.com/microsoft/TypeScript/issues/36216
         */
        get currentLine() {
            return this.lines.slice(-1)[0];
        }
        toJSON() {
            if (!this.hasMappings) {
                return null;
            }
            const sourcesIndex = new Map();
            const sources = [];
            const sourcesContent = [];
            Array.from(this.sourcesContent.keys()).forEach((url, i) => {
                sourcesIndex.set(url, i);
                sources.push(url);
                sourcesContent.push(this.sourcesContent.get(url) || null);
            });
            let mappings = '';
            let lastCol0 = 0;
            let lastSourceIndex = 0;
            let lastSourceLine0 = 0;
            let lastSourceCol0 = 0;
            this.lines.forEach(segments => {
                lastCol0 = 0;
                mappings += segments
                    .map(segment => {
                    // zero-based starting column of the line in the generated code
                    let segAsStr = toBase64VLQ(segment.col0 - lastCol0);
                    lastCol0 = segment.col0;
                    if (segment.sourceUrl != null) {
                        // zero-based index into the âsourcesâ list
                        segAsStr +=
                            toBase64VLQ(sourcesIndex.get(segment.sourceUrl) - lastSourceIndex);
                        lastSourceIndex = sourcesIndex.get(segment.sourceUrl);
                        // the zero-based starting line in the original source
                        segAsStr += toBase64VLQ(segment.sourceLine0 - lastSourceLine0);
                        lastSourceLine0 = segment.sourceLine0;
                        // the zero-based starting column in the original source
                        segAsStr += toBase64VLQ(segment.sourceCol0 - lastSourceCol0);
                        lastSourceCol0 = segment.sourceCol0;
                    }
                    return segAsStr;
                })
                    .join(',');
                mappings += ';';
            });
            mappings = mappings.slice(0, -1);
            return {
                'file': this.file || '',
                'version': VERSION,
                'sourceRoot': '',
                'sources': sources,
                'sourcesContent': sourcesContent,
                'mappings': mappings,
            };
        }
        toJsComment() {
            return this.hasMappings ? '//' + JS_B64_PREFIX + toBase64String(JSON.stringify(this, null, 0)) :
                '';
        }
    }
    function toBase64String(value) {
        let b64 = '';
        const encoded = utf8Encode(value);
        for (let i = 0; i < encoded.length;) {
            const i1 = encoded[i++];
            const i2 = i < encoded.length ? encoded[i++] : null;
            const i3 = i < encoded.length ? encoded[i++] : null;
            b64 += toBase64Digit(i1 >> 2);
            b64 += toBase64Digit(((i1 & 3) << 4) | (i2 === null ? 0 : i2 >> 4));
            b64 += i2 === null ? '=' : toBase64Digit(((i2 & 15) << 2) | (i3 === null ? 0 : i3 >> 6));
            b64 += i2 === null || i3 === null ? '=' : toBase64Digit(i3 & 63);
        }
        return b64;
    }
    function toBase64VLQ(value) {
        value = value < 0 ? ((-value) << 1) + 1 : value << 1;
        let out = '';
        do {
            let digit = value & 31;
            value = value >> 5;
            if (value > 0) {
                digit = digit | 32;
            }
            out += toBase64Digit(digit);
        } while (value > 0);
        return out;
    }
    const B64_DIGITS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    function toBase64Digit(value) {
        if (value < 0 || value >= 64) {
            throw new Error(`Can only encode value in the range [0, 63]`);
        }
        return B64_DIGITS[value];
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const _SINGLE_QUOTE_ESCAPE_STRING_RE = /'|\\|\n|\r|\$/g;
    const _LEGAL_IDENTIFIER_RE = /^[$A-Z_][0-9A-Z_$]*$/i;
    const _INDENT_WITH = '  ';
    const CATCH_ERROR_VAR$1 = variable('error', null, null);
    const CATCH_STACK_VAR$1 = variable('stack', null, null);
    class _EmittedLine {
        constructor(indent) {
            this.indent = indent;
            this.partsLength = 0;
            this.parts = [];
            this.srcSpans = [];
        }
    }
    class EmitterVisitorContext {
        constructor(_indent) {
            this._indent = _indent;
            this._classes = [];
            this._preambleLineCount = 0;
            this._lines = [new _EmittedLine(_indent)];
        }
        static createRoot() {
            return new EmitterVisitorContext(0);
        }
        /**
         * @internal strip this from published d.ts files due to
         * https://github.com/microsoft/TypeScript/issues/36216
         */
        get _currentLine() {
            return this._lines[this._lines.length - 1];
        }
        println(from, lastPart = '') {
            this.print(from || null, lastPart, true);
        }
        lineIsEmpty() {
            return this._currentLine.parts.length === 0;
        }
        lineLength() {
            return this._currentLine.indent * _INDENT_WITH.length + this._currentLine.partsLength;
        }
        print(from, part, newLine = false) {
            if (part.length > 0) {
                this._currentLine.parts.push(part);
                this._currentLine.partsLength += part.length;
                this._currentLine.srcSpans.push(from && from.sourceSpan || null);
            }
            if (newLine) {
                this._lines.push(new _EmittedLine(this._indent));
            }
        }
        removeEmptyLastLine() {
            if (this.lineIsEmpty()) {
                this._lines.pop();
            }
        }
        incIndent() {
            this._indent++;
            if (this.lineIsEmpty()) {
                this._currentLine.indent = this._indent;
            }
        }
        decIndent() {
            this._indent--;
            if (this.lineIsEmpty()) {
                this._currentLine.indent = this._indent;
            }
        }
        pushClass(clazz) {
            this._classes.push(clazz);
        }
        popClass() {
            return this._classes.pop();
        }
        get currentClass() {
            return this._classes.length > 0 ? this._classes[this._classes.length - 1] : null;
        }
        toSource() {
            return this.sourceLines
                .map(l => l.parts.length > 0 ? _createIndent(l.indent) + l.parts.join('') : '')
                .join('\n');
        }
        toSourceMapGenerator(genFilePath, startsAtLine = 0) {
            const map = new SourceMapGenerator(genFilePath);
            let firstOffsetMapped = false;
            const mapFirstOffsetIfNeeded = () => {
                if (!firstOffsetMapped) {
                    // Add a single space so that tools won't try to load the file from disk.
                    // Note: We are using virtual urls like `ng:///`, so we have to
                    // provide a content here.
                    map.addSource(genFilePath, ' ').addMapping(0, genFilePath, 0, 0);
                    firstOffsetMapped = true;
                }
            };
            for (let i = 0; i < startsAtLine; i++) {
                map.addLine();
                mapFirstOffsetIfNeeded();
            }
            this.sourceLines.forEach((line, lineIdx) => {
                map.addLine();
                const spans = line.srcSpans;
                const parts = line.parts;
                let col0 = line.indent * _INDENT_WITH.length;
                let spanIdx = 0;
                // skip leading parts without source spans
                while (spanIdx < spans.length && !spans[spanIdx]) {
                    col0 += parts[spanIdx].length;
                    spanIdx++;
                }
                if (spanIdx < spans.length && lineIdx === 0 && col0 === 0) {
                    firstOffsetMapped = true;
                }
                else {
                    mapFirstOffsetIfNeeded();
                }
                while (spanIdx < spans.length) {
                    const span = spans[spanIdx];
                    const source = span.start.file;
                    const sourceLine = span.start.line;
                    const sourceCol = span.start.col;
                    map.addSource(source.url, source.content)
                        .addMapping(col0, source.url, sourceLine, sourceCol);
                    col0 += parts[spanIdx].length;
                    spanIdx++;
                    // assign parts without span or the same span to the previous segment
                    while (spanIdx < spans.length && (span === spans[spanIdx] || !spans[spanIdx])) {
                        col0 += parts[spanIdx].length;
                        spanIdx++;
                    }
                }
            });
            return map;
        }
        setPreambleLineCount(count) {
            return this._preambleLineCount = count;
        }
        spanOf(line, column) {
            const emittedLine = this._lines[line - this._preambleLineCount];
            if (emittedLine) {
                let columnsLeft = column - _createIndent(emittedLine.indent).length;
                for (let partIndex = 0; partIndex < emittedLine.parts.length; partIndex++) {
                    const part = emittedLine.parts[partIndex];
                    if (part.length > columnsLeft) {
                        return emittedLine.srcSpans[partIndex];
                    }
                    columnsLeft -= part.length;
                }
            }
            return null;
        }
        /**
         * @internal strip this from published d.ts files due to
         * https://github.com/microsoft/TypeScript/issues/36216
         */
        get sourceLines() {
            if (this._lines.length && this._lines[this._lines.length - 1].parts.length === 0) {
                return this._lines.slice(0, -1);
            }
            return this._lines;
        }
    }
    class AbstractEmitterVisitor {
        constructor(_escapeDollarInStrings) {
            this._escapeDollarInStrings = _escapeDollarInStrings;
        }
        printLeadingComments(stmt, ctx) {
            if (stmt.leadingComments === undefined) {
                return;
            }
            for (const comment of stmt.leadingComments) {
                if (comment instanceof JSDocComment) {
                    ctx.print(stmt, `/*${comment.toString()}*/`, comment.trailingNewline);
                }
                else {
                    if (comment.multiline) {
                        ctx.print(stmt, `/* ${comment.text} */`, comment.trailingNewline);
                    }
                    else {
                        comment.text.split('\n').forEach((line) => {
                            ctx.println(stmt, `// ${line}`);
                        });
                    }
                }
            }
        }
        visitExpressionStmt(stmt, ctx) {
            this.printLeadingComments(stmt, ctx);
            stmt.expr.visitExpression(this, ctx);
            ctx.println(stmt, ';');
            return null;
        }
        visitReturnStmt(stmt, ctx) {
            this.printLeadingComments(stmt, ctx);
            ctx.print(stmt, `return `);
            stmt.value.visitExpression(this, ctx);
            ctx.println(stmt, ';');
            return null;
        }
        visitIfStmt(stmt, ctx) {
            this.printLeadingComments(stmt, ctx);
            ctx.print(stmt, `if (`);
            stmt.condition.visitExpression(this, ctx);
            ctx.print(stmt, `) {`);
            const hasElseCase = stmt.falseCase != null && stmt.falseCase.length > 0;
            if (stmt.trueCase.length <= 1 && !hasElseCase) {
                ctx.print(stmt, ` `);
                this.visitAllStatements(stmt.trueCase, ctx);
                ctx.removeEmptyLastLine();
                ctx.print(stmt, ` `);
            }
            else {
                ctx.println();
                ctx.incIndent();
                this.visitAllStatements(stmt.trueCase, ctx);
                ctx.decIndent();
                if (hasElseCase) {
                    ctx.println(stmt, `} else {`);
                    ctx.incIndent();
                    this.visitAllStatements(stmt.falseCase, ctx);
                    ctx.decIndent();
                }
            }
            ctx.println(stmt, `}`);
            return null;
        }
        visitThrowStmt(stmt, ctx) {
            this.printLeadingComments(stmt, ctx);
            ctx.print(stmt, `throw `);
            stmt.error.visitExpression(this, ctx);
            ctx.println(stmt, `;`);
            return null;
        }
        visitWriteVarExpr(expr, ctx) {
            const lineWasEmpty = ctx.lineIsEmpty();
            if (!lineWasEmpty) {
                ctx.print(expr, '(');
            }
            ctx.print(expr, `${expr.name} = `);
            expr.value.visitExpression(this, ctx);
            if (!lineWasEmpty) {
                ctx.print(expr, ')');
            }
            return null;
        }
        visitWriteKeyExpr(expr, ctx) {
            const lineWasEmpty = ctx.lineIsEmpty();
            if (!lineWasEmpty) {
                ctx.print(expr, '(');
            }
            expr.receiver.visitExpression(this, ctx);
            ctx.print(expr, `[`);
            expr.index.visitExpression(this, ctx);
            ctx.print(expr, `] = `);
            expr.value.visitExpression(this, ctx);
            if (!lineWasEmpty) {
                ctx.print(expr, ')');
            }
            return null;
        }
        visitWritePropExpr(expr, ctx) {
            const lineWasEmpty = ctx.lineIsEmpty();
            if (!lineWasEmpty) {
                ctx.print(expr, '(');
            }
            expr.receiver.visitExpression(this, ctx);
            ctx.print(expr, `.${expr.name} = `);
            expr.value.visitExpression(this, ctx);
            if (!lineWasEmpty) {
                ctx.print(expr, ')');
            }
            return null;
        }
        visitInvokeMethodExpr(expr, ctx) {
            expr.receiver.visitExpression(this, ctx);
            let name = expr.name;
            if (expr.builtin != null) {
                name = this.getBuiltinMethodName(expr.builtin);
                if (name == null) {
                    // some builtins just mean to skip the call.
                    return null;
                }
            }
            ctx.print(expr, `.${name}(`);
            this.visitAllExpressions(expr.args, ctx, `,`);
            ctx.print(expr, `)`);
            return null;
        }
        visitInvokeFunctionExpr(expr, ctx) {
            expr.fn.visitExpression(this, ctx);
            ctx.print(expr, `(`);
            this.visitAllExpressions(expr.args, ctx, ',');
            ctx.print(expr, `)`);
            return null;
        }
        visitTaggedTemplateExpr(expr, ctx) {
            expr.tag.visitExpression(this, ctx);
            ctx.print(expr, '`' + expr.template.elements[0].rawText);
            for (let i = 1; i < expr.template.elements.length; i++) {
                ctx.print(expr, '${');
                expr.template.expressions[i - 1].visitExpression(this, ctx);
                ctx.print(expr, `}${expr.template.elements[i].rawText}`);
            }
            ctx.print(expr, '`');
            return null;
        }
        visitWrappedNodeExpr(ast, ctx) {
            throw new Error('Abstract emitter cannot visit WrappedNodeExpr.');
        }
        visitTypeofExpr(expr, ctx) {
            ctx.print(expr, 'typeof ');
            expr.expr.visitExpression(this, ctx);
        }
        visitReadVarExpr(ast, ctx) {
            let varName = ast.name;
            if (ast.builtin != null) {
                switch (ast.builtin) {
                    case BuiltinVar.Super:
                        varName = 'super';
                        break;
                    case BuiltinVar.This:
                        varName = 'this';
                        break;
                    case BuiltinVar.CatchError:
                        varName = CATCH_ERROR_VAR$1.name;
                        break;
                    case BuiltinVar.CatchStack:
                        varName = CATCH_STACK_VAR$1.name;
                        break;
                    default:
                        throw new Error(`Unknown builtin variable ${ast.builtin}`);
                }
            }
            ctx.print(ast, varName);
            return null;
        }
        visitInstantiateExpr(ast, ctx) {
            ctx.print(ast, `new `);
            ast.classExpr.visitExpression(this, ctx);
            ctx.print(ast, `(`);
            this.visitAllExpressions(ast.args, ctx, ',');
            ctx.print(ast, `)`);
            return null;
        }
        visitLiteralExpr(ast, ctx) {
            const value = ast.value;
            if (typeof value === 'string') {
                ctx.print(ast, escapeIdentifier(value, this._escapeDollarInStrings));
            }
            else {
                ctx.print(ast, `${value}`);
            }
            return null;
        }
        visitLocalizedString(ast, ctx) {
            const head = ast.serializeI18nHead();
            ctx.print(ast, '$localize `' + head.raw);
            for (let i = 1; i < ast.messageParts.length; i++) {
                ctx.print(ast, '${');
                ast.expressions[i - 1].visitExpression(this, ctx);
                ctx.print(ast, `}${ast.serializeI18nTemplatePart(i).raw}`);
            }
            ctx.print(ast, '`');
            return null;
        }
        visitConditionalExpr(ast, ctx) {
            ctx.print(ast, `(`);
            ast.condition.visitExpression(this, ctx);
            ctx.print(ast, '? ');
            ast.trueCase.visitExpression(this, ctx);
            ctx.print(ast, ': ');
            ast.falseCase.visitExpression(this, ctx);
            ctx.print(ast, `)`);
            return null;
        }
        visitNotExpr(ast, ctx) {
            ctx.print(ast, '!');
            ast.condition.visitExpression(this, ctx);
            return null;
        }
        visitAssertNotNullExpr(ast, ctx) {
            ast.condition.visitExpression(this, ctx);
            return null;
        }
        visitUnaryOperatorExpr(ast, ctx) {
            let opStr;
            switch (ast.operator) {
                case UnaryOperator.Plus:
                    opStr = '+';
                    break;
                case UnaryOperator.Minus:
                    opStr = '-';
                    break;
                default:
                    throw new Error(`Unknown operator ${ast.operator}`);
            }
            if (ast.parens)
                ctx.print(ast, `(`);
            ctx.print(ast, opStr);
            ast.expr.visitExpression(this, ctx);
            if (ast.parens)
                ctx.print(ast, `)`);
            return null;
        }
        visitBinaryOperatorExpr(ast, ctx) {
            let opStr;
            switch (ast.operator) {
                case BinaryOperator.Equals:
                    opStr = '==';
                    break;
                case BinaryOperator.Identical:
                    opStr = '===';
                    break;
                case BinaryOperator.NotEquals:
                    opStr = '!=';
                    break;
                case BinaryOperator.NotIdentical:
                    opStr = '!==';
                    break;
                case BinaryOperator.And:
                    opStr = '&&';
                    break;
                case BinaryOperator.BitwiseAnd:
                    opStr = '&';
                    break;
                case BinaryOperator.Or:
                    opStr = '||';
                    break;
                case BinaryOperator.Plus:
                    opStr = '+';
                    break;
                case BinaryOperator.Minus:
                    opStr = '-';
                    break;
                case BinaryOperator.Divide:
                    opStr = '/';
                    break;
                case BinaryOperator.Multiply:
                    opStr = '*';
                    break;
                case BinaryOperator.Modulo:
                    opStr = '%';
                    break;
                case BinaryOperator.Lower:
                    opStr = '<';
                    break;
                case BinaryOperator.LowerEquals:
                    opStr = '<=';
                    break;
                case BinaryOperator.Bigger:
                    opStr = '>';
                    break;
                case BinaryOperator.BiggerEquals:
                    opStr = '>=';
                    break;
                case BinaryOperator.NullishCoalesce:
                    opStr = '??';
                    break;
                default:
                    throw new Error(`Unknown operator ${ast.operator}`);
            }
            if (ast.parens)
                ctx.print(ast, `(`);
            ast.lhs.visitExpression(this, ctx);
            ctx.print(ast, ` ${opStr} `);
            ast.rhs.visitExpression(this, ctx);
            if (ast.parens)
                ctx.print(ast, `)`);
            return null;
        }
        visitReadPropExpr(ast, ctx) {
            ast.receiver.visitExpression(this, ctx);
            ctx.print(ast, `.`);
            ctx.print(ast, ast.name);
            return null;
        }
        visitReadKeyExpr(ast, ctx) {
            ast.receiver.visitExpression(this, ctx);
            ctx.print(ast, `[`);
            ast.index.visitExpression(this, ctx);
            ctx.print(ast, `]`);
            return null;
        }
        visitLiteralArrayExpr(ast, ctx) {
            ctx.print(ast, `[`);
            this.visitAllExpressions(ast.entries, ctx, ',');
            ctx.print(ast, `]`);
            return null;
        }
        visitLiteralMapExpr(ast, ctx) {
            ctx.print(ast, `{`);
            this.visitAllObjects(entry => {
                ctx.print(ast, `${escapeIdentifier(entry.key, this._escapeDollarInStrings, entry.quoted)}:`);
                entry.value.visitExpression(this, ctx);
            }, ast.entries, ctx, ',');
            ctx.print(ast, `}`);
            return null;
        }
        visitCommaExpr(ast, ctx) {
            ctx.print(ast, '(');
            this.visitAllExpressions(ast.parts, ctx, ',');
            ctx.print(ast, ')');
            return null;
        }
        visitAllExpressions(expressions, ctx, separator) {
            this.visitAllObjects(expr => expr.visitExpression(this, ctx), expressions, ctx, separator);
        }
        visitAllObjects(handler, expressions, ctx, separator) {
            let incrementedIndent = false;
            for (let i = 0; i < expressions.length; i++) {
                if (i > 0) {
                    if (ctx.lineLength() > 80) {
                        ctx.print(null, separator, true);
                        if (!incrementedIndent) {
                            // continuation are marked with double indent.
                            ctx.incIndent();
                            ctx.incIndent();
                            incrementedIndent = true;
                        }
                    }
                    else {
                        ctx.print(null, separator, false);
                    }
                }
                handler(expressions[i]);
            }
            if (incrementedIndent) {
                // continuation are marked with double indent.
                ctx.decIndent();
                ctx.decIndent();
            }
        }
        visitAllStatements(statements, ctx) {
            statements.forEach((stmt) => stmt.visitStatement(this, ctx));
        }
    }
    function escapeIdentifier(input, escapeDollar, alwaysQuote = true) {
        if (input == null) {
            return null;
        }
        const body = input.replace(_SINGLE_QUOTE_ESCAPE_STRING_RE, (...match) => {
            if (match[0] == '$') {
                return escapeDollar ? '\\$' : '$';
            }
            else if (match[0] == '\n') {
                return '\\n';
            }
            else if (match[0] == '\r') {
                return '\\r';
            }
            else {
                return `\\${match[0]}`;
            }
        });
        const requiresQuotes = alwaysQuote || !_LEGAL_IDENTIFIER_RE.test(body);
        return requiresQuotes ? `'${body}'` : body;
    }
    function _createIndent(count) {
        let res = '';
        for (let i = 0; i < count; i++) {
            res += _INDENT_WITH;
        }
        return res;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function typeWithParameters(type, numParams) {
        if (numParams === 0) {
            return expressionType(type);
        }
        const params = [];
        for (let i = 0; i < numParams; i++) {
            params.push(DYNAMIC_TYPE);
        }
        return expressionType(type, undefined, params);
    }
    const ANIMATE_SYMBOL_PREFIX = '@';
    function prepareSyntheticPropertyName(name) {
        return `${ANIMATE_SYMBOL_PREFIX}${name}`;
    }
    function prepareSyntheticListenerName(name, phase) {
        return `${ANIMATE_SYMBOL_PREFIX}${name}.${phase}`;
    }
    function getSafePropertyAccessString(accessor, name) {
        const escapedName = escapeIdentifier(name, false, false);
        return escapedName !== name ? `${accessor}[${escapedName}]` : `${accessor}.${name}`;
    }
    function prepareSyntheticListenerFunctionName(name, phase) {
        return `animation_${name}_${phase}`;
    }
    function jitOnlyGuardedExpression(expr) {
        return guardedExpression('ngJitMode', expr);
    }
    function guardedExpression(guard, expr) {
        const guardExpr = new ExternalExpr({ name: guard, moduleName: null });
        const guardNotDefined = new BinaryOperatorExpr(BinaryOperator.Identical, new TypeofExpr(guardExpr), literal('undefined'));
        const guardUndefinedOrTrue = new BinaryOperatorExpr(BinaryOperator.Or, guardNotDefined, guardExpr, /* type */ undefined, 
        /* sourceSpan */ undefined, true);
        return new BinaryOperatorExpr(BinaryOperator.And, guardUndefinedOrTrue, expr);
    }
    function wrapReference(value) {
        const wrapped = new WrappedNodeExpr(value);
        return { value: wrapped, type: wrapped };
    }
    function refsToArray(refs, shouldForwardDeclare) {
        const values = literalArr(refs.map(ref => ref.value));
        return shouldForwardDeclare ? fn([], [new ReturnStatement(values)]) : values;
    }

    var R3FactoryDelegateType;
    (function (R3FactoryDelegateType) {
        R3FactoryDelegateType[R3FactoryDelegateType["Class"] = 0] = "Class";
        R3FactoryDelegateType[R3FactoryDelegateType["Function"] = 1] = "Function";
    })(R3FactoryDelegateType || (R3FactoryDelegateType = {}));
    var FactoryTarget;
    (function (FactoryTarget) {
        FactoryTarget[FactoryTarget["Directive"] = 0] = "Directive";
        FactoryTarget[FactoryTarget["Component"] = 1] = "Component";
        FactoryTarget[FactoryTarget["Injectable"] = 2] = "Injectable";
        FactoryTarget[FactoryTarget["Pipe"] = 3] = "Pipe";
        FactoryTarget[FactoryTarget["NgModule"] = 4] = "NgModule";
    })(FactoryTarget || (FactoryTarget = {}));
    /**
     * Construct a factory function expression for the given `R3FactoryMetadata`.
     */
    function compileFactoryFunction(meta) {
        const t = variable('t');
        let baseFactoryVar = null;
        // The type to instantiate via constructor invocation. If there is no delegated factory, meaning
        // this type is always created by constructor invocation, then this is the type-to-create
        // parameter provided by the user (t) if specified, or the current type if not. If there is a
        // delegated factory (which is used to create the current type) then this is only the type-to-
        // create parameter (t).
        const typeForCtor = !isDelegatedFactoryMetadata(meta) ?
            new BinaryOperatorExpr(BinaryOperator.Or, t, meta.internalType) :
            t;
        let ctorExpr = null;
        if (meta.deps !== null) {
            // There is a constructor (either explicitly or implicitly defined).
            if (meta.deps !== 'invalid') {
                ctorExpr = new InstantiateExpr(typeForCtor, injectDependencies(meta.deps, meta.target));
            }
        }
        else {
            // There is no constructor, use the base class' factory to construct typeForCtor.
            baseFactoryVar = variable(`Éµ${meta.name}_BaseFactory`);
            ctorExpr = baseFactoryVar.callFn([typeForCtor]);
        }
        const body = [];
        let retExpr = null;
        function makeConditionalFactory(nonCtorExpr) {
            const r = variable('r');
            body.push(r.set(NULL_EXPR).toDeclStmt());
            const ctorStmt = ctorExpr !== null ? r.set(ctorExpr).toStmt() :
                importExpr(Identifiers.invalidFactory).callFn([]).toStmt();
            body.push(ifStmt(t, [ctorStmt], [r.set(nonCtorExpr).toStmt()]));
            return r;
        }
        if (isDelegatedFactoryMetadata(meta)) {
            // This type is created with a delegated factory. If a type parameter is not specified, call
            // the factory instead.
            const delegateArgs = injectDependencies(meta.delegateDeps, meta.target);
            // Either call `new delegate(...)` or `delegate(...)` depending on meta.delegateType.
            const factoryExpr = new (meta.delegateType === R3FactoryDelegateType.Class ?
                InstantiateExpr :
                InvokeFunctionExpr)(meta.delegate, delegateArgs);
            retExpr = makeConditionalFactory(factoryExpr);
        }
        else if (isExpressionFactoryMetadata(meta)) {
            // TODO(alxhub): decide whether to lower the value here or in the caller
            retExpr = makeConditionalFactory(meta.expression);
        }
        else {
            retExpr = ctorExpr;
        }
        if (retExpr === null) {
            // The expression cannot be formed so render an `ÉµÉµinvalidFactory()` call.
            body.push(importExpr(Identifiers.invalidFactory).callFn([]).toStmt());
        }
        else if (baseFactoryVar !== null) {
            // This factory uses a base factory, so call `ÉµÉµgetInheritedFactory()` to compute it.
            const getInheritedFactoryCall = importExpr(Identifiers.getInheritedFactory).callFn([meta.internalType]);
            // Memoize the base factoryFn: `baseFactory || (baseFactory = ÉµÉµgetInheritedFactory(...))`
            const baseFactory = new BinaryOperatorExpr(BinaryOperator.Or, baseFactoryVar, baseFactoryVar.set(getInheritedFactoryCall));
            body.push(new ReturnStatement(baseFactory.callFn([typeForCtor])));
        }
        else {
            // This is straightforward factory, just return it.
            body.push(new ReturnStatement(retExpr));
        }
        let factoryFn = fn([new FnParam('t', DYNAMIC_TYPE)], body, INFERRED_TYPE, undefined, `${meta.name}_Factory`);
        if (baseFactoryVar !== null) {
            // There is a base factory variable so wrap its declaration along with the factory function into
            // an IIFE.
            factoryFn = fn([], [
                new DeclareVarStmt(baseFactoryVar.name), new ReturnStatement(factoryFn)
            ]).callFn([], /* sourceSpan */ undefined, /* pure */ true);
        }
        return {
            expression: factoryFn,
            statements: [],
            type: createFactoryType(meta),
        };
    }
    function createFactoryType(meta) {
        const ctorDepsType = meta.deps !== null && meta.deps !== 'invalid' ? createCtorDepsType(meta.deps) : NONE_TYPE;
        return expressionType(importExpr(Identifiers.FactoryDeclaration, [typeWithParameters(meta.type.type, meta.typeArgumentCount), ctorDepsType]));
    }
    function injectDependencies(deps, target) {
        return deps.map((dep, index) => compileInjectDependency(dep, target, index));
    }
    function compileInjectDependency(dep, target, index) {
        // Interpret the dependency according to its resolved type.
        if (dep.token === null) {
            return importExpr(Identifiers.invalidFactoryDep).callFn([literal(index)]);
        }
        else if (dep.attributeNameType === null) {
            // Build up the injection flags according to the metadata.
            const flags = 0 /* Default */ | (dep.self ? 2 /* Self */ : 0) |
                (dep.skipSelf ? 4 /* SkipSelf */ : 0) | (dep.host ? 1 /* Host */ : 0) |
                (dep.optional ? 8 /* Optional */ : 0) |
                (target === FactoryTarget.Pipe ? 16 /* ForPipe */ : 0);
            // If this dependency is optional or otherwise has non-default flags, then additional
            // parameters describing how to inject the dependency must be passed to the inject function
            // that's being used.
            let flagsParam = (flags !== 0 /* Default */ || dep.optional) ? literal(flags) : null;
            // Build up the arguments to the injectFn call.
            const injectArgs = [dep.token];
            if (flagsParam) {
                injectArgs.push(flagsParam);
            }
            const injectFn = getInjectFn(target);
            return importExpr(injectFn).callFn(injectArgs);
        }
        else {
            // The `dep.attributeTypeName` value is defined, which indicates that this is an `@Attribute()`
            // type dependency. For the generated JS we still want to use the `dep.token` value in case the
            // name given for the attribute is not a string literal. For example given `@Attribute(foo())`,
            // we want to generate `ÉµÉµinjectAttribute(foo())`.
            //
            // The `dep.attributeTypeName` is only actually used (in `createCtorDepType()`) to generate
            // typings.
            return importExpr(Identifiers.injectAttribute).callFn([dep.token]);
        }
    }
    function createCtorDepsType(deps) {
        let hasTypes = false;
        const attributeTypes = deps.map(dep => {
            const type = createCtorDepType(dep);
            if (type !== null) {
                hasTypes = true;
                return type;
            }
            else {
                return literal(null);
            }
        });
        if (hasTypes) {
            return expressionType(literalArr(attributeTypes));
        }
        else {
            return NONE_TYPE;
        }
    }
    function createCtorDepType(dep) {
        const entries = [];
        if (dep.attributeNameType !== null) {
            entries.push({ key: 'attribute', value: dep.attributeNameType, quoted: false });
        }
        if (dep.optional) {
            entries.push({ key: 'optional', value: literal(true), quoted: false });
        }
        if (dep.host) {
            entries.push({ key: 'host', value: literal(true), quoted: false });
        }
        if (dep.self) {
            entries.push({ key: 'self', value: literal(true), quoted: false });
        }
        if (dep.skipSelf) {
            entries.push({ key: 'skipSelf', value: literal(true), quoted: false });
        }
        return entries.length > 0 ? literalMap(entries) : null;
    }
    function isDelegatedFactoryMetadata(meta) {
        return meta.delegateType !== undefined;
    }
    function isExpressionFactoryMetadata(meta) {
        return meta.expression !== undefined;
    }
    function getInjectFn(target) {
        switch (target) {
            case FactoryTarget.Component:
            case FactoryTarget.Directive:
            case FactoryTarget.Pipe:
                return Identifiers.directiveInject;
            case FactoryTarget.NgModule:
            case FactoryTarget.Injectable:
            default:
                return Identifiers.inject;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function createR3ProviderExpression(expression, isForwardRef) {
        return { expression, isForwardRef };
    }
    function compileInjectable(meta, resolveForwardRefs) {
        let result = null;
        const factoryMeta = {
            name: meta.name,
            type: meta.type,
            internalType: meta.internalType,
            typeArgumentCount: meta.typeArgumentCount,
            deps: [],
            target: FactoryTarget.Injectable,
        };
        if (meta.useClass !== undefined) {
            // meta.useClass has two modes of operation. Either deps are specified, in which case `new` is
            // used to instantiate the class with dependencies injected, or deps are not specified and
            // the factory of the class is used to instantiate it.
            //
            // A special case exists for useClass: Type where Type is the injectable type itself and no
            // deps are specified, in which case 'useClass' is effectively ignored.
            const useClassOnSelf = meta.useClass.expression.isEquivalent(meta.internalType);
            let deps = undefined;
            if (meta.deps !== undefined) {
                deps = meta.deps;
            }
            if (deps !== undefined) {
                // factory: () => new meta.useClass(...deps)
                result = compileFactoryFunction(Object.assign(Object.assign({}, factoryMeta), { delegate: meta.useClass.expression, delegateDeps: deps, delegateType: R3FactoryDelegateType.Class }));
            }
            else if (useClassOnSelf) {
                result = compileFactoryFunction(factoryMeta);
            }
            else {
                result = {
                    statements: [],
                    expression: delegateToFactory(meta.type.value, meta.useClass.expression, resolveForwardRefs)
                };
            }
        }
        else if (meta.useFactory !== undefined) {
            if (meta.deps !== undefined) {
                result = compileFactoryFunction(Object.assign(Object.assign({}, factoryMeta), { delegate: meta.useFactory, delegateDeps: meta.deps || [], delegateType: R3FactoryDelegateType.Function }));
            }
            else {
                result = {
                    statements: [],
                    expression: fn([], [new ReturnStatement(meta.useFactory.callFn([]))])
                };
            }
        }
        else if (meta.useValue !== undefined) {
            // Note: it's safe to use `meta.useValue` instead of the `USE_VALUE in meta` check used for
            // client code because meta.useValue is an Expression which will be defined even if the actual
            // value is undefined.
            result = compileFactoryFunction(Object.assign(Object.assign({}, factoryMeta), { expression: meta.useValue.expression }));
        }
        else if (meta.useExisting !== undefined) {
            // useExisting is an `inject` call on the existing token.
            result = compileFactoryFunction(Object.assign(Object.assign({}, factoryMeta), { expression: importExpr(Identifiers.inject).callFn([meta.useExisting.expression]) }));
        }
        else {
            result = {
                statements: [],
                expression: delegateToFactory(meta.type.value, meta.internalType, resolveForwardRefs)
            };
        }
        const token = meta.internalType;
        const injectableProps = new DefinitionMap();
        injectableProps.set('token', token);
        injectableProps.set('factory', result.expression);
        // Only generate providedIn property if it has a non-null value
        if (meta.providedIn.expression.value !== null) {
            injectableProps.set('providedIn', meta.providedIn.isForwardRef ? generateForwardRef(meta.providedIn.expression) :
                meta.providedIn.expression);
        }
        const expression = importExpr(Identifiers.ÉµÉµdefineInjectable)
            .callFn([injectableProps.toLiteralMap()], undefined, true);
        return {
            expression,
            type: createInjectableType(meta),
            statements: result.statements,
        };
    }
    function createInjectableType(meta) {
        return new ExpressionType(importExpr(Identifiers.InjectableDeclaration, [typeWithParameters(meta.type.type, meta.typeArgumentCount)]));
    }
    function delegateToFactory(type, internalType, unwrapForwardRefs) {
        if (type.node === internalType.node) {
            // The types are the same, so we can simply delegate directly to the type's factory.
            // ```
            // factory: type.Éµfac
            // ```
            return internalType.prop('Éµfac');
        }
        if (!unwrapForwardRefs) {
            // The type is not wrapped in a `forwardRef()`, so we create a simple factory function that
            // accepts a sub-type as an argument.
            // ```
            // factory: function(t) { return internalType.Éµfac(t); }
            // ```
            return createFactoryFunction(internalType);
        }
        // The internalType is actually wrapped in a `forwardRef()` so we need to resolve that before
        // calling its factory.
        // ```
        // factory: function(t) { return core.resolveForwardRef(type).Éµfac(t); }
        // ```
        const unwrappedType = importExpr(Identifiers.resolveForwardRef).callFn([internalType]);
        return createFactoryFunction(unwrappedType);
    }
    function createFactoryFunction(type) {
        return fn([new FnParam('t', DYNAMIC_TYPE)], [new ReturnStatement(type.callMethod('Éµfac', [variable('t')]))]);
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function assertArrayOfStrings(identifier, value) {
        if (value == null) {
            return;
        }
        if (!Array.isArray(value)) {
            throw new Error(`Expected '${identifier}' to be an array of strings.`);
        }
        for (let i = 0; i < value.length; i += 1) {
            if (typeof value[i] !== 'string') {
                throw new Error(`Expected '${identifier}' to be an array of strings.`);
            }
        }
    }
    const UNUSABLE_INTERPOLATION_REGEXPS = [
        /^\s*$/,
        /[<>]/,
        /^[{}]$/,
        /&(#|[a-z])/i,
        /^\/\//, // comment
    ];
    function assertInterpolationSymbols(identifier, value) {
        if (value != null && !(Array.isArray(value) && value.length == 2)) {
            throw new Error(`Expected '${identifier}' to be an array, [start, end].`);
        }
        else if (value != null) {
            const start = value[0];
            const end = value[1];
            // Check for unusable interpolation symbols
            UNUSABLE_INTERPOLATION_REGEXPS.forEach(regexp => {
                if (regexp.test(start) || regexp.test(end)) {
                    throw new Error(`['${start}', '${end}'] contains unusable interpolation symbol.`);
                }
            });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class InterpolationConfig {
        constructor(start, end) {
            this.start = start;
            this.end = end;
        }
        static fromArray(markers) {
            if (!markers) {
                return DEFAULT_INTERPOLATION_CONFIG;
            }
            assertInterpolationSymbols('interpolation', markers);
            return new InterpolationConfig(markers[0], markers[1]);
        }
    }
    const DEFAULT_INTERPOLATION_CONFIG = new InterpolationConfig('{{', '}}');

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A token representing the a reference to a static type.
     *
     * This token is unique for a filePath and name and can be used as a hash table key.
     */
    class StaticSymbol {
        constructor(filePath, name, members) {
            this.filePath = filePath;
            this.name = name;
            this.members = members;
        }
        assertNoMembers() {
            if (this.members.length) {
                throw new Error(`Illegal state: symbol without members expected, but got ${JSON.stringify(this)}.`);
            }
        }
    }
    /**
     * A cache of static symbol used by the StaticReflector to return the same symbol for the
     * same symbol values.
     */
    class StaticSymbolCache {
        constructor() {
            this.cache = new Map();
        }
        get(declarationFile, name, members) {
            members = members || [];
            const memberSuffix = members.length ? `.${members.join('.')}` : '';
            const key = `"${declarationFile}".${name}${memberSuffix}`;
            let result = this.cache.get(key);
            if (!result) {
                result = new StaticSymbol(declarationFile, name, members);
                this.cache.set(key, result);
            }
            return result;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const $EOF = 0;
    const $BSPACE = 8;
    const $TAB = 9;
    const $LF = 10;
    const $VTAB = 11;
    const $FF = 12;
    const $CR = 13;
    const $SPACE = 32;
    const $BANG = 33;
    const $DQ = 34;
    const $HASH = 35;
    const $$ = 36;
    const $PERCENT = 37;
    const $AMPERSAND = 38;
    const $SQ = 39;
    const $LPAREN = 40;
    const $RPAREN = 41;
    const $STAR = 42;
    const $PLUS = 43;
    const $COMMA = 44;
    const $MINUS = 45;
    const $PERIOD = 46;
    const $SLASH = 47;
    const $COLON = 58;
    const $SEMICOLON = 59;
    const $LT = 60;
    const $EQ = 61;
    const $GT = 62;
    const $QUESTION = 63;
    const $0 = 48;
    const $7 = 55;
    const $9 = 57;
    const $A = 65;
    const $E = 69;
    const $F = 70;
    const $X = 88;
    const $Z = 90;
    const $LBRACKET = 91;
    const $BACKSLASH = 92;
    const $RBRACKET = 93;
    const $CARET = 94;
    const $_ = 95;
    const $a = 97;
    const $b = 98;
    const $e = 101;
    const $f = 102;
    const $n = 110;
    const $r = 114;
    const $t = 116;
    const $u = 117;
    const $v = 118;
    const $x = 120;
    const $z = 122;
    const $LBRACE = 123;
    const $BAR = 124;
    const $RBRACE = 125;
    const $NBSP = 160;
    const $BT = 96;
    function isWhitespace(code) {
        return (code >= $TAB && code <= $SPACE) || (code == $NBSP);
    }
    function isDigit(code) {
        return $0 <= code && code <= $9;
    }
    function isAsciiLetter(code) {
        return code >= $a && code <= $z || code >= $A && code <= $Z;
    }
    function isAsciiHexDigit(code) {
        return code >= $a && code <= $f || code >= $A && code <= $F || isDigit(code);
    }
    function isNewLine(code) {
        return code === $LF || code === $CR;
    }
    function isOctalDigit(code) {
        return $0 <= code && code <= $7;
    }
    function isQuote(code) {
        return code === $SQ || code === $DQ || code === $BT;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class ParseLocation {
        constructor(file, offset, line, col) {
            this.file = file;
            this.offset = offset;
            this.line = line;
            this.col = col;
        }
        toString() {
            return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;
        }
        moveBy(delta) {
            const source = this.file.content;
            const len = source.length;
            let offset = this.offset;
            let line = this.line;
            let col = this.col;
            while (offset > 0 && delta < 0) {
                offset--;
                delta++;
                const ch = source.charCodeAt(offset);
                if (ch == $LF) {
                    line--;
                    const priorLine = source.substr(0, offset - 1).lastIndexOf(String.fromCharCode($LF));
                    col = priorLine > 0 ? offset - priorLine : offset;
                }
                else {
                    col--;
                }
            }
            while (offset < len && delta > 0) {
                const ch = source.charCodeAt(offset);
                offset++;
                delta--;
                if (ch == $LF) {
                    line++;
                    col = 0;
                }
                else {
                    col++;
                }
            }
            return new ParseLocation(this.file, offset, line, col);
        }
        // Return the source around the location
        // Up to `maxChars` or `maxLines` on each side of the location
        getContext(maxChars, maxLines) {
            const content = this.file.content;
            let startOffset = this.offset;
            if (startOffset != null) {
                if (startOffset > content.length - 1) {
                    startOffset = content.length - 1;
                }
                let endOffset = startOffset;
                let ctxChars = 0;
                let ctxLines = 0;
                while (ctxChars < maxChars && startOffset > 0) {
                    startOffset--;
                    ctxChars++;
                    if (content[startOffset] == '\n') {
                        if (++ctxLines == maxLines) {
                            break;
                        }
                    }
                }
                ctxChars = 0;
                ctxLines = 0;
                while (ctxChars < maxChars && endOffset < content.length - 1) {
                    endOffset++;
                    ctxChars++;
                    if (content[endOffset] == '\n') {
                        if (++ctxLines == maxLines) {
                            break;
                        }
                    }
                }
                return {
                    before: content.substring(startOffset, this.offset),
                    after: content.substring(this.offset, endOffset + 1),
                };
            }
            return null;
        }
    }
    class ParseSourceFile {
        constructor(content, url) {
            this.content = content;
            this.url = url;
        }
    }
    class ParseSourceSpan {
        /**
         * Create an object that holds information about spans of tokens/nodes captured during
         * lexing/parsing of text.
         *
         * @param start
         * The location of the start of the span (having skipped leading trivia).
         * Skipping leading trivia makes source-spans more "user friendly", since things like HTML
         * elements will appear to begin at the start of the opening tag, rather than at the start of any
         * leading trivia, which could include newlines.
         *
         * @param end
         * The location of the end of the span.
         *
         * @param fullStart
         * The start of the token without skipping the leading trivia.
         * This is used by tooling that splits tokens further, such as extracting Angular interpolations
         * from text tokens. Such tooling creates new source-spans relative to the original token's
         * source-span. If leading trivia characters have been skipped then the new source-spans may be
         * incorrectly offset.
         *
         * @param details
         * Additional information (such as identifier names) that should be associated with the span.
         */
        constructor(start, end, fullStart = start, details = null) {
            this.start = start;
            this.end = end;
            this.fullStart = fullStart;
            this.details = details;
        }
        toString() {
            return this.start.file.content.substring(this.start.offset, this.end.offset);
        }
    }
    var ParseErrorLevel;
    (function (ParseErrorLevel) {
        ParseErrorLevel[ParseErrorLevel["WARNING"] = 0] = "WARNING";
        ParseErrorLevel[ParseErrorLevel["ERROR"] = 1] = "ERROR";
    })(ParseErrorLevel || (ParseErrorLevel = {}));
    class ParseError {
        constructor(span, msg, level = ParseErrorLevel.ERROR) {
            this.span = span;
            this.msg = msg;
            this.level = level;
        }
        contextualMessage() {
            const ctx = this.span.start.getContext(100, 3);
            return ctx ? `${this.msg} ("${ctx.before}[${ParseErrorLevel[this.level]} ->]${ctx.after}")` :
                this.msg;
        }
        toString() {
            const details = this.span.details ? `, ${this.span.details}` : '';
            return `${this.contextualMessage()}: ${this.span.start}${details}`;
        }
    }
    /**
     * Generates Source Span object for a given R3 Type for JIT mode.
     *
     * @param kind Component or Directive.
     * @param typeName name of the Component or Directive.
     * @param sourceUrl reference to Component or Directive source.
     * @returns instance of ParseSourceSpan that represent a given Component or Directive.
     */
    function r3JitTypeSourceSpan(kind, typeName, sourceUrl) {
        const sourceFileName = `in ${kind} ${typeName} in ${sourceUrl}`;
        const sourceFile = new ParseSourceFile('', sourceFileName);
        return new ParseSourceSpan(new ParseLocation(sourceFile, -1, -1, -1), new ParseLocation(sourceFile, -1, -1, -1));
    }
    function syntaxError(msg, parseErrors) {
        const error = Error(msg);
        error[ERROR_SYNTAX_ERROR] = true;
        if (parseErrors)
            error[ERROR_PARSE_ERRORS] = parseErrors;
        return error;
    }
    const ERROR_SYNTAX_ERROR = 'ngSyntaxError';
    const ERROR_PARSE_ERRORS = 'ngParseErrors';
    let _anonymousTypeIndex = 0;
    function identifierName(compileIdentifier) {
        if (!compileIdentifier || !compileIdentifier.reference) {
            return null;
        }
        const ref = compileIdentifier.reference;
        if (ref instanceof StaticSymbol) {
            return ref.name;
        }
        if (ref['__anonymousType']) {
            return ref['__anonymousType'];
        }
        if (ref['__forward_ref__']) {
            // We do not want to try to stringify a `forwardRef()` function because that would cause the
            // inner function to be evaluated too early, defeating the whole point of the `forwardRef`.
            return '__forward_ref__';
        }
        let identifier = stringify(ref);
        if (identifier.indexOf('(') >= 0) {
            // case: anonymous functions!
            identifier = `anonymous_${_anonymousTypeIndex++}`;
            ref['__anonymousType'] = identifier;
        }
        else {
            identifier = sanitizeIdentifier(identifier);
        }
        return identifier;
    }
    function sanitizeIdentifier(name) {
        return name.replace(/\W/g, '_');
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * In TypeScript, tagged template functions expect a "template object", which is an array of
     * "cooked" strings plus a `raw` property that contains an array of "raw" strings. This is
     * typically constructed with a function called `__makeTemplateObject(cooked, raw)`, but it may not
     * be available in all environments.
     *
     * This is a JavaScript polyfill that uses __makeTemplateObject when it's available, but otherwise
     * creates an inline helper with the same functionality.
     *
     * In the inline function, if `Object.defineProperty` is available we use that to attach the `raw`
     * array.
     */
    const makeTemplateObjectPolyfill = '(this&&this.__makeTemplateObject||function(e,t){return Object.defineProperty?Object.defineProperty(e,"raw",{value:t}):e.raw=t,e})';
    class AbstractJsEmitterVisitor extends AbstractEmitterVisitor {
        constructor() {
            super(false);
        }
        visitDeclareClassStmt(stmt, ctx) {
            ctx.pushClass(stmt);
            this._visitClassConstructor(stmt, ctx);
            if (stmt.parent != null) {
                ctx.print(stmt, `${stmt.name}.prototype = Object.create(`);
                stmt.parent.visitExpression(this, ctx);
                ctx.println(stmt, `.prototype);`);
            }
            stmt.getters.forEach((getter) => this._visitClassGetter(stmt, getter, ctx));
            stmt.methods.forEach((method) => this._visitClassMethod(stmt, method, ctx));
            ctx.popClass();
            return null;
        }
        _visitClassConstructor(stmt, ctx) {
            ctx.print(stmt, `function ${stmt.name}(`);
            if (stmt.constructorMethod != null) {
                this._visitParams(stmt.constructorMethod.params, ctx);
            }
            ctx.println(stmt, `) {`);
            ctx.incIndent();
            if (stmt.constructorMethod != null) {
                if (stmt.constructorMethod.body.length > 0) {
                    ctx.println(stmt, `var self = this;`);
                    this.visitAllStatements(stmt.constructorMethod.body, ctx);
                }
            }
            ctx.decIndent();
            ctx.println(stmt, `}`);
        }
        _visitClassGetter(stmt, getter, ctx) {
            ctx.println(stmt, `Object.defineProperty(${stmt.name}.prototype, '${getter.name}', { get: function() {`);
            ctx.incIndent();
            if (getter.body.length > 0) {
                ctx.println(stmt, `var self = this;`);
                this.visitAllStatements(getter.body, ctx);
            }
            ctx.decIndent();
            ctx.println(stmt, `}});`);
        }
        _visitClassMethod(stmt, method, ctx) {
            ctx.print(stmt, `${stmt.name}.prototype.${method.name} = function(`);
            this._visitParams(method.params, ctx);
            ctx.println(stmt, `) {`);
            ctx.incIndent();
            if (method.body.length > 0) {
                ctx.println(stmt, `var self = this;`);
                this.visitAllStatements(method.body, ctx);
            }
            ctx.decIndent();
            ctx.println(stmt, `};`);
        }
        visitWrappedNodeExpr(ast, ctx) {
            throw new Error('Cannot emit a WrappedNodeExpr in Javascript.');
        }
        visitReadVarExpr(ast, ctx) {
            if (ast.builtin === BuiltinVar.This) {
                ctx.print(ast, 'self');
            }
            else if (ast.builtin === BuiltinVar.Super) {
                throw new Error(`'super' needs to be handled at a parent ast node, not at the variable level!`);
            }
            else {
                super.visitReadVarExpr(ast, ctx);
            }
            return null;
        }
        visitDeclareVarStmt(stmt, ctx) {
            ctx.print(stmt, `var ${stmt.name}`);
            if (stmt.value) {
                ctx.print(stmt, ' = ');
                stmt.value.visitExpression(this, ctx);
            }
            ctx.println(stmt, `;`);
            return null;
        }
        visitCastExpr(ast, ctx) {
            ast.value.visitExpression(this, ctx);
            return null;
        }
        visitInvokeFunctionExpr(expr, ctx) {
            const fnExpr = expr.fn;
            if (fnExpr instanceof ReadVarExpr && fnExpr.builtin === BuiltinVar.Super) {
                ctx.currentClass.parent.visitExpression(this, ctx);
                ctx.print(expr, `.call(this`);
                if (expr.args.length > 0) {
                    ctx.print(expr, `, `);
                    this.visitAllExpressions(expr.args, ctx, ',');
                }
                ctx.print(expr, `)`);
            }
            else {
                super.visitInvokeFunctionExpr(expr, ctx);
            }
            return null;
        }
        visitTaggedTemplateExpr(ast, ctx) {
            // The following convoluted piece of code is effectively the downlevelled equivalent of
            // ```
            // tag`...`
            // ```
            // which is effectively like:
            // ```
            // tag(__makeTemplateObject(cooked, raw), expression1, expression2, ...);
            // ```
            const elements = ast.template.elements;
            ast.tag.visitExpression(this, ctx);
            ctx.print(ast, `(${makeTemplateObjectPolyfill}(`);
            ctx.print(ast, `[${elements.map(part => escapeIdentifier(part.text, false)).join(', ')}], `);
            ctx.print(ast, `[${elements.map(part => escapeIdentifier(part.rawText, false)).join(', ')}])`);
            ast.template.expressions.forEach(expression => {
                ctx.print(ast, ', ');
                expression.visitExpression(this, ctx);
            });
            ctx.print(ast, ')');
            return null;
        }
        visitFunctionExpr(ast, ctx) {
            ctx.print(ast, `function${ast.name ? ' ' + ast.name : ''}(`);
            this._visitParams(ast.params, ctx);
            ctx.println(ast, `) {`);
            ctx.incIndent();
            this.visitAllStatements(ast.statements, ctx);
            ctx.decIndent();
            ctx.print(ast, `}`);
            return null;
        }
        visitDeclareFunctionStmt(stmt, ctx) {
            ctx.print(stmt, `function ${stmt.name}(`);
            this._visitParams(stmt.params, ctx);
            ctx.println(stmt, `) {`);
            ctx.incIndent();
            this.visitAllStatements(stmt.statements, ctx);
            ctx.decIndent();
            ctx.println(stmt, `}`);
            return null;
        }
        visitTryCatchStmt(stmt, ctx) {
            ctx.println(stmt, `try {`);
            ctx.incIndent();
            this.visitAllStatements(stmt.bodyStmts, ctx);
            ctx.decIndent();
            ctx.println(stmt, `} catch (${CATCH_ERROR_VAR$1.name}) {`);
            ctx.incIndent();
            const catchStmts = [CATCH_STACK_VAR$1.set(CATCH_ERROR_VAR$1.prop('stack')).toDeclStmt(null, [
                    StmtModifier.Final
                ])].concat(stmt.catchStmts);
            this.visitAllStatements(catchStmts, ctx);
            ctx.decIndent();
            ctx.println(stmt, `}`);
            return null;
        }
        visitLocalizedString(ast, ctx) {
            // The following convoluted piece of code is effectively the downlevelled equivalent of
            // ```
            // $localize `...`
            // ```
            // which is effectively like:
            // ```
            // $localize(__makeTemplateObject(cooked, raw), expression1, expression2, ...);
            // ```
            ctx.print(ast, `$localize(${makeTemplateObjectPolyfill}(`);
            const parts = [ast.serializeI18nHead()];
            for (let i = 1; i < ast.messageParts.length; i++) {
                parts.push(ast.serializeI18nTemplatePart(i));
            }
            ctx.print(ast, `[${parts.map(part => escapeIdentifier(part.cooked, false)).join(', ')}], `);
            ctx.print(ast, `[${parts.map(part => escapeIdentifier(part.raw, false)).join(', ')}])`);
            ast.expressions.forEach(expression => {
                ctx.print(ast, ', ');
                expression.visitExpression(this, ctx);
            });
            ctx.print(ast, ')');
            return null;
        }
        _visitParams(params, ctx) {
            this.visitAllObjects(param => ctx.print(null, param.name), params, ctx, ',');
        }
        getBuiltinMethodName(method) {
            let name;
            switch (method) {
                case BuiltinMethod.ConcatArray:
                    name = 'concat';
                    break;
                case BuiltinMethod.SubscribeObservable:
                    name = 'subscribe';
                    break;
                case BuiltinMethod.Bind:
                    name = 'bind';
                    break;
                default:
                    throw new Error(`Unknown builtin method: ${method}`);
            }
            return name;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * The Trusted Types policy, or null if Trusted Types are not
     * enabled/supported, or undefined if the policy has not been created yet.
     */
    let policy;
    /**
     * Returns the Trusted Types policy, or null if Trusted Types are not
     * enabled/supported. The first call to this function will create the policy.
     */
    function getPolicy() {
        if (policy === undefined) {
            policy = null;
            if (_global.trustedTypes) {
                try {
                    policy =
                        _global.trustedTypes.createPolicy('angular#unsafe-jit', {
                            createScript: (s) => s,
                        });
                }
                catch (_a) {
                    // trustedTypes.createPolicy throws if called with a name that is
                    // already registered, even in report-only mode. Until the API changes,
                    // catch the error not to break the applications functionally. In such
                    // cases, the code will fall back to using strings.
                }
            }
        }
        return policy;
    }
    /**
     * Unsafely promote a string to a TrustedScript, falling back to strings when
     * Trusted Types are not available.
     * @security In particular, it must be assured that the provided string will
     * never cause an XSS vulnerability if used in a context that will be
     * interpreted and executed as a script by a browser, e.g. when calling eval.
     */
    function trustedScriptFromString(script) {
        var _a;
        return ((_a = getPolicy()) === null || _a === void 0 ? void 0 : _a.createScript(script)) || script;
    }
    /**
     * Unsafely call the Function constructor with the given string arguments.
     * @security This is a security-sensitive function; any use of this function
     * must go through security review. In particular, it must be assured that it
     * is only called from the JIT compiler, as use in other code can lead to XSS
     * vulnerabilities.
     */
    function newTrustedFunctionForJIT(...args) {
        if (!_global.trustedTypes) {
            // In environments that don't support Trusted Types, fall back to the most
            // straightforward implementation:
            return new Function(...args);
        }
        // Chrome currently does not support passing TrustedScript to the Function
        // constructor. The following implements the workaround proposed on the page
        // below, where the Chromium bug is also referenced:
        // https://github.com/w3c/webappsec-trusted-types/wiki/Trusted-Types-for-function-constructor
        const fnArgs = args.slice(0, -1).join(',');
        const fnBody = args[args.length - 1];
        const body = `(function anonymous(${fnArgs}
) { ${fnBody}
})`;
        // Using eval directly confuses the compiler and prevents this module from
        // being stripped out of JS binaries even if not used. The global['eval']
        // indirection fixes that.
        const fn = _global['eval'](trustedScriptFromString(body));
        if (fn.bind === undefined) {
            // Workaround for a browser bug that only exists in Chrome 83, where passing
            // a TrustedScript to eval just returns the TrustedScript back without
            // evaluating it. In that case, fall back to the most straightforward
            // implementation:
            return new Function(...args);
        }
        // To completely mimic the behavior of calling "new Function", two more
        // things need to happen:
        // 1. Stringifying the resulting function should return its source code
        fn.toString = () => body;
        // 2. When calling the resulting function, `this` should refer to `global`
        return fn.bind(_global);
        // When Trusted Types support in Function constructors is widely available,
        // the implementation of this function can be simplified to:
        // return new Function(...args.map(a => trustedScriptFromString(a)));
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A helper class to manage the evaluation of JIT generated code.
     */
    class JitEvaluator {
        /**
         *
         * @param sourceUrl The URL of the generated code.
         * @param statements An array of Angular statement AST nodes to be evaluated.
         * @param reflector A helper used when converting the statements to executable code.
         * @param createSourceMaps If true then create a source-map for the generated code and include it
         * inline as a source-map comment.
         * @returns A map of all the variables in the generated code.
         */
        evaluateStatements(sourceUrl, statements, reflector, createSourceMaps) {
            const converter = new JitEmitterVisitor(reflector);
            const ctx = EmitterVisitorContext.createRoot();
            // Ensure generated code is in strict mode
            if (statements.length > 0 && !isUseStrictStatement(statements[0])) {
                statements = [
                    literal('use strict').toStmt(),
                    ...statements,
                ];
            }
            converter.visitAllStatements(statements, ctx);
            converter.createReturnStmt(ctx);
            return this.evaluateCode(sourceUrl, ctx, converter.getArgs(), createSourceMaps);
        }
        /**
         * Evaluate a piece of JIT generated code.
         * @param sourceUrl The URL of this generated code.
         * @param ctx A context object that contains an AST of the code to be evaluated.
         * @param vars A map containing the names and values of variables that the evaluated code might
         * reference.
         * @param createSourceMap If true then create a source-map for the generated code and include it
         * inline as a source-map comment.
         * @returns The result of evaluating the code.
         */
        evaluateCode(sourceUrl, ctx, vars, createSourceMap) {
            let fnBody = `"use strict";${ctx.toSource()}\n//# sourceURL=${sourceUrl}`;
            const fnArgNames = [];
            const fnArgValues = [];
            for (const argName in vars) {
                fnArgValues.push(vars[argName]);
                fnArgNames.push(argName);
            }
            if (createSourceMap) {
                // using `new Function(...)` generates a header, 1 line of no arguments, 2 lines otherwise
                // E.g. ```
                // function anonymous(a,b,c
                // /**/) { ... }```
                // We don't want to hard code this fact, so we auto detect it via an empty function first.
                const emptyFn = newTrustedFunctionForJIT(...fnArgNames.concat('return null;')).toString();
                const headerLines = emptyFn.slice(0, emptyFn.indexOf('return null;')).split('\n').length - 1;
                fnBody += `\n${ctx.toSourceMapGenerator(sourceUrl, headerLines).toJsComment()}`;
            }
            const fn = newTrustedFunctionForJIT(...fnArgNames.concat(fnBody));
            return this.executeFunction(fn, fnArgValues);
        }
        /**
         * Execute a JIT generated function by calling it.
         *
         * This method can be overridden in tests to capture the functions that are generated
         * by this `JitEvaluator` class.
         *
         * @param fn A function to execute.
         * @param args The arguments to pass to the function being executed.
         * @returns The return value of the executed function.
         */
        executeFunction(fn, args) {
            return fn(...args);
        }
    }
    /**
     * An Angular AST visitor that converts AST nodes into executable JavaScript code.
     */
    class JitEmitterVisitor extends AbstractJsEmitterVisitor {
        constructor(reflector) {
            super();
            this.reflector = reflector;
            this._evalArgNames = [];
            this._evalArgValues = [];
            this._evalExportedVars = [];
        }
        createReturnStmt(ctx) {
            const stmt = new ReturnStatement(new LiteralMapExpr(this._evalExportedVars.map(resultVar => new LiteralMapEntry(resultVar, variable(resultVar), false))));
            stmt.visitStatement(this, ctx);
        }
        getArgs() {
            const result = {};
            for (let i = 0; i < this._evalArgNames.length; i++) {
                result[this._evalArgNames[i]] = this._evalArgValues[i];
            }
            return result;
        }
        visitExternalExpr(ast, ctx) {
            this._emitReferenceToExternal(ast, this.reflector.resolveExternalReference(ast.value), ctx);
            return null;
        }
        visitWrappedNodeExpr(ast, ctx) {
            this._emitReferenceToExternal(ast, ast.node, ctx);
            return null;
        }
        visitDeclareVarStmt(stmt, ctx) {
            if (stmt.hasModifier(StmtModifier.Exported)) {
                this._evalExportedVars.push(stmt.name);
            }
            return super.visitDeclareVarStmt(stmt, ctx);
        }
        visitDeclareFunctionStmt(stmt, ctx) {
            if (stmt.hasModifier(StmtModifier.Exported)) {
                this._evalExportedVars.push(stmt.name);
            }
            return super.visitDeclareFunctionStmt(stmt, ctx);
        }
        visitDeclareClassStmt(stmt, ctx) {
            if (stmt.hasModifier(StmtModifier.Exported)) {
                this._evalExportedVars.push(stmt.name);
            }
            return super.visitDeclareClassStmt(stmt, ctx);
        }
        _emitReferenceToExternal(ast, value, ctx) {
            let id = this._evalArgValues.indexOf(value);
            if (id === -1) {
                id = this._evalArgValues.length;
                this._evalArgValues.push(value);
                const name = identifierName({ reference: value }) || 'val';
                this._evalArgNames.push(`jit_${name}_${id}`);
            }
            ctx.print(ast, this._evalArgNames[id]);
        }
    }
    function isUseStrictStatement(statement) {
        return statement.isEquivalent(literal('use strict').toStmt());
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function compileInjector(meta) {
        const definitionMap = new DefinitionMap();
        if (meta.providers !== null) {
            definitionMap.set('providers', meta.providers);
        }
        if (meta.imports.length > 0) {
            definitionMap.set('imports', literalArr(meta.imports));
        }
        const expression = importExpr(Identifiers.defineInjector).callFn([definitionMap.toLiteralMap()], undefined, true);
        const type = createInjectorType(meta);
        return { expression, type, statements: [] };
    }
    function createInjectorType(meta) {
        return new ExpressionType(importExpr(Identifiers.InjectorDeclaration, [new ExpressionType(meta.type.type)]));
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Implementation of `CompileReflector` which resolves references to @angular/core
     * symbols at runtime, according to a consumer-provided mapping.
     *
     * Only supports `resolveExternalReference`, all other methods throw.
     */
    class R3JitReflector {
        constructor(context) {
            this.context = context;
        }
        resolveExternalReference(ref) {
            // This reflector only handles @angular/core imports.
            if (ref.moduleName !== '@angular/core') {
                throw new Error(`Cannot resolve external reference to ${ref.moduleName}, only references to @angular/core are supported.`);
            }
            if (!this.context.hasOwnProperty(ref.name)) {
                throw new Error(`No value provided for @angular/core symbol '${ref.name}'.`);
            }
            return this.context[ref.name];
        }
        parameters(typeOrFunc) {
            throw new Error('Not implemented.');
        }
        annotations(typeOrFunc) {
            throw new Error('Not implemented.');
        }
        shallowAnnotations(typeOrFunc) {
            throw new Error('Not implemented.');
        }
        tryAnnotations(typeOrFunc) {
            throw new Error('Not implemented.');
        }
        propMetadata(typeOrFunc) {
            throw new Error('Not implemented.');
        }
        hasLifecycleHook(type, lcProperty) {
            throw new Error('Not implemented.');
        }
        guards(typeOrFunc) {
            throw new Error('Not implemented.');
        }
        componentModuleUrl(type, cmpMetadata) {
            throw new Error('Not implemented.');
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Construct an `R3NgModuleDef` for the given `R3NgModuleMetadata`.
     */
    function compileNgModule(meta) {
        const { internalType, bootstrap, declarations, imports, exports, schemas, containsForwardDecls, emitInline, id } = meta;
        const statements = [];
        const definitionMap = new DefinitionMap();
        definitionMap.set('type', internalType);
        if (bootstrap.length > 0) {
            definitionMap.set('bootstrap', refsToArray(bootstrap, containsForwardDecls));
        }
        // If requested to emit scope information inline, pass the `declarations`, `imports` and `exports`
        // to the `ÉµÉµdefineNgModule()` call. The JIT compilation uses this.
        if (emitInline) {
            if (declarations.length > 0) {
                definitionMap.set('declarations', refsToArray(declarations, containsForwardDecls));
            }
            if (imports.length > 0) {
                definitionMap.set('imports', refsToArray(imports, containsForwardDecls));
            }
            if (exports.length > 0) {
                definitionMap.set('exports', refsToArray(exports, containsForwardDecls));
            }
        }
        // If not emitting inline, the scope information is not passed into `ÉµÉµdefineNgModule` as it would
        // prevent tree-shaking of the declarations, imports and exports references.
        else {
            const setNgModuleScopeCall = generateSetNgModuleScopeCall(meta);
            if (setNgModuleScopeCall !== null) {
                statements.push(setNgModuleScopeCall);
            }
        }
        if (schemas !== null && schemas.length > 0) {
            definitionMap.set('schemas', literalArr(schemas.map(ref => ref.value)));
        }
        if (id !== null) {
            definitionMap.set('id', id);
        }
        const expression = importExpr(Identifiers.defineNgModule).callFn([definitionMap.toLiteralMap()], undefined, true);
        const type = createNgModuleType(meta);
        return { expression, type, statements };
    }
    /**
     * This function is used in JIT mode to generate the call to `ÉµÉµdefineNgModule()` from a call to
     * `ÉµÉµngDeclareNgModule()`.
     */
    function compileNgModuleDeclarationExpression(meta) {
        const definitionMap = new DefinitionMap();
        definitionMap.set('type', new WrappedNodeExpr(meta.type));
        if (meta.bootstrap !== undefined) {
            definitionMap.set('bootstrap', new WrappedNodeExpr(meta.bootstrap));
        }
        if (meta.declarations !== undefined) {
            definitionMap.set('declarations', new WrappedNodeExpr(meta.declarations));
        }
        if (meta.imports !== undefined) {
            definitionMap.set('imports', new WrappedNodeExpr(meta.imports));
        }
        if (meta.exports !== undefined) {
            definitionMap.set('exports', new WrappedNodeExpr(meta.exports));
        }
        if (meta.schemas !== undefined) {
            definitionMap.set('schemas', new WrappedNodeExpr(meta.schemas));
        }
        if (meta.id !== undefined) {
            definitionMap.set('id', new WrappedNodeExpr(meta.id));
        }
        return importExpr(Identifiers.defineNgModule).callFn([definitionMap.toLiteralMap()]);
    }
    function createNgModuleType({ type: moduleType, declarations, imports, exports }) {
        return new ExpressionType(importExpr(Identifiers.NgModuleDeclaration, [
            new ExpressionType(moduleType.type), tupleTypeOf(declarations), tupleTypeOf(imports),
            tupleTypeOf(exports)
        ]));
    }
    /**
     * Generates a function call to `ÉµÉµsetNgModuleScope` with all necessary information so that the
     * transitive module scope can be computed during runtime in JIT mode. This call is marked pure
     * such that the references to declarations, imports and exports may be elided causing these
     * symbols to become tree-shakeable.
     */
    function generateSetNgModuleScopeCall(meta) {
        const { adjacentType: moduleType, declarations, imports, exports, containsForwardDecls } = meta;
        const scopeMap = new DefinitionMap();
        if (declarations.length > 0) {
            scopeMap.set('declarations', refsToArray(declarations, containsForwardDecls));
        }
        if (imports.length > 0) {
            scopeMap.set('imports', refsToArray(imports, containsForwardDecls));
        }
        if (exports.length > 0) {
            scopeMap.set('exports', refsToArray(exports, containsForwardDecls));
        }
        if (Object.keys(scopeMap.values).length === 0) {
            return null;
        }
        // setNgModuleScope(...)
        const fnCall = new InvokeFunctionExpr(
        /* fn */ importExpr(Identifiers.setNgModuleScope), 
        /* args */ [moduleType, scopeMap.toLiteralMap()]);
        // (ngJitMode guard) && setNgModuleScope(...)
        const guardedCall = jitOnlyGuardedExpression(fnCall);
        // function() { (ngJitMode guard) && setNgModuleScope(...); }
        const iife = new FunctionExpr(
        /* params */ [], 
        /* statements */ [guardedCall.toStmt()]);
        // (function() { (ngJitMode guard) && setNgModuleScope(...); })()
        const iifeCall = new InvokeFunctionExpr(
        /* fn */ iife, 
        /* args */ []);
        return iifeCall.toStmt();
    }
    function tupleTypeOf(exp) {
        const types = exp.map(ref => typeofExpr(ref.type));
        return exp.length > 0 ? expressionType(literalArr(types)) : NONE_TYPE;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function compilePipeFromMetadata(metadata) {
        const definitionMapValues = [];
        // e.g. `name: 'myPipe'`
        definitionMapValues.push({ key: 'name', value: literal(metadata.pipeName), quoted: false });
        // e.g. `type: MyPipe`
        definitionMapValues.push({ key: 'type', value: metadata.type.value, quoted: false });
        // e.g. `pure: true`
        definitionMapValues.push({ key: 'pure', value: literal(metadata.pure), quoted: false });
        const expression = importExpr(Identifiers.definePipe).callFn([literalMap(definitionMapValues)], undefined, true);
        const type = createPipeType(metadata);
        return { expression, type, statements: [] };
    }
    function createPipeType(metadata) {
        return new ExpressionType(importExpr(Identifiers.PipeDeclaration, [
            typeWithParameters(metadata.type.type, metadata.typeArgumentCount),
            new ExpressionType(new LiteralExpr(metadata.pipeName)),
        ]));
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class ParserError {
        constructor(message, input, errLocation, ctxLocation) {
            this.input = input;
            this.errLocation = errLocation;
            this.ctxLocation = ctxLocation;
            this.message = `Parser Error: ${message} ${errLocation} [${input}] in ${ctxLocation}`;
        }
    }
    class ParseSpan {
        constructor(start, end) {
            this.start = start;
            this.end = end;
        }
        toAbsolute(absoluteOffset) {
            return new AbsoluteSourceSpan(absoluteOffset + this.start, absoluteOffset + this.end);
        }
    }
    class AST {
        constructor(span, 
        /**
         * Absolute location of the expression AST in a source code file.
         */
        sourceSpan) {
            this.span = span;
            this.sourceSpan = sourceSpan;
        }
        toString() {
            return 'AST';
        }
    }
    class ASTWithName extends AST {
        constructor(span, sourceSpan, nameSpan) {
            super(span, sourceSpan);
            this.nameSpan = nameSpan;
        }
    }
    /**
     * Represents a quoted expression of the form:
     *
     * quote = prefix `:` uninterpretedExpression
     * prefix = identifier
     * uninterpretedExpression = arbitrary string
     *
     * A quoted expression is meant to be pre-processed by an AST transformer that
     * converts it into another AST that no longer contains quoted expressions.
     * It is meant to allow third-party developers to extend Angular template
     * expression language. The `uninterpretedExpression` part of the quote is
     * therefore not interpreted by the Angular's own expression parser.
     */
    class Quote extends AST {
        constructor(span, sourceSpan, prefix, uninterpretedExpression, location) {
            super(span, sourceSpan);
            this.prefix = prefix;
            this.uninterpretedExpression = uninterpretedExpression;
            this.location = location;
        }
        visit(visitor, context = null) {
            return visitor.visitQuote(this, context);
        }
        toString() {
            return 'Quote';
        }
    }
    class EmptyExpr extends AST {
        visit(visitor, context = null) {
            // do nothing
        }
    }
    class ImplicitReceiver extends AST {
        visit(visitor, context = null) {
            return visitor.visitImplicitReceiver(this, context);
        }
    }
    /**
     * Receiver when something is accessed through `this` (e.g. `this.foo`). Note that this class
     * inherits from `ImplicitReceiver`, because accessing something through `this` is treated the
     * same as accessing it implicitly inside of an Angular template (e.g. `[attr.title]="this.title"`
     * is the same as `[attr.title]="title"`.). Inheriting allows for the `this` accesses to be treated
     * the same as implicit ones, except for a couple of exceptions like `$event` and `$any`.
     * TODO: we should find a way for this class not to extend from `ImplicitReceiver` in the future.
     */
    class ThisReceiver extends ImplicitReceiver {
        visit(visitor, context = null) {
            var _a;
            return (_a = visitor.visitThisReceiver) === null || _a === void 0 ? void 0 : _a.call(visitor, this, context);
        }
    }
    /**
     * Multiple expressions separated by a semicolon.
     */
    class Chain extends AST {
        constructor(span, sourceSpan, expressions) {
            super(span, sourceSpan);
            this.expressions = expressions;
        }
        visit(visitor, context = null) {
            return visitor.visitChain(this, context);
        }
    }
    class Conditional extends AST {
        constructor(span, sourceSpan, condition, trueExp, falseExp) {
            super(span, sourceSpan);
            this.condition = condition;
            this.trueExp = trueExp;
            this.falseExp = falseExp;
        }
        visit(visitor, context = null) {
            return visitor.visitConditional(this, context);
        }
    }
    class PropertyRead extends ASTWithName {
        constructor(span, sourceSpan, nameSpan, receiver, name) {
            super(span, sourceSpan, nameSpan);
            this.receiver = receiver;
            this.name = name;
        }
        visit(visitor, context = null) {
            return visitor.visitPropertyRead(this, context);
        }
    }
    class PropertyWrite extends ASTWithName {
        constructor(span, sourceSpan, nameSpan, receiver, name, value) {
            super(span, sourceSpan, nameSpan);
            this.receiver = receiver;
            this.name = name;
            this.value = value;
        }
        visit(visitor, context = null) {
            return visitor.visitPropertyWrite(this, context);
        }
    }
    class SafePropertyRead extends ASTWithName {
        constructor(span, sourceSpan, nameSpan, receiver, name) {
            super(span, sourceSpan, nameSpan);
            this.receiver = receiver;
            this.name = name;
        }
        visit(visitor, context = null) {
            return visitor.visitSafePropertyRead(this, context);
        }
    }
    class KeyedRead extends AST {
        constructor(span, sourceSpan, receiver, key) {
            super(span, sourceSpan);
            this.receiver = receiver;
            this.key = key;
        }
        visit(visitor, context = null) {
            return visitor.visitKeyedRead(this, context);
        }
    }
    class SafeKeyedRead extends AST {
        constructor(span, sourceSpan, receiver, key) {
            super(span, sourceSpan);
            this.receiver = receiver;
            this.key = key;
        }
        visit(visitor, context = null) {
            return visitor.visitSafeKeyedRead(this, context);
        }
    }
    class KeyedWrite extends AST {
        constructor(span, sourceSpan, receiver, key, value) {
            super(span, sourceSpan);
            this.receiver = receiver;
            this.key = key;
            this.value = value;
        }
        visit(visitor, context = null) {
            return visitor.visitKeyedWrite(this, context);
        }
    }
    class BindingPipe extends ASTWithName {
        constructor(span, sourceSpan, exp, name, args, nameSpan) {
            super(span, sourceSpan, nameSpan);
            this.exp = exp;
            this.name = name;
            this.args = args;
        }
        visit(visitor, context = null) {
            return visitor.visitPipe(this, context);
        }
    }
    class LiteralPrimitive extends AST {
        constructor(span, sourceSpan, value) {
            super(span, sourceSpan);
            this.value = value;
        }
        visit(visitor, context = null) {
            return visitor.visitLiteralPrimitive(this, context);
        }
    }
    class LiteralArray extends AST {
        constructor(span, sourceSpan, expressions) {
            super(span, sourceSpan);
            this.expressions = expressions;
        }
        visit(visitor, context = null) {
            return visitor.visitLiteralArray(this, context);
        }
    }
    class LiteralMap extends AST {
        constructor(span, sourceSpan, keys, values) {
            super(span, sourceSpan);
            this.keys = keys;
            this.values = values;
        }
        visit(visitor, context = null) {
            return visitor.visitLiteralMap(this, context);
        }
    }
    class Interpolation extends AST {
        constructor(span, sourceSpan, strings, expressions) {
            super(span, sourceSpan);
            this.strings = strings;
            this.expressions = expressions;
        }
        visit(visitor, context = null) {
            return visitor.visitInterpolation(this, context);
        }
    }
    class Binary extends AST {
        constructor(span, sourceSpan, operation, left, right) {
            super(span, sourceSpan);
            this.operation = operation;
            this.left = left;
            this.right = right;
        }
        visit(visitor, context = null) {
            return visitor.visitBinary(this, context);
        }
    }
    /**
     * For backwards compatibility reasons, `Unary` inherits from `Binary` and mimics the binary AST
     * node that was originally used. This inheritance relation can be deleted in some future major,
     * after consumers have been given a chance to fully support Unary.
     */
    class Unary extends Binary {
        /**
         * During the deprecation period this constructor is private, to avoid consumers from creating
         * a `Unary` with the fallback properties for `Binary`.
         */
        constructor(span, sourceSpan, operator, expr, binaryOp, binaryLeft, binaryRight) {
            super(span, sourceSpan, binaryOp, binaryLeft, binaryRight);
            this.operator = operator;
            this.expr = expr;
        }
        /**
         * Creates a unary minus expression "-x", represented as `Binary` using "0 - x".
         */
        static createMinus(span, sourceSpan, expr) {
            return new Unary(span, sourceSpan, '-', expr, '-', new LiteralPrimitive(span, sourceSpan, 0), expr);
        }
        /**
         * Creates a unary plus expression "+x", represented as `Binary` using "x - 0".
         */
        static createPlus(span, sourceSpan, expr) {
            return new Unary(span, sourceSpan, '+', expr, '-', expr, new LiteralPrimitive(span, sourceSpan, 0));
        }
        visit(visitor, context = null) {
            if (visitor.visitUnary !== undefined) {
                return visitor.visitUnary(this, context);
            }
            return visitor.visitBinary(this, context);
        }
    }
    class PrefixNot extends AST {
        constructor(span, sourceSpan, expression) {
            super(span, sourceSpan);
            this.expression = expression;
        }
        visit(visitor, context = null) {
            return visitor.visitPrefixNot(this, context);
        }
    }
    class NonNullAssert extends AST {
        constructor(span, sourceSpan, expression) {
            super(span, sourceSpan);
            this.expression = expression;
        }
        visit(visitor, context = null) {
            return visitor.visitNonNullAssert(this, context);
        }
    }
    class MethodCall extends ASTWithName {
        constructor(span, sourceSpan, nameSpan, receiver, name, args, argumentSpan) {
            super(span, sourceSpan, nameSpan);
            this.receiver = receiver;
            this.name = name;
            this.args = args;
            this.argumentSpan = argumentSpan;
        }
        visit(visitor, context = null) {
            return visitor.visitMethodCall(this, context);
        }
    }
    class SafeMethodCall extends ASTWithName {
        constructor(span, sourceSpan, nameSpan, receiver, name, args, argumentSpan) {
            super(span, sourceSpan, nameSpan);
            this.receiver = receiver;
            this.name = name;
            this.args = args;
            this.argumentSpan = argumentSpan;
        }
        visit(visitor, context = null) {
            return visitor.visitSafeMethodCall(this, context);
        }
    }
    class FunctionCall extends AST {
        constructor(span, sourceSpan, target, args) {
            super(span, sourceSpan);
            this.target = target;
            this.args = args;
        }
        visit(visitor, context = null) {
            return visitor.visitFunctionCall(this, context);
        }
    }
    /**
     * Records the absolute position of a text span in a source file, where `start` and `end` are the
     * starting and ending byte offsets, respectively, of the text span in a source file.
     */
    class AbsoluteSourceSpan {
        constructor(start, end) {
            this.start = start;
            this.end = end;
        }
    }
    class ASTWithSource extends AST {
        constructor(ast, source, location, absoluteOffset, errors) {
            super(new ParseSpan(0, source === null ? 0 : source.length), new AbsoluteSourceSpan(absoluteOffset, source === null ? absoluteOffset : absoluteOffset + source.length));
            this.ast = ast;
            this.source = source;
            this.location = location;
            this.errors = errors;
        }
        visit(visitor, context = null) {
            if (visitor.visitASTWithSource) {
                return visitor.visitASTWithSource(this, context);
            }
            return this.ast.visit(visitor, context);
        }
        toString() {
            return `${this.source} in ${this.location}`;
        }
    }
    class VariableBinding {
        /**
         * @param sourceSpan entire span of the binding.
         * @param key name of the LHS along with its span.
         * @param value optional value for the RHS along with its span.
         */
        constructor(sourceSpan, key, value) {
            this.sourceSpan = sourceSpan;
            this.key = key;
            this.value = value;
        }
    }
    class ExpressionBinding {
        /**
         * @param sourceSpan entire span of the binding.
         * @param key binding name, like ngForOf, ngForTrackBy, ngIf, along with its
         * span. Note that the length of the span may not be the same as
         * `key.source.length`. For example,
         * 1. key.source = ngFor, key.span is for "ngFor"
         * 2. key.source = ngForOf, key.span is for "of"
         * 3. key.source = ngForTrackBy, key.span is for "trackBy"
         * @param value optional expression for the RHS.
         */
        constructor(sourceSpan, key, value) {
            this.sourceSpan = sourceSpan;
            this.key = key;
            this.value = value;
        }
    }
    class RecursiveAstVisitor {
        visit(ast, context) {
            // The default implementation just visits every node.
            // Classes that extend RecursiveAstVisitor should override this function
            // to selectively visit the specified node.
            ast.visit(this, context);
        }
        visitUnary(ast, context) {
            this.visit(ast.expr, context);
        }
        visitBinary(ast, context) {
            this.visit(ast.left, context);
            this.visit(ast.right, context);
        }
        visitChain(ast, context) {
            this.visitAll(ast.expressions, context);
        }
        visitConditional(ast, context) {
            this.visit(ast.condition, context);
            this.visit(ast.trueExp, context);
            this.visit(ast.falseExp, context);
        }
        visitPipe(ast, context) {
            this.visit(ast.exp, context);
            this.visitAll(ast.args, context);
        }
        visitFunctionCall(ast, context) {
            if (ast.target) {
                this.visit(ast.target, context);
            }
            this.visitAll(ast.args, context);
        }
        visitImplicitReceiver(ast, context) { }
        visitThisReceiver(ast, context) { }
        visitInterpolation(ast, context) {
            this.visitAll(ast.expressions, context);
        }
        visitKeyedRead(ast, context) {
            this.visit(ast.receiver, context);
            this.visit(ast.key, context);
        }
        visitKeyedWrite(ast, context) {
            this.visit(ast.receiver, context);
            this.visit(ast.key, context);
            this.visit(ast.value, context);
        }
        visitLiteralArray(ast, context) {
            this.visitAll(ast.expressions, context);
        }
        visitLiteralMap(ast, context) {
            this.visitAll(ast.values, context);
        }
        visitLiteralPrimitive(ast, context) { }
        visitMethodCall(ast, context) {
            this.visit(ast.receiver, context);
            this.visitAll(ast.args, context);
        }
        visitPrefixNot(ast, context) {
            this.visit(ast.expression, context);
        }
        visitNonNullAssert(ast, context) {
            this.visit(ast.expression, context);
        }
        visitPropertyRead(ast, context) {
            this.visit(ast.receiver, context);
        }
        visitPropertyWrite(ast, context) {
            this.visit(ast.receiver, context);
            this.visit(ast.value, context);
        }
        visitSafePropertyRead(ast, context) {
            this.visit(ast.receiver, context);
        }
        visitSafeMethodCall(ast, context) {
            this.visit(ast.receiver, context);
            this.visitAll(ast.args, context);
        }
        visitSafeKeyedRead(ast, context) {
            this.visit(ast.receiver, context);
            this.visit(ast.key, context);
        }
        visitQuote(ast, context) { }
        // This is not part of the AstVisitor interface, just a helper method
        visitAll(asts, context) {
            for (const ast of asts) {
                this.visit(ast, context);
            }
        }
    }
    class AstTransformer {
        visitImplicitReceiver(ast, context) {
            return ast;
        }
        visitThisReceiver(ast, context) {
            return ast;
        }
        visitInterpolation(ast, context) {
            return new Interpolation(ast.span, ast.sourceSpan, ast.strings, this.visitAll(ast.expressions));
        }
        visitLiteralPrimitive(ast, context) {
            return new LiteralPrimitive(ast.span, ast.sourceSpan, ast.value);
        }
        visitPropertyRead(ast, context) {
            return new PropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name);
        }
        visitPropertyWrite(ast, context) {
            return new PropertyWrite(ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name, ast.value.visit(this));
        }
        visitSafePropertyRead(ast, context) {
            return new SafePropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name);
        }
        visitMethodCall(ast, context) {
            return new MethodCall(ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name, this.visitAll(ast.args), ast.argumentSpan);
        }
        visitSafeMethodCall(ast, context) {
            return new SafeMethodCall(ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name, this.visitAll(ast.args), ast.argumentSpan);
        }
        visitFunctionCall(ast, context) {
            return new FunctionCall(ast.span, ast.sourceSpan, ast.target.visit(this), this.visitAll(ast.args));
        }
        visitLiteralArray(ast, context) {
            return new LiteralArray(ast.span, ast.sourceSpan, this.visitAll(ast.expressions));
        }
        visitLiteralMap(ast, context) {
            return new LiteralMap(ast.span, ast.sourceSpan, ast.keys, this.visitAll(ast.values));
        }
        visitUnary(ast, context) {
            switch (ast.operator) {
                case '+':
                    return Unary.createPlus(ast.span, ast.sourceSpan, ast.expr.visit(this));
                case '-':
                    return Unary.createMinus(ast.span, ast.sourceSpan, ast.expr.visit(this));
                default:
                    throw new Error(`Unknown unary operator ${ast.operator}`);
            }
        }
        visitBinary(ast, context) {
            return new Binary(ast.span, ast.sourceSpan, ast.operation, ast.left.visit(this), ast.right.visit(this));
        }
        visitPrefixNot(ast, context) {
            return new PrefixNot(ast.span, ast.sourceSpan, ast.expression.visit(this));
        }
        visitNonNullAssert(ast, context) {
            return new NonNullAssert(ast.span, ast.sourceSpan, ast.expression.visit(this));
        }
        visitConditional(ast, context) {
            return new Conditional(ast.span, ast.sourceSpan, ast.condition.visit(this), ast.trueExp.visit(this), ast.falseExp.visit(this));
        }
        visitPipe(ast, context) {
            return new BindingPipe(ast.span, ast.sourceSpan, ast.exp.visit(this), ast.name, this.visitAll(ast.args), ast.nameSpan);
        }
        visitKeyedRead(ast, context) {
            return new KeyedRead(ast.span, ast.sourceSpan, ast.receiver.visit(this), ast.key.visit(this));
        }
        visitKeyedWrite(ast, context) {
            return new KeyedWrite(ast.span, ast.sourceSpan, ast.receiver.visit(this), ast.key.visit(this), ast.value.visit(this));
        }
        visitAll(asts) {
            const res = [];
            for (let i = 0; i < asts.length; ++i) {
                res[i] = asts[i].visit(this);
            }
            return res;
        }
        visitChain(ast, context) {
            return new Chain(ast.span, ast.sourceSpan, this.visitAll(ast.expressions));
        }
        visitQuote(ast, context) {
            return new Quote(ast.span, ast.sourceSpan, ast.prefix, ast.uninterpretedExpression, ast.location);
        }
        visitSafeKeyedRead(ast, context) {
            return new SafeKeyedRead(ast.span, ast.sourceSpan, ast.receiver.visit(this), ast.key.visit(this));
        }
    }
    // A transformer that only creates new nodes if the transformer makes a change or
    // a change is made a child node.
    class AstMemoryEfficientTransformer {
        visitImplicitReceiver(ast, context) {
            return ast;
        }
        visitThisReceiver(ast, context) {
            return ast;
        }
        visitInterpolation(ast, context) {
            const expressions = this.visitAll(ast.expressions);
            if (expressions !== ast.expressions)
                return new Interpolation(ast.span, ast.sourceSpan, ast.strings, expressions);
            return ast;
        }
        visitLiteralPrimitive(ast, context) {
            return ast;
        }
        visitPropertyRead(ast, context) {
            const receiver = ast.receiver.visit(this);
            if (receiver !== ast.receiver) {
                return new PropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name);
            }
            return ast;
        }
        visitPropertyWrite(ast, context) {
            const receiver = ast.receiver.visit(this);
            const value = ast.value.visit(this);
            if (receiver !== ast.receiver || value !== ast.value) {
                return new PropertyWrite(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name, value);
            }
            return ast;
        }
        visitSafePropertyRead(ast, context) {
            const receiver = ast.receiver.visit(this);
            if (receiver !== ast.receiver) {
                return new SafePropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name);
            }
            return ast;
        }
        visitMethodCall(ast, context) {
            const receiver = ast.receiver.visit(this);
            const args = this.visitAll(ast.args);
            if (receiver !== ast.receiver || args !== ast.args) {
                return new MethodCall(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name, args, ast.argumentSpan);
            }
            return ast;
        }
        visitSafeMethodCall(ast, context) {
            const receiver = ast.receiver.visit(this);
            const args = this.visitAll(ast.args);
            if (receiver !== ast.receiver || args !== ast.args) {
                return new SafeMethodCall(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name, args, ast.argumentSpan);
            }
            return ast;
        }
        visitFunctionCall(ast, context) {
            const target = ast.target && ast.target.visit(this);
            const args = this.visitAll(ast.args);
            if (target !== ast.target || args !== ast.args) {
                return new FunctionCall(ast.span, ast.sourceSpan, target, args);
            }
            return ast;
        }
        visitLiteralArray(ast, context) {
            const expressions = this.visitAll(ast.expressions);
            if (expressions !== ast.expressions) {
                return new LiteralArray(ast.span, ast.sourceSpan, expressions);
            }
            return ast;
        }
        visitLiteralMap(ast, context) {
            const values = this.visitAll(ast.values);
            if (values !== ast.values) {
                return new LiteralMap(ast.span, ast.sourceSpan, ast.keys, values);
            }
            return ast;
        }
        visitUnary(ast, context) {
            const expr = ast.expr.visit(this);
            if (expr !== ast.expr) {
                switch (ast.operator) {
                    case '+':
                        return Unary.createPlus(ast.span, ast.sourceSpan, expr);
                    case '-':
                        return Unary.createMinus(ast.span, ast.sourceSpan, expr);
                    default:
                        throw new Error(`Unknown unary operator ${ast.operator}`);
                }
            }
            return ast;
        }
        visitBinary(ast, context) {
            const left = ast.left.visit(this);
            const right = ast.right.visit(this);
            if (left !== ast.left || right !== ast.right) {
                return new Binary(ast.span, ast.sourceSpan, ast.operation, left, right);
            }
            return ast;
        }
        visitPrefixNot(ast, context) {
            const expression = ast.expression.visit(this);
            if (expression !== ast.expression) {
                return new PrefixNot(ast.span, ast.sourceSpan, expression);
            }
            return ast;
        }
        visitNonNullAssert(ast, context) {
            const expression = ast.expression.visit(this);
            if (expression !== ast.expression) {
                return new NonNullAssert(ast.span, ast.sourceSpan, expression);
            }
            return ast;
        }
        visitConditional(ast, context) {
            const condition = ast.condition.visit(this);
            const trueExp = ast.trueExp.visit(this);
            const falseExp = ast.falseExp.visit(this);
            if (condition !== ast.condition || trueExp !== ast.trueExp || falseExp !== ast.falseExp) {
                return new Conditional(ast.span, ast.sourceSpan, condition, trueExp, falseExp);
            }
            return ast;
        }
        visitPipe(ast, context) {
            const exp = ast.exp.visit(this);
            const args = this.visitAll(ast.args);
            if (exp !== ast.exp || args !== ast.args) {
                return new BindingPipe(ast.span, ast.sourceSpan, exp, ast.name, args, ast.nameSpan);
            }
            return ast;
        }
        visitKeyedRead(ast, context) {
            const obj = ast.receiver.visit(this);
            const key = ast.key.visit(this);
            if (obj !== ast.receiver || key !== ast.key) {
                return new KeyedRead(ast.span, ast.sourceSpan, obj, key);
            }
            return ast;
        }
        visitKeyedWrite(ast, context) {
            const obj = ast.receiver.visit(this);
            const key = ast.key.visit(this);
            const value = ast.value.visit(this);
            if (obj !== ast.receiver || key !== ast.key || value !== ast.value) {
                return new KeyedWrite(ast.span, ast.sourceSpan, obj, key, value);
            }
            return ast;
        }
        visitAll(asts) {
            const res = [];
            let modified = false;
            for (let i = 0; i < asts.length; ++i) {
                const original = asts[i];
                const value = original.visit(this);
                res[i] = value;
                modified = modified || value !== original;
            }
            return modified ? res : asts;
        }
        visitChain(ast, context) {
            const expressions = this.visitAll(ast.expressions);
            if (expressions !== ast.expressions) {
                return new Chain(ast.span, ast.sourceSpan, expressions);
            }
            return ast;
        }
        visitQuote(ast, context) {
            return ast;
        }
        visitSafeKeyedRead(ast, context) {
            const obj = ast.receiver.visit(this);
            const key = ast.key.visit(this);
            if (obj !== ast.receiver || key !== ast.key) {
                return new SafeKeyedRead(ast.span, ast.sourceSpan, obj, key);
            }
            return ast;
        }
    }
    // Bindings
    class ParsedProperty {
        constructor(name, expression, type, 
        // TODO(FW-2095): `keySpan` should really be required but allows `undefined` so VE does
        // not need to be updated. Make `keySpan` required when VE is removed.
        sourceSpan, keySpan, valueSpan) {
            this.name = name;
            this.expression = expression;
            this.type = type;
            this.sourceSpan = sourceSpan;
            this.keySpan = keySpan;
            this.valueSpan = valueSpan;
            this.isLiteral = this.type === ParsedPropertyType.LITERAL_ATTR;
            this.isAnimation = this.type === ParsedPropertyType.ANIMATION;
        }
    }
    var ParsedPropertyType;
    (function (ParsedPropertyType) {
        ParsedPropertyType[ParsedPropertyType["DEFAULT"] = 0] = "DEFAULT";
        ParsedPropertyType[ParsedPropertyType["LITERAL_ATTR"] = 1] = "LITERAL_ATTR";
        ParsedPropertyType[ParsedPropertyType["ANIMATION"] = 2] = "ANIMATION";
    })(ParsedPropertyType || (ParsedPropertyType = {}));
    class ParsedEvent {
        // Regular events have a target
        // Animation events have a phase
        constructor(name, targetOrPhase, type, handler, sourceSpan, 
        // TODO(FW-2095): keySpan should be required but was made optional to avoid changing VE
        handlerSpan, keySpan) {
            this.name = name;
            this.targetOrPhase = targetOrPhase;
            this.type = type;
            this.handler = handler;
            this.sourceSpan = sourceSpan;
            this.handlerSpan = handlerSpan;
            this.keySpan = keySpan;
        }
    }
    /**
     * ParsedVariable represents a variable declaration in a microsyntax expression.
     */
    class ParsedVariable {
        constructor(name, value, sourceSpan, keySpan, valueSpan) {
            this.name = name;
            this.value = value;
            this.sourceSpan = sourceSpan;
            this.keySpan = keySpan;
            this.valueSpan = valueSpan;
        }
    }
    class BoundElementProperty {
        constructor(name, type, securityContext, value, unit, sourceSpan, keySpan, valueSpan) {
            this.name = name;
            this.type = type;
            this.securityContext = securityContext;
            this.value = value;
            this.unit = unit;
            this.sourceSpan = sourceSpan;
            this.keySpan = keySpan;
            this.valueSpan = valueSpan;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const CORE$1 = '@angular/core';
    class Identifiers$1 {
    }
    Identifiers$1.ANALYZE_FOR_ENTRY_COMPONENTS = {
        name: 'ANALYZE_FOR_ENTRY_COMPONENTS',
        moduleName: CORE$1,
    };
    Identifiers$1.ElementRef = { name: 'ElementRef', moduleName: CORE$1 };
    Identifiers$1.NgModuleRef = { name: 'NgModuleRef', moduleName: CORE$1 };
    Identifiers$1.ViewContainerRef = { name: 'ViewContainerRef', moduleName: CORE$1 };
    Identifiers$1.ChangeDetectorRef = {
        name: 'ChangeDetectorRef',
        moduleName: CORE$1,
    };
    Identifiers$1.QueryList = { name: 'QueryList', moduleName: CORE$1 };
    Identifiers$1.TemplateRef = { name: 'TemplateRef', moduleName: CORE$1 };
    Identifiers$1.Renderer2 = { name: 'Renderer2', moduleName: CORE$1 };
    Identifiers$1.CodegenComponentFactoryResolver = {
        name: 'ÉµCodegenComponentFactoryResolver',
        moduleName: CORE$1,
    };
    Identifiers$1.ComponentFactoryResolver = {
        name: 'ComponentFactoryResolver',
        moduleName: CORE$1,
    };
    Identifiers$1.ComponentFactory = { name: 'ComponentFactory', moduleName: CORE$1 };
    Identifiers$1.ComponentRef = { name: 'ComponentRef', moduleName: CORE$1 };
    Identifiers$1.NgModuleFactory = { name: 'NgModuleFactory', moduleName: CORE$1 };
    Identifiers$1.createModuleFactory = {
        name: 'Éµcmf',
        moduleName: CORE$1,
    };
    Identifiers$1.moduleDef = {
        name: 'Éµmod',
        moduleName: CORE$1,
    };
    Identifiers$1.moduleProviderDef = {
        name: 'Éµmpd',
        moduleName: CORE$1,
    };
    Identifiers$1.RegisterModuleFactoryFn = {
        name: 'ÉµregisterModuleFactory',
        moduleName: CORE$1,
    };
    Identifiers$1.inject = { name: 'ÉµÉµinject', moduleName: CORE$1 };
    Identifiers$1.directiveInject = { name: 'ÉµÉµdirectiveInject', moduleName: CORE$1 };
    Identifiers$1.INJECTOR = { name: 'INJECTOR', moduleName: CORE$1 };
    Identifiers$1.Injector = { name: 'Injector', moduleName: CORE$1 };
    Identifiers$1.ViewEncapsulation = {
        name: 'ViewEncapsulation',
        moduleName: CORE$1,
    };
    Identifiers$1.ChangeDetectionStrategy = {
        name: 'ChangeDetectionStrategy',
        moduleName: CORE$1,
    };
    Identifiers$1.SecurityContext = {
        name: 'SecurityContext',
        moduleName: CORE$1,
    };
    Identifiers$1.LOCALE_ID = { name: 'LOCALE_ID', moduleName: CORE$1 };
    Identifiers$1.TRANSLATIONS_FORMAT = {
        name: 'TRANSLATIONS_FORMAT',
        moduleName: CORE$1,
    };
    Identifiers$1.inlineInterpolate = {
        name: 'ÉµinlineInterpolate',
        moduleName: CORE$1,
    };
    Identifiers$1.interpolate = { name: 'Éµinterpolate', moduleName: CORE$1 };
    Identifiers$1.EMPTY_ARRAY = { name: 'ÉµEMPTY_ARRAY', moduleName: CORE$1 };
    Identifiers$1.EMPTY_MAP = { name: 'ÉµEMPTY_MAP', moduleName: CORE$1 };
    Identifiers$1.Renderer = { name: 'Renderer', moduleName: CORE$1 };
    Identifiers$1.viewDef = { name: 'Éµvid', moduleName: CORE$1 };
    Identifiers$1.elementDef = { name: 'Éµeld', moduleName: CORE$1 };
    Identifiers$1.anchorDef = { name: 'Éµand', moduleName: CORE$1 };
    Identifiers$1.textDef = { name: 'Éµted', moduleName: CORE$1 };
    Identifiers$1.directiveDef = { name: 'Éµdid', moduleName: CORE$1 };
    Identifiers$1.providerDef = { name: 'Éµprd', moduleName: CORE$1 };
    Identifiers$1.queryDef = { name: 'Éµqud', moduleName: CORE$1 };
    Identifiers$1.pureArrayDef = { name: 'Éµpad', moduleName: CORE$1 };
    Identifiers$1.pureObjectDef = { name: 'Éµpod', moduleName: CORE$1 };
    Identifiers$1.purePipeDef = { name: 'Éµppd', moduleName: CORE$1 };
    Identifiers$1.pipeDef = { name: 'Éµpid', moduleName: CORE$1 };
    Identifiers$1.nodeValue = { name: 'Éµnov', moduleName: CORE$1 };
    Identifiers$1.ngContentDef = { name: 'Éµncd', moduleName: CORE$1 };
    Identifiers$1.unwrapValue = { name: 'Éµunv', moduleName: CORE$1 };
    Identifiers$1.createRendererType2 = { name: 'Éµcrt', moduleName: CORE$1 };
    // type only
    Identifiers$1.RendererType2 = {
        name: 'RendererType2',
        moduleName: CORE$1,
    };
    // type only
    Identifiers$1.ViewDefinition = {
        name: 'ÉµViewDefinition',
        moduleName: CORE$1,
    };
    Identifiers$1.createComponentFactory = { name: 'Éµccf', moduleName: CORE$1 };
    function createTokenForReference(reference) {
        return { identifier: { reference: reference } };
    }
    function createTokenForExternalReference(reflector, reference) {
        return createTokenForReference(reflector.resolveExternalReference(reference));
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class EventHandlerVars {
    }
    EventHandlerVars.event = variable('$event');
    class ConvertActionBindingResult {
        constructor(
        /**
         * Render2 compatible statements,
         */
        stmts, 
        /**
         * Variable name used with render2 compatible statements.
         */
        allowDefault) {
            this.stmts = stmts;
            this.allowDefault = allowDefault;
            /**
             * This is bit of a hack. It converts statements which render2 expects to statements which are
             * expected by render3.
             *
             * Example: `<div click="doSomething($event)">` will generate:
             *
             * Render3:
             * ```
             * const pd_b:any = ((<any>ctx.doSomething($event)) !== false);
             * return pd_b;
             * ```
             *
             * but render2 expects:
             * ```
             * return ctx.doSomething($event);
             * ```
             */
            // TODO(misko): remove this hack once we no longer support ViewEngine.
            this.render3Stmts = stmts.map((statement) => {
                if (statement instanceof DeclareVarStmt && statement.name == allowDefault.name &&
                    statement.value instanceof BinaryOperatorExpr) {
                    const lhs = statement.value.lhs;
                    return new ReturnStatement(lhs.value);
                }
                return statement;
            });
        }
    }
    /**
     * Converts the given expression AST into an executable output AST, assuming the expression is
     * used in an action binding (e.g. an event handler).
     */
    function convertActionBinding(localResolver, implicitReceiver, action, bindingId, interpolationFunction, baseSourceSpan, implicitReceiverAccesses, globals) {
        if (!localResolver) {
            localResolver = new DefaultLocalResolver(globals);
        }
        const actionWithoutBuiltins = convertPropertyBindingBuiltins({
            createLiteralArrayConverter: (argCount) => {
                // Note: no caching for literal arrays in actions.
                return (args) => literalArr(args);
            },
            createLiteralMapConverter: (keys) => {
                // Note: no caching for literal maps in actions.
                return (values) => {
                    const entries = keys.map((k, i) => ({
                        key: k.key,
                        value: values[i],
                        quoted: k.quoted,
                    }));
                    return literalMap(entries);
                };
            },
            createPipeConverter: (name) => {
                throw new Error(`Illegal State: Actions are not allowed to contain pipes. Pipe: ${name}`);
            }
        }, action);
        const visitor = new _AstToIrVisitor(localResolver, implicitReceiver, bindingId, interpolationFunction, baseSourceSpan, implicitReceiverAccesses);
        const actionStmts = [];
        flattenStatements(actionWithoutBuiltins.visit(visitor, _Mode.Statement), actionStmts);
        prependTemporaryDecls(visitor.temporaryCount, bindingId, actionStmts);
        if (visitor.usesImplicitReceiver) {
            localResolver.notifyImplicitReceiverUse();
        }
        const lastIndex = actionStmts.length - 1;
        let preventDefaultVar = null;
        if (lastIndex >= 0) {
            const lastStatement = actionStmts[lastIndex];
            const returnExpr = convertStmtIntoExpression(lastStatement);
            if (returnExpr) {
                // Note: We need to cast the result of the method call to dynamic,
                // as it might be a void method!
                preventDefaultVar = createPreventDefaultVar(bindingId);
                actionStmts[lastIndex] =
                    preventDefaultVar.set(returnExpr.cast(DYNAMIC_TYPE).notIdentical(literal(false)))
                        .toDeclStmt(null, [StmtModifier.Final]);
            }
        }
        return new ConvertActionBindingResult(actionStmts, preventDefaultVar);
    }
    function convertPropertyBindingBuiltins(converterFactory, ast) {
        return convertBuiltins(converterFactory, ast);
    }
    class ConvertPropertyBindingResult {
        constructor(stmts, currValExpr) {
            this.stmts = stmts;
            this.currValExpr = currValExpr;
        }
    }
    var BindingForm;
    (function (BindingForm) {
        // The general form of binding expression, supports all expressions.
        BindingForm[BindingForm["General"] = 0] = "General";
        // Try to generate a simple binding (no temporaries or statements)
        // otherwise generate a general binding
        BindingForm[BindingForm["TrySimple"] = 1] = "TrySimple";
        // Inlines assignment of temporaries into the generated expression. The result may still
        // have statements attached for declarations of temporary variables.
        // This is the only relevant form for Ivy, the other forms are only used in ViewEngine.
        BindingForm[BindingForm["Expression"] = 2] = "Expression";
    })(BindingForm || (BindingForm = {}));
    /**
     * Converts the given expression AST into an executable output AST, assuming the expression
     * is used in property binding. The expression has to be preprocessed via
     * `convertPropertyBindingBuiltins`.
     */
    function convertPropertyBinding(localResolver, implicitReceiver, expressionWithoutBuiltins, bindingId, form, interpolationFunction) {
        if (!localResolver) {
            localResolver = new DefaultLocalResolver();
        }
        const visitor = new _AstToIrVisitor(localResolver, implicitReceiver, bindingId, interpolationFunction);
        const outputExpr = expressionWithoutBuiltins.visit(visitor, _Mode.Expression);
        const stmts = getStatementsFromVisitor(visitor, bindingId);
        if (visitor.usesImplicitReceiver) {
            localResolver.notifyImplicitReceiverUse();
        }
        if (visitor.temporaryCount === 0 && form == BindingForm.TrySimple) {
            return new ConvertPropertyBindingResult([], outputExpr);
        }
        else if (form === BindingForm.Expression) {
            return new ConvertPropertyBindingResult(stmts, outputExpr);
        }
        const currValExpr = createCurrValueExpr(bindingId);
        stmts.push(currValExpr.set(outputExpr).toDeclStmt(DYNAMIC_TYPE, [StmtModifier.Final]));
        return new ConvertPropertyBindingResult(stmts, currValExpr);
    }
    /**
     * Given some expression, such as a binding or interpolation expression, and a context expression to
     * look values up on, visit each facet of the given expression resolving values from the context
     * expression such that a list of arguments can be derived from the found values that can be used as
     * arguments to an external update instruction.
     *
     * @param localResolver The resolver to use to look up expressions by name appropriately
     * @param contextVariableExpression The expression representing the context variable used to create
     * the final argument expressions
     * @param expressionWithArgumentsToExtract The expression to visit to figure out what values need to
     * be resolved and what arguments list to build.
     * @param bindingId A name prefix used to create temporary variable names if they're needed for the
     * arguments generated
     * @returns An array of expressions that can be passed as arguments to instruction expressions like
     * `o.importExpr(R3.propertyInterpolate).callFn(result)`
     */
    function convertUpdateArguments(localResolver, contextVariableExpression, expressionWithArgumentsToExtract, bindingId) {
        const visitor = new _AstToIrVisitor(localResolver, contextVariableExpression, bindingId, undefined);
        const outputExpr = expressionWithArgumentsToExtract.visit(visitor, _Mode.Expression);
        if (visitor.usesImplicitReceiver) {
            localResolver.notifyImplicitReceiverUse();
        }
        const stmts = getStatementsFromVisitor(visitor, bindingId);
        // Removing the first argument, because it was a length for ViewEngine, not Ivy.
        let args = outputExpr.args.slice(1);
        if (expressionWithArgumentsToExtract instanceof Interpolation) {
            // If we're dealing with an interpolation of 1 value with an empty prefix and suffix, reduce the
            // args returned to just the value, because we're going to pass it to a special instruction.
            const strings = expressionWithArgumentsToExtract.strings;
            if (args.length === 3 && strings[0] === '' && strings[1] === '') {
                // Single argument interpolate instructions.
                args = [args[1]];
            }
            else if (args.length >= 19) {
                // 19 or more arguments must be passed to the `interpolateV`-style instructions, which accept
                // an array of arguments
                args = [literalArr(args)];
            }
        }
        return { stmts, args };
    }
    function getStatementsFromVisitor(visitor, bindingId) {
        const stmts = [];
        for (let i = 0; i < visitor.temporaryCount; i++) {
            stmts.push(temporaryDeclaration(bindingId, i));
        }
        return stmts;
    }
    function convertBuiltins(converterFactory, ast) {
        const visitor = new _BuiltinAstConverter(converterFactory);
        return ast.visit(visitor);
    }
    function temporaryName(bindingId, temporaryNumber) {
        return `tmp_${bindingId}_${temporaryNumber}`;
    }
    function temporaryDeclaration(bindingId, temporaryNumber) {
        return new DeclareVarStmt(temporaryName(bindingId, temporaryNumber));
    }
    function prependTemporaryDecls(temporaryCount, bindingId, statements) {
        for (let i = temporaryCount - 1; i >= 0; i--) {
            statements.unshift(temporaryDeclaration(bindingId, i));
        }
    }
    var _Mode;
    (function (_Mode) {
        _Mode[_Mode["Statement"] = 0] = "Statement";
        _Mode[_Mode["Expression"] = 1] = "Expression";
    })(_Mode || (_Mode = {}));
    function ensureStatementMode(mode, ast) {
        if (mode !== _Mode.Statement) {
            throw new Error(`Expected a statement, but saw ${ast}`);
        }
    }
    function ensureExpressionMode(mode, ast) {
        if (mode !== _Mode.Expression) {
            throw new Error(`Expected an expression, but saw ${ast}`);
        }
    }
    function convertToStatementIfNeeded(mode, expr) {
        if (mode === _Mode.Statement) {
            return expr.toStmt();
        }
        else {
            return expr;
        }
    }
    class _BuiltinAstConverter extends AstTransformer {
        constructor(_converterFactory) {
            super();
            this._converterFactory = _converterFactory;
        }
        visitPipe(ast, context) {
            const args = [ast.exp, ...ast.args].map(ast => ast.visit(this, context));
            return new BuiltinFunctionCall(ast.span, ast.sourceSpan, args, this._converterFactory.createPipeConverter(ast.name, args.length));
        }
        visitLiteralArray(ast, context) {
            const args = ast.expressions.map(ast => ast.visit(this, context));
            return new BuiltinFunctionCall(ast.span, ast.sourceSpan, args, this._converterFactory.createLiteralArrayConverter(ast.expressions.length));
        }
        visitLiteralMap(ast, context) {
            const args = ast.values.map(ast => ast.visit(this, context));
            return new BuiltinFunctionCall(ast.span, ast.sourceSpan, args, this._converterFactory.createLiteralMapConverter(ast.keys));
        }
    }
    class _AstToIrVisitor {
        constructor(_localResolver, _implicitReceiver, bindingId, interpolationFunction, baseSourceSpan, implicitReceiverAccesses) {
            this._localResolver = _localResolver;
            this._implicitReceiver = _implicitReceiver;
            this.bindingId = bindingId;
            this.interpolationFunction = interpolationFunction;
            this.baseSourceSpan = baseSourceSpan;
            this.implicitReceiverAccesses = implicitReceiverAccesses;
            this._nodeMap = new Map();
            this._resultMap = new Map();
            this._currentTemporary = 0;
            this.temporaryCount = 0;
            this.usesImplicitReceiver = false;
        }
        visitUnary(ast, mode) {
            let op;
            switch (ast.operator) {
                case '+':
                    op = UnaryOperator.Plus;
                    break;
                case '-':
                    op = UnaryOperator.Minus;
                    break;
                default:
                    throw new Error(`Unsupported operator ${ast.operator}`);
            }
            return convertToStatementIfNeeded(mode, new UnaryOperatorExpr(op, this._visit(ast.expr, _Mode.Expression), undefined, this.convertSourceSpan(ast.span)));
        }
        visitBinary(ast, mode) {
            let op;
            switch (ast.operation) {
                case '+':
                    op = BinaryOperator.Plus;
                    break;
                case '-':
                    op = BinaryOperator.Minus;
                    break;
                case '*':
                    op = BinaryOperator.Multiply;
                    break;
                case '/':
                    op = BinaryOperator.Divide;
                    break;
                case '%':
                    op = BinaryOperator.Modulo;
                    break;
                case '&&':
                    op = BinaryOperator.And;
                    break;
                case '||':
                    op = BinaryOperator.Or;
                    break;
                case '==':
                    op = BinaryOperator.Equals;
                    break;
                case '!=':
                    op = BinaryOperator.NotEquals;
                    break;
                case '===':
                    op = BinaryOperator.Identical;
                    break;
                case '!==':
                    op = BinaryOperator.NotIdentical;
                    break;
                case '<':
                    op = BinaryOperator.Lower;
                    break;
                case '>':
                    op = BinaryOperator.Bigger;
                    break;
                case '<=':
                    op = BinaryOperator.LowerEquals;
                    break;
                case '>=':
                    op = BinaryOperator.BiggerEquals;
                    break;
                case '??':
                    return this.convertNullishCoalesce(ast, mode);
                default:
                    throw new Error(`Unsupported operation ${ast.operation}`);
            }
            return convertToStatementIfNeeded(mode, new BinaryOperatorExpr(op, this._visit(ast.left, _Mode.Expression), this._visit(ast.right, _Mode.Expression), undefined, this.convertSourceSpan(ast.span)));
        }
        visitChain(ast, mode) {
            ensureStatementMode(mode, ast);
            return this.visitAll(ast.expressions, mode);
        }
        visitConditional(ast, mode) {
            const value = this._visit(ast.condition, _Mode.Expression);
            return convertToStatementIfNeeded(mode, value.conditional(this._visit(ast.trueExp, _Mode.Expression), this._visit(ast.falseExp, _Mode.Expression), this.convertSourceSpan(ast.span)));
        }
        visitPipe(ast, mode) {
            throw new Error(`Illegal state: Pipes should have been converted into functions. Pipe: ${ast.name}`);
        }
        visitFunctionCall(ast, mode) {
            const convertedArgs = this.visitAll(ast.args, _Mode.Expression);
            let fnResult;
            if (ast instanceof BuiltinFunctionCall) {
                fnResult = ast.converter(convertedArgs);
            }
            else {
                fnResult = this._visit(ast.target, _Mode.Expression)
                    .callFn(convertedArgs, this.convertSourceSpan(ast.span));
            }
            return convertToStatementIfNeeded(mode, fnResult);
        }
        visitImplicitReceiver(ast, mode) {
            ensureExpressionMode(mode, ast);
            this.usesImplicitReceiver = true;
            return this._implicitReceiver;
        }
        visitThisReceiver(ast, mode) {
            return this.visitImplicitReceiver(ast, mode);
        }
        visitInterpolation(ast, mode) {
            ensureExpressionMode(mode, ast);
            const args = [literal(ast.expressions.length)];
            for (let i = 0; i < ast.strings.length - 1; i++) {
                args.push(literal(ast.strings[i]));
                args.push(this._visit(ast.expressions[i], _Mode.Expression));
            }
            args.push(literal(ast.strings[ast.strings.length - 1]));
            if (this.interpolationFunction) {
                return this.interpolationFunction(args);
            }
            return ast.expressions.length <= 9 ?
                importExpr(Identifiers$1.inlineInterpolate).callFn(args) :
                importExpr(Identifiers$1.interpolate).callFn([
                    args[0], literalArr(args.slice(1), undefined, this.convertSourceSpan(ast.span))
                ]);
        }
        visitKeyedRead(ast, mode) {
            const leftMostSafe = this.leftMostSafeNode(ast);
            if (leftMostSafe) {
                return this.convertSafeAccess(ast, leftMostSafe, mode);
            }
            else {
                return convertToStatementIfNeeded(mode, this._visit(ast.receiver, _Mode.Expression).key(this._visit(ast.key, _Mode.Expression)));
            }
        }
        visitKeyedWrite(ast, mode) {
            const obj = this._visit(ast.receiver, _Mode.Expression);
            const key = this._visit(ast.key, _Mode.Expression);
            const value = this._visit(ast.value, _Mode.Expression);
            if (obj === this._implicitReceiver) {
                this._localResolver.maybeRestoreView();
            }
            return convertToStatementIfNeeded(mode, obj.key(key).set(value));
        }
        visitLiteralArray(ast, mode) {
            throw new Error(`Illegal State: literal arrays should have been converted into functions`);
        }
        visitLiteralMap(ast, mode) {
            throw new Error(`Illegal State: literal maps should have been converted into functions`);
        }
        visitLiteralPrimitive(ast, mode) {
            // For literal values of null, undefined, true, or false allow type interference
            // to infer the type.
            const type = ast.value === null || ast.value === undefined || ast.value === true || ast.value === true ?
                INFERRED_TYPE :
                undefined;
            return convertToStatementIfNeeded(mode, literal(ast.value, type, this.convertSourceSpan(ast.span)));
        }
        _getLocal(name, receiver) {
            var _a;
            if (((_a = this._localResolver.globals) === null || _a === void 0 ? void 0 : _a.has(name)) && receiver instanceof ThisReceiver) {
                return null;
            }
            return this._localResolver.getLocal(name);
        }
        visitMethodCall(ast, mode) {
            if (ast.receiver instanceof ImplicitReceiver &&
                !(ast.receiver instanceof ThisReceiver) && ast.name === '$any') {
                const args = this.visitAll(ast.args, _Mode.Expression);
                if (args.length != 1) {
                    throw new Error(`Invalid call to $any, expected 1 argument but received ${args.length || 'none'}`);
                }
                return args[0].cast(DYNAMIC_TYPE, this.convertSourceSpan(ast.span));
            }
            const leftMostSafe = this.leftMostSafeNode(ast);
            if (leftMostSafe) {
                return this.convertSafeAccess(ast, leftMostSafe, mode);
            }
            else {
                const args = this.visitAll(ast.args, _Mode.Expression);
                const prevUsesImplicitReceiver = this.usesImplicitReceiver;
                let result = null;
                const receiver = this._visit(ast.receiver, _Mode.Expression);
                if (receiver === this._implicitReceiver) {
                    const varExpr = this._getLocal(ast.name, ast.receiver);
                    if (varExpr) {
                        // Restore the previous "usesImplicitReceiver" state since the implicit
                        // receiver has been replaced with a resolved local expression.
                        this.usesImplicitReceiver = prevUsesImplicitReceiver;
                        result = varExpr.callFn(args);
                        this.addImplicitReceiverAccess(ast.name);
                    }
                }
                if (result == null) {
                    result = receiver.callMethod(ast.name, args, this.convertSourceSpan(ast.span));
                }
                return convertToStatementIfNeeded(mode, result);
            }
        }
        visitPrefixNot(ast, mode) {
            return convertToStatementIfNeeded(mode, not(this._visit(ast.expression, _Mode.Expression)));
        }
        visitNonNullAssert(ast, mode) {
            return convertToStatementIfNeeded(mode, assertNotNull(this._visit(ast.expression, _Mode.Expression)));
        }
        visitPropertyRead(ast, mode) {
            const leftMostSafe = this.leftMostSafeNode(ast);
            if (leftMostSafe) {
                return this.convertSafeAccess(ast, leftMostSafe, mode);
            }
            else {
                let result = null;
                const prevUsesImplicitReceiver = this.usesImplicitReceiver;
                const receiver = this._visit(ast.receiver, _Mode.Expression);
                if (receiver === this._implicitReceiver) {
                    result = this._getLocal(ast.name, ast.receiver);
                    if (result) {
                        // Restore the previous "usesImplicitReceiver" state since the implicit
                        // receiver has been replaced with a resolved local expression.
                        this.usesImplicitReceiver = prevUsesImplicitReceiver;
                        this.addImplicitReceiverAccess(ast.name);
                    }
                }
                if (result == null) {
                    result = receiver.prop(ast.name);
                }
                return convertToStatementIfNeeded(mode, result);
            }
        }
        visitPropertyWrite(ast, mode) {
            const receiver = this._visit(ast.receiver, _Mode.Expression);
            const prevUsesImplicitReceiver = this.usesImplicitReceiver;
            let varExpr = null;
            if (receiver === this._implicitReceiver) {
                const localExpr = this._getLocal(ast.name, ast.receiver);
                if (localExpr) {
                    if (localExpr instanceof ReadPropExpr) {
                        // If the local variable is a property read expression, it's a reference
                        // to a 'context.property' value and will be used as the target of the
                        // write expression.
                        varExpr = localExpr;
                        // Restore the previous "usesImplicitReceiver" state since the implicit
                        // receiver has been replaced with a resolved local expression.
                        this.usesImplicitReceiver = prevUsesImplicitReceiver;
                        this.addImplicitReceiverAccess(ast.name);
                    }
                    else {
                        // Otherwise it's an error.
                        const receiver = ast.name;
                        const value = (ast.value instanceof PropertyRead) ? ast.value.name : undefined;
                        throw new Error(`Cannot assign value "${value}" to template variable "${receiver}". Template variables are read-only.`);
                    }
                }
            }
            // If no local expression could be produced, use the original receiver's
            // property as the target.
            if (varExpr === null) {
                varExpr = receiver.prop(ast.name);
            }
            return convertToStatementIfNeeded(mode, varExpr.set(this._visit(ast.value, _Mode.Expression)));
        }
        visitSafePropertyRead(ast, mode) {
            return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);
        }
        visitSafeMethodCall(ast, mode) {
            return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);
        }
        visitSafeKeyedRead(ast, mode) {
            return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);
        }
        visitAll(asts, mode) {
            return asts.map(ast => this._visit(ast, mode));
        }
        visitQuote(ast, mode) {
            throw new Error(`Quotes are not supported for evaluation!
        Statement: ${ast.uninterpretedExpression} located at ${ast.location}`);
        }
        _visit(ast, mode) {
            const result = this._resultMap.get(ast);
            if (result)
                return result;
            return (this._nodeMap.get(ast) || ast).visit(this, mode);
        }
        convertSafeAccess(ast, leftMostSafe, mode) {
            // If the expression contains a safe access node on the left it needs to be converted to
            // an expression that guards the access to the member by checking the receiver for blank. As
            // execution proceeds from left to right, the left most part of the expression must be guarded
            // first but, because member access is left associative, the right side of the expression is at
            // the top of the AST. The desired result requires lifting a copy of the left part of the
            // expression up to test it for blank before generating the unguarded version.
            // Consider, for example the following expression: a?.b.c?.d.e
            // This results in the ast:
            //         .
            //        / \
            //       ?.   e
            //      /  \
            //     .    d
            //    / \
            //   ?.  c
            //  /  \
            // a    b
            // The following tree should be generated:
            //
            //        /---- ? ----\
            //       /      |      \
            //     a   /--- ? ---\  null
            //        /     |     \
            //       .      .     null
            //      / \    / \
            //     .  c   .   e
            //    / \    / \
            //   a   b  .   d
            //         / \
            //        .   c
            //       / \
            //      a   b
            //
            // Notice that the first guard condition is the left hand of the left most safe access node
            // which comes in as leftMostSafe to this routine.
            let guardedExpression = this._visit(leftMostSafe.receiver, _Mode.Expression);
            let temporary = undefined;
            if (this.needsTemporaryInSafeAccess(leftMostSafe.receiver)) {
                // If the expression has method calls or pipes then we need to save the result into a
                // temporary variable to avoid calling stateful or impure code more than once.
                temporary = this.allocateTemporary();
                // Preserve the result in the temporary variable
                guardedExpression = temporary.set(guardedExpression);
                // Ensure all further references to the guarded expression refer to the temporary instead.
                this._resultMap.set(leftMostSafe.receiver, temporary);
            }
            const condition = guardedExpression.isBlank();
            // Convert the ast to an unguarded access to the receiver's member. The map will substitute
            // leftMostNode with its unguarded version in the call to `this.visit()`.
            if (leftMostSafe instanceof SafeMethodCall) {
                this._nodeMap.set(leftMostSafe, new MethodCall(leftMostSafe.span, leftMostSafe.sourceSpan, leftMostSafe.nameSpan, leftMostSafe.receiver, leftMostSafe.name, leftMostSafe.args, leftMostSafe.argumentSpan));
            }
            else if (leftMostSafe instanceof SafeKeyedRead) {
                this._nodeMap.set(leftMostSafe, new KeyedRead(leftMostSafe.span, leftMostSafe.sourceSpan, leftMostSafe.receiver, leftMostSafe.key));
            }
            else {
                this._nodeMap.set(leftMostSafe, new PropertyRead(leftMostSafe.span, leftMostSafe.sourceSpan, leftMostSafe.nameSpan, leftMostSafe.receiver, leftMostSafe.name));
            }
            // Recursively convert the node now without the guarded member access.
            const access = this._visit(ast, _Mode.Expression);
            // Remove the mapping. This is not strictly required as the converter only traverses each node
            // once but is safer if the conversion is changed to traverse the nodes more than once.
            this._nodeMap.delete(leftMostSafe);
            // If we allocated a temporary, release it.
            if (temporary) {
                this.releaseTemporary(temporary);
            }
            // Produce the conditional
            return convertToStatementIfNeeded(mode, condition.conditional(NULL_EXPR, access));
        }
        convertNullishCoalesce(ast, mode) {
            const left = this._visit(ast.left, _Mode.Expression);
            const right = this._visit(ast.right, _Mode.Expression);
            const temporary = this.allocateTemporary();
            this.releaseTemporary(temporary);
            // Generate the following expression. It is identical to how TS
            // transpiles binary expressions with a nullish coalescing operator.
            // let temp;
            // (temp = a) !== null && temp !== undefined ? temp : b;
            return convertToStatementIfNeeded(mode, temporary.set(left)
                .notIdentical(NULL_EXPR)
                .and(temporary.notIdentical(literal(undefined)))
                .conditional(temporary, right));
        }
        // Given an expression of the form a?.b.c?.d.e then the left most safe node is
        // the (a?.b). The . and ?. are left associative thus can be rewritten as:
        // ((((a?.c).b).c)?.d).e. This returns the most deeply nested safe read or
        // safe method call as this needs to be transformed initially to:
        //   a == null ? null : a.c.b.c?.d.e
        // then to:
        //   a == null ? null : a.b.c == null ? null : a.b.c.d.e
        leftMostSafeNode(ast) {
            const visit = (visitor, ast) => {
                return (this._nodeMap.get(ast) || ast).visit(visitor);
            };
            return ast.visit({
                visitUnary(ast) {
                    return null;
                },
                visitBinary(ast) {
                    return null;
                },
                visitChain(ast) {
                    return null;
                },
                visitConditional(ast) {
                    return null;
                },
                visitFunctionCall(ast) {
                    return null;
                },
                visitImplicitReceiver(ast) {
                    return null;
                },
                visitThisReceiver(ast) {
                    return null;
                },
                visitInterpolation(ast) {
                    return null;
                },
                visitKeyedRead(ast) {
                    return visit(this, ast.receiver);
                },
                visitKeyedWrite(ast) {
                    return null;
                },
                visitLiteralArray(ast) {
                    return null;
                },
                visitLiteralMap(ast) {
                    return null;
                },
                visitLiteralPrimitive(ast) {
                    return null;
                },
                visitMethodCall(ast) {
                    return visit(this, ast.receiver);
                },
                visitPipe(ast) {
                    return null;
                },
                visitPrefixNot(ast) {
                    return null;
                },
                visitNonNullAssert(ast) {
                    return null;
                },
                visitPropertyRead(ast) {
                    return visit(this, ast.receiver);
                },
                visitPropertyWrite(ast) {
                    return null;
                },
                visitQuote(ast) {
                    return null;
                },
                visitSafeMethodCall(ast) {
                    return visit(this, ast.receiver) || ast;
                },
                visitSafePropertyRead(ast) {
                    return visit(this, ast.receiver) || ast;
                },
                visitSafeKeyedRead(ast) {
                    return visit(this, ast.receiver) || ast;
                }
            });
        }
        // Returns true of the AST includes a method or a pipe indicating that, if the
        // expression is used as the target of a safe property or method access then
        // the expression should be stored into a temporary variable.
        needsTemporaryInSafeAccess(ast) {
            const visit = (visitor, ast) => {
                return ast && (this._nodeMap.get(ast) || ast).visit(visitor);
            };
            const visitSome = (visitor, ast) => {
                return ast.some(ast => visit(visitor, ast));
            };
            return ast.visit({
                visitUnary(ast) {
                    return visit(this, ast.expr);
                },
                visitBinary(ast) {
                    return visit(this, ast.left) || visit(this, ast.right);
                },
                visitChain(ast) {
                    return false;
                },
                visitConditional(ast) {
                    return visit(this, ast.condition) || visit(this, ast.trueExp) || visit(this, ast.falseExp);
                },
                visitFunctionCall(ast) {
                    return true;
                },
                visitImplicitReceiver(ast) {
                    return false;
                },
                visitThisReceiver(ast) {
                    return false;
                },
                visitInterpolation(ast) {
                    return visitSome(this, ast.expressions);
                },
                visitKeyedRead(ast) {
                    return false;
                },
                visitKeyedWrite(ast) {
                    return false;
                },
                visitLiteralArray(ast) {
                    return true;
                },
                visitLiteralMap(ast) {
                    return true;
                },
                visitLiteralPrimitive(ast) {
                    return false;
                },
                visitMethodCall(ast) {
                    return true;
                },
                visitPipe(ast) {
                    return true;
                },
                visitPrefixNot(ast) {
                    return visit(this, ast.expression);
                },
                visitNonNullAssert(ast) {
                    return visit(this, ast.expression);
                },
                visitPropertyRead(ast) {
                    return false;
                },
                visitPropertyWrite(ast) {
                    return false;
                },
                visitQuote(ast) {
                    return false;
                },
                visitSafeMethodCall(ast) {
                    return true;
                },
                visitSafePropertyRead(ast) {
                    return false;
                },
                visitSafeKeyedRead(ast) {
                    return false;
                }
            });
        }
        allocateTemporary() {
            const tempNumber = this._currentTemporary++;
            this.temporaryCount = Math.max(this._currentTemporary, this.temporaryCount);
            return new ReadVarExpr(temporaryName(this.bindingId, tempNumber));
        }
        releaseTemporary(temporary) {
            this._currentTemporary--;
            if (temporary.name != temporaryName(this.bindingId, this._currentTemporary)) {
                throw new Error(`Temporary ${temporary.name} released out of order`);
            }
        }
        /**
         * Creates an absolute `ParseSourceSpan` from the relative `ParseSpan`.
         *
         * `ParseSpan` objects are relative to the start of the expression.
         * This method converts these to full `ParseSourceSpan` objects that
         * show where the span is within the overall source file.
         *
         * @param span the relative span to convert.
         * @returns a `ParseSourceSpan` for the given span or null if no
         * `baseSourceSpan` was provided to this class.
         */
        convertSourceSpan(span) {
            if (this.baseSourceSpan) {
                const start = this.baseSourceSpan.start.moveBy(span.start);
                const end = this.baseSourceSpan.start.moveBy(span.end);
                const fullStart = this.baseSourceSpan.fullStart.moveBy(span.start);
                return new ParseSourceSpan(start, end, fullStart);
            }
            else {
                return null;
            }
        }
        /** Adds the name of an AST to the list of implicit receiver accesses. */
        addImplicitReceiverAccess(name) {
            if (this.implicitReceiverAccesses) {
                this.implicitReceiverAccesses.add(name);
            }
        }
    }
    function flattenStatements(arg, output) {
        if (Array.isArray(arg)) {
            arg.forEach((entry) => flattenStatements(entry, output));
        }
        else {
            output.push(arg);
        }
    }
    class DefaultLocalResolver {
        constructor(globals) {
            this.globals = globals;
        }
        notifyImplicitReceiverUse() { }
        maybeRestoreView() { }
        getLocal(name) {
            if (name === EventHandlerVars.event.name) {
                return EventHandlerVars.event;
            }
            return null;
        }
    }
    function createCurrValueExpr(bindingId) {
        return variable(`currVal_${bindingId}`); // fix syntax highlighting: `
    }
    function createPreventDefaultVar(bindingId) {
        return variable(`pd_${bindingId}`);
    }
    function convertStmtIntoExpression(stmt) {
        if (stmt instanceof ExpressionStatement) {
            return stmt.expr;
        }
        else if (stmt instanceof ReturnStatement) {
            return stmt.value;
        }
        return null;
    }
    class BuiltinFunctionCall extends FunctionCall {
        constructor(span, sourceSpan, args, converter) {
            super(span, sourceSpan, null, args);
            this.converter = converter;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * This file is a port of shadowCSS from webcomponents.js to TypeScript.
     *
     * Please make sure to keep to edits in sync with the source file.
     *
     * Source:
     * https://github.com/webcomponents/webcomponentsjs/blob/4efecd7e0e/src/ShadowCSS/ShadowCSS.js
     *
     * The original file level comment is reproduced below
     */
    /*
      This is a limited shim for ShadowDOM css styling.
      https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html#styles

      The intention here is to support only the styling features which can be
      relatively simply implemented. The goal is to allow users to avoid the
      most obvious pitfalls and do so without compromising performance significantly.
      For ShadowDOM styling that's not covered here, a set of best practices
      can be provided that should allow users to accomplish more complex styling.

      The following is a list of specific ShadowDOM styling features and a brief
      discussion of the approach used to shim.

      Shimmed features:

      * :host, :host-context: ShadowDOM allows styling of the shadowRoot's host
      element using the :host rule. To shim this feature, the :host styles are
      reformatted and prefixed with a given scope name and promoted to a
      document level stylesheet.
      For example, given a scope name of .foo, a rule like this:

        :host {
            background: red;
          }
        }

      becomes:

        .foo {
          background: red;
        }

      * encapsulation: Styles defined within ShadowDOM, apply only to
      dom inside the ShadowDOM. Polymer uses one of two techniques to implement
      this feature.

      By default, rules are prefixed with the host element tag name
      as a descendant selector. This ensures styling does not leak out of the 'top'
      of the element's ShadowDOM. For example,

      div {
          font-weight: bold;
        }

      becomes:

      x-foo div {
          font-weight: bold;
        }

      becomes:


      Alternatively, if WebComponents.ShadowCSS.strictStyling is set to true then
      selectors are scoped by adding an attribute selector suffix to each
      simple selector that contains the host element tag name. Each element
      in the element's ShadowDOM template is also given the scope attribute.
      Thus, these rules match only elements that have the scope attribute.
      For example, given a scope name of x-foo, a rule like this:

        div {
          font-weight: bold;
        }

      becomes:

        div[x-foo] {
          font-weight: bold;
        }

      Note that elements that are dynamically added to a scope must have the scope
      selector added to them manually.

      * upper/lower bound encapsulation: Styles which are defined outside a
      shadowRoot should not cross the ShadowDOM boundary and should not apply
      inside a shadowRoot.

      This styling behavior is not emulated. Some possible ways to do this that
      were rejected due to complexity and/or performance concerns include: (1) reset
      every possible property for every possible selector for a given scope name;
      (2) re-implement css in javascript.

      As an alternative, users should make sure to use selectors
      specific to the scope in which they are working.

      * ::distributed: This behavior is not emulated. It's often not necessary
      to style the contents of a specific insertion point and instead, descendants
      of the host element can be styled selectively. Users can also create an
      extra node around an insertion point and style that node's contents
      via descendent selectors. For example, with a shadowRoot like this:

        <style>
          ::content(div) {
            background: red;
          }
        </style>
        <content></content>

      could become:

        <style>
          / *@polyfill .content-container div * /
          ::content(div) {
            background: red;
          }
        </style>
        <div class="content-container">
          <content></content>
        </div>

      Note the use of @polyfill in the comment above a ShadowDOM specific style
      declaration. This is a directive to the styling shim to use the selector
      in comments in lieu of the next selector when running under polyfill.
    */
    class ShadowCss {
        constructor() {
            this.strictStyling = true;
        }
        /*
         * Shim some cssText with the given selector. Returns cssText that can
         * be included in the document via WebComponents.ShadowCSS.addCssToDocument(css).
         *
         * When strictStyling is true:
         * - selector is the attribute added to all elements inside the host,
         * - hostSelector is the attribute added to the host itself.
         */
        shimCssText(cssText, selector, hostSelector = '') {
            const commentsWithHash = extractCommentsWithHash(cssText);
            cssText = stripComments(cssText);
            cssText = this._insertDirectives(cssText);
            const scopedCssText = this._scopeCssText(cssText, selector, hostSelector);
            return [scopedCssText, ...commentsWithHash].join('\n');
        }
        _insertDirectives(cssText) {
            cssText = this._insertPolyfillDirectivesInCssText(cssText);
            return this._insertPolyfillRulesInCssText(cssText);
        }
        /*
         * Process styles to convert native ShadowDOM rules that will trip
         * up the css parser; we rely on decorating the stylesheet with inert rules.
         *
         * For example, we convert this rule:
         *
         * polyfill-next-selector { content: ':host menu-item'; }
         * ::content menu-item {
         *
         * to this:
         *
         * scopeName menu-item {
         *
         **/
        _insertPolyfillDirectivesInCssText(cssText) {
            // Difference with webcomponents.js: does not handle comments
            return cssText.replace(_cssContentNextSelectorRe, function (...m) {
                return m[2] + '{';
            });
        }
        /*
         * Process styles to add rules which will only apply under the polyfill
         *
         * For example, we convert this rule:
         *
         * polyfill-rule {
         *   content: ':host menu-item';
         * ...
         * }
         *
         * to this:
         *
         * scopeName menu-item {...}
         *
         **/
        _insertPolyfillRulesInCssText(cssText) {
            // Difference with webcomponents.js: does not handle comments
            return cssText.replace(_cssContentRuleRe, (...m) => {
                const rule = m[0].replace(m[1], '').replace(m[2], '');
                return m[4] + rule;
            });
        }
        /* Ensure styles are scoped. Pseudo-scoping takes a rule like:
         *
         *  .foo {... }
         *
         *  and converts this to
         *
         *  scopeName .foo { ... }
         */
        _scopeCssText(cssText, scopeSelector, hostSelector) {
            const unscopedRules = this._extractUnscopedRulesFromCssText(cssText);
            // replace :host and :host-context -shadowcsshost and -shadowcsshost respectively
            cssText = this._insertPolyfillHostInCssText(cssText);
            cssText = this._convertColonHost(cssText);
            cssText = this._convertColonHostContext(cssText);
            cssText = this._convertShadowDOMSelectors(cssText);
            if (scopeSelector) {
                cssText = this._scopeSelectors(cssText, scopeSelector, hostSelector);
            }
            cssText = cssText + '\n' + unscopedRules;
            return cssText.trim();
        }
        /*
         * Process styles to add rules which will only apply under the polyfill
         * and do not process via CSSOM. (CSSOM is destructive to rules on rare
         * occasions, e.g. -webkit-calc on Safari.)
         * For example, we convert this rule:
         *
         * @polyfill-unscoped-rule {
         *   content: 'menu-item';
         * ... }
         *
         * to this:
         *
         * menu-item {...}
         *
         **/
        _extractUnscopedRulesFromCssText(cssText) {
            // Difference with webcomponents.js: does not handle comments
            let r = '';
            let m;
            _cssContentUnscopedRuleRe.lastIndex = 0;
            while ((m = _cssContentUnscopedRuleRe.exec(cssText)) !== null) {
                const rule = m[0].replace(m[2], '').replace(m[1], m[4]);
                r += rule + '\n\n';
            }
            return r;
        }
        /*
         * convert a rule like :host(.foo) > .bar { }
         *
         * to
         *
         * .foo<scopeName> > .bar
         */
        _convertColonHost(cssText) {
            return cssText.replace(_cssColonHostRe, (_, hostSelectors, otherSelectors) => {
                if (hostSelectors) {
                    const convertedSelectors = [];
                    const hostSelectorArray = hostSelectors.split(',').map(p => p.trim());
                    for (const hostSelector of hostSelectorArray) {
                        if (!hostSelector)
                            break;
                        const convertedSelector = _polyfillHostNoCombinator + hostSelector.replace(_polyfillHost, '') + otherSelectors;
                        convertedSelectors.push(convertedSelector);
                    }
                    return convertedSelectors.join(',');
                }
                else {
                    return _polyfillHostNoCombinator + otherSelectors;
                }
            });
        }
        /*
         * convert a rule like :host-context(.foo) > .bar { }
         *
         * to
         *
         * .foo<scopeName> > .bar, .foo <scopeName> > .bar { }
         *
         * and
         *
         * :host-context(.foo:host) .bar { ... }
         *
         * to
         *
         * .foo<scopeName> .bar { ... }
         */
        _convertColonHostContext(cssText) {
            return cssText.replace(_cssColonHostContextReGlobal, selectorText => {
                // We have captured a selector that contains a `:host-context` rule.
                var _a;
                // For backward compatibility `:host-context` may contain a comma separated list of selectors.
                // Each context selector group will contain a list of host-context selectors that must match
                // an ancestor of the host.
                // (Normally `contextSelectorGroups` will only contain a single array of context selectors.)
                const contextSelectorGroups = [[]];
                // There may be more than `:host-context` in this selector so `selectorText` could look like:
                // `:host-context(.one):host-context(.two)`.
                // Execute `_cssColonHostContextRe` over and over until we have extracted all the
                // `:host-context` selectors from this selector.
                let match;
                while (match = _cssColonHostContextRe.exec(selectorText)) {
                    // `match` = [':host-context(<selectors>)<rest>', <selectors>, <rest>]
                    // The `<selectors>` could actually be a comma separated list: `:host-context(.one, .two)`.
                    const newContextSelectors = ((_a = match[1]) !== null && _a !== void 0 ? _a : '').trim().split(',').map(m => m.trim()).filter(m => m !== '');
                    // We must duplicate the current selector group for each of these new selectors.
                    // For example if the current groups are:
                    // ```
                    // [
                    //   ['a', 'b', 'c'],
                    //   ['x', 'y', 'z'],
                    // ]
                    // ```
                    // And we have a new set of comma separated selectors: `:host-context(m,n)` then the new
                    // groups are:
                    // ```
                    // [
                    //   ['a', 'b', 'c', 'm'],
                    //   ['x', 'y', 'z', 'm'],
                    //   ['a', 'b', 'c', 'n'],
                    //   ['x', 'y', 'z', 'n'],
                    // ]
                    // ```
                    const contextSelectorGroupsLength = contextSelectorGroups.length;
                    repeatGroups(contextSelectorGroups, newContextSelectors.length);
                    for (let i = 0; i < newContextSelectors.length; i++) {
                        for (let j = 0; j < contextSelectorGroupsLength; j++) {
                            contextSelectorGroups[j + (i * contextSelectorGroupsLength)].push(newContextSelectors[i]);
                        }
                    }
                    // Update the `selectorText` and see repeat to see if there are more `:host-context`s.
                    selectorText = match[2];
                }
                // The context selectors now must be combined with each other to capture all the possible
                // selectors that `:host-context` can match. See `combineHostContextSelectors()` for more
                // info about how this is done.
                return contextSelectorGroups
                    .map(contextSelectors => combineHostContextSelectors(contextSelectors, selectorText))
                    .join(', ');
            });
        }
        /*
         * Convert combinators like ::shadow and pseudo-elements like ::content
         * by replacing with space.
         */
        _convertShadowDOMSelectors(cssText) {
            return _shadowDOMSelectorsRe.reduce((result, pattern) => result.replace(pattern, ' '), cssText);
        }
        // change a selector like 'div' to 'name div'
        _scopeSelectors(cssText, scopeSelector, hostSelector) {
            return processRules(cssText, (rule) => {
                let selector = rule.selector;
                let content = rule.content;
                if (rule.selector[0] !== '@') {
                    selector =
                        this._scopeSelector(rule.selector, scopeSelector, hostSelector, this.strictStyling);
                }
                else if (rule.selector.startsWith('@media') || rule.selector.startsWith('@supports') ||
                    rule.selector.startsWith('@document')) {
                    content = this._scopeSelectors(rule.content, scopeSelector, hostSelector);
                }
                else if (rule.selector.startsWith('@font-face') || rule.selector.startsWith('@page')) {
                    content = this._stripScopingSelectors(rule.content);
                }
                return new CssRule(selector, content);
            });
        }
        /**
         * Handle a css text that is within a rule that should not contain scope selectors by simply
         * removing them! An example of such a rule is `@font-face`.
         *
         * `@font-face` rules cannot contain nested selectors. Nor can they be nested under a selector.
         * Normally this would be a syntax error by the author of the styles. But in some rare cases, such
         * as importing styles from a library, and applying `:host ::ng-deep` to the imported styles, we
         * can end up with broken css if the imported styles happen to contain @font-face rules.
         *
         * For example:
         *
         * ```
         * :host ::ng-deep {
         *   import 'some/lib/containing/font-face';
         * }
         *
         * Similar logic applies to `@page` rules which can contain a particular set of properties,
         * as well as some specific at-rules. Since they can't be encapsulated, we have to strip
         * any scoping selectors from them. For more information: https://www.w3.org/TR/css-page-3
         * ```
         */
        _stripScopingSelectors(cssText) {
            return processRules(cssText, rule => {
                const selector = rule.selector.replace(_shadowDeepSelectors, ' ')
                    .replace(_polyfillHostNoCombinatorRe, ' ');
                return new CssRule(selector, rule.content);
            });
        }
        _scopeSelector(selector, scopeSelector, hostSelector, strict) {
            return selector.split(',')
                .map(part => part.trim().split(_shadowDeepSelectors))
                .map((deepParts) => {
                const [shallowPart, ...otherParts] = deepParts;
                const applyScope = (shallowPart) => {
                    if (this._selectorNeedsScoping(shallowPart, scopeSelector)) {
                        return strict ?
                            this._applyStrictSelectorScope(shallowPart, scopeSelector, hostSelector) :
                            this._applySelectorScope(shallowPart, scopeSelector, hostSelector);
                    }
                    else {
                        return shallowPart;
                    }
                };
                return [applyScope(shallowPart), ...otherParts].join(' ');
            })
                .join(', ');
        }
        _selectorNeedsScoping(selector, scopeSelector) {
            const re = this._makeScopeMatcher(scopeSelector);
            return !re.test(selector);
        }
        _makeScopeMatcher(scopeSelector) {
            const lre = /\[/g;
            const rre = /\]/g;
            scopeSelector = scopeSelector.replace(lre, '\\[').replace(rre, '\\]');
            return new RegExp('^(' + scopeSelector + ')' + _selectorReSuffix, 'm');
        }
        _applySelectorScope(selector, scopeSelector, hostSelector) {
            // Difference from webcomponents.js: scopeSelector could not be an array
            return this._applySimpleSelectorScope(selector, scopeSelector, hostSelector);
        }
        // scope via name and [is=name]
        _applySimpleSelectorScope(selector, scopeSelector, hostSelector) {
            // In Android browser, the lastIndex is not reset when the regex is used in String.replace()
            _polyfillHostRe.lastIndex = 0;
            if (_polyfillHostRe.test(selector)) {
                const replaceBy = this.strictStyling ? `[${hostSelector}]` : scopeSelector;
                return selector
                    .replace(_polyfillHostNoCombinatorRe, (hnc, selector) => {
                    return selector.replace(/([^:]*)(:*)(.*)/, (_, before, colon, after) => {
                        return before + replaceBy + colon + after;
                    });
                })
                    .replace(_polyfillHostRe, replaceBy + ' ');
            }
            return scopeSelector + ' ' + selector;
        }
        // return a selector with [name] suffix on each simple selector
        // e.g. .foo.bar > .zot becomes .foo[name].bar[name] > .zot[name]  /** @internal */
        _applyStrictSelectorScope(selector, scopeSelector, hostSelector) {
            const isRe = /\[is=([^\]]*)\]/g;
            scopeSelector = scopeSelector.replace(isRe, (_, ...parts) => parts[0]);
            const attrName = '[' + scopeSelector + ']';
            const _scopeSelectorPart = (p) => {
                let scopedP = p.trim();
                if (!scopedP) {
                    return '';
                }
                if (p.indexOf(_polyfillHostNoCombinator) > -1) {
                    scopedP = this._applySimpleSelectorScope(p, scopeSelector, hostSelector);
                }
                else {
                    // remove :host since it should be unnecessary
                    const t = p.replace(_polyfillHostRe, '');
                    if (t.length > 0) {
                        const matches = t.match(/([^:]*)(:*)(.*)/);
                        if (matches) {
                            scopedP = matches[1] + attrName + matches[2] + matches[3];
                        }
                    }
                }
                return scopedP;
            };
            const safeContent = new SafeSelector(selector);
            selector = safeContent.content();
            let scopedSelector = '';
            let startIndex = 0;
            let res;
            const sep = /( |>|\+|~(?!=))\s*/g;
            // If a selector appears before :host it should not be shimmed as it
            // matches on ancestor elements and not on elements in the host's shadow
            // `:host-context(div)` is transformed to
            // `-shadowcsshost-no-combinatordiv, div -shadowcsshost-no-combinator`
            // the `div` is not part of the component in the 2nd selectors and should not be scoped.
            // Historically `component-tag:host` was matching the component so we also want to preserve
            // this behavior to avoid breaking legacy apps (it should not match).
            // The behavior should be:
            // - `tag:host` -> `tag[h]` (this is to avoid breaking legacy apps, should not match anything)
            // - `tag :host` -> `tag [h]` (`tag` is not scoped because it's considered part of a
            //   `:host-context(tag)`)
            const hasHost = selector.indexOf(_polyfillHostNoCombinator) > -1;
            // Only scope parts after the first `-shadowcsshost-no-combinator` when it is present
            let shouldScope = !hasHost;
            while ((res = sep.exec(selector)) !== null) {
                const separator = res[1];
                const part = selector.slice(startIndex, res.index).trim();
                shouldScope = shouldScope || part.indexOf(_polyfillHostNoCombinator) > -1;
                const scopedPart = shouldScope ? _scopeSelectorPart(part) : part;
                scopedSelector += `${scopedPart} ${separator} `;
                startIndex = sep.lastIndex;
            }
            const part = selector.substring(startIndex);
            shouldScope = shouldScope || part.indexOf(_polyfillHostNoCombinator) > -1;
            scopedSelector += shouldScope ? _scopeSelectorPart(part) : part;
            // replace the placeholders with their original values
            return safeContent.restore(scopedSelector);
        }
        _insertPolyfillHostInCssText(selector) {
            return selector.replace(_colonHostContextRe, _polyfillHostContext)
                .replace(_colonHostRe, _polyfillHost);
        }
    }
    class SafeSelector {
        constructor(selector) {
            this.placeholders = [];
            this.index = 0;
            // Replaces attribute selectors with placeholders.
            // The WS in [attr="va lue"] would otherwise be interpreted as a selector separator.
            selector = this._escapeRegexMatches(selector, /(\[[^\]]*\])/g);
            // CSS allows for certain special characters to be used in selectors if they're escaped.
            // E.g. `.foo:blue` won't match a class called `foo:blue`, because the colon denotes a
            // pseudo-class, but writing `.foo\:blue` will match, because the colon was escaped.
            // Replace all escape sequences (`\` followed by a character) with a placeholder so
            // that our handling of pseudo-selectors doesn't mess with them.
            selector = this._escapeRegexMatches(selector, /(\\.)/g);
            // Replaces the expression in `:nth-child(2n + 1)` with a placeholder.
            // WS and "+" would otherwise be interpreted as selector separators.
            this._content = selector.replace(/(:nth-[-\w]+)(\([^)]+\))/g, (_, pseudo, exp) => {
                const replaceBy = `__ph-${this.index}__`;
                this.placeholders.push(exp);
                this.index++;
                return pseudo + replaceBy;
            });
        }
        restore(content) {
            return content.replace(/__ph-(\d+)__/g, (_ph, index) => this.placeholders[+index]);
        }
        content() {
            return this._content;
        }
        /**
         * Replaces all of the substrings that match a regex within a
         * special string (e.g. `__ph-0__`, `__ph-1__`, etc).
         */
        _escapeRegexMatches(content, pattern) {
            return content.replace(pattern, (_, keep) => {
                const replaceBy = `__ph-${this.index}__`;
                this.placeholders.push(keep);
                this.index++;
                return replaceBy;
            });
        }
    }
    const _cssContentNextSelectorRe = /polyfill-next-selector[^}]*content:[\s]*?(['"])(.*?)\1[;\s]*}([^{]*?){/gim;
    const _cssContentRuleRe = /(polyfill-rule)[^}]*(content:[\s]*(['"])(.*?)\3)[;\s]*[^}]*}/gim;
    const _cssContentUnscopedRuleRe = /(polyfill-unscoped-rule)[^}]*(content:[\s]*(['"])(.*?)\3)[;\s]*[^}]*}/gim;
    const _polyfillHost = '-shadowcsshost';
    // note: :host-context pre-processed to -shadowcsshostcontext.
    const _polyfillHostContext = '-shadowcsscontext';
    const _parenSuffix = '(?:\\((' +
        '(?:\\([^)(]*\\)|[^)(]*)+?' +
        ')\\))?([^,{]*)';
    const _cssColonHostRe = new RegExp(_polyfillHost + _parenSuffix, 'gim');
    const _cssColonHostContextReGlobal = new RegExp(_polyfillHostContext + _parenSuffix, 'gim');
    const _cssColonHostContextRe = new RegExp(_polyfillHostContext + _parenSuffix, 'im');
    const _polyfillHostNoCombinator = _polyfillHost + '-no-combinator';
    const _polyfillHostNoCombinatorRe = /-shadowcsshost-no-combinator([^\s]*)/;
    const _shadowDOMSelectorsRe = [
        /::shadow/g,
        /::content/g,
        // Deprecated selectors
        /\/shadow-deep\//g,
        /\/shadow\//g,
    ];
    // The deep combinator is deprecated in the CSS spec
    // Support for `>>>`, `deep`, `::ng-deep` is then also deprecated and will be removed in the future.
    // see https://github.com/angular/angular/pull/17677
    const _shadowDeepSelectors = /(?:>>>)|(?:\/deep\/)|(?:::ng-deep)/g;
    const _selectorReSuffix = '([>\\s~+[.,{:][\\s\\S]*)?$';
    const _polyfillHostRe = /-shadowcsshost/gim;
    const _colonHostRe = /:host/gim;
    const _colonHostContextRe = /:host-context/gim;
    const _commentRe = /\/\*[\s\S]*?\*\//g;
    function stripComments(input) {
        return input.replace(_commentRe, '');
    }
    const _commentWithHashRe = /\/\*\s*#\s*source(Mapping)?URL=[\s\S]+?\*\//g;
    function extractCommentsWithHash(input) {
        return input.match(_commentWithHashRe) || [];
    }
    const BLOCK_PLACEHOLDER = '%BLOCK%';
    const QUOTE_PLACEHOLDER = '%QUOTED%';
    const _ruleRe = /(\s*)([^;\{\}]+?)(\s*)((?:{%BLOCK%}?\s*;?)|(?:\s*;))/g;
    const _quotedRe = /%QUOTED%/g;
    const CONTENT_PAIRS = new Map([['{', '}']]);
    const QUOTE_PAIRS = new Map([[`"`, `"`], [`'`, `'`]]);
    class CssRule {
        constructor(selector, content) {
            this.selector = selector;
            this.content = content;
        }
    }
    function processRules(input, ruleCallback) {
        const inputWithEscapedQuotes = escapeBlocks(input, QUOTE_PAIRS, QUOTE_PLACEHOLDER);
        const inputWithEscapedBlocks = escapeBlocks(inputWithEscapedQuotes.escapedString, CONTENT_PAIRS, BLOCK_PLACEHOLDER);
        let nextBlockIndex = 0;
        let nextQuoteIndex = 0;
        return inputWithEscapedBlocks.escapedString
            .replace(_ruleRe, (...m) => {
            const selector = m[2];
            let content = '';
            let suffix = m[4];
            let contentPrefix = '';
            if (suffix && suffix.startsWith('{' + BLOCK_PLACEHOLDER)) {
                content = inputWithEscapedBlocks.blocks[nextBlockIndex++];
                suffix = suffix.substring(BLOCK_PLACEHOLDER.length + 1);
                contentPrefix = '{';
            }
            const rule = ruleCallback(new CssRule(selector, content));
            return `${m[1]}${rule.selector}${m[3]}${contentPrefix}${rule.content}${suffix}`;
        })
            .replace(_quotedRe, () => inputWithEscapedQuotes.blocks[nextQuoteIndex++]);
    }
    class StringWithEscapedBlocks {
        constructor(escapedString, blocks) {
            this.escapedString = escapedString;
            this.blocks = blocks;
        }
    }
    function escapeBlocks(input, charPairs, placeholder) {
        const resultParts = [];
        const escapedBlocks = [];
        let openCharCount = 0;
        let nonBlockStartIndex = 0;
        let blockStartIndex = -1;
        let openChar;
        let closeChar;
        for (let i = 0; i < input.length; i++) {
            const char = input[i];
            if (char === '\\') {
                i++;
            }
            else if (char === closeChar) {
                openCharCount--;
                if (openCharCount === 0) {
                    escapedBlocks.push(input.substring(blockStartIndex, i));
                    resultParts.push(placeholder);
                    nonBlockStartIndex = i;
                    blockStartIndex = -1;
                    openChar = closeChar = undefined;
                }
            }
            else if (char === openChar) {
                openCharCount++;
            }
            else if (openCharCount === 0 && charPairs.has(char)) {
                openChar = char;
                closeChar = charPairs.get(char);
                openCharCount = 1;
                blockStartIndex = i + 1;
                resultParts.push(input.substring(nonBlockStartIndex, blockStartIndex));
            }
        }
        if (blockStartIndex !== -1) {
            escapedBlocks.push(input.substring(blockStartIndex));
            resultParts.push(placeholder);
        }
        else {
            resultParts.push(input.substring(nonBlockStartIndex));
        }
        return new StringWithEscapedBlocks(resultParts.join(''), escapedBlocks);
    }
    /**
     * Combine the `contextSelectors` with the `hostMarker` and the `otherSelectors`
     * to create a selector that matches the same as `:host-context()`.
     *
     * Given a single context selector `A` we need to output selectors that match on the host and as an
     * ancestor of the host:
     *
     * ```
     * A <hostMarker>, A<hostMarker> {}
     * ```
     *
     * When there is more than one context selector we also have to create combinations of those
     * selectors with each other. For example if there are `A` and `B` selectors the output is:
     *
     * ```
     * AB<hostMarker>, AB <hostMarker>, A B<hostMarker>,
     * B A<hostMarker>, A B <hostMarker>, B A <hostMarker> {}
     * ```
     *
     * And so on...
     *
     * @param hostMarker the string that selects the host element.
     * @param contextSelectors an array of context selectors that will be combined.
     * @param otherSelectors the rest of the selectors that are not context selectors.
     */
    function combineHostContextSelectors(contextSelectors, otherSelectors) {
        const hostMarker = _polyfillHostNoCombinator;
        _polyfillHostRe.lastIndex = 0; // reset the regex to ensure we get an accurate test
        const otherSelectorsHasHost = _polyfillHostRe.test(otherSelectors);
        // If there are no context selectors then just output a host marker
        if (contextSelectors.length === 0) {
            return hostMarker + otherSelectors;
        }
        const combined = [contextSelectors.pop() || ''];
        while (contextSelectors.length > 0) {
            const length = combined.length;
            const contextSelector = contextSelectors.pop();
            for (let i = 0; i < length; i++) {
                const previousSelectors = combined[i];
                // Add the new selector as a descendant of the previous selectors
                combined[length * 2 + i] = previousSelectors + ' ' + contextSelector;
                // Add the new selector as an ancestor of the previous selectors
                combined[length + i] = contextSelector + ' ' + previousSelectors;
                // Add the new selector to act on the same element as the previous selectors
                combined[i] = contextSelector + previousSelectors;
            }
        }
        // Finally connect the selector to the `hostMarker`s: either acting directly on the host
        // (A<hostMarker>) or as an ancestor (A <hostMarker>).
        return combined
            .map(s => otherSelectorsHasHost ?
            `${s}${otherSelectors}` :
            `${s}${hostMarker}${otherSelectors}, ${s} ${hostMarker}${otherSelectors}`)
            .join(',');
    }
    /**
     * Mutate the given `groups` array so that there are `multiples` clones of the original array
     * stored.
     *
     * For example `repeatGroups([a, b], 3)` will result in `[a, b, a, b, a, b]` - but importantly the
     * newly added groups will be clones of the original.
     *
     * @param groups An array of groups of strings that will be repeated. This array is mutated
     *     in-place.
     * @param multiples The number of times the current groups should appear.
     */
    function repeatGroups(groups, multiples) {
        const length = groups.length;
        for (let i = 1; i < multiples; i++) {
            for (let j = 0; j < length; j++) {
                groups[j + (i * length)] = groups[j].slice(0);
            }
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    // group 0: "[prop] or (event) or @trigger"
    // group 1: "prop" from "[prop]"
    // group 2: "event" from "(event)"
    // group 3: "@trigger" from "@trigger"
    const HOST_REG_EXP = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))|(\@[-\w]+)$/;
    function viewClassName(compType, embeddedTemplateIndex) {
        return `View_${identifierName({ reference: compType })}_${embeddedTemplateIndex}`;
    }
    function rendererTypeName(compType) {
        return `RenderType_${identifierName({ reference: compType })}`;
    }
    function hostViewClassName(compType) {
        return `HostView_${identifierName({ reference: compType })}`;
    }
    function componentFactoryName(compType) {
        return `${identifierName({ reference: compType })}NgFactory`;
    }
    var CompileSummaryKind;
    (function (CompileSummaryKind) {
        CompileSummaryKind[CompileSummaryKind["Pipe"] = 0] = "Pipe";
        CompileSummaryKind[CompileSummaryKind["Directive"] = 1] = "Directive";
        CompileSummaryKind[CompileSummaryKind["NgModule"] = 2] = "NgModule";
        CompileSummaryKind[CompileSummaryKind["Injectable"] = 3] = "Injectable";
    })(CompileSummaryKind || (CompileSummaryKind = {}));
    function tokenName(token) {
        return token.value != null ? sanitizeIdentifier(token.value) : identifierName(token.identifier);
    }
    function tokenReference(token) {
        if (token.identifier != null) {
            return token.identifier.reference;
        }
        else {
            return token.value;
        }
    }
    /**
     * Metadata about a stylesheet
     */
    class CompileStylesheetMetadata {
        constructor({ moduleUrl, styles, styleUrls } = {}) {
            this.moduleUrl = moduleUrl || null;
            this.styles = _normalizeArray(styles);
            this.styleUrls = _normalizeArray(styleUrls);
        }
    }
    /**
     * Metadata regarding compilation of a template.
     */
    class CompileTemplateMetadata {
        constructor({ encapsulation, template, templateUrl, htmlAst, styles, styleUrls, externalStylesheets, animations, ngContentSelectors, interpolation, isInline, preserveWhitespaces }) {
            this.encapsulation = encapsulation;
            this.template = template;
            this.templateUrl = templateUrl;
            this.htmlAst = htmlAst;
            this.styles = _normalizeArray(styles);
            this.styleUrls = _normalizeArray(styleUrls);
            this.externalStylesheets = _normalizeArray(externalStylesheets);
            this.animations = animations ? flatten(animations) : [];
            this.ngContentSelectors = ngContentSelectors || [];
            if (interpolation && interpolation.length != 2) {
                throw new Error(`'interpolation' should have a start and an end symbol.`);
            }
            this.interpolation = interpolation;
            this.isInline = isInline;
            this.preserveWhitespaces = preserveWhitespaces;
        }
        toSummary() {
            return {
                ngContentSelectors: this.ngContentSelectors,
                encapsulation: this.encapsulation,
                styles: this.styles,
                animations: this.animations
            };
        }
    }
    /**
     * Metadata regarding compilation of a directive.
     */
    class CompileDirectiveMetadata {
        constructor({ isHost, type, isComponent, selector, exportAs, changeDetection, inputs, outputs, hostListeners, hostProperties, hostAttributes, providers, viewProviders, queries, guards, viewQueries, entryComponents, template, componentViewType, rendererType, componentFactory }) {
            this.isHost = !!isHost;
            this.type = type;
            this.isComponent = isComponent;
            this.selector = selector;
            this.exportAs = exportAs;
            this.changeDetection = changeDetection;
            this.inputs = inputs;
            this.outputs = outputs;
            this.hostListeners = hostListeners;
            this.hostProperties = hostProperties;
            this.hostAttributes = hostAttributes;
            this.providers = _normalizeArray(providers);
            this.viewProviders = _normalizeArray(viewProviders);
            this.queries = _normalizeArray(queries);
            this.guards = guards;
            this.viewQueries = _normalizeArray(viewQueries);
            this.entryComponents = _normalizeArray(entryComponents);
            this.template = template;
            this.componentViewType = componentViewType;
            this.rendererType = rendererType;
            this.componentFactory = componentFactory;
        }
        static create({ isHost, type, isComponent, selector, exportAs, changeDetection, inputs, outputs, host, providers, viewProviders, queries, guards, viewQueries, entryComponents, template, componentViewType, rendererType, componentFactory }) {
            const hostListeners = {};
            const hostProperties = {};
            const hostAttributes = {};
            if (host != null) {
                Object.keys(host).forEach(key => {
                    const value = host[key];
                    const matches = key.match(HOST_REG_EXP);
                    if (matches === null) {
                        hostAttributes[key] = value;
                    }
                    else if (matches[1] != null) {
                        hostProperties[matches[1]] = value;
                    }
                    else if (matches[2] != null) {
                        hostListeners[matches[2]] = value;
                    }
                });
            }
            const inputsMap = {};
            if (inputs != null) {
                inputs.forEach((bindConfig) => {
                    // canonical syntax: `dirProp: elProp`
                    // if there is no `:`, use dirProp = elProp
                    const parts = splitAtColon(bindConfig, [bindConfig, bindConfig]);
                    inputsMap[parts[0]] = parts[1];
                });
            }
            const outputsMap = {};
            if (outputs != null) {
                outputs.forEach((bindConfig) => {
                    // canonical syntax: `dirProp: elProp`
                    // if there is no `:`, use dirProp = elProp
                    const parts = splitAtColon(bindConfig, [bindConfig, bindConfig]);
                    outputsMap[parts[0]] = parts[1];
                });
            }
            return new CompileDirectiveMetadata({
                isHost,
                type,
                isComponent: !!isComponent,
                selector,
                exportAs,
                changeDetection,
                inputs: inputsMap,
                outputs: outputsMap,
                hostListeners,
                hostProperties,
                hostAttributes,
                providers,
                viewProviders,
                queries,
                guards,
                viewQueries,
                entryComponents,
                template,
                componentViewType,
                rendererType,
                componentFactory,
            });
        }
        toSummary() {
            return {
                summaryKind: CompileSummaryKind.Directive,
                type: this.type,
                isComponent: this.isComponent,
                selector: this.selector,
                exportAs: this.exportAs,
                inputs: this.inputs,
                outputs: this.outputs,
                hostListeners: this.hostListeners,
                hostProperties: this.hostProperties,
                hostAttributes: this.hostAttributes,
                providers: this.providers,
                viewProviders: this.viewProviders,
                queries: this.queries,
                guards: this.guards,
                viewQueries: this.viewQueries,
                entryComponents: this.entryComponents,
                changeDetection: this.changeDetection,
                template: this.template && this.template.toSummary(),
                componentViewType: this.componentViewType,
                rendererType: this.rendererType,
                componentFactory: this.componentFactory
            };
        }
    }
    class CompilePipeMetadata {
        constructor({ type, name, pure }) {
            this.type = type;
            this.name = name;
            this.pure = !!pure;
        }
        toSummary() {
            return {
                summaryKind: CompileSummaryKind.Pipe,
                type: this.type,
                name: this.name,
                pure: this.pure
            };
        }
    }
    /**
     * Metadata regarding compilation of a module.
     */
    class CompileNgModuleMetadata {
        constructor({ type, providers, declaredDirectives, exportedDirectives, declaredPipes, exportedPipes, entryComponents, bootstrapComponents, importedModules, exportedModules, schemas, transitiveModule, id }) {
            this.type = type || null;
            this.declaredDirectives = _normalizeArray(declaredDirectives);
            this.exportedDirectives = _normalizeArray(exportedDirectives);
            this.declaredPipes = _normalizeArray(declaredPipes);
            this.exportedPipes = _normalizeArray(exportedPipes);
            this.providers = _normalizeArray(providers);
            this.entryComponents = _normalizeArray(entryComponents);
            this.bootstrapComponents = _normalizeArray(bootstrapComponents);
            this.importedModules = _normalizeArray(importedModules);
            this.exportedModules = _normalizeArray(exportedModules);
            this.schemas = _normalizeArray(schemas);
            this.id = id || null;
            this.transitiveModule = transitiveModule || null;
        }
        toSummary() {
            const module = this.transitiveModule;
            return {
                summaryKind: CompileSummaryKind.NgModule,
                type: this.type,
                entryComponents: module.entryComponents,
                providers: module.providers,
                modules: module.modules,
                exportedDirectives: module.exportedDirectives,
                exportedPipes: module.exportedPipes
            };
        }
    }
    class TransitiveCompileNgModuleMetadata {
        constructor() {
            this.directivesSet = new Set();
            this.directives = [];
            this.exportedDirectivesSet = new Set();
            this.exportedDirectives = [];
            this.pipesSet = new Set();
            this.pipes = [];
            this.exportedPipesSet = new Set();
            this.exportedPipes = [];
            this.modulesSet = new Set();
            this.modules = [];
            this.entryComponentsSet = new Set();
            this.entryComponents = [];
            this.providers = [];
        }
        addProvider(provider, module) {
            this.providers.push({ provider: provider, module: module });
        }
        addDirective(id) {
            if (!this.directivesSet.has(id.reference)) {
                this.directivesSet.add(id.reference);
                this.directives.push(id);
            }
        }
        addExportedDirective(id) {
            if (!this.exportedDirectivesSet.has(id.reference)) {
                this.exportedDirectivesSet.add(id.reference);
                this.exportedDirectives.push(id);
            }
        }
        addPipe(id) {
            if (!this.pipesSet.has(id.reference)) {
                this.pipesSet.add(id.reference);
                this.pipes.push(id);
            }
        }
        addExportedPipe(id) {
            if (!this.exportedPipesSet.has(id.reference)) {
                this.exportedPipesSet.add(id.reference);
                this.exportedPipes.push(id);
            }
        }
        addModule(id) {
            if (!this.modulesSet.has(id.reference)) {
                this.modulesSet.add(id.reference);
                this.modules.push(id);
            }
        }
        addEntryComponent(ec) {
            if (!this.entryComponentsSet.has(ec.componentType)) {
                this.entryComponentsSet.add(ec.componentType);
                this.entryComponents.push(ec);
            }
        }
    }
    function _normalizeArray(obj) {
        return obj || [];
    }
    class ProviderMeta {
        constructor(token, { useClass, useValue, useExisting, useFactory, deps, multi }) {
            this.token = token;
            this.useClass = useClass || null;
            this.useValue = useValue;
            this.useExisting = useExisting;
            this.useFactory = useFactory || null;
            this.dependencies = deps || null;
            this.multi = !!multi;
        }
    }
    function flatten(list) {
        return list.reduce((flat, item) => {
            const flatItem = Array.isArray(item) ? flatten(item) : item;
            return flat.concat(flatItem);
        }, []);
    }
    function jitSourceUrl(url) {
        // Note: We need 3 "/" so that ng shows up as a separate domain
        // in the chrome dev tools.
        return url.replace(/(\w+:\/\/[\w:-]+)?(\/+)?/, 'ng:///');
    }
    function templateSourceUrl(ngModuleType, compMeta, templateMeta) {
        let url;
        if (templateMeta.isInline) {
            if (compMeta.type.reference instanceof StaticSymbol) {
                // Note: a .ts file might contain multiple components with inline templates,
                // so we need to give them unique urls, as these will be used for sourcemaps.
                url = `${compMeta.type.reference.filePath}.${compMeta.type.reference.name}.html`;
            }
            else {
                url = `${identifierName(ngModuleType)}/${identifierName(compMeta.type)}.html`;
            }
        }
        else {
            url = templateMeta.templateUrl;
        }
        return compMeta.type.reference instanceof StaticSymbol ? url : jitSourceUrl(url);
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const COMPONENT_VARIABLE = '%COMP%';
    const HOST_ATTR = `_nghost-${COMPONENT_VARIABLE}`;
    const CONTENT_ATTR = `_ngcontent-${COMPONENT_VARIABLE}`;

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A path is an ordered set of elements. Typically a path is to  a
     * particular offset in a source file. The head of the list is the top
     * most node. The tail is the node that contains the offset directly.
     *
     * For example, the expression `a + b + c` might have an ast that looks
     * like:
     *     +
     *    / \
     *   a   +
     *      / \
     *     b   c
     *
     * The path to the node at offset 9 would be `['+' at 1-10, '+' at 7-10,
     * 'c' at 9-10]` and the path the node at offset 1 would be
     * `['+' at 1-10, 'a' at 1-2]`.
     */
    class AstPath {
        constructor(path, position = -1) {
            this.path = path;
            this.position = position;
        }
        get empty() {
            return !this.path || !this.path.length;
        }
        get head() {
            return this.path[0];
        }
        get tail() {
            return this.path[this.path.length - 1];
        }
        parentOf(node) {
            return node && this.path[this.path.indexOf(node) - 1];
        }
        childOf(node) {
            return this.path[this.path.indexOf(node) + 1];
        }
        first(ctor) {
            for (let i = this.path.length - 1; i >= 0; i--) {
                let item = this.path[i];
                if (item instanceof ctor)
                    return item;
            }
        }
        push(node) {
            this.path.push(node);
        }
        pop() {
            return this.path.pop();
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class NodeWithI18n {
        constructor(sourceSpan, i18n) {
            this.sourceSpan = sourceSpan;
            this.i18n = i18n;
        }
    }
    class Text$2 extends NodeWithI18n {
        constructor(value, sourceSpan, tokens, i18n) {
            super(sourceSpan, i18n);
            this.value = value;
            this.tokens = tokens;
        }
        visit(visitor, context) {
            return visitor.visitText(this, context);
        }
    }
    class Expansion extends NodeWithI18n {
        constructor(switchValue, type, cases, sourceSpan, switchValueSourceSpan, i18n) {
            super(sourceSpan, i18n);
            this.switchValue = switchValue;
            this.type = type;
            this.cases = cases;
            this.switchValueSourceSpan = switchValueSourceSpan;
        }
        visit(visitor, context) {
            return visitor.visitExpansion(this, context);
        }
    }
    class ExpansionCase {
        constructor(value, expression, sourceSpan, valueSourceSpan, expSourceSpan) {
            this.value = value;
            this.expression = expression;
            this.sourceSpan = sourceSpan;
            this.valueSourceSpan = valueSourceSpan;
            this.expSourceSpan = expSourceSpan;
        }
        visit(visitor, context) {
            return visitor.visitExpansionCase(this, context);
        }
    }
    class Attribute extends NodeWithI18n {
        constructor(name, value, sourceSpan, keySpan, valueSpan, valueTokens, i18n) {
            super(sourceSpan, i18n);
            this.name = name;
            this.value = value;
            this.keySpan = keySpan;
            this.valueSpan = valueSpan;
            this.valueTokens = valueTokens;
        }
        visit(visitor, context) {
            return visitor.visitAttribute(this, context);
        }
    }
    class Element$1 extends NodeWithI18n {
        constructor(name, attrs, children, sourceSpan, startSourceSpan, endSourceSpan = null, i18n) {
            super(sourceSpan, i18n);
            this.name = name;
            this.attrs = attrs;
            this.children = children;
            this.startSourceSpan = startSourceSpan;
            this.endSourceSpan = endSourceSpan;
        }
        visit(visitor, context) {
            return visitor.visitElement(this, context);
        }
    }
    class Comment$1 {
        constructor(value, sourceSpan) {
            this.value = value;
            this.sourceSpan = sourceSpan;
        }
        visit(visitor, context) {
            return visitor.visitComment(this, context);
        }
    }
    function visitAll$1(visitor, nodes, context = null) {
        const result = [];
        const visit = visitor.visit ?
            (ast) => visitor.visit(ast, context) || ast.visit(visitor, context) :
            (ast) => ast.visit(visitor, context);
        nodes.forEach(ast => {
            const astResult = visit(ast);
            if (astResult) {
                result.push(astResult);
            }
        });
        return result;
    }
    class RecursiveVisitor {
        constructor() { }
        visitElement(ast, context) {
            this.visitChildren(context, visit => {
                visit(ast.attrs);
                visit(ast.children);
            });
        }
        visitAttribute(ast, context) { }
        visitText(ast, context) { }
        visitComment(ast, context) { }
        visitExpansion(ast, context) {
            return this.visitChildren(context, visit => {
                visit(ast.cases);
            });
        }
        visitExpansionCase(ast, context) { }
        visitChildren(context, cb) {
            let results = [];
            let t = this;
            function visit(children) {
                if (children)
                    results.push(visitAll$1(t, children, context));
            }
            cb(visit);
            return Array.prototype.concat.apply([], results);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    // Mapping between all HTML entity names and their unicode representation.
    // Generated from https://html.spec.whatwg.org/multipage/entities.json by stripping
    // the `&` and `;` from the keys and removing the duplicates.
    // see https://www.w3.org/TR/html51/syntax.html#named-character-references
    const NAMED_ENTITIES = {
        'AElig': '\u00C6',
        'AMP': '\u0026',
        'amp': '\u0026',
        'Aacute': '\u00C1',
        'Abreve': '\u0102',
        'Acirc': '\u00C2',
        'Acy': '\u0410',
        'Afr': '\uD835\uDD04',
        'Agrave': '\u00C0',
        'Alpha': '\u0391',
        'Amacr': '\u0100',
        'And': '\u2A53',
        'Aogon': '\u0104',
        'Aopf': '\uD835\uDD38',
        'ApplyFunction': '\u2061',
        'af': '\u2061',
        'Aring': '\u00C5',
        'angst': '\u00C5',
        'Ascr': '\uD835\uDC9C',
        'Assign': '\u2254',
        'colone': '\u2254',
        'coloneq': '\u2254',
        'Atilde': '\u00C3',
        'Auml': '\u00C4',
        'Backslash': '\u2216',
        'setminus': '\u2216',
        'setmn': '\u2216',
        'smallsetminus': '\u2216',
        'ssetmn': '\u2216',
        'Barv': '\u2AE7',
        'Barwed': '\u2306',
        'doublebarwedge': '\u2306',
        'Bcy': '\u0411',
        'Because': '\u2235',
        'becaus': '\u2235',
        'because': '\u2235',
        'Bernoullis': '\u212C',
        'Bscr': '\u212C',
        'bernou': '\u212C',
        'Beta': '\u0392',
        'Bfr': '\uD835\uDD05',
        'Bopf': '\uD835\uDD39',
        'Breve': '\u02D8',
        'breve': '\u02D8',
        'Bumpeq': '\u224E',
        'HumpDownHump': '\u224E',
        'bump': '\u224E',
        'CHcy': '\u0427',
        'COPY': '\u00A9',
        'copy': '\u00A9',
        'Cacute': '\u0106',
        'Cap': '\u22D2',
        'CapitalDifferentialD': '\u2145',
        'DD': '\u2145',
        'Cayleys': '\u212D',
        'Cfr': '\u212D',
        'Ccaron': '\u010C',
        'Ccedil': '\u00C7',
        'Ccirc': '\u0108',
        'Cconint': '\u2230',
        'Cdot': '\u010A',
        'Cedilla': '\u00B8',
        'cedil': '\u00B8',
        'CenterDot': '\u00B7',
        'centerdot': '\u00B7',
        'middot': '\u00B7',
        'Chi': '\u03A7',
        'CircleDot': '\u2299',
        'odot': '\u2299',
        'CircleMinus': '\u2296',
        'ominus': '\u2296',
        'CirclePlus': '\u2295',
        'oplus': '\u2295',
        'CircleTimes': '\u2297',
        'otimes': '\u2297',
        'ClockwiseContourIntegral': '\u2232',
        'cwconint': '\u2232',
        'CloseCurlyDoubleQuote': '\u201D',
        'rdquo': '\u201D',
        'rdquor': '\u201D',
        'CloseCurlyQuote': '\u2019',
        'rsquo': '\u2019',
        'rsquor': '\u2019',
        'Colon': '\u2237',
        'Proportion': '\u2237',
        'Colone': '\u2A74',
        'Congruent': '\u2261',
        'equiv': '\u2261',
        'Conint': '\u222F',
        'DoubleContourIntegral': '\u222F',
        'ContourIntegral': '\u222E',
        'conint': '\u222E',
        'oint': '\u222E',
        'Copf': '\u2102',
        'complexes': '\u2102',
        'Coproduct': '\u2210',
        'coprod': '\u2210',
        'CounterClockwiseContourIntegral': '\u2233',
        'awconint': '\u2233',
        'Cross': '\u2A2F',
        'Cscr': '\uD835\uDC9E',
        'Cup': '\u22D3',
        'CupCap': '\u224D',
        'asympeq': '\u224D',
        'DDotrahd': '\u2911',
        'DJcy': '\u0402',
        'DScy': '\u0405',
        'DZcy': '\u040F',
        'Dagger': '\u2021',
        'ddagger': '\u2021',
        'Darr': '\u21A1',
        'Dashv': '\u2AE4',
        'DoubleLeftTee': '\u2AE4',
        'Dcaron': '\u010E',
        'Dcy': '\u0414',
        'Del': '\u2207',
        'nabla': '\u2207',
        'Delta': '\u0394',
        'Dfr': '\uD835\uDD07',
        'DiacriticalAcute': '\u00B4',
        'acute': '\u00B4',
        'DiacriticalDot': '\u02D9',
        'dot': '\u02D9',
        'DiacriticalDoubleAcute': '\u02DD',
        'dblac': '\u02DD',
        'DiacriticalGrave': '\u0060',
        'grave': '\u0060',
        'DiacriticalTilde': '\u02DC',
        'tilde': '\u02DC',
        'Diamond': '\u22C4',
        'diam': '\u22C4',
        'diamond': '\u22C4',
        'DifferentialD': '\u2146',
        'dd': '\u2146',
        'Dopf': '\uD835\uDD3B',
        'Dot': '\u00A8',
        'DoubleDot': '\u00A8',
        'die': '\u00A8',
        'uml': '\u00A8',
        'DotDot': '\u20DC',
        'DotEqual': '\u2250',
        'doteq': '\u2250',
        'esdot': '\u2250',
        'DoubleDownArrow': '\u21D3',
        'Downarrow': '\u21D3',
        'dArr': '\u21D3',
        'DoubleLeftArrow': '\u21D0',
        'Leftarrow': '\u21D0',
        'lArr': '\u21D0',
        'DoubleLeftRightArrow': '\u21D4',
        'Leftrightarrow': '\u21D4',
        'hArr': '\u21D4',
        'iff': '\u21D4',
        'DoubleLongLeftArrow': '\u27F8',
        'Longleftarrow': '\u27F8',
        'xlArr': '\u27F8',
        'DoubleLongLeftRightArrow': '\u27FA',
        'Longleftrightarrow': '\u27FA',
        'xhArr': '\u27FA',
        'DoubleLongRightArrow': '\u27F9',
        'Longrightarrow': '\u27F9',
        'xrArr': '\u27F9',
        'DoubleRightArrow': '\u21D2',
        'Implies': '\u21D2',
        'Rightarrow': '\u21D2',
        'rArr': '\u21D2',
        'DoubleRightTee': '\u22A8',
        'vDash': '\u22A8',
        'DoubleUpArrow': '\u21D1',
        'Uparrow': '\u21D1',
        'uArr': '\u21D1',
        'DoubleUpDownArrow': '\u21D5',
        'Updownarrow': '\u21D5',
        'vArr': '\u21D5',
        'DoubleVerticalBar': '\u2225',
        'par': '\u2225',
        'parallel': '\u2225',
        'shortparallel': '\u2225',
        'spar': '\u2225',
        'DownArrow': '\u2193',
        'ShortDownArrow': '\u2193',
        'darr': '\u2193',
        'downarrow': '\u2193',
        'DownArrowBar': '\u2913',
        'DownArrowUpArrow': '\u21F5',
        'duarr': '\u21F5',
        'DownBreve': '\u0311',
        'DownLeftRightVector': '\u2950',
        'DownLeftTeeVector': '\u295E',
        'DownLeftVector': '\u21BD',
        'leftharpoondown': '\u21BD',
        'lhard': '\u21BD',
        'DownLeftVectorBar': '\u2956',
        'DownRightTeeVector': '\u295F',
        'DownRightVector': '\u21C1',
        'rhard': '\u21C1',
        'rightharpoondown': '\u21C1',
        'DownRightVectorBar': '\u2957',
        'DownTee': '\u22A4',
        'top': '\u22A4',
        'DownTeeArrow': '\u21A7',
        'mapstodown': '\u21A7',
        'Dscr': '\uD835\uDC9F',
        'Dstrok': '\u0110',
        'ENG': '\u014A',
        'ETH': '\u00D0',
        'Eacute': '\u00C9',
        'Ecaron': '\u011A',
        'Ecirc': '\u00CA',
        'Ecy': '\u042D',
        'Edot': '\u0116',
        'Efr': '\uD835\uDD08',
        'Egrave': '\u00C8',
        'Element': '\u2208',
        'in': '\u2208',
        'isin': '\u2208',
        'isinv': '\u2208',
        'Emacr': '\u0112',
        'EmptySmallSquare': '\u25FB',
        'EmptyVerySmallSquare': '\u25AB',
        'Eogon': '\u0118',
        'Eopf': '\uD835\uDD3C',
        'Epsilon': '\u0395',
        'Equal': '\u2A75',
        'EqualTilde': '\u2242',
        'eqsim': '\u2242',
        'esim': '\u2242',
        'Equilibrium': '\u21CC',
        'rightleftharpoons': '\u21CC',
        'rlhar': '\u21CC',
        'Escr': '\u2130',
        'expectation': '\u2130',
        'Esim': '\u2A73',
        'Eta': '\u0397',
        'Euml': '\u00CB',
        'Exists': '\u2203',
        'exist': '\u2203',
        'ExponentialE': '\u2147',
        'ee': '\u2147',
        'exponentiale': '\u2147',
        'Fcy': '\u0424',
        'Ffr': '\uD835\uDD09',
        'FilledSmallSquare': '\u25FC',
        'FilledVerySmallSquare': '\u25AA',
        'blacksquare': '\u25AA',
        'squarf': '\u25AA',
        'squf': '\u25AA',
        'Fopf': '\uD835\uDD3D',
        'ForAll': '\u2200',
        'forall': '\u2200',
        'Fouriertrf': '\u2131',
        'Fscr': '\u2131',
        'GJcy': '\u0403',
        'GT': '\u003E',
        'gt': '\u003E',
        'Gamma': '\u0393',
        'Gammad': '\u03DC',
        'Gbreve': '\u011E',
        'Gcedil': '\u0122',
        'Gcirc': '\u011C',
        'Gcy': '\u0413',
        'Gdot': '\u0120',
        'Gfr': '\uD835\uDD0A',
        'Gg': '\u22D9',
        'ggg': '\u22D9',
        'Gopf': '\uD835\uDD3E',
        'GreaterEqual': '\u2265',
        'ge': '\u2265',
        'geq': '\u2265',
        'GreaterEqualLess': '\u22DB',
        'gel': '\u22DB',
        'gtreqless': '\u22DB',
        'GreaterFullEqual': '\u2267',
        'gE': '\u2267',
        'geqq': '\u2267',
        'GreaterGreater': '\u2AA2',
        'GreaterLess': '\u2277',
        'gl': '\u2277',
        'gtrless': '\u2277',
        'GreaterSlantEqual': '\u2A7E',
        'geqslant': '\u2A7E',
        'ges': '\u2A7E',
        'GreaterTilde': '\u2273',
        'gsim': '\u2273',
        'gtrsim': '\u2273',
        'Gscr': '\uD835\uDCA2',
        'Gt': '\u226B',
        'NestedGreaterGreater': '\u226B',
        'gg': '\u226B',
        'HARDcy': '\u042A',
        'Hacek': '\u02C7',
        'caron': '\u02C7',
        'Hat': '\u005E',
        'Hcirc': '\u0124',
        'Hfr': '\u210C',
        'Poincareplane': '\u210C',
        'HilbertSpace': '\u210B',
        'Hscr': '\u210B',
        'hamilt': '\u210B',
        'Hopf': '\u210D',
        'quaternions': '\u210D',
        'HorizontalLine': '\u2500',
        'boxh': '\u2500',
        'Hstrok': '\u0126',
        'HumpEqual': '\u224F',
        'bumpe': '\u224F',
        'bumpeq': '\u224F',
        'IEcy': '\u0415',
        'IJlig': '\u0132',
        'IOcy': '\u0401',
        'Iacute': '\u00CD',
        'Icirc': '\u00CE',
        'Icy': '\u0418',
        'Idot': '\u0130',
        'Ifr': '\u2111',
        'Im': '\u2111',
        'image': '\u2111',
        'imagpart': '\u2111',
        'Igrave': '\u00CC',
        'Imacr': '\u012A',
        'ImaginaryI': '\u2148',
        'ii': '\u2148',
        'Int': '\u222C',
        'Integral': '\u222B',
        'int': '\u222B',
        'Intersection': '\u22C2',
        'bigcap': '\u22C2',
        'xcap': '\u22C2',
        'InvisibleComma': '\u2063',
        'ic': '\u2063',
        'InvisibleTimes': '\u2062',
        'it': '\u2062',
        'Iogon': '\u012E',
        'Iopf': '\uD835\uDD40',
        'Iota': '\u0399',
        'Iscr': '\u2110',
        'imagline': '\u2110',
        'Itilde': '\u0128',
        'Iukcy': '\u0406',
        'Iuml': '\u00CF',
        'Jcirc': '\u0134',
        'Jcy': '\u0419',
        'Jfr': '\uD835\uDD0D',
        'Jopf': '\uD835\uDD41',
        'Jscr': '\uD835\uDCA5',
        'Jsercy': '\u0408',
        'Jukcy': '\u0404',
        'KHcy': '\u0425',
        'KJcy': '\u040C',
        'Kappa': '\u039A',
        'Kcedil': '\u0136',
        'Kcy': '\u041A',
        'Kfr': '\uD835\uDD0E',
        'Kopf': '\uD835\uDD42',
        'Kscr': '\uD835\uDCA6',
        'LJcy': '\u0409',
        'LT': '\u003C',
        'lt': '\u003C',
        'Lacute': '\u0139',
        'Lambda': '\u039B',
        'Lang': '\u27EA',
        'Laplacetrf': '\u2112',
        'Lscr': '\u2112',
        'lagran': '\u2112',
        'Larr': '\u219E',
        'twoheadleftarrow': '\u219E',
        'Lcaron': '\u013D',
        'Lcedil': '\u013B',
        'Lcy': '\u041B',
        'LeftAngleBracket': '\u27E8',
        'lang': '\u27E8',
        'langle': '\u27E8',
        'LeftArrow': '\u2190',
        'ShortLeftArrow': '\u2190',
        'larr': '\u2190',
        'leftarrow': '\u2190',
        'slarr': '\u2190',
        'LeftArrowBar': '\u21E4',
        'larrb': '\u21E4',
        'LeftArrowRightArrow': '\u21C6',
        'leftrightarrows': '\u21C6',
        'lrarr': '\u21C6',
        'LeftCeiling': '\u2308',
        'lceil': '\u2308',
        'LeftDoubleBracket': '\u27E6',
        'lobrk': '\u27E6',
        'LeftDownTeeVector': '\u2961',
        'LeftDownVector': '\u21C3',
        'dharl': '\u21C3',
        'downharpoonleft': '\u21C3',
        'LeftDownVectorBar': '\u2959',
        'LeftFloor': '\u230A',
        'lfloor': '\u230A',
        'LeftRightArrow': '\u2194',
        'harr': '\u2194',
        'leftrightarrow': '\u2194',
        'LeftRightVector': '\u294E',
        'LeftTee': '\u22A3',
        'dashv': '\u22A3',
        'LeftTeeArrow': '\u21A4',
        'mapstoleft': '\u21A4',
        'LeftTeeVector': '\u295A',
        'LeftTriangle': '\u22B2',
        'vartriangleleft': '\u22B2',
        'vltri': '\u22B2',
        'LeftTriangleBar': '\u29CF',
        'LeftTriangleEqual': '\u22B4',
        'ltrie': '\u22B4',
        'trianglelefteq': '\u22B4',
        'LeftUpDownVector': '\u2951',
        'LeftUpTeeVector': '\u2960',
        'LeftUpVector': '\u21BF',
        'uharl': '\u21BF',
        'upharpoonleft': '\u21BF',
        'LeftUpVectorBar': '\u2958',
        'LeftVector': '\u21BC',
        'leftharpoonup': '\u21BC',
        'lharu': '\u21BC',
        'LeftVectorBar': '\u2952',
        'LessEqualGreater': '\u22DA',
        'leg': '\u22DA',
        'lesseqgtr': '\u22DA',
        'LessFullEqual': '\u2266',
        'lE': '\u2266',
        'leqq': '\u2266',
        'LessGreater': '\u2276',
        'lessgtr': '\u2276',
        'lg': '\u2276',
        'LessLess': '\u2AA1',
        'LessSlantEqual': '\u2A7D',
        'leqslant': '\u2A7D',
        'les': '\u2A7D',
        'LessTilde': '\u2272',
        'lesssim': '\u2272',
        'lsim': '\u2272',
        'Lfr': '\uD835\uDD0F',
        'Ll': '\u22D8',
        'Lleftarrow': '\u21DA',
        'lAarr': '\u21DA',
        'Lmidot': '\u013F',
        'LongLeftArrow': '\u27F5',
        'longleftarrow': '\u27F5',
        'xlarr': '\u27F5',
        'LongLeftRightArrow': '\u27F7',
        'longleftrightarrow': '\u27F7',
        'xharr': '\u27F7',
        'LongRightArrow': '\u27F6',
        'longrightarrow': '\u27F6',
        'xrarr': '\u27F6',
        'Lopf': '\uD835\uDD43',
        'LowerLeftArrow': '\u2199',
        'swarr': '\u2199',
        'swarrow': '\u2199',
        'LowerRightArrow': '\u2198',
        'searr': '\u2198',
        'searrow': '\u2198',
        'Lsh': '\u21B0',
        'lsh': '\u21B0',
        'Lstrok': '\u0141',
        'Lt': '\u226A',
        'NestedLessLess': '\u226A',
        'll': '\u226A',
        'Map': '\u2905',
        'Mcy': '\u041C',
        'MediumSpace': '\u205F',
        'Mellintrf': '\u2133',
        'Mscr': '\u2133',
        'phmmat': '\u2133',
        'Mfr': '\uD835\uDD10',
        'MinusPlus': '\u2213',
        'mnplus': '\u2213',
        'mp': '\u2213',
        'Mopf': '\uD835\uDD44',
        'Mu': '\u039C',
        'NJcy': '\u040A',
        'Nacute': '\u0143',
        'Ncaron': '\u0147',
        'Ncedil': '\u0145',
        'Ncy': '\u041D',
        'NegativeMediumSpace': '\u200B',
        'NegativeThickSpace': '\u200B',
        'NegativeThinSpace': '\u200B',
        'NegativeVeryThinSpace': '\u200B',
        'ZeroWidthSpace': '\u200B',
        'NewLine': '\u000A',
        'Nfr': '\uD835\uDD11',
        'NoBreak': '\u2060',
        'NonBreakingSpace': '\u00A0',
        'nbsp': '\u00A0',
        'Nopf': '\u2115',
        'naturals': '\u2115',
        'Not': '\u2AEC',
        'NotCongruent': '\u2262',
        'nequiv': '\u2262',
        'NotCupCap': '\u226D',
        'NotDoubleVerticalBar': '\u2226',
        'npar': '\u2226',
        'nparallel': '\u2226',
        'nshortparallel': '\u2226',
        'nspar': '\u2226',
        'NotElement': '\u2209',
        'notin': '\u2209',
        'notinva': '\u2209',
        'NotEqual': '\u2260',
        'ne': '\u2260',
        'NotEqualTilde': '\u2242\u0338',
        'nesim': '\u2242\u0338',
        'NotExists': '\u2204',
        'nexist': '\u2204',
        'nexists': '\u2204',
        'NotGreater': '\u226F',
        'ngt': '\u226F',
        'ngtr': '\u226F',
        'NotGreaterEqual': '\u2271',
        'nge': '\u2271',
        'ngeq': '\u2271',
        'NotGreaterFullEqual': '\u2267\u0338',
        'ngE': '\u2267\u0338',
        'ngeqq': '\u2267\u0338',
        'NotGreaterGreater': '\u226B\u0338',
        'nGtv': '\u226B\u0338',
        'NotGreaterLess': '\u2279',
        'ntgl': '\u2279',
        'NotGreaterSlantEqual': '\u2A7E\u0338',
        'ngeqslant': '\u2A7E\u0338',
        'nges': '\u2A7E\u0338',
        'NotGreaterTilde': '\u2275',
        'ngsim': '\u2275',
        'NotHumpDownHump': '\u224E\u0338',
        'nbump': '\u224E\u0338',
        'NotHumpEqual': '\u224F\u0338',
        'nbumpe': '\u224F\u0338',
        'NotLeftTriangle': '\u22EA',
        'nltri': '\u22EA',
        'ntriangleleft': '\u22EA',
        'NotLeftTriangleBar': '\u29CF\u0338',
        'NotLeftTriangleEqual': '\u22EC',
        'nltrie': '\u22EC',
        'ntrianglelefteq': '\u22EC',
        'NotLess': '\u226E',
        'nless': '\u226E',
        'nlt': '\u226E',
        'NotLessEqual': '\u2270',
        'nle': '\u2270',
        'nleq': '\u2270',
        'NotLessGreater': '\u2278',
        'ntlg': '\u2278',
        'NotLessLess': '\u226A\u0338',
        'nLtv': '\u226A\u0338',
        'NotLessSlantEqual': '\u2A7D\u0338',
        'nleqslant': '\u2A7D\u0338',
        'nles': '\u2A7D\u0338',
        'NotLessTilde': '\u2274',
        'nlsim': '\u2274',
        'NotNestedGreaterGreater': '\u2AA2\u0338',
        'NotNestedLessLess': '\u2AA1\u0338',
        'NotPrecedes': '\u2280',
        'npr': '\u2280',
        'nprec': '\u2280',
        'NotPrecedesEqual': '\u2AAF\u0338',
        'npre': '\u2AAF\u0338',
        'npreceq': '\u2AAF\u0338',
        'NotPrecedesSlantEqual': '\u22E0',
        'nprcue': '\u22E0',
        'NotReverseElement': '\u220C',
        'notni': '\u220C',
        'notniva': '\u220C',
        'NotRightTriangle': '\u22EB',
        'nrtri': '\u22EB',
        'ntriangleright': '\u22EB',
        'NotRightTriangleBar': '\u29D0\u0338',
        'NotRightTriangleEqual': '\u22ED',
        'nrtrie': '\u22ED',
        'ntrianglerighteq': '\u22ED',
        'NotSquareSubset': '\u228F\u0338',
        'NotSquareSubsetEqual': '\u22E2',
        'nsqsube': '\u22E2',
        'NotSquareSuperset': '\u2290\u0338',
        'NotSquareSupersetEqual': '\u22E3',
        'nsqsupe': '\u22E3',
        'NotSubset': '\u2282\u20D2',
        'nsubset': '\u2282\u20D2',
        'vnsub': '\u2282\u20D2',
        'NotSubsetEqual': '\u2288',
        'nsube': '\u2288',
        'nsubseteq': '\u2288',
        'NotSucceeds': '\u2281',
        'nsc': '\u2281',
        'nsucc': '\u2281',
        'NotSucceedsEqual': '\u2AB0\u0338',
        'nsce': '\u2AB0\u0338',
        'nsucceq': '\u2AB0\u0338',
        'NotSucceedsSlantEqual': '\u22E1',
        'nsccue': '\u22E1',
        'NotSucceedsTilde': '\u227F\u0338',
        'NotSuperset': '\u2283\u20D2',
        'nsupset': '\u2283\u20D2',
        'vnsup': '\u2283\u20D2',
        'NotSupersetEqual': '\u2289',
        'nsupe': '\u2289',
        'nsupseteq': '\u2289',
        'NotTilde': '\u2241',
        'nsim': '\u2241',
        'NotTildeEqual': '\u2244',
        'nsime': '\u2244',
        'nsimeq': '\u2244',
        'NotTildeFullEqual': '\u2247',
        'ncong': '\u2247',
        'NotTildeTilde': '\u2249',
        'nap': '\u2249',
        'napprox': '\u2249',
        'NotVerticalBar': '\u2224',
        'nmid': '\u2224',
        'nshortmid': '\u2224',
        'nsmid': '\u2224',
        'Nscr': '\uD835\uDCA9',
        'Ntilde': '\u00D1',
        'Nu': '\u039D',
        'OElig': '\u0152',
        'Oacute': '\u00D3',
        'Ocirc': '\u00D4',
        'Ocy': '\u041E',
        'Odblac': '\u0150',
        'Ofr': '\uD835\uDD12',
        'Ograve': '\u00D2',
        'Omacr': '\u014C',
        'Omega': '\u03A9',
        'ohm': '\u03A9',
        'Omicron': '\u039F',
        'Oopf': '\uD835\uDD46',
        'OpenCurlyDoubleQuote': '\u201C',
        'ldquo': '\u201C',
        'OpenCurlyQuote': '\u2018',
        'lsquo': '\u2018',
        'Or': '\u2A54',
        'Oscr': '\uD835\uDCAA',
        'Oslash': '\u00D8',
        'Otilde': '\u00D5',
        'Otimes': '\u2A37',
        'Ouml': '\u00D6',
        'OverBar': '\u203E',
        'oline': '\u203E',
        'OverBrace': '\u23DE',
        'OverBracket': '\u23B4',
        'tbrk': '\u23B4',
        'OverParenthesis': '\u23DC',
        'PartialD': '\u2202',
        'part': '\u2202',
        'Pcy': '\u041F',
        'Pfr': '\uD835\uDD13',
        'Phi': '\u03A6',
        'Pi': '\u03A0',
        'PlusMinus': '\u00B1',
        'plusmn': '\u00B1',
        'pm': '\u00B1',
        'Popf': '\u2119',
        'primes': '\u2119',
        'Pr': '\u2ABB',
        'Precedes': '\u227A',
        'pr': '\u227A',
        'prec': '\u227A',
        'PrecedesEqual': '\u2AAF',
        'pre': '\u2AAF',
        'preceq': '\u2AAF',
        'PrecedesSlantEqual': '\u227C',
        'prcue': '\u227C',
        'preccurlyeq': '\u227C',
        'PrecedesTilde': '\u227E',
        'precsim': '\u227E',
        'prsim': '\u227E',
        'Prime': '\u2033',
        'Product': '\u220F',
        'prod': '\u220F',
        'Proportional': '\u221D',
        'prop': '\u221D',
        'propto': '\u221D',
        'varpropto': '\u221D',
        'vprop': '\u221D',
        'Pscr': '\uD835\uDCAB',
        'Psi': '\u03A8',
        'QUOT': '\u0022',
        'quot': '\u0022',
        'Qfr': '\uD835\uDD14',
        'Qopf': '\u211A',
        'rationals': '\u211A',
        'Qscr': '\uD835\uDCAC',
        'RBarr': '\u2910',
        'drbkarow': '\u2910',
        'REG': '\u00AE',
        'circledR': '\u00AE',
        'reg': '\u00AE',
        'Racute': '\u0154',
        'Rang': '\u27EB',
        'Rarr': '\u21A0',
        'twoheadrightarrow': '\u21A0',
        'Rarrtl': '\u2916',
        'Rcaron': '\u0158',
        'Rcedil': '\u0156',
        'Rcy': '\u0420',
        'Re': '\u211C',
        'Rfr': '\u211C',
        'real': '\u211C',
        'realpart': '\u211C',
        'ReverseElement': '\u220B',
        'SuchThat': '\u220B',
        'ni': '\u220B',
        'niv': '\u220B',
        'ReverseEquilibrium': '\u21CB',
        'leftrightharpoons': '\u21CB',
        'lrhar': '\u21CB',
        'ReverseUpEquilibrium': '\u296F',
        'duhar': '\u296F',
        'Rho': '\u03A1',
        'RightAngleBracket': '\u27E9',
        'rang': '\u27E9',
        'rangle': '\u27E9',
        'RightArrow': '\u2192',
        'ShortRightArrow': '\u2192',
        'rarr': '\u2192',
        'rightarrow': '\u2192',
        'srarr': '\u2192',
        'RightArrowBar': '\u21E5',
        'rarrb': '\u21E5',
        'RightArrowLeftArrow': '\u21C4',
        'rightleftarrows': '\u21C4',
        'rlarr': '\u21C4',
        'RightCeiling': '\u2309',
        'rceil': '\u2309',
        'RightDoubleBracket': '\u27E7',
        'robrk': '\u27E7',
        'RightDownTeeVector': '\u295D',
        'RightDownVector': '\u21C2',
        'dharr': '\u21C2',
        'downharpoonright': '\u21C2',
        'RightDownVectorBar': '\u2955',
        'RightFloor': '\u230B',
        'rfloor': '\u230B',
        'RightTee': '\u22A2',
        'vdash': '\u22A2',
        'RightTeeArrow': '\u21A6',
        'map': '\u21A6',
        'mapsto': '\u21A6',
        'RightTeeVector': '\u295B',
        'RightTriangle': '\u22B3',
        'vartriangleright': '\u22B3',
        'vrtri': '\u22B3',
        'RightTriangleBar': '\u29D0',
        'RightTriangleEqual': '\u22B5',
        'rtrie': '\u22B5',
        'trianglerighteq': '\u22B5',
        'RightUpDownVector': '\u294F',
        'RightUpTeeVector': '\u295C',
        'RightUpVector': '\u21BE',
        'uharr': '\u21BE',
        'upharpoonright': '\u21BE',
        'RightUpVectorBar': '\u2954',
        'RightVector': '\u21C0',
        'rharu': '\u21C0',
        'rightharpoonup': '\u21C0',
        'RightVectorBar': '\u2953',
        'Ropf': '\u211D',
        'reals': '\u211D',
        'RoundImplies': '\u2970',
        'Rrightarrow': '\u21DB',
        'rAarr': '\u21DB',
        'Rscr': '\u211B',
        'realine': '\u211B',
        'Rsh': '\u21B1',
        'rsh': '\u21B1',
        'RuleDelayed': '\u29F4',
        'SHCHcy': '\u0429',
        'SHcy': '\u0428',
        'SOFTcy': '\u042C',
        'Sacute': '\u015A',
        'Sc': '\u2ABC',
        'Scaron': '\u0160',
        'Scedil': '\u015E',
        'Scirc': '\u015C',
        'Scy': '\u0421',
        'Sfr': '\uD835\uDD16',
        'ShortUpArrow': '\u2191',
        'UpArrow': '\u2191',
        'uarr': '\u2191',
        'uparrow': '\u2191',
        'Sigma': '\u03A3',
        'SmallCircle': '\u2218',
        'compfn': '\u2218',
        'Sopf': '\uD835\uDD4A',
        'Sqrt': '\u221A',
        'radic': '\u221A',
        'Square': '\u25A1',
        'squ': '\u25A1',
        'square': '\u25A1',
        'SquareIntersection': '\u2293',
        'sqcap': '\u2293',
        'SquareSubset': '\u228F',
        'sqsub': '\u228F',
        'sqsubset': '\u228F',
        'SquareSubsetEqual': '\u2291',
        'sqsube': '\u2291',
        'sqsubseteq': '\u2291',
        'SquareSuperset': '\u2290',
        'sqsup': '\u2290',
        'sqsupset': '\u2290',
        'SquareSupersetEqual': '\u2292',
        'sqsupe': '\u2292',
        'sqsupseteq': '\u2292',
        'SquareUnion': '\u2294',
        'sqcup': '\u2294',
        'Sscr': '\uD835\uDCAE',
        'Star': '\u22C6',
        'sstarf': '\u22C6',
        'Sub': '\u22D0',
        'Subset': '\u22D0',
        'SubsetEqual': '\u2286',
        'sube': '\u2286',
        'subseteq': '\u2286',
        'Succeeds': '\u227B',
        'sc': '\u227B',
        'succ': '\u227B',
        'SucceedsEqual': '\u2AB0',
        'sce': '\u2AB0',
        'succeq': '\u2AB0',
        'SucceedsSlantEqual': '\u227D',
        'sccue': '\u227D',
        'succcurlyeq': '\u227D',
        'SucceedsTilde': '\u227F',
        'scsim': '\u227F',
        'succsim': '\u227F',
        'Sum': '\u2211',
        'sum': '\u2211',
        'Sup': '\u22D1',
        'Supset': '\u22D1',
        'Superset': '\u2283',
        'sup': '\u2283',
        'supset': '\u2283',
        'SupersetEqual': '\u2287',
        'supe': '\u2287',
        'supseteq': '\u2287',
        'THORN': '\u00DE',
        'TRADE': '\u2122',
        'trade': '\u2122',
        'TSHcy': '\u040B',
        'TScy': '\u0426',
        'Tab': '\u0009',
        'Tau': '\u03A4',
        'Tcaron': '\u0164',
        'Tcedil': '\u0162',
        'Tcy': '\u0422',
        'Tfr': '\uD835\uDD17',
        'Therefore': '\u2234',
        'there4': '\u2234',
        'therefore': '\u2234',
        'Theta': '\u0398',
        'ThickSpace': '\u205F\u200A',
        'ThinSpace': '\u2009',
        'thinsp': '\u2009',
        'Tilde': '\u223C',
        'sim': '\u223C',
        'thicksim': '\u223C',
        'thksim': '\u223C',
        'TildeEqual': '\u2243',
        'sime': '\u2243',
        'simeq': '\u2243',
        'TildeFullEqual': '\u2245',
        'cong': '\u2245',
        'TildeTilde': '\u2248',
        'ap': '\u2248',
        'approx': '\u2248',
        'asymp': '\u2248',
        'thickapprox': '\u2248',
        'thkap': '\u2248',
        'Topf': '\uD835\uDD4B',
        'TripleDot': '\u20DB',
        'tdot': '\u20DB',
        'Tscr': '\uD835\uDCAF',
        'Tstrok': '\u0166',
        'Uacute': '\u00DA',
        'Uarr': '\u219F',
        'Uarrocir': '\u2949',
        'Ubrcy': '\u040E',
        'Ubreve': '\u016C',
        'Ucirc': '\u00DB',
        'Ucy': '\u0423',
        'Udblac': '\u0170',
        'Ufr': '\uD835\uDD18',
        'Ugrave': '\u00D9',
        'Umacr': '\u016A',
        'UnderBar': '\u005F',
        'lowbar': '\u005F',
        'UnderBrace': '\u23DF',
        'UnderBracket': '\u23B5',
        'bbrk': '\u23B5',
        'UnderParenthesis': '\u23DD',
        'Union': '\u22C3',
        'bigcup': '\u22C3',
        'xcup': '\u22C3',
        'UnionPlus': '\u228E',
        'uplus': '\u228E',
        'Uogon': '\u0172',
        'Uopf': '\uD835\uDD4C',
        'UpArrowBar': '\u2912',
        'UpArrowDownArrow': '\u21C5',
        'udarr': '\u21C5',
        'UpDownArrow': '\u2195',
        'updownarrow': '\u2195',
        'varr': '\u2195',
        'UpEquilibrium': '\u296E',
        'udhar': '\u296E',
        'UpTee': '\u22A5',
        'bot': '\u22A5',
        'bottom': '\u22A5',
        'perp': '\u22A5',
        'UpTeeArrow': '\u21A5',
        'mapstoup': '\u21A5',
        'UpperLeftArrow': '\u2196',
        'nwarr': '\u2196',
        'nwarrow': '\u2196',
        'UpperRightArrow': '\u2197',
        'nearr': '\u2197',
        'nearrow': '\u2197',
        'Upsi': '\u03D2',
        'upsih': '\u03D2',
        'Upsilon': '\u03A5',
        'Uring': '\u016E',
        'Uscr': '\uD835\uDCB0',
        'Utilde': '\u0168',
        'Uuml': '\u00DC',
        'VDash': '\u22AB',
        'Vbar': '\u2AEB',
        'Vcy': '\u0412',
        'Vdash': '\u22A9',
        'Vdashl': '\u2AE6',
        'Vee': '\u22C1',
        'bigvee': '\u22C1',
        'xvee': '\u22C1',
        'Verbar': '\u2016',
        'Vert': '\u2016',
        'VerticalBar': '\u2223',
        'mid': '\u2223',
        'shortmid': '\u2223',
        'smid': '\u2223',
        'VerticalLine': '\u007C',
        'verbar': '\u007C',
        'vert': '\u007C',
        'VerticalSeparator': '\u2758',
        'VerticalTilde': '\u2240',
        'wr': '\u2240',
        'wreath': '\u2240',
        'VeryThinSpace': '\u200A',
        'hairsp': '\u200A',
        'Vfr': '\uD835\uDD19',
        'Vopf': '\uD835\uDD4D',
        'Vscr': '\uD835\uDCB1',
        'Vvdash': '\u22AA',
        'Wcirc': '\u0174',
        'Wedge': '\u22C0',
        'bigwedge': '\u22C0',
        'xwedge': '\u22C0',
        'Wfr': '\uD835\uDD1A',
        'Wopf': '\uD835\uDD4E',
        'Wscr': '\uD835\uDCB2',
        'Xfr': '\uD835\uDD1B',
        'Xi': '\u039E',
        'Xopf': '\uD835\uDD4F',
        'Xscr': '\uD835\uDCB3',
        'YAcy': '\u042F',
        'YIcy': '\u0407',
        'YUcy': '\u042E',
        'Yacute': '\u00DD',
        'Ycirc': '\u0176',
        'Ycy': '\u042B',
        'Yfr': '\uD835\uDD1C',
        'Yopf': '\uD835\uDD50',
        'Yscr': '\uD835\uDCB4',
        'Yuml': '\u0178',
        'ZHcy': '\u0416',
        'Zacute': '\u0179',
        'Zcaron': '\u017D',
        'Zcy': '\u0417',
        'Zdot': '\u017B',
        'Zeta': '\u0396',
        'Zfr': '\u2128',
        'zeetrf': '\u2128',
        'Zopf': '\u2124',
        'integers': '\u2124',
        'Zscr': '\uD835\uDCB5',
        'aacute': '\u00E1',
        'abreve': '\u0103',
        'ac': '\u223E',
        'mstpos': '\u223E',
        'acE': '\u223E\u0333',
        'acd': '\u223F',
        'acirc': '\u00E2',
        'acy': '\u0430',
        'aelig': '\u00E6',
        'afr': '\uD835\uDD1E',
        'agrave': '\u00E0',
        'alefsym': '\u2135',
        'aleph': '\u2135',
        'alpha': '\u03B1',
        'amacr': '\u0101',
        'amalg': '\u2A3F',
        'and': '\u2227',
        'wedge': '\u2227',
        'andand': '\u2A55',
        'andd': '\u2A5C',
        'andslope': '\u2A58',
        'andv': '\u2A5A',
        'ang': '\u2220',
        'angle': '\u2220',
        'ange': '\u29A4',
        'angmsd': '\u2221',
        'measuredangle': '\u2221',
        'angmsdaa': '\u29A8',
        'angmsdab': '\u29A9',
        'angmsdac': '\u29AA',
        'angmsdad': '\u29AB',
        'angmsdae': '\u29AC',
        'angmsdaf': '\u29AD',
        'angmsdag': '\u29AE',
        'angmsdah': '\u29AF',
        'angrt': '\u221F',
        'angrtvb': '\u22BE',
        'angrtvbd': '\u299D',
        'angsph': '\u2222',
        'angzarr': '\u237C',
        'aogon': '\u0105',
        'aopf': '\uD835\uDD52',
        'apE': '\u2A70',
        'apacir': '\u2A6F',
        'ape': '\u224A',
        'approxeq': '\u224A',
        'apid': '\u224B',
        'apos': '\u0027',
        'aring': '\u00E5',
        'ascr': '\uD835\uDCB6',
        'ast': '\u002A',
        'midast': '\u002A',
        'atilde': '\u00E3',
        'auml': '\u00E4',
        'awint': '\u2A11',
        'bNot': '\u2AED',
        'backcong': '\u224C',
        'bcong': '\u224C',
        'backepsilon': '\u03F6',
        'bepsi': '\u03F6',
        'backprime': '\u2035',
        'bprime': '\u2035',
        'backsim': '\u223D',
        'bsim': '\u223D',
        'backsimeq': '\u22CD',
        'bsime': '\u22CD',
        'barvee': '\u22BD',
        'barwed': '\u2305',
        'barwedge': '\u2305',
        'bbrktbrk': '\u23B6',
        'bcy': '\u0431',
        'bdquo': '\u201E',
        'ldquor': '\u201E',
        'bemptyv': '\u29B0',
        'beta': '\u03B2',
        'beth': '\u2136',
        'between': '\u226C',
        'twixt': '\u226C',
        'bfr': '\uD835\uDD1F',
        'bigcirc': '\u25EF',
        'xcirc': '\u25EF',
        'bigodot': '\u2A00',
        'xodot': '\u2A00',
        'bigoplus': '\u2A01',
        'xoplus': '\u2A01',
        'bigotimes': '\u2A02',
        'xotime': '\u2A02',
        'bigsqcup': '\u2A06',
        'xsqcup': '\u2A06',
        'bigstar': '\u2605',
        'starf': '\u2605',
        'bigtriangledown': '\u25BD',
        'xdtri': '\u25BD',
        'bigtriangleup': '\u25B3',
        'xutri': '\u25B3',
        'biguplus': '\u2A04',
        'xuplus': '\u2A04',
        'bkarow': '\u290D',
        'rbarr': '\u290D',
        'blacklozenge': '\u29EB',
        'lozf': '\u29EB',
        'blacktriangle': '\u25B4',
        'utrif': '\u25B4',
        'blacktriangledown': '\u25BE',
        'dtrif': '\u25BE',
        'blacktriangleleft': '\u25C2',
        'ltrif': '\u25C2',
        'blacktriangleright': '\u25B8',
        'rtrif': '\u25B8',
        'blank': '\u2423',
        'blk12': '\u2592',
        'blk14': '\u2591',
        'blk34': '\u2593',
        'block': '\u2588',
        'bne': '\u003D\u20E5',
        'bnequiv': '\u2261\u20E5',
        'bnot': '\u2310',
        'bopf': '\uD835\uDD53',
        'bowtie': '\u22C8',
        'boxDL': '\u2557',
        'boxDR': '\u2554',
        'boxDl': '\u2556',
        'boxDr': '\u2553',
        'boxH': '\u2550',
        'boxHD': '\u2566',
        'boxHU': '\u2569',
        'boxHd': '\u2564',
        'boxHu': '\u2567',
        'boxUL': '\u255D',
        'boxUR': '\u255A',
        'boxUl': '\u255C',
        'boxUr': '\u2559',
        'boxV': '\u2551',
        'boxVH': '\u256C',
        'boxVL': '\u2563',
        'boxVR': '\u2560',
        'boxVh': '\u256B',
        'boxVl': '\u2562',
        'boxVr': '\u255F',
        'boxbox': '\u29C9',
        'boxdL': '\u2555',
        'boxdR': '\u2552',
        'boxdl': '\u2510',
        'boxdr': '\u250C',
        'boxhD': '\u2565',
        'boxhU': '\u2568',
        'boxhd': '\u252C',
        'boxhu': '\u2534',
        'boxminus': '\u229F',
        'minusb': '\u229F',
        'boxplus': '\u229E',
        'plusb': '\u229E',
        'boxtimes': '\u22A0',
        'timesb': '\u22A0',
        'boxuL': '\u255B',
        'boxuR': '\u2558',
        'boxul': '\u2518',
        'boxur': '\u2514',
        'boxv': '\u2502',
        'boxvH': '\u256A',
        'boxvL': '\u2561',
        'boxvR': '\u255E',
        'boxvh': '\u253C',
        'boxvl': '\u2524',
        'boxvr': '\u251C',
        'brvbar': '\u00A6',
        'bscr': '\uD835\uDCB7',
        'bsemi': '\u204F',
        'bsol': '\u005C',
        'bsolb': '\u29C5',
        'bsolhsub': '\u27C8',
        'bull': '\u2022',
        'bullet': '\u2022',
        'bumpE': '\u2AAE',
        'cacute': '\u0107',
        'cap': '\u2229',
        'capand': '\u2A44',
        'capbrcup': '\u2A49',
        'capcap': '\u2A4B',
        'capcup': '\u2A47',
        'capdot': '\u2A40',
        'caps': '\u2229\uFE00',
        'caret': '\u2041',
        'ccaps': '\u2A4D',
        'ccaron': '\u010D',
        'ccedil': '\u00E7',
        'ccirc': '\u0109',
        'ccups': '\u2A4C',
        'ccupssm': '\u2A50',
        'cdot': '\u010B',
        'cemptyv': '\u29B2',
        'cent': '\u00A2',
        'cfr': '\uD835\uDD20',
        'chcy': '\u0447',
        'check': '\u2713',
        'checkmark': '\u2713',
        'chi': '\u03C7',
        'cir': '\u25CB',
        'cirE': '\u29C3',
        'circ': '\u02C6',
        'circeq': '\u2257',
        'cire': '\u2257',
        'circlearrowleft': '\u21BA',
        'olarr': '\u21BA',
        'circlearrowright': '\u21BB',
        'orarr': '\u21BB',
        'circledS': '\u24C8',
        'oS': '\u24C8',
        'circledast': '\u229B',
        'oast': '\u229B',
        'circledcirc': '\u229A',
        'ocir': '\u229A',
        'circleddash': '\u229D',
        'odash': '\u229D',
        'cirfnint': '\u2A10',
        'cirmid': '\u2AEF',
        'cirscir': '\u29C2',
        'clubs': '\u2663',
        'clubsuit': '\u2663',
        'colon': '\u003A',
        'comma': '\u002C',
        'commat': '\u0040',
        'comp': '\u2201',
        'complement': '\u2201',
        'congdot': '\u2A6D',
        'copf': '\uD835\uDD54',
        'copysr': '\u2117',
        'crarr': '\u21B5',
        'cross': '\u2717',
        'cscr': '\uD835\uDCB8',
        'csub': '\u2ACF',
        'csube': '\u2AD1',
        'csup': '\u2AD0',
        'csupe': '\u2AD2',
        'ctdot': '\u22EF',
        'cudarrl': '\u2938',
        'cudarrr': '\u2935',
        'cuepr': '\u22DE',
        'curlyeqprec': '\u22DE',
        'cuesc': '\u22DF',
        'curlyeqsucc': '\u22DF',
        'cularr': '\u21B6',
        'curvearrowleft': '\u21B6',
        'cularrp': '\u293D',
        'cup': '\u222A',
        'cupbrcap': '\u2A48',
        'cupcap': '\u2A46',
        'cupcup': '\u2A4A',
        'cupdot': '\u228D',
        'cupor': '\u2A45',
        'cups': '\u222A\uFE00',
        'curarr': '\u21B7',
        'curvearrowright': '\u21B7',
        'curarrm': '\u293C',
        'curlyvee': '\u22CE',
        'cuvee': '\u22CE',
        'curlywedge': '\u22CF',
        'cuwed': '\u22CF',
        'curren': '\u00A4',
        'cwint': '\u2231',
        'cylcty': '\u232D',
        'dHar': '\u2965',
        'dagger': '\u2020',
        'daleth': '\u2138',
        'dash': '\u2010',
        'hyphen': '\u2010',
        'dbkarow': '\u290F',
        'rBarr': '\u290F',
        'dcaron': '\u010F',
        'dcy': '\u0434',
        'ddarr': '\u21CA',
        'downdownarrows': '\u21CA',
        'ddotseq': '\u2A77',
        'eDDot': '\u2A77',
        'deg': '\u00B0',
        'delta': '\u03B4',
        'demptyv': '\u29B1',
        'dfisht': '\u297F',
        'dfr': '\uD835\uDD21',
        'diamondsuit': '\u2666',
        'diams': '\u2666',
        'digamma': '\u03DD',
        'gammad': '\u03DD',
        'disin': '\u22F2',
        'div': '\u00F7',
        'divide': '\u00F7',
        'divideontimes': '\u22C7',
        'divonx': '\u22C7',
        'djcy': '\u0452',
        'dlcorn': '\u231E',
        'llcorner': '\u231E',
        'dlcrop': '\u230D',
        'dollar': '\u0024',
        'dopf': '\uD835\uDD55',
        'doteqdot': '\u2251',
        'eDot': '\u2251',
        'dotminus': '\u2238',
        'minusd': '\u2238',
        'dotplus': '\u2214',
        'plusdo': '\u2214',
        'dotsquare': '\u22A1',
        'sdotb': '\u22A1',
        'drcorn': '\u231F',
        'lrcorner': '\u231F',
        'drcrop': '\u230C',
        'dscr': '\uD835\uDCB9',
        'dscy': '\u0455',
        'dsol': '\u29F6',
        'dstrok': '\u0111',
        'dtdot': '\u22F1',
        'dtri': '\u25BF',
        'triangledown': '\u25BF',
        'dwangle': '\u29A6',
        'dzcy': '\u045F',
        'dzigrarr': '\u27FF',
        'eacute': '\u00E9',
        'easter': '\u2A6E',
        'ecaron': '\u011B',
        'ecir': '\u2256',
        'eqcirc': '\u2256',
        'ecirc': '\u00EA',
        'ecolon': '\u2255',
        'eqcolon': '\u2255',
        'ecy': '\u044D',
        'edot': '\u0117',
        'efDot': '\u2252',
        'fallingdotseq': '\u2252',
        'efr': '\uD835\uDD22',
        'eg': '\u2A9A',
        'egrave': '\u00E8',
        'egs': '\u2A96',
        'eqslantgtr': '\u2A96',
        'egsdot': '\u2A98',
        'el': '\u2A99',
        'elinters': '\u23E7',
        'ell': '\u2113',
        'els': '\u2A95',
        'eqslantless': '\u2A95',
        'elsdot': '\u2A97',
        'emacr': '\u0113',
        'empty': '\u2205',
        'emptyset': '\u2205',
        'emptyv': '\u2205',
        'varnothing': '\u2205',
        'emsp13': '\u2004',
        'emsp14': '\u2005',
        'emsp': '\u2003',
        'eng': '\u014B',
        'ensp': '\u2002',
        'eogon': '\u0119',
        'eopf': '\uD835\uDD56',
        'epar': '\u22D5',
        'eparsl': '\u29E3',
        'eplus': '\u2A71',
        'epsi': '\u03B5',
        'epsilon': '\u03B5',
        'epsiv': '\u03F5',
        'straightepsilon': '\u03F5',
        'varepsilon': '\u03F5',
        'equals': '\u003D',
        'equest': '\u225F',
        'questeq': '\u225F',
        'equivDD': '\u2A78',
        'eqvparsl': '\u29E5',
        'erDot': '\u2253',
        'risingdotseq': '\u2253',
        'erarr': '\u2971',
        'escr': '\u212F',
        'eta': '\u03B7',
        'eth': '\u00F0',
        'euml': '\u00EB',
        'euro': '\u20AC',
        'excl': '\u0021',
        'fcy': '\u0444',
        'female': '\u2640',
        'ffilig': '\uFB03',
        'fflig': '\uFB00',
        'ffllig': '\uFB04',
        'ffr': '\uD835\uDD23',
        'filig': '\uFB01',
        'fjlig': '\u0066\u006A',
        'flat': '\u266D',
        'fllig': '\uFB02',
        'fltns': '\u25B1',
        'fnof': '\u0192',
        'fopf': '\uD835\uDD57',
        'fork': '\u22D4',
        'pitchfork': '\u22D4',
        'forkv': '\u2AD9',
        'fpartint': '\u2A0D',
        'frac12': '\u00BD',
        'half': '\u00BD',
        'frac13': '\u2153',
        'frac14': '\u00BC',
        'frac15': '\u2155',
        'frac16': '\u2159',
        'frac18': '\u215B',
        'frac23': '\u2154',
        'frac25': '\u2156',
        'frac34': '\u00BE',
        'frac35': '\u2157',
        'frac38': '\u215C',
        'frac45': '\u2158',
        'frac56': '\u215A',
        'frac58': '\u215D',
        'frac78': '\u215E',
        'frasl': '\u2044',
        'frown': '\u2322',
        'sfrown': '\u2322',
        'fscr': '\uD835\uDCBB',
        'gEl': '\u2A8C',
        'gtreqqless': '\u2A8C',
        'gacute': '\u01F5',
        'gamma': '\u03B3',
        'gap': '\u2A86',
        'gtrapprox': '\u2A86',
        'gbreve': '\u011F',
        'gcirc': '\u011D',
        'gcy': '\u0433',
        'gdot': '\u0121',
        'gescc': '\u2AA9',
        'gesdot': '\u2A80',
        'gesdoto': '\u2A82',
        'gesdotol': '\u2A84',
        'gesl': '\u22DB\uFE00',
        'gesles': '\u2A94',
        'gfr': '\uD835\uDD24',
        'gimel': '\u2137',
        'gjcy': '\u0453',
        'glE': '\u2A92',
        'gla': '\u2AA5',
        'glj': '\u2AA4',
        'gnE': '\u2269',
        'gneqq': '\u2269',
        'gnap': '\u2A8A',
        'gnapprox': '\u2A8A',
        'gne': '\u2A88',
        'gneq': '\u2A88',
        'gnsim': '\u22E7',
        'gopf': '\uD835\uDD58',
        'gscr': '\u210A',
        'gsime': '\u2A8E',
        'gsiml': '\u2A90',
        'gtcc': '\u2AA7',
        'gtcir': '\u2A7A',
        'gtdot': '\u22D7',
        'gtrdot': '\u22D7',
        'gtlPar': '\u2995',
        'gtquest': '\u2A7C',
        'gtrarr': '\u2978',
        'gvertneqq': '\u2269\uFE00',
        'gvnE': '\u2269\uFE00',
        'hardcy': '\u044A',
        'harrcir': '\u2948',
        'harrw': '\u21AD',
        'leftrightsquigarrow': '\u21AD',
        'hbar': '\u210F',
        'hslash': '\u210F',
        'planck': '\u210F',
        'plankv': '\u210F',
        'hcirc': '\u0125',
        'hearts': '\u2665',
        'heartsuit': '\u2665',
        'hellip': '\u2026',
        'mldr': '\u2026',
        'hercon': '\u22B9',
        'hfr': '\uD835\uDD25',
        'hksearow': '\u2925',
        'searhk': '\u2925',
        'hkswarow': '\u2926',
        'swarhk': '\u2926',
        'hoarr': '\u21FF',
        'homtht': '\u223B',
        'hookleftarrow': '\u21A9',
        'larrhk': '\u21A9',
        'hookrightarrow': '\u21AA',
        'rarrhk': '\u21AA',
        'hopf': '\uD835\uDD59',
        'horbar': '\u2015',
        'hscr': '\uD835\uDCBD',
        'hstrok': '\u0127',
        'hybull': '\u2043',
        'iacute': '\u00ED',
        'icirc': '\u00EE',
        'icy': '\u0438',
        'iecy': '\u0435',
        'iexcl': '\u00A1',
        'ifr': '\uD835\uDD26',
        'igrave': '\u00EC',
        'iiiint': '\u2A0C',
        'qint': '\u2A0C',
        'iiint': '\u222D',
        'tint': '\u222D',
        'iinfin': '\u29DC',
        'iiota': '\u2129',
        'ijlig': '\u0133',
        'imacr': '\u012B',
        'imath': '\u0131',
        'inodot': '\u0131',
        'imof': '\u22B7',
        'imped': '\u01B5',
        'incare': '\u2105',
        'infin': '\u221E',
        'infintie': '\u29DD',
        'intcal': '\u22BA',
        'intercal': '\u22BA',
        'intlarhk': '\u2A17',
        'intprod': '\u2A3C',
        'iprod': '\u2A3C',
        'iocy': '\u0451',
        'iogon': '\u012F',
        'iopf': '\uD835\uDD5A',
        'iota': '\u03B9',
        'iquest': '\u00BF',
        'iscr': '\uD835\uDCBE',
        'isinE': '\u22F9',
        'isindot': '\u22F5',
        'isins': '\u22F4',
        'isinsv': '\u22F3',
        'itilde': '\u0129',
        'iukcy': '\u0456',
        'iuml': '\u00EF',
        'jcirc': '\u0135',
        'jcy': '\u0439',
        'jfr': '\uD835\uDD27',
        'jmath': '\u0237',
        'jopf': '\uD835\uDD5B',
        'jscr': '\uD835\uDCBF',
        'jsercy': '\u0458',
        'jukcy': '\u0454',
        'kappa': '\u03BA',
        'kappav': '\u03F0',
        'varkappa': '\u03F0',
        'kcedil': '\u0137',
        'kcy': '\u043A',
        'kfr': '\uD835\uDD28',
        'kgreen': '\u0138',
        'khcy': '\u0445',
        'kjcy': '\u045C',
        'kopf': '\uD835\uDD5C',
        'kscr': '\uD835\uDCC0',
        'lAtail': '\u291B',
        'lBarr': '\u290E',
        'lEg': '\u2A8B',
        'lesseqqgtr': '\u2A8B',
        'lHar': '\u2962',
        'lacute': '\u013A',
        'laemptyv': '\u29B4',
        'lambda': '\u03BB',
        'langd': '\u2991',
        'lap': '\u2A85',
        'lessapprox': '\u2A85',
        'laquo': '\u00AB',
        'larrbfs': '\u291F',
        'larrfs': '\u291D',
        'larrlp': '\u21AB',
        'looparrowleft': '\u21AB',
        'larrpl': '\u2939',
        'larrsim': '\u2973',
        'larrtl': '\u21A2',
        'leftarrowtail': '\u21A2',
        'lat': '\u2AAB',
        'latail': '\u2919',
        'late': '\u2AAD',
        'lates': '\u2AAD\uFE00',
        'lbarr': '\u290C',
        'lbbrk': '\u2772',
        'lbrace': '\u007B',
        'lcub': '\u007B',
        'lbrack': '\u005B',
        'lsqb': '\u005B',
        'lbrke': '\u298B',
        'lbrksld': '\u298F',
        'lbrkslu': '\u298D',
        'lcaron': '\u013E',
        'lcedil': '\u013C',
        'lcy': '\u043B',
        'ldca': '\u2936',
        'ldrdhar': '\u2967',
        'ldrushar': '\u294B',
        'ldsh': '\u21B2',
        'le': '\u2264',
        'leq': '\u2264',
        'leftleftarrows': '\u21C7',
        'llarr': '\u21C7',
        'leftthreetimes': '\u22CB',
        'lthree': '\u22CB',
        'lescc': '\u2AA8',
        'lesdot': '\u2A7F',
        'lesdoto': '\u2A81',
        'lesdotor': '\u2A83',
        'lesg': '\u22DA\uFE00',
        'lesges': '\u2A93',
        'lessdot': '\u22D6',
        'ltdot': '\u22D6',
        'lfisht': '\u297C',
        'lfr': '\uD835\uDD29',
        'lgE': '\u2A91',
        'lharul': '\u296A',
        'lhblk': '\u2584',
        'ljcy': '\u0459',
        'llhard': '\u296B',
        'lltri': '\u25FA',
        'lmidot': '\u0140',
        'lmoust': '\u23B0',
        'lmoustache': '\u23B0',
        'lnE': '\u2268',
        'lneqq': '\u2268',
        'lnap': '\u2A89',
        'lnapprox': '\u2A89',
        'lne': '\u2A87',
        'lneq': '\u2A87',
        'lnsim': '\u22E6',
        'loang': '\u27EC',
        'loarr': '\u21FD',
        'longmapsto': '\u27FC',
        'xmap': '\u27FC',
        'looparrowright': '\u21AC',
        'rarrlp': '\u21AC',
        'lopar': '\u2985',
        'lopf': '\uD835\uDD5D',
        'loplus': '\u2A2D',
        'lotimes': '\u2A34',
        'lowast': '\u2217',
        'loz': '\u25CA',
        'lozenge': '\u25CA',
        'lpar': '\u0028',
        'lparlt': '\u2993',
        'lrhard': '\u296D',
        'lrm': '\u200E',
        'lrtri': '\u22BF',
        'lsaquo': '\u2039',
        'lscr': '\uD835\uDCC1',
        'lsime': '\u2A8D',
        'lsimg': '\u2A8F',
        'lsquor': '\u201A',
        'sbquo': '\u201A',
        'lstrok': '\u0142',
        'ltcc': '\u2AA6',
        'ltcir': '\u2A79',
        'ltimes': '\u22C9',
        'ltlarr': '\u2976',
        'ltquest': '\u2A7B',
        'ltrPar': '\u2996',
        'ltri': '\u25C3',
        'triangleleft': '\u25C3',
        'lurdshar': '\u294A',
        'luruhar': '\u2966',
        'lvertneqq': '\u2268\uFE00',
        'lvnE': '\u2268\uFE00',
        'mDDot': '\u223A',
        'macr': '\u00AF',
        'strns': '\u00AF',
        'male': '\u2642',
        'malt': '\u2720',
        'maltese': '\u2720',
        'marker': '\u25AE',
        'mcomma': '\u2A29',
        'mcy': '\u043C',
        'mdash': '\u2014',
        'mfr': '\uD835\uDD2A',
        'mho': '\u2127',
        'micro': '\u00B5',
        'midcir': '\u2AF0',
        'minus': '\u2212',
        'minusdu': '\u2A2A',
        'mlcp': '\u2ADB',
        'models': '\u22A7',
        'mopf': '\uD835\uDD5E',
        'mscr': '\uD835\uDCC2',
        'mu': '\u03BC',
        'multimap': '\u22B8',
        'mumap': '\u22B8',
        'nGg': '\u22D9\u0338',
        'nGt': '\u226B\u20D2',
        'nLeftarrow': '\u21CD',
        'nlArr': '\u21CD',
        'nLeftrightarrow': '\u21CE',
        'nhArr': '\u21CE',
        'nLl': '\u22D8\u0338',
        'nLt': '\u226A\u20D2',
        'nRightarrow': '\u21CF',
        'nrArr': '\u21CF',
        'nVDash': '\u22AF',
        'nVdash': '\u22AE',
        'nacute': '\u0144',
        'nang': '\u2220\u20D2',
        'napE': '\u2A70\u0338',
        'napid': '\u224B\u0338',
        'napos': '\u0149',
        'natur': '\u266E',
        'natural': '\u266E',
        'ncap': '\u2A43',
        'ncaron': '\u0148',
        'ncedil': '\u0146',
        'ncongdot': '\u2A6D\u0338',
        'ncup': '\u2A42',
        'ncy': '\u043D',
        'ndash': '\u2013',
        'neArr': '\u21D7',
        'nearhk': '\u2924',
        'nedot': '\u2250\u0338',
        'nesear': '\u2928',
        'toea': '\u2928',
        'nfr': '\uD835\uDD2B',
        'nharr': '\u21AE',
        'nleftrightarrow': '\u21AE',
        'nhpar': '\u2AF2',
        'nis': '\u22FC',
        'nisd': '\u22FA',
        'njcy': '\u045A',
        'nlE': '\u2266\u0338',
        'nleqq': '\u2266\u0338',
        'nlarr': '\u219A',
        'nleftarrow': '\u219A',
        'nldr': '\u2025',
        'nopf': '\uD835\uDD5F',
        'not': '\u00AC',
        'notinE': '\u22F9\u0338',
        'notindot': '\u22F5\u0338',
        'notinvb': '\u22F7',
        'notinvc': '\u22F6',
        'notnivb': '\u22FE',
        'notnivc': '\u22FD',
        'nparsl': '\u2AFD\u20E5',
        'npart': '\u2202\u0338',
        'npolint': '\u2A14',
        'nrarr': '\u219B',
        'nrightarrow': '\u219B',
        'nrarrc': '\u2933\u0338',
        'nrarrw': '\u219D\u0338',
        'nscr': '\uD835\uDCC3',
        'nsub': '\u2284',
        'nsubE': '\u2AC5\u0338',
        'nsubseteqq': '\u2AC5\u0338',
        'nsup': '\u2285',
        'nsupE': '\u2AC6\u0338',
        'nsupseteqq': '\u2AC6\u0338',
        'ntilde': '\u00F1',
        'nu': '\u03BD',
        'num': '\u0023',
        'numero': '\u2116',
        'numsp': '\u2007',
        'nvDash': '\u22AD',
        'nvHarr': '\u2904',
        'nvap': '\u224D\u20D2',
        'nvdash': '\u22AC',
        'nvge': '\u2265\u20D2',
        'nvgt': '\u003E\u20D2',
        'nvinfin': '\u29DE',
        'nvlArr': '\u2902',
        'nvle': '\u2264\u20D2',
        'nvlt': '\u003C\u20D2',
        'nvltrie': '\u22B4\u20D2',
        'nvrArr': '\u2903',
        'nvrtrie': '\u22B5\u20D2',
        'nvsim': '\u223C\u20D2',
        'nwArr': '\u21D6',
        'nwarhk': '\u2923',
        'nwnear': '\u2927',
        'oacute': '\u00F3',
        'ocirc': '\u00F4',
        'ocy': '\u043E',
        'odblac': '\u0151',
        'odiv': '\u2A38',
        'odsold': '\u29BC',
        'oelig': '\u0153',
        'ofcir': '\u29BF',
        'ofr': '\uD835\uDD2C',
        'ogon': '\u02DB',
        'ograve': '\u00F2',
        'ogt': '\u29C1',
        'ohbar': '\u29B5',
        'olcir': '\u29BE',
        'olcross': '\u29BB',
        'olt': '\u29C0',
        'omacr': '\u014D',
        'omega': '\u03C9',
        'omicron': '\u03BF',
        'omid': '\u29B6',
        'oopf': '\uD835\uDD60',
        'opar': '\u29B7',
        'operp': '\u29B9',
        'or': '\u2228',
        'vee': '\u2228',
        'ord': '\u2A5D',
        'order': '\u2134',
        'orderof': '\u2134',
        'oscr': '\u2134',
        'ordf': '\u00AA',
        'ordm': '\u00BA',
        'origof': '\u22B6',
        'oror': '\u2A56',
        'orslope': '\u2A57',
        'orv': '\u2A5B',
        'oslash': '\u00F8',
        'osol': '\u2298',
        'otilde': '\u00F5',
        'otimesas': '\u2A36',
        'ouml': '\u00F6',
        'ovbar': '\u233D',
        'para': '\u00B6',
        'parsim': '\u2AF3',
        'parsl': '\u2AFD',
        'pcy': '\u043F',
        'percnt': '\u0025',
        'period': '\u002E',
        'permil': '\u2030',
        'pertenk': '\u2031',
        'pfr': '\uD835\uDD2D',
        'phi': '\u03C6',
        'phiv': '\u03D5',
        'straightphi': '\u03D5',
        'varphi': '\u03D5',
        'phone': '\u260E',
        'pi': '\u03C0',
        'piv': '\u03D6',
        'varpi': '\u03D6',
        'planckh': '\u210E',
        'plus': '\u002B',
        'plusacir': '\u2A23',
        'pluscir': '\u2A22',
        'plusdu': '\u2A25',
        'pluse': '\u2A72',
        'plussim': '\u2A26',
        'plustwo': '\u2A27',
        'pointint': '\u2A15',
        'popf': '\uD835\uDD61',
        'pound': '\u00A3',
        'prE': '\u2AB3',
        'prap': '\u2AB7',
        'precapprox': '\u2AB7',
        'precnapprox': '\u2AB9',
        'prnap': '\u2AB9',
        'precneqq': '\u2AB5',
        'prnE': '\u2AB5',
        'precnsim': '\u22E8',
        'prnsim': '\u22E8',
        'prime': '\u2032',
        'profalar': '\u232E',
        'profline': '\u2312',
        'profsurf': '\u2313',
        'prurel': '\u22B0',
        'pscr': '\uD835\uDCC5',
        'psi': '\u03C8',
        'puncsp': '\u2008',
        'qfr': '\uD835\uDD2E',
        'qopf': '\uD835\uDD62',
        'qprime': '\u2057',
        'qscr': '\uD835\uDCC6',
        'quatint': '\u2A16',
        'quest': '\u003F',
        'rAtail': '\u291C',
        'rHar': '\u2964',
        'race': '\u223D\u0331',
        'racute': '\u0155',
        'raemptyv': '\u29B3',
        'rangd': '\u2992',
        'range': '\u29A5',
        'raquo': '\u00BB',
        'rarrap': '\u2975',
        'rarrbfs': '\u2920',
        'rarrc': '\u2933',
        'rarrfs': '\u291E',
        'rarrpl': '\u2945',
        'rarrsim': '\u2974',
        'rarrtl': '\u21A3',
        'rightarrowtail': '\u21A3',
        'rarrw': '\u219D',
        'rightsquigarrow': '\u219D',
        'ratail': '\u291A',
        'ratio': '\u2236',
        'rbbrk': '\u2773',
        'rbrace': '\u007D',
        'rcub': '\u007D',
        'rbrack': '\u005D',
        'rsqb': '\u005D',
        'rbrke': '\u298C',
        'rbrksld': '\u298E',
        'rbrkslu': '\u2990',
        'rcaron': '\u0159',
        'rcedil': '\u0157',
        'rcy': '\u0440',
        'rdca': '\u2937',
        'rdldhar': '\u2969',
        'rdsh': '\u21B3',
        'rect': '\u25AD',
        'rfisht': '\u297D',
        'rfr': '\uD835\uDD2F',
        'rharul': '\u296C',
        'rho': '\u03C1',
        'rhov': '\u03F1',
        'varrho': '\u03F1',
        'rightrightarrows': '\u21C9',
        'rrarr': '\u21C9',
        'rightthreetimes': '\u22CC',
        'rthree': '\u22CC',
        'ring': '\u02DA',
        'rlm': '\u200F',
        'rmoust': '\u23B1',
        'rmoustache': '\u23B1',
        'rnmid': '\u2AEE',
        'roang': '\u27ED',
        'roarr': '\u21FE',
        'ropar': '\u2986',
        'ropf': '\uD835\uDD63',
        'roplus': '\u2A2E',
        'rotimes': '\u2A35',
        'rpar': '\u0029',
        'rpargt': '\u2994',
        'rppolint': '\u2A12',
        'rsaquo': '\u203A',
        'rscr': '\uD835\uDCC7',
        'rtimes': '\u22CA',
        'rtri': '\u25B9',
        'triangleright': '\u25B9',
        'rtriltri': '\u29CE',
        'ruluhar': '\u2968',
        'rx': '\u211E',
        'sacute': '\u015B',
        'scE': '\u2AB4',
        'scap': '\u2AB8',
        'succapprox': '\u2AB8',
        'scaron': '\u0161',
        'scedil': '\u015F',
        'scirc': '\u015D',
        'scnE': '\u2AB6',
        'succneqq': '\u2AB6',
        'scnap': '\u2ABA',
        'succnapprox': '\u2ABA',
        'scnsim': '\u22E9',
        'succnsim': '\u22E9',
        'scpolint': '\u2A13',
        'scy': '\u0441',
        'sdot': '\u22C5',
        'sdote': '\u2A66',
        'seArr': '\u21D8',
        'sect': '\u00A7',
        'semi': '\u003B',
        'seswar': '\u2929',
        'tosa': '\u2929',
        'sext': '\u2736',
        'sfr': '\uD835\uDD30',
        'sharp': '\u266F',
        'shchcy': '\u0449',
        'shcy': '\u0448',
        'shy': '\u00AD',
        'sigma': '\u03C3',
        'sigmaf': '\u03C2',
        'sigmav': '\u03C2',
        'varsigma': '\u03C2',
        'simdot': '\u2A6A',
        'simg': '\u2A9E',
        'simgE': '\u2AA0',
        'siml': '\u2A9D',
        'simlE': '\u2A9F',
        'simne': '\u2246',
        'simplus': '\u2A24',
        'simrarr': '\u2972',
        'smashp': '\u2A33',
        'smeparsl': '\u29E4',
        'smile': '\u2323',
        'ssmile': '\u2323',
        'smt': '\u2AAA',
        'smte': '\u2AAC',
        'smtes': '\u2AAC\uFE00',
        'softcy': '\u044C',
        'sol': '\u002F',
        'solb': '\u29C4',
        'solbar': '\u233F',
        'sopf': '\uD835\uDD64',
        'spades': '\u2660',
        'spadesuit': '\u2660',
        'sqcaps': '\u2293\uFE00',
        'sqcups': '\u2294\uFE00',
        'sscr': '\uD835\uDCC8',
        'star': '\u2606',
        'sub': '\u2282',
        'subset': '\u2282',
        'subE': '\u2AC5',
        'subseteqq': '\u2AC5',
        'subdot': '\u2ABD',
        'subedot': '\u2AC3',
        'submult': '\u2AC1',
        'subnE': '\u2ACB',
        'subsetneqq': '\u2ACB',
        'subne': '\u228A',
        'subsetneq': '\u228A',
        'subplus': '\u2ABF',
        'subrarr': '\u2979',
        'subsim': '\u2AC7',
        'subsub': '\u2AD5',
        'subsup': '\u2AD3',
        'sung': '\u266A',
        'sup1': '\u00B9',
        'sup2': '\u00B2',
        'sup3': '\u00B3',
        'supE': '\u2AC6',
        'supseteqq': '\u2AC6',
        'supdot': '\u2ABE',
        'supdsub': '\u2AD8',
        'supedot': '\u2AC4',
        'suphsol': '\u27C9',
        'suphsub': '\u2AD7',
        'suplarr': '\u297B',
        'supmult': '\u2AC2',
        'supnE': '\u2ACC',
        'supsetneqq': '\u2ACC',
        'supne': '\u228B',
        'supsetneq': '\u228B',
        'supplus': '\u2AC0',
        'supsim': '\u2AC8',
        'supsub': '\u2AD4',
        'supsup': '\u2AD6',
        'swArr': '\u21D9',
        'swnwar': '\u292A',
        'szlig': '\u00DF',
        'target': '\u2316',
        'tau': '\u03C4',
        'tcaron': '\u0165',
        'tcedil': '\u0163',
        'tcy': '\u0442',
        'telrec': '\u2315',
        'tfr': '\uD835\uDD31',
        'theta': '\u03B8',
        'thetasym': '\u03D1',
        'thetav': '\u03D1',
        'vartheta': '\u03D1',
        'thorn': '\u00FE',
        'times': '\u00D7',
        'timesbar': '\u2A31',
        'timesd': '\u2A30',
        'topbot': '\u2336',
        'topcir': '\u2AF1',
        'topf': '\uD835\uDD65',
        'topfork': '\u2ADA',
        'tprime': '\u2034',
        'triangle': '\u25B5',
        'utri': '\u25B5',
        'triangleq': '\u225C',
        'trie': '\u225C',
        'tridot': '\u25EC',
        'triminus': '\u2A3A',
        'triplus': '\u2A39',
        'trisb': '\u29CD',
        'tritime': '\u2A3B',
        'trpezium': '\u23E2',
        'tscr': '\uD835\uDCC9',
        'tscy': '\u0446',
        'tshcy': '\u045B',
        'tstrok': '\u0167',
        'uHar': '\u2963',
        'uacute': '\u00FA',
        'ubrcy': '\u045E',
        'ubreve': '\u016D',
        'ucirc': '\u00FB',
        'ucy': '\u0443',
        'udblac': '\u0171',
        'ufisht': '\u297E',
        'ufr': '\uD835\uDD32',
        'ugrave': '\u00F9',
        'uhblk': '\u2580',
        'ulcorn': '\u231C',
        'ulcorner': '\u231C',
        'ulcrop': '\u230F',
        'ultri': '\u25F8',
        'umacr': '\u016B',
        'uogon': '\u0173',
        'uopf': '\uD835\uDD66',
        'upsi': '\u03C5',
        'upsilon': '\u03C5',
        'upuparrows': '\u21C8',
        'uuarr': '\u21C8',
        'urcorn': '\u231D',
        'urcorner': '\u231D',
        'urcrop': '\u230E',
        'uring': '\u016F',
        'urtri': '\u25F9',
        'uscr': '\uD835\uDCCA',
        'utdot': '\u22F0',
        'utilde': '\u0169',
        'uuml': '\u00FC',
        'uwangle': '\u29A7',
        'vBar': '\u2AE8',
        'vBarv': '\u2AE9',
        'vangrt': '\u299C',
        'varsubsetneq': '\u228A\uFE00',
        'vsubne': '\u228A\uFE00',
        'varsubsetneqq': '\u2ACB\uFE00',
        'vsubnE': '\u2ACB\uFE00',
        'varsupsetneq': '\u228B\uFE00',
        'vsupne': '\u228B\uFE00',
        'varsupsetneqq': '\u2ACC\uFE00',
        'vsupnE': '\u2ACC\uFE00',
        'vcy': '\u0432',
        'veebar': '\u22BB',
        'veeeq': '\u225A',
        'vellip': '\u22EE',
        'vfr': '\uD835\uDD33',
        'vopf': '\uD835\uDD67',
        'vscr': '\uD835\uDCCB',
        'vzigzag': '\u299A',
        'wcirc': '\u0175',
        'wedbar': '\u2A5F',
        'wedgeq': '\u2259',
        'weierp': '\u2118',
        'wp': '\u2118',
        'wfr': '\uD835\uDD34',
        'wopf': '\uD835\uDD68',
        'wscr': '\uD835\uDCCC',
        'xfr': '\uD835\uDD35',
        'xi': '\u03BE',
        'xnis': '\u22FB',
        'xopf': '\uD835\uDD69',
        'xscr': '\uD835\uDCCD',
        'yacute': '\u00FD',
        'yacy': '\u044F',
        'ycirc': '\u0177',
        'ycy': '\u044B',
        'yen': '\u00A5',
        'yfr': '\uD835\uDD36',
        'yicy': '\u0457',
        'yopf': '\uD835\uDD6A',
        'yscr': '\uD835\uDCCE',
        'yucy': '\u044E',
        'yuml': '\u00FF',
        'zacute': '\u017A',
        'zcaron': '\u017E',
        'zcy': '\u0437',
        'zdot': '\u017C',
        'zeta': '\u03B6',
        'zfr': '\uD835\uDD37',
        'zhcy': '\u0436',
        'zigrarr': '\u21DD',
        'zopf': '\uD835\uDD6B',
        'zscr': '\uD835\uDCCF',
        'zwj': '\u200D',
        'zwnj': '\u200C'
    };
    // The &ngsp; pseudo-entity is denoting a space. see:
    // https://github.com/dart-lang/angular/blob/0bb611387d29d65b5af7f9d2515ab571fd3fbee4/_tests/test/compiler/preserve_whitespace_test.dart
    const NGSP_UNICODE = '\uE500';
    NAMED_ENTITIES['ngsp'] = NGSP_UNICODE;

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class TokenError extends ParseError {
        constructor(errorMsg, tokenType, span) {
            super(span, errorMsg);
            this.tokenType = tokenType;
        }
    }
    class TokenizeResult {
        constructor(tokens, errors, nonNormalizedIcuExpressions) {
            this.tokens = tokens;
            this.errors = errors;
            this.nonNormalizedIcuExpressions = nonNormalizedIcuExpressions;
        }
    }
    function tokenize(source, url, getTagDefinition, options = {}) {
        const tokenizer = new _Tokenizer(new ParseSourceFile(source, url), getTagDefinition, options);
        tokenizer.tokenize();
        return new TokenizeResult(mergeTextTokens(tokenizer.tokens), tokenizer.errors, tokenizer.nonNormalizedIcuExpressions);
    }
    const _CR_OR_CRLF_REGEXP = /\r\n?/g;
    function _unexpectedCharacterErrorMsg(charCode) {
        const char = charCode === $EOF ? 'EOF' : String.fromCharCode(charCode);
        return `Unexpected character "${char}"`;
    }
    function _unknownEntityErrorMsg(entitySrc) {
        return `Unknown entity "${entitySrc}" - use the "&#<decimal>;" or  "&#x<hex>;" syntax`;
    }
    function _unparsableEntityErrorMsg(type, entityStr) {
        return `Unable to parse entity "${entityStr}" - ${type} character reference entities must end with ";"`;
    }
    var CharacterReferenceType;
    (function (CharacterReferenceType) {
        CharacterReferenceType["HEX"] = "hexadecimal";
        CharacterReferenceType["DEC"] = "decimal";
    })(CharacterReferenceType || (CharacterReferenceType = {}));
    class _ControlFlowError {
        constructor(error) {
            this.error = error;
        }
    }
    // See https://www.w3.org/TR/html51/syntax.html#writing-html-documents
    class _Tokenizer {
        /**
         * @param _file The html source file being tokenized.
         * @param _getTagDefinition A function that will retrieve a tag definition for a given tag name.
         * @param options Configuration of the tokenization.
         */
        constructor(_file, _getTagDefinition, options) {
            this._getTagDefinition = _getTagDefinition;
            this._currentTokenStart = null;
            this._currentTokenType = null;
            this._expansionCaseStack = [];
            this._inInterpolation = false;
            this.tokens = [];
            this.errors = [];
            this.nonNormalizedIcuExpressions = [];
            this._tokenizeIcu = options.tokenizeExpansionForms || false;
            this._interpolationConfig = options.interpolationConfig || DEFAULT_INTERPOLATION_CONFIG;
            this._leadingTriviaCodePoints =
                options.leadingTriviaChars && options.leadingTriviaChars.map(c => c.codePointAt(0) || 0);
            const range = options.range || { endPos: _file.content.length, startPos: 0, startLine: 0, startCol: 0 };
            this._cursor = options.escapedString ? new EscapedCharacterCursor(_file, range) :
                new PlainCharacterCursor(_file, range);
            this._preserveLineEndings = options.preserveLineEndings || false;
            this._escapedString = options.escapedString || false;
            this._i18nNormalizeLineEndingsInICUs = options.i18nNormalizeLineEndingsInICUs || false;
            try {
                this._cursor.init();
            }
            catch (e) {
                this.handleError(e);
            }
        }
        _processCarriageReturns(content) {
            if (this._preserveLineEndings) {
                return content;
            }
            // https://www.w3.org/TR/html51/syntax.html#preprocessing-the-input-stream
            // In order to keep the original position in the source, we can not
            // pre-process it.
            // Instead CRs are processed right before instantiating the tokens.
            return content.replace(_CR_OR_CRLF_REGEXP, '\n');
        }
        tokenize() {
            while (this._cursor.peek() !== $EOF) {
                const start = this._cursor.clone();
                try {
                    if (this._attemptCharCode($LT)) {
                        if (this._attemptCharCode($BANG)) {
                            if (this._attemptCharCode($LBRACKET)) {
                                this._consumeCdata(start);
                            }
                            else if (this._attemptCharCode($MINUS)) {
                                this._consumeComment(start);
                            }
                            else {
                                this._consumeDocType(start);
                            }
                        }
                        else if (this._attemptCharCode($SLASH)) {
                            this._consumeTagClose(start);
                        }
                        else {
                            this._consumeTagOpen(start);
                        }
                    }
                    else if (!(this._tokenizeIcu && this._tokenizeExpansionForm())) {
                        // In (possibly interpolated) text the end of the text is given by `isTextEnd()`, while
                        // the premature end of an interpolation is given by the start of a new HTML element.
                        this._consumeWithInterpolation(5 /* TEXT */, 8 /* INTERPOLATION */, () => this._isTextEnd(), () => this._isTagStart());
                    }
                }
                catch (e) {
                    this.handleError(e);
                }
            }
            this._beginToken(24 /* EOF */);
            this._endToken([]);
        }
        /**
         * @returns whether an ICU token has been created
         * @internal
         */
        _tokenizeExpansionForm() {
            if (this.isExpansionFormStart()) {
                this._consumeExpansionFormStart();
                return true;
            }
            if (isExpansionCaseStart(this._cursor.peek()) && this._isInExpansionForm()) {
                this._consumeExpansionCaseStart();
                return true;
            }
            if (this._cursor.peek() === $RBRACE) {
                if (this._isInExpansionCase()) {
                    this._consumeExpansionCaseEnd();
                    return true;
                }
                if (this._isInExpansionForm()) {
                    this._consumeExpansionFormEnd();
                    return true;
                }
            }
            return false;
        }
        _beginToken(type, start = this._cursor.clone()) {
            this._currentTokenStart = start;
            this._currentTokenType = type;
        }
        _endToken(parts, end) {
            if (this._currentTokenStart === null) {
                throw new TokenError('Programming error - attempted to end a token when there was no start to the token', this._currentTokenType, this._cursor.getSpan(end));
            }
            if (this._currentTokenType === null) {
                throw new TokenError('Programming error - attempted to end a token which has no token type', null, this._cursor.getSpan(this._currentTokenStart));
            }
            const token = {
                type: this._currentTokenType,
                parts,
                sourceSpan: (end !== null && end !== void 0 ? end : this._cursor).getSpan(this._currentTokenStart, this._leadingTriviaCodePoints),
            };
            this.tokens.push(token);
            this._currentTokenStart = null;
            this._currentTokenType = null;
            return token;
        }
        _createError(msg, span) {
            if (this._isInExpansionForm()) {
                msg += ` (Do you have an unescaped "{" in your template? Use "{{ '{' }}") to escape it.)`;
            }
            const error = new TokenError(msg, this._currentTokenType, span);
            this._currentTokenStart = null;
            this._currentTokenType = null;
            return new _ControlFlowError(error);
        }
        handleError(e) {
            if (e instanceof CursorError) {
                e = this._createError(e.msg, this._cursor.getSpan(e.cursor));
            }
            if (e instanceof _ControlFlowError) {
                this.errors.push(e.error);
            }
            else {
                throw e;
            }
        }
        _attemptCharCode(charCode) {
            if (this._cursor.peek() === charCode) {
                this._cursor.advance();
                return true;
            }
            return false;
        }
        _attemptCharCodeCaseInsensitive(charCode) {
            if (compareCharCodeCaseInsensitive(this._cursor.peek(), charCode)) {
                this._cursor.advance();
                return true;
            }
            return false;
        }
        _requireCharCode(charCode) {
            const location = this._cursor.clone();
            if (!this._attemptCharCode(charCode)) {
                throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(location));
            }
        }
        _attemptStr(chars) {
            const len = chars.length;
            if (this._cursor.charsLeft() < len) {
                return false;
            }
            const initialPosition = this._cursor.clone();
            for (let i = 0; i < len; i++) {
                if (!this._attemptCharCode(chars.charCodeAt(i))) {
                    // If attempting to parse the string fails, we want to reset the parser
                    // to where it was before the attempt
                    this._cursor = initialPosition;
                    return false;
                }
            }
            return true;
        }
        _attemptStrCaseInsensitive(chars) {
            for (let i = 0; i < chars.length; i++) {
                if (!this._attemptCharCodeCaseInsensitive(chars.charCodeAt(i))) {
                    return false;
                }
            }
            return true;
        }
        _requireStr(chars) {
            const location = this._cursor.clone();
            if (!this._attemptStr(chars)) {
                throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(location));
            }
        }
        _attemptCharCodeUntilFn(predicate) {
            while (!predicate(this._cursor.peek())) {
                this._cursor.advance();
            }
        }
        _requireCharCodeUntilFn(predicate, len) {
            const start = this._cursor.clone();
            this._attemptCharCodeUntilFn(predicate);
            if (this._cursor.diff(start) < len) {
                throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(start));
            }
        }
        _attemptUntilChar(char) {
            while (this._cursor.peek() !== char) {
                this._cursor.advance();
            }
        }
        _readChar() {
            // Don't rely upon reading directly from `_input` as the actual char value
            // may have been generated from an escape sequence.
            const char = String.fromCodePoint(this._cursor.peek());
            this._cursor.advance();
            return char;
        }
        _consumeEntity(textTokenType) {
            this._beginToken(9 /* ENCODED_ENTITY */);
            const start = this._cursor.clone();
            this._cursor.advance();
            if (this._attemptCharCode($HASH)) {
                const isHex = this._attemptCharCode($x) || this._attemptCharCode($X);
                const codeStart = this._cursor.clone();
                this._attemptCharCodeUntilFn(isDigitEntityEnd);
                if (this._cursor.peek() != $SEMICOLON) {
                    // Advance cursor to include the peeked character in the string provided to the error
                    // message.
                    this._cursor.advance();
                    const entityType = isHex ? CharacterReferenceType.HEX : CharacterReferenceType.DEC;
                    throw this._createError(_unparsableEntityErrorMsg(entityType, this._cursor.getChars(start)), this._cursor.getSpan());
                }
                const strNum = this._cursor.getChars(codeStart);
                this._cursor.advance();
                try {
                    const charCode = parseInt(strNum, isHex ? 16 : 10);
                    this._endToken([String.fromCharCode(charCode), this._cursor.getChars(start)]);
                }
                catch (_a) {
                    throw this._createError(_unknownEntityErrorMsg(this._cursor.getChars(start)), this._cursor.getSpan());
                }
            }
            else {
                const nameStart = this._cursor.clone();
                this._attemptCharCodeUntilFn(isNamedEntityEnd);
                if (this._cursor.peek() != $SEMICOLON) {
                    // No semicolon was found so abort the encoded entity token that was in progress, and treat
                    // this as a text token
                    this._beginToken(textTokenType, start);
                    this._cursor = nameStart;
                    this._endToken(['&']);
                }
                else {
                    const name = this._cursor.getChars(nameStart);
                    this._cursor.advance();
                    const char = NAMED_ENTITIES[name];
                    if (!char) {
                        throw this._createError(_unknownEntityErrorMsg(name), this._cursor.getSpan(start));
                    }
                    this._endToken([char, `&${name};`]);
                }
            }
        }
        _consumeRawText(consumeEntities, endMarkerPredicate) {
            this._beginToken(consumeEntities ? 6 /* ESCAPABLE_RAW_TEXT */ : 7 /* RAW_TEXT */);
            const parts = [];
            while (true) {
                const tagCloseStart = this._cursor.clone();
                const foundEndMarker = endMarkerPredicate();
                this._cursor = tagCloseStart;
                if (foundEndMarker) {
                    break;
                }
                if (consumeEntities && this._cursor.peek() === $AMPERSAND) {
                    this._endToken([this._processCarriageReturns(parts.join(''))]);
                    parts.length = 0;
                    this._consumeEntity(6 /* ESCAPABLE_RAW_TEXT */);
                    this._beginToken(6 /* ESCAPABLE_RAW_TEXT */);
                }
                else {
                    parts.push(this._readChar());
                }
            }
            this._endToken([this._processCarriageReturns(parts.join(''))]);
        }
        _consumeComment(start) {
            this._beginToken(10 /* COMMENT_START */, start);
            this._requireCharCode($MINUS);
            this._endToken([]);
            this._consumeRawText(false, () => this._attemptStr('-->'));
            this._beginToken(11 /* COMMENT_END */);
            this._requireStr('-->');
            this._endToken([]);
        }
        _consumeCdata(start) {
            this._beginToken(12 /* CDATA_START */, start);
            this._requireStr('CDATA[');
            this._endToken([]);
            this._consumeRawText(false, () => this._attemptStr(']]>'));
            this._beginToken(13 /* CDATA_END */);
            this._requireStr(']]>');
            this._endToken([]);
        }
        _consumeDocType(start) {
            this._beginToken(18 /* DOC_TYPE */, start);
            const contentStart = this._cursor.clone();
            this._attemptUntilChar($GT);
            const content = this._cursor.getChars(contentStart);
            this._cursor.advance();
            this._endToken([content]);
        }
        _consumePrefixAndName() {
            const nameOrPrefixStart = this._cursor.clone();
            let prefix = '';
            while (this._cursor.peek() !== $COLON && !isPrefixEnd(this._cursor.peek())) {
                this._cursor.advance();
            }
            let nameStart;
            if (this._cursor.peek() === $COLON) {
                prefix = this._cursor.getChars(nameOrPrefixStart);
                this._cursor.advance();
                nameStart = this._cursor.clone();
            }
            else {
                nameStart = nameOrPrefixStart;
            }
            this._requireCharCodeUntilFn(isNameEnd, prefix === '' ? 0 : 1);
            const name = this._cursor.getChars(nameStart);
            return [prefix, name];
        }
        _consumeTagOpen(start) {
            let tagName;
            let prefix;
            let openTagToken;
            try {
                if (!isAsciiLetter(this._cursor.peek())) {
                    throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(start));
                }
                openTagToken = this._consumeTagOpenStart(start);
                prefix = openTagToken.parts[0];
                tagName = openTagToken.parts[1];
                this._attemptCharCodeUntilFn(isNotWhitespace);
                while (this._cursor.peek() !== $SLASH && this._cursor.peek() !== $GT &&
                    this._cursor.peek() !== $LT && this._cursor.peek() !== $EOF) {
                    this._consumeAttributeName();
                    this._attemptCharCodeUntilFn(isNotWhitespace);
                    if (this._attemptCharCode($EQ)) {
                        this._attemptCharCodeUntilFn(isNotWhitespace);
                        this._consumeAttributeValue();
                    }
                    this._attemptCharCodeUntilFn(isNotWhitespace);
                }
                this._consumeTagOpenEnd();
            }
            catch (e) {
                if (e instanceof _ControlFlowError) {
                    if (openTagToken) {
                        // We errored before we could close the opening tag, so it is incomplete.
                        openTagToken.type = 4 /* INCOMPLETE_TAG_OPEN */;
                    }
                    else {
                        // When the start tag is invalid, assume we want a "<" as text.
                        // Back to back text tokens are merged at the end.
                        this._beginToken(5 /* TEXT */, start);
                        this._endToken(['<']);
                    }
                    return;
                }
                throw e;
            }
            const contentTokenType = this._getTagDefinition(tagName).getContentType(prefix);
            if (contentTokenType === TagContentType.RAW_TEXT) {
                this._consumeRawTextWithTagClose(prefix, tagName, false);
            }
            else if (contentTokenType === TagContentType.ESCAPABLE_RAW_TEXT) {
                this._consumeRawTextWithTagClose(prefix, tagName, true);
            }
        }
        _consumeRawTextWithTagClose(prefix, tagName, consumeEntities) {
            this._consumeRawText(consumeEntities, () => {
                if (!this._attemptCharCode($LT))
                    return false;
                if (!this._attemptCharCode($SLASH))
                    return false;
                this._attemptCharCodeUntilFn(isNotWhitespace);
                if (!this._attemptStrCaseInsensitive(tagName))
                    return false;
                this._attemptCharCodeUntilFn(isNotWhitespace);
                return this._attemptCharCode($GT);
            });
            this._beginToken(3 /* TAG_CLOSE */);
            this._requireCharCodeUntilFn(code => code === $GT, 3);
            this._cursor.advance(); // Consume the `>`
            this._endToken([prefix, tagName]);
        }
        _consumeTagOpenStart(start) {
            this._beginToken(0 /* TAG_OPEN_START */, start);
            const parts = this._consumePrefixAndName();
            return this._endToken(parts);
        }
        _consumeAttributeName() {
            const attrNameStart = this._cursor.peek();
            if (attrNameStart === $SQ || attrNameStart === $DQ) {
                throw this._createError(_unexpectedCharacterErrorMsg(attrNameStart), this._cursor.getSpan());
            }
            this._beginToken(14 /* ATTR_NAME */);
            const prefixAndName = this._consumePrefixAndName();
            this._endToken(prefixAndName);
        }
        _consumeAttributeValue() {
            if (this._cursor.peek() === $SQ || this._cursor.peek() === $DQ) {
                const quoteChar = this._cursor.peek();
                this._consumeQuote(quoteChar);
                // In an attribute then end of the attribute value and the premature end to an interpolation
                // are both triggered by the `quoteChar`.
                const endPredicate = () => this._cursor.peek() === quoteChar;
                this._consumeWithInterpolation(16 /* ATTR_VALUE_TEXT */, 17 /* ATTR_VALUE_INTERPOLATION */, endPredicate, endPredicate);
                this._consumeQuote(quoteChar);
            }
            else {
                const endPredicate = () => isNameEnd(this._cursor.peek());
                this._consumeWithInterpolation(16 /* ATTR_VALUE_TEXT */, 17 /* ATTR_VALUE_INTERPOLATION */, endPredicate, endPredicate);
            }
        }
        _consumeQuote(quoteChar) {
            this._beginToken(15 /* ATTR_QUOTE */);
            this._requireCharCode(quoteChar);
            this._endToken([String.fromCodePoint(quoteChar)]);
        }
        _consumeTagOpenEnd() {
            const tokenType = this._attemptCharCode($SLASH) ? 2 /* TAG_OPEN_END_VOID */ : 1 /* TAG_OPEN_END */;
            this._beginToken(tokenType);
            this._requireCharCode($GT);
            this._endToken([]);
        }
        _consumeTagClose(start) {
            this._beginToken(3 /* TAG_CLOSE */, start);
            this._attemptCharCodeUntilFn(isNotWhitespace);
            const prefixAndName = this._consumePrefixAndName();
            this._attemptCharCodeUntilFn(isNotWhitespace);
            this._requireCharCode($GT);
            this._endToken(prefixAndName);
        }
        _consumeExpansionFormStart() {
            this._beginToken(19 /* EXPANSION_FORM_START */);
            this._requireCharCode($LBRACE);
            this._endToken([]);
            this._expansionCaseStack.push(19 /* EXPANSION_FORM_START */);
            this._beginToken(7 /* RAW_TEXT */);
            const condition = this._readUntil($COMMA);
            const normalizedCondition = this._processCarriageReturns(condition);
            if (this._i18nNormalizeLineEndingsInICUs) {
                // We explicitly want to normalize line endings for this text.
                this._endToken([normalizedCondition]);
            }
            else {
                // We are not normalizing line endings.
                const conditionToken = this._endToken([condition]);
                if (normalizedCondition !== condition) {
                    this.nonNormalizedIcuExpressions.push(conditionToken);
                }
            }
            this._requireCharCode($COMMA);
            this._attemptCharCodeUntilFn(isNotWhitespace);
            this._beginToken(7 /* RAW_TEXT */);
            const type = this._readUntil($COMMA);
            this._endToken([type]);
            this._requireCharCode($COMMA);
            this._attemptCharCodeUntilFn(isNotWhitespace);
        }
        _consumeExpansionCaseStart() {
            this._beginToken(20 /* EXPANSION_CASE_VALUE */);
            const value = this._readUntil($LBRACE).trim();
            this._endToken([value]);
            this._attemptCharCodeUntilFn(isNotWhitespace);
            this._beginToken(21 /* EXPANSION_CASE_EXP_START */);
            this._requireCharCode($LBRACE);
            this._endToken([]);
            this._attemptCharCodeUntilFn(isNotWhitespace);
            this._expansionCaseStack.push(21 /* EXPANSION_CASE_EXP_START */);
        }
        _consumeExpansionCaseEnd() {
            this._beginToken(22 /* EXPANSION_CASE_EXP_END */);
            this._requireCharCode($RBRACE);
            this._endToken([]);
            this._attemptCharCodeUntilFn(isNotWhitespace);
            this._expansionCaseStack.pop();
        }
        _consumeExpansionFormEnd() {
            this._beginToken(23 /* EXPANSION_FORM_END */);
            this._requireCharCode($RBRACE);
            this._endToken([]);
            this._expansionCaseStack.pop();
        }
        /**
         * Consume a string that may contain interpolation expressions.
         *
         * The first token consumed will be of `tokenType` and then there will be alternating
         * `interpolationTokenType` and `tokenType` tokens until the `endPredicate()` returns true.
         *
         * If an interpolation token ends prematurely it will have no end marker in its `parts` array.
         *
         * @param textTokenType the kind of tokens to interleave around interpolation tokens.
         * @param interpolationTokenType the kind of tokens that contain interpolation.
         * @param endPredicate a function that should return true when we should stop consuming.
         * @param endInterpolation a function that should return true if there is a premature end to an
         *     interpolation expression - i.e. before we get to the normal interpolation closing marker.
         */
        _consumeWithInterpolation(textTokenType, interpolationTokenType, endPredicate, endInterpolation) {
            this._beginToken(textTokenType);
            const parts = [];
            while (!endPredicate()) {
                const current = this._cursor.clone();
                if (this._interpolationConfig && this._attemptStr(this._interpolationConfig.start)) {
                    this._endToken([this._processCarriageReturns(parts.join(''))], current);
                    parts.length = 0;
                    this._consumeInterpolation(interpolationTokenType, current, endInterpolation);
                    this._beginToken(textTokenType);
                }
                else if (this._cursor.peek() === $AMPERSAND) {
                    this._endToken([this._processCarriageReturns(parts.join(''))]);
                    parts.length = 0;
                    this._consumeEntity(textTokenType);
                    this._beginToken(textTokenType);
                }
                else {
                    parts.push(this._readChar());
                }
            }
            // It is possible that an interpolation was started but not ended inside this text token.
            // Make sure that we reset the state of the lexer correctly.
            this._inInterpolation = false;
            this._endToken([this._processCarriageReturns(parts.join(''))]);
        }
        /**
         * Consume a block of text that has been interpreted as an Angular interpolation.
         *
         * @param interpolationTokenType the type of the interpolation token to generate.
         * @param interpolationStart a cursor that points to the start of this interpolation.
         * @param prematureEndPredicate a function that should return true if the next characters indicate
         *     an end to the interpolation before its normal closing marker.
         */
        _consumeInterpolation(interpolationTokenType, interpolationStart, prematureEndPredicate) {
            const parts = [];
            this._beginToken(interpolationTokenType, interpolationStart);
            parts.push(this._interpolationConfig.start);
            // Find the end of the interpolation, ignoring content inside quotes.
            const expressionStart = this._cursor.clone();
            let inQuote = null;
            let inComment = false;
            while (this._cursor.peek() !== $EOF &&
                (prematureEndPredicate === null || !prematureEndPredicate())) {
                const current = this._cursor.clone();
                if (this._isTagStart()) {
                    // We are starting what looks like an HTML element in the middle of this interpolation.
                    // Reset the cursor to before the `<` character and end the interpolation token.
                    // (This is actually wrong but here for backward compatibility).
                    this._cursor = current;
                    parts.push(this._getProcessedChars(expressionStart, current));
                    this._endToken(parts);
                    return;
                }
                if (inQuote === null) {
                    if (this._attemptStr(this._interpolationConfig.end)) {
                        // We are not in a string, and we hit the end interpolation marker
                        parts.push(this._getProcessedChars(expressionStart, current));
                        parts.push(this._interpolationConfig.end);
                        this._endToken(parts);
                        return;
                    }
                    else if (this._attemptStr('//')) {
                        // Once we are in a comment we ignore any quotes
                        inComment = true;
                    }
                }
                const char = this._cursor.peek();
                this._cursor.advance();
                if (char === $BACKSLASH) {
                    // Skip the next character because it was escaped.
                    this._cursor.advance();
                }
                else if (char === inQuote) {
                    // Exiting the current quoted string
                    inQuote = null;
                }
                else if (!inComment && inQuote === null && isQuote(char)) {
                    // Entering a new quoted string
                    inQuote = char;
                }
            }
            // We hit EOF without finding a closing interpolation marker
            parts.push(this._getProcessedChars(expressionStart, this._cursor));
            this._endToken(parts);
        }
        _getProcessedChars(start, end) {
            return this._processCarriageReturns(end.getChars(start));
        }
        _isTextEnd() {
            if (this._isTagStart() || this._cursor.peek() === $EOF) {
                return true;
            }
            if (this._tokenizeIcu && !this._inInterpolation) {
                if (this.isExpansionFormStart()) {
                    // start of an expansion form
                    return true;
                }
                if (this._cursor.peek() === $RBRACE && this._isInExpansionCase()) {
                    // end of and expansion case
                    return true;
                }
            }
            return false;
        }
        /**
         * Returns true if the current cursor is pointing to the start of a tag
         * (opening/closing/comments/cdata/etc).
         */
        _isTagStart() {
            if (this._cursor.peek() === $LT) {
                // We assume that `<` followed by whitespace is not the start of an HTML element.
                const tmp = this._cursor.clone();
                tmp.advance();
                // If the next character is alphabetic, ! nor / then it is a tag start
                const code = tmp.peek();
                if (($a <= code && code <= $z) || ($A <= code && code <= $Z) ||
                    code === $SLASH || code === $BANG) {
                    return true;
                }
            }
            return false;
        }
        _readUntil(char) {
            const start = this._cursor.clone();
            this._attemptUntilChar(char);
            return this._cursor.getChars(start);
        }
        _isInExpansionCase() {
            return this._expansionCaseStack.length > 0 &&
                this._expansionCaseStack[this._expansionCaseStack.length - 1] ===
                    21 /* EXPANSION_CASE_EXP_START */;
        }
        _isInExpansionForm() {
            return this._expansionCaseStack.length > 0 &&
                this._expansionCaseStack[this._expansionCaseStack.length - 1] ===
                    19 /* EXPANSION_FORM_START */;
        }
        isExpansionFormStart() {
            if (this._cursor.peek() !== $LBRACE) {
                return false;
            }
            if (this._interpolationConfig) {
                const start = this._cursor.clone();
                const isInterpolation = this._attemptStr(this._interpolationConfig.start);
                this._cursor = start;
                return !isInterpolation;
            }
            return true;
        }
    }
    function isNotWhitespace(code) {
        return !isWhitespace(code) || code === $EOF;
    }
    function isNameEnd(code) {
        return isWhitespace(code) || code === $GT || code === $LT ||
            code === $SLASH || code === $SQ || code === $DQ || code === $EQ ||
            code === $EOF;
    }
    function isPrefixEnd(code) {
        return (code < $a || $z < code) && (code < $A || $Z < code) &&
            (code < $0 || code > $9);
    }
    function isDigitEntityEnd(code) {
        return code === $SEMICOLON || code === $EOF || !isAsciiHexDigit(code);
    }
    function isNamedEntityEnd(code) {
        return code === $SEMICOLON || code === $EOF || !isAsciiLetter(code);
    }
    function isExpansionCaseStart(peek) {
        return peek !== $RBRACE;
    }
    function compareCharCodeCaseInsensitive(code1, code2) {
        return toUpperCaseCharCode(code1) === toUpperCaseCharCode(code2);
    }
    function toUpperCaseCharCode(code) {
        return code >= $a && code <= $z ? code - $a + $A : code;
    }
    function mergeTextTokens(srcTokens) {
        const dstTokens = [];
        let lastDstToken = undefined;
        for (let i = 0; i < srcTokens.length; i++) {
            const token = srcTokens[i];
            if ((lastDstToken && lastDstToken.type === 5 /* TEXT */ && token.type === 5 /* TEXT */) ||
                (lastDstToken && lastDstToken.type === 16 /* ATTR_VALUE_TEXT */ &&
                    token.type === 16 /* ATTR_VALUE_TEXT */)) {
                lastDstToken.parts[0] += token.parts[0];
                lastDstToken.sourceSpan.end = token.sourceSpan.end;
            }
            else {
                lastDstToken = token;
                dstTokens.push(lastDstToken);
            }
        }
        return dstTokens;
    }
    class PlainCharacterCursor {
        constructor(fileOrCursor, range) {
            if (fileOrCursor instanceof PlainCharacterCursor) {
                this.file = fileOrCursor.file;
                this.input = fileOrCursor.input;
                this.end = fileOrCursor.end;
                const state = fileOrCursor.state;
                // Note: avoid using `{...fileOrCursor.state}` here as that has a severe performance penalty.
                // In ES5 bundles the object spread operator is translated into the `__assign` helper, which
                // is not optimized by VMs as efficiently as a raw object literal. Since this constructor is
                // called in tight loops, this difference matters.
                this.state = {
                    peek: state.peek,
                    offset: state.offset,
                    line: state.line,
                    column: state.column,
                };
            }
            else {
                if (!range) {
                    throw new Error('Programming error: the range argument must be provided with a file argument.');
                }
                this.file = fileOrCursor;
                this.input = fileOrCursor.content;
                this.end = range.endPos;
                this.state = {
                    peek: -1,
                    offset: range.startPos,
                    line: range.startLine,
                    column: range.startCol,
                };
            }
        }
        clone() {
            return new PlainCharacterCursor(this);
        }
        peek() {
            return this.state.peek;
        }
        charsLeft() {
            return this.end - this.state.offset;
        }
        diff(other) {
            return this.state.offset - other.state.offset;
        }
        advance() {
            this.advanceState(this.state);
        }
        init() {
            this.updatePeek(this.state);
        }
        getSpan(start, leadingTriviaCodePoints) {
            start = start || this;
            let fullStart = start;
            if (leadingTriviaCodePoints) {
                while (this.diff(start) > 0 && leadingTriviaCodePoints.indexOf(start.peek()) !== -1) {
                    if (fullStart === start) {
                        start = start.clone();
                    }
                    start.advance();
                }
            }
            const startLocation = this.locationFromCursor(start);
            const endLocation = this.locationFromCursor(this);
            const fullStartLocation = fullStart !== start ? this.locationFromCursor(fullStart) : startLocation;
            return new ParseSourceSpan(startLocation, endLocation, fullStartLocation);
        }
        getChars(start) {
            return this.input.substring(start.state.offset, this.state.offset);
        }
        charAt(pos) {
            return this.input.charCodeAt(pos);
        }
        advanceState(state) {
            if (state.offset >= this.end) {
                this.state = state;
                throw new CursorError('Unexpected character "EOF"', this);
            }
            const currentChar = this.charAt(state.offset);
            if (currentChar === $LF) {
                state.line++;
                state.column = 0;
            }
            else if (!isNewLine(currentChar)) {
                state.column++;
            }
            state.offset++;
            this.updatePeek(state);
        }
        updatePeek(state) {
            state.peek = state.offset >= this.end ? $EOF : this.charAt(state.offset);
        }
        locationFromCursor(cursor) {
            return new ParseLocation(cursor.file, cursor.state.offset, cursor.state.line, cursor.state.column);
        }
    }
    class EscapedCharacterCursor extends PlainCharacterCursor {
        constructor(fileOrCursor, range) {
            if (fileOrCursor instanceof EscapedCharacterCursor) {
                super(fileOrCursor);
                this.internalState = Object.assign({}, fileOrCursor.internalState);
            }
            else {
                super(fileOrCursor, range);
                this.internalState = this.state;
            }
        }
        advance() {
            this.state = this.internalState;
            super.advance();
            this.processEscapeSequence();
        }
        init() {
            super.init();
            this.processEscapeSequence();
        }
        clone() {
            return new EscapedCharacterCursor(this);
        }
        getChars(start) {
            const cursor = start.clone();
            let chars = '';
            while (cursor.internalState.offset < this.internalState.offset) {
                chars += String.fromCodePoint(cursor.peek());
                cursor.advance();
            }
            return chars;
        }
        /**
         * Process the escape sequence that starts at the current position in the text.
         *
         * This method is called to ensure that `peek` has the unescaped value of escape sequences.
         */
        processEscapeSequence() {
            const peek = () => this.internalState.peek;
            if (peek() === $BACKSLASH) {
                // We have hit an escape sequence so we need the internal state to become independent
                // of the external state.
                this.internalState = Object.assign({}, this.state);
                // Move past the backslash
                this.advanceState(this.internalState);
                // First check for standard control char sequences
                if (peek() === $n) {
                    this.state.peek = $LF;
                }
                else if (peek() === $r) {
                    this.state.peek = $CR;
                }
                else if (peek() === $v) {
                    this.state.peek = $VTAB;
                }
                else if (peek() === $t) {
                    this.state.peek = $TAB;
                }
                else if (peek() === $b) {
                    this.state.peek = $BSPACE;
                }
                else if (peek() === $f) {
                    this.state.peek = $FF;
                }
                // Now consider more complex sequences
                else if (peek() === $u) {
                    // Unicode code-point sequence
                    this.advanceState(this.internalState); // advance past the `u` char
                    if (peek() === $LBRACE) {
                        // Variable length Unicode, e.g. `\x{123}`
                        this.advanceState(this.internalState); // advance past the `{` char
                        // Advance past the variable number of hex digits until we hit a `}` char
                        const digitStart = this.clone();
                        let length = 0;
                        while (peek() !== $RBRACE) {
                            this.advanceState(this.internalState);
                            length++;
                        }
                        this.state.peek = this.decodeHexDigits(digitStart, length);
                    }
                    else {
                        // Fixed length Unicode, e.g. `\u1234`
                        const digitStart = this.clone();
                        this.advanceState(this.internalState);
                        this.advanceState(this.internalState);
                        this.advanceState(this.internalState);
                        this.state.peek = this.decodeHexDigits(digitStart, 4);
                    }
                }
                else if (peek() === $x) {
                    // Hex char code, e.g. `\x2F`
                    this.advanceState(this.internalState); // advance past the `x` char
                    const digitStart = this.clone();
                    this.advanceState(this.internalState);
                    this.state.peek = this.decodeHexDigits(digitStart, 2);
                }
                else if (isOctalDigit(peek())) {
                    // Octal char code, e.g. `\012`,
                    let octal = '';
                    let length = 0;
                    let previous = this.clone();
                    while (isOctalDigit(peek()) && length < 3) {
                        previous = this.clone();
                        octal += String.fromCodePoint(peek());
                        this.advanceState(this.internalState);
                        length++;
                    }
                    this.state.peek = parseInt(octal, 8);
                    // Backup one char
                    this.internalState = previous.internalState;
                }
                else if (isNewLine(this.internalState.peek)) {
                    // Line continuation `\` followed by a new line
                    this.advanceState(this.internalState); // advance over the newline
                    this.state = this.internalState;
                }
                else {
                    // If none of the `if` blocks were executed then we just have an escaped normal character.
                    // In that case we just, effectively, skip the backslash from the character.
                    this.state.peek = this.internalState.peek;
                }
            }
        }
        decodeHexDigits(start, length) {
            const hex = this.input.substr(start.internalState.offset, length);
            const charCode = parseInt(hex, 16);
            if (!isNaN(charCode)) {
                return charCode;
            }
            else {
                start.state = start.internalState;
                throw new CursorError('Invalid hexadecimal escape sequence', start);
            }
        }
    }
    class CursorError {
        constructor(msg, cursor) {
            this.msg = msg;
            this.cursor = cursor;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class TreeError extends ParseError {
        constructor(elementName, span, msg) {
            super(span, msg);
            this.elementName = elementName;
        }
        static create(elementName, span, msg) {
            return new TreeError(elementName, span, msg);
        }
    }
    class ParseTreeResult {
        constructor(rootNodes, errors) {
            this.rootNodes = rootNodes;
            this.errors = errors;
        }
    }
    class Parser {
        constructor(getTagDefinition) {
            this.getTagDefinition = getTagDefinition;
        }
        parse(source, url, options) {
            const tokenizeResult = tokenize(source, url, this.getTagDefinition, options);
            const parser = new _TreeBuilder(tokenizeResult.tokens, this.getTagDefinition);
            parser.build();
            return new ParseTreeResult(parser.rootNodes, tokenizeResult.errors.concat(parser.errors));
        }
    }
    class _TreeBuilder {
        constructor(tokens, getTagDefinition) {
            this.tokens = tokens;
            this.getTagDefinition = getTagDefinition;
            this._index = -1;
            this._elementStack = [];
            this.rootNodes = [];
            this.errors = [];
            this._advance();
        }
        build() {
            while (this._peek.type !== 24 /* EOF */) {
                if (this._peek.type === 0 /* TAG_OPEN_START */ ||
                    this._peek.type === 4 /* INCOMPLETE_TAG_OPEN */) {
                    this._consumeStartTag(this._advance());
                }
                else if (this._peek.type === 3 /* TAG_CLOSE */) {
                    this._consumeEndTag(this._advance());
                }
                else if (this._peek.type === 12 /* CDATA_START */) {
                    this._closeVoidElement();
                    this._consumeCdata(this._advance());
                }
                else if (this._peek.type === 10 /* COMMENT_START */) {
                    this._closeVoidElement();
                    this._consumeComment(this._advance());
                }
                else if (this._peek.type === 5 /* TEXT */ || this._peek.type === 7 /* RAW_TEXT */ ||
                    this._peek.type === 6 /* ESCAPABLE_RAW_TEXT */) {
                    this._closeVoidElement();
                    this._consumeText(this._advance());
                }
                else if (this._peek.type === 19 /* EXPANSION_FORM_START */) {
                    this._consumeExpansion(this._advance());
                }
                else {
                    // Skip all other tokens...
                    this._advance();
                }
            }
        }
        _advance() {
            const prev = this._peek;
            if (this._index < this.tokens.length - 1) {
                // Note: there is always an EOF token at the end
                this._index++;
            }
            this._peek = this.tokens[this._index];
            return prev;
        }
        _advanceIf(type) {
            if (this._peek.type === type) {
                return this._advance();
            }
            return null;
        }
        _consumeCdata(_startToken) {
            this._consumeText(this._advance());
            this._advanceIf(13 /* CDATA_END */);
        }
        _consumeComment(token) {
            const text = this._advanceIf(7 /* RAW_TEXT */);
            this._advanceIf(11 /* COMMENT_END */);
            const value = text != null ? text.parts[0].trim() : null;
            this._addToParent(new Comment$1(value, token.sourceSpan));
        }
        _consumeExpansion(token) {
            const switchValue = this._advance();
            const type = this._advance();
            const cases = [];
            // read =
            while (this._peek.type === 20 /* EXPANSION_CASE_VALUE */) {
                const expCase = this._parseExpansionCase();
                if (!expCase)
                    return; // error
                cases.push(expCase);
            }
            // read the final }
            if (this._peek.type !== 23 /* EXPANSION_FORM_END */) {
                this.errors.push(TreeError.create(null, this._peek.sourceSpan, `Invalid ICU message. Missing '}'.`));
                return;
            }
            const sourceSpan = new ParseSourceSpan(token.sourceSpan.start, this._peek.sourceSpan.end, token.sourceSpan.fullStart);
            this._addToParent(new Expansion(switchValue.parts[0], type.parts[0], cases, sourceSpan, switchValue.sourceSpan));
            this._advance();
        }
        _parseExpansionCase() {
            const value = this._advance();
            // read {
            if (this._peek.type !== 21 /* EXPANSION_CASE_EXP_START */) {
                this.errors.push(TreeError.create(null, this._peek.sourceSpan, `Invalid ICU message. Missing '{'.`));
                return null;
            }
            // read until }
            const start = this._advance();
            const exp = this._collectExpansionExpTokens(start);
            if (!exp)
                return null;
            const end = this._advance();
            exp.push({ type: 24 /* EOF */, parts: [], sourceSpan: end.sourceSpan });
            // parse everything in between { and }
            const expansionCaseParser = new _TreeBuilder(exp, this.getTagDefinition);
            expansionCaseParser.build();
            if (expansionCaseParser.errors.length > 0) {
                this.errors = this.errors.concat(expansionCaseParser.errors);
                return null;
            }
            const sourceSpan = new ParseSourceSpan(value.sourceSpan.start, end.sourceSpan.end, value.sourceSpan.fullStart);
            const expSourceSpan = new ParseSourceSpan(start.sourceSpan.start, end.sourceSpan.end, start.sourceSpan.fullStart);
            return new ExpansionCase(value.parts[0], expansionCaseParser.rootNodes, sourceSpan, value.sourceSpan, expSourceSpan);
        }
        _collectExpansionExpTokens(start) {
            const exp = [];
            const expansionFormStack = [21 /* EXPANSION_CASE_EXP_START */];
            while (true) {
                if (this._peek.type === 19 /* EXPANSION_FORM_START */ ||
                    this._peek.type === 21 /* EXPANSION_CASE_EXP_START */) {
                    expansionFormStack.push(this._peek.type);
                }
                if (this._peek.type === 22 /* EXPANSION_CASE_EXP_END */) {
                    if (lastOnStack(expansionFormStack, 21 /* EXPANSION_CASE_EXP_START */)) {
                        expansionFormStack.pop();
                        if (expansionFormStack.length === 0)
                            return exp;
                    }
                    else {
                        this.errors.push(TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`));
                        return null;
                    }
                }
                if (this._peek.type === 23 /* EXPANSION_FORM_END */) {
                    if (lastOnStack(expansionFormStack, 19 /* EXPANSION_FORM_START */)) {
                        expansionFormStack.pop();
                    }
                    else {
                        this.errors.push(TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`));
                        return null;
                    }
                }
                if (this._peek.type === 24 /* EOF */) {
                    this.errors.push(TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`));
                    return null;
                }
                exp.push(this._advance());
            }
        }
        _consumeText(token) {
            const tokens = [token];
            const startSpan = token.sourceSpan;
            let text = token.parts[0];
            if (text.length > 0 && text[0] === '\n') {
                const parent = this._getParentElement();
                if (parent != null && parent.children.length === 0 &&
                    this.getTagDefinition(parent.name).ignoreFirstLf) {
                    text = text.substring(1);
                    tokens[0] = { type: token.type, sourceSpan: token.sourceSpan, parts: [text] };
                }
            }
            while (this._peek.type === 8 /* INTERPOLATION */ || this._peek.type === 5 /* TEXT */ ||
                this._peek.type === 9 /* ENCODED_ENTITY */) {
                token = this._advance();
                tokens.push(token);
                if (token.type === 8 /* INTERPOLATION */) {
                    // For backward compatibility we decode HTML entities that appear in interpolation
                    // expressions. This is arguably a bug, but it could be a considerable breaking change to
                    // fix it. It should be addressed in a larger project to refactor the entire parser/lexer
                    // chain after View Engine has been removed.
                    text += token.parts.join('').replace(/&([^;]+);/g, decodeEntity);
                }
                else if (token.type === 9 /* ENCODED_ENTITY */) {
                    text += token.parts[0];
                }
                else {
                    text += token.parts.join('');
                }
            }
            if (text.length > 0) {
                const endSpan = token.sourceSpan;
                this._addToParent(new Text$2(text, new ParseSourceSpan(startSpan.start, endSpan.end, startSpan.fullStart, startSpan.details), tokens));
            }
        }
        _closeVoidElement() {
            const el = this._getParentElement();
            if (el && this.getTagDefinition(el.name).isVoid) {
                this._elementStack.pop();
            }
        }
        _consumeStartTag(startTagToken) {
            const [prefix, name] = startTagToken.parts;
            const attrs = [];
            while (this._peek.type === 14 /* ATTR_NAME */) {
                attrs.push(this._consumeAttr(this._advance()));
            }
            const fullName = this._getElementFullName(prefix, name, this._getParentElement());
            let selfClosing = false;
            // Note: There could have been a tokenizer error
            // so that we don't get a token for the end tag...
            if (this._peek.type === 2 /* TAG_OPEN_END_VOID */) {
                this._advance();
                selfClosing = true;
                const tagDef = this.getTagDefinition(fullName);
                if (!(tagDef.canSelfClose || getNsPrefix(fullName) !== null || tagDef.isVoid)) {
                    this.errors.push(TreeError.create(fullName, startTagToken.sourceSpan, `Only void and foreign elements can be self closed "${startTagToken.parts[1]}"`));
                }
            }
            else if (this._peek.type === 1 /* TAG_OPEN_END */) {
                this._advance();
                selfClosing = false;
            }
            const end = this._peek.sourceSpan.fullStart;
            const span = new ParseSourceSpan(startTagToken.sourceSpan.start, end, startTagToken.sourceSpan.fullStart);
            // Create a separate `startSpan` because `span` will be modified when there is an `end` span.
            const startSpan = new ParseSourceSpan(startTagToken.sourceSpan.start, end, startTagToken.sourceSpan.fullStart);
            const el = new Element$1(fullName, attrs, [], span, startSpan, undefined);
            this._pushElement(el);
            if (selfClosing) {
                // Elements that are self-closed have their `endSourceSpan` set to the full span, as the
                // element start tag also represents the end tag.
                this._popElement(fullName, span);
            }
            else if (startTagToken.type === 4 /* INCOMPLETE_TAG_OPEN */) {
                // We already know the opening tag is not complete, so it is unlikely it has a corresponding
                // close tag. Let's optimistically parse it as a full element and emit an error.
                this._popElement(fullName, null);
                this.errors.push(TreeError.create(fullName, span, `Opening tag "${fullName}" not terminated.`));
            }
        }
        _pushElement(el) {
            const parentEl = this._getParentElement();
            if (parentEl && this.getTagDefinition(parentEl.name).isClosedByChild(el.name)) {
                this._elementStack.pop();
            }
            this._addToParent(el);
            this._elementStack.push(el);
        }
        _consumeEndTag(endTagToken) {
            const fullName = this._getElementFullName(endTagToken.parts[0], endTagToken.parts[1], this._getParentElement());
            if (this.getTagDefinition(fullName).isVoid) {
                this.errors.push(TreeError.create(fullName, endTagToken.sourceSpan, `Void elements do not have end tags "${endTagToken.parts[1]}"`));
            }
            else if (!this._popElement(fullName, endTagToken.sourceSpan)) {
                const errMsg = `Unexpected closing tag "${fullName}". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags`;
                this.errors.push(TreeError.create(fullName, endTagToken.sourceSpan, errMsg));
            }
        }
        /**
         * Closes the nearest element with the tag name `fullName` in the parse tree.
         * `endSourceSpan` is the span of the closing tag, or null if the element does
         * not have a closing tag (for example, this happens when an incomplete
         * opening tag is recovered).
         */
        _popElement(fullName, endSourceSpan) {
            let unexpectedCloseTagDetected = false;
            for (let stackIndex = this._elementStack.length - 1; stackIndex >= 0; stackIndex--) {
                const el = this._elementStack[stackIndex];
                if (el.name === fullName) {
                    // Record the parse span with the element that is being closed. Any elements that are
                    // removed from the element stack at this point are closed implicitly, so they won't get
                    // an end source span (as there is no explicit closing element).
                    el.endSourceSpan = endSourceSpan;
                    el.sourceSpan.end = endSourceSpan !== null ? endSourceSpan.end : el.sourceSpan.end;
                    this._elementStack.splice(stackIndex, this._elementStack.length - stackIndex);
                    return !unexpectedCloseTagDetected;
                }
                if (!this.getTagDefinition(el.name).closedByParent) {
                    // Note that we encountered an unexpected close tag but continue processing the element
                    // stack so we can assign an `endSourceSpan` if there is a corresponding start tag for this
                    // end tag in the stack.
                    unexpectedCloseTagDetected = true;
                }
            }
            return false;
        }
        _consumeAttr(attrName) {
            const fullName = mergeNsAndName(attrName.parts[0], attrName.parts[1]);
            let attrEnd = attrName.sourceSpan.end;
            // Consume any quote
            if (this._peek.type === 15 /* ATTR_QUOTE */) {
                this._advance();
            }
            // Consume the attribute value
            let value = '';
            const valueTokens = [];
            let valueStartSpan = undefined;
            let valueEnd = undefined;
            // NOTE: We need to use a new variable `nextTokenType` here to hide the actual type of
            // `_peek.type` from TS. Otherwise TS will narrow the type of `_peek.type` preventing it from
            // being able to consider `ATTR_VALUE_INTERPOLATION` as an option. This is because TS is not
            // able to see that `_advance()` will actually mutate `_peek`.
            const nextTokenType = this._peek.type;
            if (nextTokenType === 16 /* ATTR_VALUE_TEXT */) {
                valueStartSpan = this._peek.sourceSpan;
                valueEnd = this._peek.sourceSpan.end;
                while (this._peek.type === 16 /* ATTR_VALUE_TEXT */ ||
                    this._peek.type === 17 /* ATTR_VALUE_INTERPOLATION */ ||
                    this._peek.type === 9 /* ENCODED_ENTITY */) {
                    const valueToken = this._advance();
                    valueTokens.push(valueToken);
                    if (valueToken.type === 17 /* ATTR_VALUE_INTERPOLATION */) {
                        // For backward compatibility we decode HTML entities that appear in interpolation
                        // expressions. This is arguably a bug, but it could be a considerable breaking change to
                        // fix it. It should be addressed in a larger project to refactor the entire parser/lexer
                        // chain after View Engine has been removed.
                        value += valueToken.parts.join('').replace(/&([^;]+);/g, decodeEntity);
                    }
                    else if (valueToken.type === 9 /* ENCODED_ENTITY */) {
                        value += valueToken.parts[0];
                    }
                    else {
                        value += valueToken.parts.join('');
                    }
                    valueEnd = attrEnd = valueToken.sourceSpan.end;
                }
            }
            // Consume any quote
            if (this._peek.type === 15 /* ATTR_QUOTE */) {
                const quoteToken = this._advance();
                attrEnd = quoteToken.sourceSpan.end;
            }
            const valueSpan = valueStartSpan && valueEnd &&
                new ParseSourceSpan(valueStartSpan.start, valueEnd, valueStartSpan.fullStart);
            return new Attribute(fullName, value, new ParseSourceSpan(attrName.sourceSpan.start, attrEnd, attrName.sourceSpan.fullStart), attrName.sourceSpan, valueSpan, valueTokens.length > 0 ? valueTokens : undefined, undefined);
        }
        _getParentElement() {
            return this._elementStack.length > 0 ? this._elementStack[this._elementStack.length - 1] : null;
        }
        _addToParent(node) {
            const parent = this._getParentElement();
            if (parent != null) {
                parent.children.push(node);
            }
            else {
                this.rootNodes.push(node);
            }
        }
        _getElementFullName(prefix, localName, parentElement) {
            if (prefix === '') {
                prefix = this.getTagDefinition(localName).implicitNamespacePrefix || '';
                if (prefix === '' && parentElement != null) {
                    const parentTagName = splitNsName(parentElement.name)[1];
                    const parentTagDefinition = this.getTagDefinition(parentTagName);
                    if (!parentTagDefinition.preventNamespaceInheritance) {
                        prefix = getNsPrefix(parentElement.name);
                    }
                }
            }
            return mergeNsAndName(prefix, localName);
        }
    }
    function lastOnStack(stack, element) {
        return stack.length > 0 && stack[stack.length - 1] === element;
    }
    /**
     * Decode the `entity` string, which we believe is the contents of an HTML entity.
     *
     * If the string is not actually a valid/known entity then just return the original `match` string.
     */
    function decodeEntity(match, entity) {
        if (NAMED_ENTITIES[entity] !== undefined) {
            return NAMED_ENTITIES[entity] || match;
        }
        if (/^#x[a-f0-9]+$/i.test(entity)) {
            return String.fromCodePoint(parseInt(entity.slice(2), 16));
        }
        if (/^#\d+$/.test(entity)) {
            return String.fromCodePoint(parseInt(entity.slice(1), 10));
        }
        return match;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class HtmlParser extends Parser {
        constructor() {
            super(getHtmlTagDefinition);
        }
        parse(source, url, options) {
            return super.parse(source, url, options);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const PRESERVE_WS_ATTR_NAME = 'ngPreserveWhitespaces';
    const SKIP_WS_TRIM_TAGS = new Set(['pre', 'template', 'textarea', 'script', 'style']);
    // Equivalent to \s with \u00a0 (non-breaking space) excluded.
    // Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp
    const WS_CHARS = ' \f\n\r\t\v\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff';
    const NO_WS_REGEXP = new RegExp(`[^${WS_CHARS}]`);
    const WS_REPLACE_REGEXP = new RegExp(`[${WS_CHARS}]{2,}`, 'g');
    function hasPreserveWhitespacesAttr(attrs) {
        return attrs.some((attr) => attr.name === PRESERVE_WS_ATTR_NAME);
    }
    /**
     * Angular Dart introduced &ngsp; as a placeholder for non-removable space, see:
     * https://github.com/dart-lang/angular/blob/0bb611387d29d65b5af7f9d2515ab571fd3fbee4/_tests/test/compiler/preserve_whitespace_test.dart#L25-L32
     * In Angular Dart &ngsp; is converted to the 0xE500 PUA (Private Use Areas) unicode character
     * and later on replaced by a space. We are re-implementing the same idea here.
     */
    function replaceNgsp(value) {
        // lexer is replacing the &ngsp; pseudo-entity with NGSP_UNICODE
        return value.replace(new RegExp(NGSP_UNICODE, 'g'), ' ');
    }
    /**
     * This visitor can walk HTML parse tree and remove / trim text nodes using the following rules:
     * - consider spaces, tabs and new lines as whitespace characters;
     * - drop text nodes consisting of whitespace characters only;
     * - for all other text nodes replace consecutive whitespace characters with one space;
     * - convert &ngsp; pseudo-entity to a single space;
     *
     * Removal and trimming of whitespaces have positive performance impact (less code to generate
     * while compiling templates, faster view creation). At the same time it can be "destructive"
     * in some cases (whitespaces can influence layout). Because of the potential of breaking layout
     * this visitor is not activated by default in Angular 5 and people need to explicitly opt-in for
     * whitespace removal. The default option for whitespace removal will be revisited in Angular 6
     * and might be changed to "on" by default.
     */
    class WhitespaceVisitor {
        visitElement(element, context) {
            if (SKIP_WS_TRIM_TAGS.has(element.name) || hasPreserveWhitespacesAttr(element.attrs)) {
                // don't descent into elements where we need to preserve whitespaces
                // but still visit all attributes to eliminate one used as a market to preserve WS
                return new Element$1(element.name, visitAll$1(this, element.attrs), element.children, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);
            }
            return new Element$1(element.name, element.attrs, visitAllWithSiblings(this, element.children), element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);
        }
        visitAttribute(attribute, context) {
            return attribute.name !== PRESERVE_WS_ATTR_NAME ? attribute : null;
        }
        visitText(text, context) {
            const isNotBlank = text.value.match(NO_WS_REGEXP);
            const hasExpansionSibling = context &&
                (context.prev instanceof Expansion || context.next instanceof Expansion);
            if (isNotBlank || hasExpansionSibling) {
                // Process the whitespace in the tokens of this Text node
                const tokens = text.tokens.map(token => token.type === 5 /* TEXT */ ? createWhitespaceProcessedTextToken(token) : token);
                // Process the whitespace of the value of this Text node
                const value = processWhitespace(text.value);
                return new Text$2(value, text.sourceSpan, tokens, text.i18n);
            }
            return null;
        }
        visitComment(comment, context) {
            return comment;
        }
        visitExpansion(expansion, context) {
            return expansion;
        }
        visitExpansionCase(expansionCase, context) {
            return expansionCase;
        }
    }
    function createWhitespaceProcessedTextToken({ type, parts, sourceSpan }) {
        return { type, parts: [processWhitespace(parts[0])], sourceSpan };
    }
    function processWhitespace(text) {
        return replaceNgsp(text).replace(WS_REPLACE_REGEXP, ' ');
    }
    function removeWhitespaces(htmlAstWithErrors) {
        return new ParseTreeResult(visitAll$1(new WhitespaceVisitor(), htmlAstWithErrors.rootNodes), htmlAstWithErrors.errors);
    }
    function visitAllWithSiblings(visitor, nodes) {
        const result = [];
        nodes.forEach((ast, i) => {
            const context = { prev: nodes[i - 1], next: nodes[i + 1] };
            const astResult = ast.visit(visitor, context);
            if (astResult) {
                result.push(astResult);
            }
        });
        return result;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    // http://cldr.unicode.org/index/cldr-spec/plural-rules
    const PLURAL_CASES = ['zero', 'one', 'two', 'few', 'many', 'other'];
    /**
     * Expands special forms into elements.
     *
     * For example,
     *
     * ```
     * { messages.length, plural,
     *   =0 {zero}
     *   =1 {one}
     *   other {more than one}
     * }
     * ```
     *
     * will be expanded into
     *
     * ```
     * <ng-container [ngPlural]="messages.length">
     *   <ng-template ngPluralCase="=0">zero</ng-template>
     *   <ng-template ngPluralCase="=1">one</ng-template>
     *   <ng-template ngPluralCase="other">more than one</ng-template>
     * </ng-container>
     * ```
     */
    function expandNodes(nodes) {
        const expander = new _Expander();
        return new ExpansionResult(visitAll$1(expander, nodes), expander.isExpanded, expander.errors);
    }
    class ExpansionResult {
        constructor(nodes, expanded, errors) {
            this.nodes = nodes;
            this.expanded = expanded;
            this.errors = errors;
        }
    }
    class ExpansionError extends ParseError {
        constructor(span, errorMsg) {
            super(span, errorMsg);
        }
    }
    /**
     * Expand expansion forms (plural, select) to directives
     *
     * @internal
     */
    class _Expander {
        constructor() {
            this.isExpanded = false;
            this.errors = [];
        }
        visitElement(element, context) {
            return new Element$1(element.name, element.attrs, visitAll$1(this, element.children), element.sourceSpan, element.startSourceSpan, element.endSourceSpan);
        }
        visitAttribute(attribute, context) {
            return attribute;
        }
        visitText(text, context) {
            return text;
        }
        visitComment(comment, context) {
            return comment;
        }
        visitExpansion(icu, context) {
            this.isExpanded = true;
            return icu.type === 'plural' ? _expandPluralForm(icu, this.errors) :
                _expandDefaultForm(icu, this.errors);
        }
        visitExpansionCase(icuCase, context) {
            throw new Error('Should not be reached');
        }
    }
    // Plural forms are expanded to `NgPlural` and `NgPluralCase`s
    function _expandPluralForm(ast, errors) {
        const children = ast.cases.map(c => {
            if (PLURAL_CASES.indexOf(c.value) === -1 && !c.value.match(/^=\d+$/)) {
                errors.push(new ExpansionError(c.valueSourceSpan, `Plural cases should be "=<number>" or one of ${PLURAL_CASES.join(', ')}`));
            }
            const expansionResult = expandNodes(c.expression);
            errors.push(...expansionResult.errors);
            return new Element$1(`ng-template`, [new Attribute('ngPluralCase', `${c.value}`, c.valueSourceSpan, undefined /* keySpan */, undefined /* valueSpan */, undefined /* valueTokens */, undefined /* i18n */)], expansionResult.nodes, c.sourceSpan, c.sourceSpan, c.sourceSpan);
        });
        const switchAttr = new Attribute('[ngPlural]', ast.switchValue, ast.switchValueSourceSpan, undefined /* keySpan */, undefined /* valueSpan */, undefined /* valueTokens */, undefined /* i18n */);
        return new Element$1('ng-container', [switchAttr], children, ast.sourceSpan, ast.sourceSpan, ast.sourceSpan);
    }
    // ICU messages (excluding plural form) are expanded to `NgSwitch`  and `NgSwitchCase`s
    function _expandDefaultForm(ast, errors) {
        const children = ast.cases.map(c => {
            const expansionResult = expandNodes(c.expression);
            errors.push(...expansionResult.errors);
            if (c.value === 'other') {
                // other is the default case when no values match
                return new Element$1(`ng-template`, [new Attribute('ngSwitchDefault', '', c.valueSourceSpan, undefined /* keySpan */, undefined /* valueSpan */, undefined /* valueTokens */, undefined /* i18n */)], expansionResult.nodes, c.sourceSpan, c.sourceSpan, c.sourceSpan);
            }
            return new Element$1(`ng-template`, [new Attribute('ngSwitchCase', `${c.value}`, c.valueSourceSpan, undefined /* keySpan */, undefined /* valueSpan */, undefined /* valueTokens */, undefined /* i18n */)], expansionResult.nodes, c.sourceSpan, c.sourceSpan, c.sourceSpan);
        });
        const switchAttr = new Attribute('[ngSwitch]', ast.switchValue, ast.switchValueSourceSpan, undefined /* keySpan */, undefined /* valueSpan */, undefined /* valueTokens */, undefined /* i18n */);
        return new Element$1('ng-container', [switchAttr], children, ast.sourceSpan, ast.sourceSpan, ast.sourceSpan);
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A segment of text within the template.
     */
    class TextAst {
        constructor(value, ngContentIndex, sourceSpan) {
            this.value = value;
            this.ngContentIndex = ngContentIndex;
            this.sourceSpan = sourceSpan;
        }
        visit(visitor, context) {
            return visitor.visitText(this, context);
        }
    }
    /**
     * A bound expression within the text of a template.
     */
    class BoundTextAst {
        constructor(value, ngContentIndex, sourceSpan) {
            this.value = value;
            this.ngContentIndex = ngContentIndex;
            this.sourceSpan = sourceSpan;
        }
        visit(visitor, context) {
            return visitor.visitBoundText(this, context);
        }
    }
    /**
     * A plain attribute on an element.
     */
    class AttrAst {
        constructor(name, value, sourceSpan) {
            this.name = name;
            this.value = value;
            this.sourceSpan = sourceSpan;
        }
        visit(visitor, context) {
            return visitor.visitAttr(this, context);
        }
    }
    const BoundPropertyMapping = {
        [4 /* Animation */]: 4 /* Animation */,
        [1 /* Attribute */]: 1 /* Attribute */,
        [2 /* Class */]: 2 /* Class */,
        [0 /* Property */]: 0 /* Property */,
        [3 /* Style */]: 3 /* Style */,
    };
    /**
     * A binding for an element property (e.g. `[property]="expression"`) or an animation trigger (e.g.
     * `[@trigger]="stateExp"`)
     */
    class BoundElementPropertyAst {
        constructor(name, type, securityContext, value, unit, sourceSpan) {
            this.name = name;
            this.type = type;
            this.securityContext = securityContext;
            this.value = value;
            this.unit = unit;
            this.sourceSpan = sourceSpan;
            this.isAnimation = this.type === 4 /* Animation */;
        }
        static fromBoundProperty(prop) {
            const type = BoundPropertyMapping[prop.type];
            return new BoundElementPropertyAst(prop.name, type, prop.securityContext, prop.value, prop.unit, prop.sourceSpan);
        }
        visit(visitor, context) {
            return visitor.visitElementProperty(this, context);
        }
    }
    /**
     * A binding for an element event (e.g. `(event)="handler()"`) or an animation trigger event (e.g.
     * `(@trigger.phase)="callback($event)"`).
     */
    class BoundEventAst {
        constructor(name, target, phase, handler, sourceSpan, handlerSpan) {
            this.name = name;
            this.target = target;
            this.phase = phase;
            this.handler = handler;
            this.sourceSpan = sourceSpan;
            this.handlerSpan = handlerSpan;
            this.fullName = BoundEventAst.calcFullName(this.name, this.target, this.phase);
            this.isAnimation = !!this.phase;
        }
        static calcFullName(name, target, phase) {
            if (target) {
                return `${target}:${name}`;
            }
            if (phase) {
                return `@${name}.${phase}`;
            }
            return name;
        }
        static fromParsedEvent(event) {
            const target = event.type === 0 /* Regular */ ? event.targetOrPhase : null;
            const phase = event.type === 1 /* Animation */ ? event.targetOrPhase : null;
            return new BoundEventAst(event.name, target, phase, event.handler, event.sourceSpan, event.handlerSpan);
        }
        visit(visitor, context) {
            return visitor.visitEvent(this, context);
        }
    }
    /**
     * A reference declaration on an element (e.g. `let someName="expression"`).
     */
    class ReferenceAst {
        constructor(name, value, originalValue, sourceSpan) {
            this.name = name;
            this.value = value;
            this.originalValue = originalValue;
            this.sourceSpan = sourceSpan;
        }
        visit(visitor, context) {
            return visitor.visitReference(this, context);
        }
    }
    /**
     * A variable declaration on a <ng-template> (e.g. `var-someName="someLocalName"`).
     */
    class VariableAst {
        constructor(name, value, sourceSpan, valueSpan) {
            this.name = name;
            this.value = value;
            this.sourceSpan = sourceSpan;
            this.valueSpan = valueSpan;
        }
        static fromParsedVariable(v) {
            return new VariableAst(v.name, v.value, v.sourceSpan, v.valueSpan);
        }
        visit(visitor, context) {
            return visitor.visitVariable(this, context);
        }
    }
    /**
     * An element declaration in a template.
     */
    class ElementAst {
        constructor(name, attrs, inputs, outputs, references, directives, providers, hasViewContainer, queryMatches, children, ngContentIndex, sourceSpan, endSourceSpan) {
            this.name = name;
            this.attrs = attrs;
            this.inputs = inputs;
            this.outputs = outputs;
            this.references = references;
            this.directives = directives;
            this.providers = providers;
            this.hasViewContainer = hasViewContainer;
            this.queryMatches = queryMatches;
            this.children = children;
            this.ngContentIndex = ngContentIndex;
            this.sourceSpan = sourceSpan;
            this.endSourceSpan = endSourceSpan;
        }
        visit(visitor, context) {
            return visitor.visitElement(this, context);
        }
    }
    /**
     * A `<ng-template>` element included in an Angular template.
     */
    class EmbeddedTemplateAst {
        constructor(attrs, outputs, references, variables, directives, providers, hasViewContainer, queryMatches, children, ngContentIndex, sourceSpan) {
            this.attrs = attrs;
            this.outputs = outputs;
            this.references = references;
            this.variables = variables;
            this.directives = directives;
            this.providers = providers;
            this.hasViewContainer = hasViewContainer;
            this.queryMatches = queryMatches;
            this.children = children;
            this.ngContentIndex = ngContentIndex;
            this.sourceSpan = sourceSpan;
        }
        visit(visitor, context) {
            return visitor.visitEmbeddedTemplate(this, context);
        }
    }
    /**
     * A directive property with a bound value (e.g. `*ngIf="condition").
     */
    class BoundDirectivePropertyAst {
        constructor(directiveName, templateName, value, sourceSpan) {
            this.directiveName = directiveName;
            this.templateName = templateName;
            this.value = value;
            this.sourceSpan = sourceSpan;
        }
        visit(visitor, context) {
            return visitor.visitDirectiveProperty(this, context);
        }
    }
    /**
     * A directive declared on an element.
     */
    class DirectiveAst {
        constructor(directive, inputs, hostProperties, hostEvents, contentQueryStartId, sourceSpan) {
            this.directive = directive;
            this.inputs = inputs;
            this.hostProperties = hostProperties;
            this.hostEvents = hostEvents;
            this.contentQueryStartId = contentQueryStartId;
            this.sourceSpan = sourceSpan;
        }
        visit(visitor, context) {
            return visitor.visitDirective(this, context);
        }
    }
    /**
     * A provider declared on an element
     */
    class ProviderAst {
        constructor(token, multiProvider, eager, providers, providerType, lifecycleHooks, sourceSpan, isModule) {
            this.token = token;
            this.multiProvider = multiProvider;
            this.eager = eager;
            this.providers = providers;
            this.providerType = providerType;
            this.lifecycleHooks = lifecycleHooks;
            this.sourceSpan = sourceSpan;
            this.isModule = isModule;
        }
        visit(visitor, context) {
            // No visit method in the visitor for now...
            return null;
        }
    }
    var ProviderAstType;
    (function (ProviderAstType) {
        ProviderAstType[ProviderAstType["PublicService"] = 0] = "PublicService";
        ProviderAstType[ProviderAstType["PrivateService"] = 1] = "PrivateService";
        ProviderAstType[ProviderAstType["Component"] = 2] = "Component";
        ProviderAstType[ProviderAstType["Directive"] = 3] = "Directive";
        ProviderAstType[ProviderAstType["Builtin"] = 4] = "Builtin";
    })(ProviderAstType || (ProviderAstType = {}));
    /**
     * Position where content is to be projected (instance of `<ng-content>` in a template).
     */
    class NgContentAst {
        constructor(index, ngContentIndex, sourceSpan) {
            this.index = index;
            this.ngContentIndex = ngContentIndex;
            this.sourceSpan = sourceSpan;
        }
        visit(visitor, context) {
            return visitor.visitNgContent(this, context);
        }
    }
    /**
     * A visitor that accepts each node but doesn't do anything. It is intended to be used
     * as the base class for a visitor that is only interested in a subset of the node types.
     */
    class NullTemplateVisitor {
        visitNgContent(ast, context) { }
        visitEmbeddedTemplate(ast, context) { }
        visitElement(ast, context) { }
        visitReference(ast, context) { }
        visitVariable(ast, context) { }
        visitEvent(ast, context) { }
        visitElementProperty(ast, context) { }
        visitAttr(ast, context) { }
        visitBoundText(ast, context) { }
        visitText(ast, context) { }
        visitDirective(ast, context) { }
        visitDirectiveProperty(ast, context) { }
    }
    /**
     * Base class that can be used to build a visitor that visits each node
     * in an template ast recursively.
     */
    class RecursiveTemplateAstVisitor extends NullTemplateVisitor {
        constructor() {
            super();
        }
        // Nodes with children
        visitEmbeddedTemplate(ast, context) {
            return this.visitChildren(context, visit => {
                visit(ast.attrs);
                visit(ast.references);
                visit(ast.variables);
                visit(ast.directives);
                visit(ast.providers);
                visit(ast.children);
            });
        }
        visitElement(ast, context) {
            return this.visitChildren(context, visit => {
                visit(ast.attrs);
                visit(ast.inputs);
                visit(ast.outputs);
                visit(ast.references);
                visit(ast.directives);
                visit(ast.providers);
                visit(ast.children);
            });
        }
        visitDirective(ast, context) {
            return this.visitChildren(context, visit => {
                visit(ast.inputs);
                visit(ast.hostProperties);
                visit(ast.hostEvents);
            });
        }
        visitChildren(context, cb) {
            let results = [];
            let t = this;
            function visit(children) {
                if (children && children.length)
                    results.push(templateVisitAll(t, children, context));
            }
            cb(visit);
            return Array.prototype.concat.apply([], results);
        }
    }
    /**
     * Visit every node in a list of {@link TemplateAst}s with the given {@link TemplateAstVisitor}.
     */
    function templateVisitAll(visitor, asts, context = null) {
        const result = [];
        const visit = visitor.visit ?
            (ast) => visitor.visit(ast, context) || ast.visit(visitor, context) :
            (ast) => ast.visit(visitor, context);
        asts.forEach(ast => {
            const astResult = visit(ast);
            if (astResult) {
                result.push(astResult);
            }
        });
        return result;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class ProviderError extends ParseError {
        constructor(message, span) {
            super(span, message);
        }
    }
    class ProviderViewContext {
        constructor(reflector, component) {
            this.reflector = reflector;
            this.component = component;
            this.errors = [];
            this.viewQueries = _getViewQueries(component);
            this.viewProviders = new Map();
            component.viewProviders.forEach((provider) => {
                if (this.viewProviders.get(tokenReference(provider.token)) == null) {
                    this.viewProviders.set(tokenReference(provider.token), true);
                }
            });
        }
    }
    class ProviderElementContext {
        constructor(viewContext, _parent, _isViewRoot, _directiveAsts, attrs, refs, isTemplate, contentQueryStartId, _sourceSpan) {
            this.viewContext = viewContext;
            this._parent = _parent;
            this._isViewRoot = _isViewRoot;
            this._directiveAsts = _directiveAsts;
            this._sourceSpan = _sourceSpan;
            this._transformedProviders = new Map();
            this._seenProviders = new Map();
            this._queriedTokens = new Map();
            this.transformedHasViewContainer = false;
            this._attrs = {};
            attrs.forEach((attrAst) => this._attrs[attrAst.name] = attrAst.value);
            const directivesMeta = _directiveAsts.map(directiveAst => directiveAst.directive);
            this._allProviders =
                _resolveProvidersFromDirectives(directivesMeta, _sourceSpan, viewContext.errors);
            this._contentQueries = _getContentQueries(contentQueryStartId, directivesMeta);
            Array.from(this._allProviders.values()).forEach((provider) => {
                this._addQueryReadsTo(provider.token, provider.token, this._queriedTokens);
            });
            if (isTemplate) {
                const templateRefId = createTokenForExternalReference(this.viewContext.reflector, Identifiers$1.TemplateRef);
                this._addQueryReadsTo(templateRefId, templateRefId, this._queriedTokens);
            }
            refs.forEach((refAst) => {
                let defaultQueryValue = refAst.value ||
                    createTokenForExternalReference(this.viewContext.reflector, Identifiers$1.ElementRef);
                this._addQueryReadsTo({ value: refAst.name }, defaultQueryValue, this._queriedTokens);
            });
            if (this._queriedTokens.get(this.viewContext.reflector.resolveExternalReference(Identifiers$1.ViewContainerRef))) {
                this.transformedHasViewContainer = true;
            }
            // create the providers that we know are eager first
            Array.from(this._allProviders.values()).forEach((provider) => {
                const eager = provider.eager || this._queriedTokens.get(tokenReference(provider.token));
                if (eager) {
                    this._getOrCreateLocalProvider(provider.providerType, provider.token, true);
                }
            });
        }
        afterElement() {
            // collect lazy providers
            Array.from(this._allProviders.values()).forEach((provider) => {
                this._getOrCreateLocalProvider(provider.providerType, provider.token, false);
            });
        }
        get transformProviders() {
            // Note: Maps keep their insertion order.
            const lazyProviders = [];
            const eagerProviders = [];
            this._transformedProviders.forEach(provider => {
                if (provider.eager) {
                    eagerProviders.push(provider);
                }
                else {
                    lazyProviders.push(provider);
                }
            });
            return lazyProviders.concat(eagerProviders);
        }
        get transformedDirectiveAsts() {
            const sortedProviderTypes = this.transformProviders.map(provider => provider.token.identifier);
            const sortedDirectives = this._directiveAsts.slice();
            sortedDirectives.sort((dir1, dir2) => sortedProviderTypes.indexOf(dir1.directive.type) -
                sortedProviderTypes.indexOf(dir2.directive.type));
            return sortedDirectives;
        }
        get queryMatches() {
            const allMatches = [];
            this._queriedTokens.forEach((matches) => {
                allMatches.push(...matches);
            });
            return allMatches;
        }
        _addQueryReadsTo(token, defaultValue, queryReadTokens) {
            this._getQueriesFor(token).forEach((query) => {
                const queryValue = query.meta.read || defaultValue;
                const tokenRef = tokenReference(queryValue);
                let queryMatches = queryReadTokens.get(tokenRef);
                if (!queryMatches) {
                    queryMatches = [];
                    queryReadTokens.set(tokenRef, queryMatches);
                }
                queryMatches.push({ queryId: query.queryId, value: queryValue });
            });
        }
        _getQueriesFor(token) {
            const result = [];
            let currentEl = this;
            let distance = 0;
            let queries;
            while (currentEl !== null) {
                queries = currentEl._contentQueries.get(tokenReference(token));
                if (queries) {
                    result.push(...queries.filter((query) => query.meta.descendants || distance <= 1));
                }
                if (currentEl._directiveAsts.length > 0) {
                    distance++;
                }
                currentEl = currentEl._parent;
            }
            queries = this.viewContext.viewQueries.get(tokenReference(token));
            if (queries) {
                result.push(...queries);
            }
            return result;
        }
        _getOrCreateLocalProvider(requestingProviderType, token, eager) {
            const resolvedProvider = this._allProviders.get(tokenReference(token));
            if (!resolvedProvider ||
                ((requestingProviderType === ProviderAstType.Directive ||
                    requestingProviderType === ProviderAstType.PublicService) &&
                    resolvedProvider.providerType === ProviderAstType.PrivateService) ||
                ((requestingProviderType === ProviderAstType.PrivateService ||
                    requestingProviderType === ProviderAstType.PublicService) &&
                    resolvedProvider.providerType === ProviderAstType.Builtin)) {
                return null;
            }
            let transformedProviderAst = this._transformedProviders.get(tokenReference(token));
            if (transformedProviderAst) {
                return transformedProviderAst;
            }
            if (this._seenProviders.get(tokenReference(token)) != null) {
                this.viewContext.errors.push(new ProviderError(`Cannot instantiate cyclic dependency! ${tokenName(token)}`, this._sourceSpan));
                return null;
            }
            this._seenProviders.set(tokenReference(token), true);
            const transformedProviders = resolvedProvider.providers.map((provider) => {
                let transformedUseValue = provider.useValue;
                let transformedUseExisting = provider.useExisting;
                let transformedDeps = undefined;
                if (provider.useExisting != null) {
                    const existingDiDep = this._getDependency(resolvedProvider.providerType, { token: provider.useExisting }, eager);
                    if (existingDiDep.token != null) {
                        transformedUseExisting = existingDiDep.token;
                    }
                    else {
                        transformedUseExisting = null;
                        transformedUseValue = existingDiDep.value;
                    }
                }
                else if (provider.useFactory) {
                    const deps = provider.deps || provider.useFactory.diDeps;
                    transformedDeps =
                        deps.map((dep) => this._getDependency(resolvedProvider.providerType, dep, eager));
                }
                else if (provider.useClass) {
                    const deps = provider.deps || provider.useClass.diDeps;
                    transformedDeps =
                        deps.map((dep) => this._getDependency(resolvedProvider.providerType, dep, eager));
                }
                return _transformProvider(provider, {
                    useExisting: transformedUseExisting,
                    useValue: transformedUseValue,
                    deps: transformedDeps
                });
            });
            transformedProviderAst =
                _transformProviderAst(resolvedProvider, { eager: eager, providers: transformedProviders });
            this._transformedProviders.set(tokenReference(token), transformedProviderAst);
            return transformedProviderAst;
        }
        _getLocalDependency(requestingProviderType, dep, eager = false) {
            if (dep.isAttribute) {
                const attrValue = this._attrs[dep.token.value];
                return { isValue: true, value: attrValue == null ? null : attrValue };
            }
            if (dep.token != null) {
                // access builtints
                if ((requestingProviderType === ProviderAstType.Directive ||
                    requestingProviderType === ProviderAstType.Component)) {
                    if (tokenReference(dep.token) ===
                        this.viewContext.reflector.resolveExternalReference(Identifiers$1.Renderer) ||
                        tokenReference(dep.token) ===
                            this.viewContext.reflector.resolveExternalReference(Identifiers$1.ElementRef) ||
                        tokenReference(dep.token) ===
                            this.viewContext.reflector.resolveExternalReference(Identifiers$1.ChangeDetectorRef) ||
                        tokenReference(dep.token) ===
                            this.viewContext.reflector.resolveExternalReference(Identifiers$1.TemplateRef)) {
                        return dep;
                    }
                    if (tokenReference(dep.token) ===
                        this.viewContext.reflector.resolveExternalReference(Identifiers$1.ViewContainerRef)) {
                        this.transformedHasViewContainer = true;
                    }
                }
                // access the injector
                if (tokenReference(dep.token) ===
                    this.viewContext.reflector.resolveExternalReference(Identifiers$1.Injector)) {
                    return dep;
                }
                // access providers
                if (this._getOrCreateLocalProvider(requestingProviderType, dep.token, eager) != null) {
                    return dep;
                }
            }
            return null;
        }
        _getDependency(requestingProviderType, dep, eager = false) {
            let currElement = this;
            let currEager = eager;
            let result = null;
            if (!dep.isSkipSelf) {
                result = this._getLocalDependency(requestingProviderType, dep, eager);
            }
            if (dep.isSelf) {
                if (!result && dep.isOptional) {
                    result = { isValue: true, value: null };
                }
            }
            else {
                // check parent elements
                while (!result && currElement._parent) {
                    const prevElement = currElement;
                    currElement = currElement._parent;
                    if (prevElement._isViewRoot) {
                        currEager = false;
                    }
                    result = currElement._getLocalDependency(ProviderAstType.PublicService, dep, currEager);
                }
                // check @Host restriction
                if (!result) {
                    if (!dep.isHost || this.viewContext.component.isHost ||
                        this.viewContext.component.type.reference === tokenReference(dep.token) ||
                        this.viewContext.viewProviders.get(tokenReference(dep.token)) != null) {
                        result = dep;
                    }
                    else {
                        result = dep.isOptional ? { isValue: true, value: null } : null;
                    }
                }
            }
            if (!result) {
                this.viewContext.errors.push(new ProviderError(`No provider for ${tokenName(dep.token)}`, this._sourceSpan));
            }
            return result;
        }
    }
    function _transformProvider(provider, { useExisting, useValue, deps }) {
        return {
            token: provider.token,
            useClass: provider.useClass,
            useExisting: useExisting,
            useFactory: provider.useFactory,
            useValue: useValue,
            deps: deps,
            multi: provider.multi
        };
    }
    function _transformProviderAst(provider, { eager, providers }) {
        return new ProviderAst(provider.token, provider.multiProvider, provider.eager || eager, providers, provider.providerType, provider.lifecycleHooks, provider.sourceSpan, provider.isModule);
    }
    function _resolveProvidersFromDirectives(directives, sourceSpan, targetErrors) {
        const providersByToken = new Map();
        directives.forEach((directive) => {
            const dirProvider = { token: { identifier: directive.type }, useClass: directive.type };
            _resolveProviders([dirProvider], directive.isComponent ? ProviderAstType.Component : ProviderAstType.Directive, true, sourceSpan, targetErrors, providersByToken, /* isModule */ false);
        });
        // Note: directives need to be able to overwrite providers of a component!
        const directivesWithComponentFirst = directives.filter(dir => dir.isComponent).concat(directives.filter(dir => !dir.isComponent));
        directivesWithComponentFirst.forEach((directive) => {
            _resolveProviders(directive.providers, ProviderAstType.PublicService, false, sourceSpan, targetErrors, providersByToken, /* isModule */ false);
            _resolveProviders(directive.viewProviders, ProviderAstType.PrivateService, false, sourceSpan, targetErrors, providersByToken, /* isModule */ false);
        });
        return providersByToken;
    }
    function _resolveProviders(providers, providerType, eager, sourceSpan, targetErrors, targetProvidersByToken, isModule) {
        providers.forEach((provider) => {
            let resolvedProvider = targetProvidersByToken.get(tokenReference(provider.token));
            if (resolvedProvider != null && !!resolvedProvider.multiProvider !== !!provider.multi) {
                targetErrors.push(new ProviderError(`Mixing multi and non multi provider is not possible for token ${tokenName(resolvedProvider.token)}`, sourceSpan));
            }
            if (!resolvedProvider) {
                const lifecycleHooks = provider.token.identifier &&
                    provider.token.identifier.lifecycleHooks ?
                    provider.token.identifier.lifecycleHooks :
                    [];
                const isUseValue = !(provider.useClass || provider.useExisting || provider.useFactory);
                resolvedProvider = new ProviderAst(provider.token, !!provider.multi, eager || isUseValue, [provider], providerType, lifecycleHooks, sourceSpan, isModule);
                targetProvidersByToken.set(tokenReference(provider.token), resolvedProvider);
            }
            else {
                if (!provider.multi) {
                    resolvedProvider.providers.length = 0;
                }
                resolvedProvider.providers.push(provider);
            }
        });
    }
    function _getViewQueries(component) {
        // Note: queries start with id 1 so we can use the number in a Bloom filter!
        let viewQueryId = 1;
        const viewQueries = new Map();
        if (component.viewQueries) {
            component.viewQueries.forEach((query) => _addQueryToTokenMap(viewQueries, { meta: query, queryId: viewQueryId++ }));
        }
        return viewQueries;
    }
    function _getContentQueries(contentQueryStartId, directives) {
        let contentQueryId = contentQueryStartId;
        const contentQueries = new Map();
        directives.forEach((directive, directiveIndex) => {
            if (directive.queries) {
                directive.queries.forEach((query) => _addQueryToTokenMap(contentQueries, { meta: query, queryId: contentQueryId++ }));
            }
        });
        return contentQueries;
    }
    function _addQueryToTokenMap(map, query) {
        query.meta.selectors.forEach((token) => {
            let entry = map.get(tokenReference(token));
            if (!entry) {
                entry = [];
                map.set(tokenReference(token), entry);
            }
            entry.push(query);
        });
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class StyleWithImports {
        constructor(style, styleUrls) {
            this.style = style;
            this.styleUrls = styleUrls;
        }
    }
    function isStyleUrlResolvable(url) {
        if (url == null || url.length === 0 || url[0] == '/')
            return false;
        const schemeMatch = url.match(URL_WITH_SCHEMA_REGEXP);
        return schemeMatch === null || schemeMatch[1] == 'package' || schemeMatch[1] == 'asset';
    }
    /**
     * Rewrites stylesheets by resolving and removing the @import urls that
     * are either relative or don't have a `package:` scheme
     */
    function extractStyleUrls(resolver, baseUrl, cssText) {
        const foundUrls = [];
        const modifiedCssText = cssText.replace(CSS_STRIPPABLE_COMMENT_REGEXP, '')
            .replace(CSS_IMPORT_REGEXP, (...m) => {
            const url = m[1] || m[2];
            if (!isStyleUrlResolvable(url)) {
                // Do not attempt to resolve non-package absolute URLs with URI
                // scheme
                return m[0];
            }
            foundUrls.push(resolver.resolve(baseUrl, url));
            return '';
        });
        return new StyleWithImports(modifiedCssText, foundUrls);
    }
    const CSS_IMPORT_REGEXP = /@import\s+(?:url\()?\s*(?:(?:['"]([^'"]*))|([^;\)\s]*))[^;]*;?/g;
    const CSS_STRIPPABLE_COMMENT_REGEXP = /\/\*(?!#\s*(?:sourceURL|sourceMappingURL)=)[\s\S]+?\*\//g;
    const URL_WITH_SCHEMA_REGEXP = /^([^:/?#]+):/;

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const PROPERTY_PARTS_SEPARATOR = '.';
    const ATTRIBUTE_PREFIX = 'attr';
    const CLASS_PREFIX = 'class';
    const STYLE_PREFIX = 'style';
    const TEMPLATE_ATTR_PREFIX = '*';
    const ANIMATE_PROP_PREFIX = 'animate-';
    /**
     * Parses bindings in templates and in the directive host area.
     */
    class BindingParser {
        constructor(_exprParser, _interpolationConfig, _schemaRegistry, pipes, errors) {
            this._exprParser = _exprParser;
            this._interpolationConfig = _interpolationConfig;
            this._schemaRegistry = _schemaRegistry;
            this.errors = errors;
            this.pipesByName = null;
            this._usedPipes = new Map();
            // When the `pipes` parameter is `null`, do not check for used pipes
            // This is used in IVY when we might not know the available pipes at compile time
            if (pipes) {
                const pipesByName = new Map();
                pipes.forEach(pipe => pipesByName.set(pipe.name, pipe));
                this.pipesByName = pipesByName;
            }
        }
        get interpolationConfig() {
            return this._interpolationConfig;
        }
        getUsedPipes() {
            return Array.from(this._usedPipes.values());
        }
        createBoundHostProperties(dirMeta, sourceSpan) {
            if (dirMeta.hostProperties) {
                const boundProps = [];
                Object.keys(dirMeta.hostProperties).forEach(propName => {
                    const expression = dirMeta.hostProperties[propName];
                    if (typeof expression === 'string') {
                        this.parsePropertyBinding(propName, expression, true, sourceSpan, sourceSpan.start.offset, undefined, [], 
                        // Use the `sourceSpan` for  `keySpan`. This isn't really accurate, but neither is the
                        // sourceSpan, as it represents the sourceSpan of the host itself rather than the
                        // source of the host binding (which doesn't exist in the template). Regardless,
                        // neither of these values are used in Ivy but are only here to satisfy the function
                        // signature. This should likely be refactored in the future so that `sourceSpan`
                        // isn't being used inaccurately.
                        boundProps, sourceSpan);
                    }
                    else {
                        this._reportError(`Value of the host property binding "${propName}" needs to be a string representing an expression but got "${expression}" (${typeof expression})`, sourceSpan);
                    }
                });
                return boundProps;
            }
            return null;
        }
        createDirectiveHostPropertyAsts(dirMeta, elementSelector, sourceSpan) {
            const boundProps = this.createBoundHostProperties(dirMeta, sourceSpan);
            return boundProps &&
                boundProps.map((prop) => this.createBoundElementProperty(elementSelector, prop));
        }
        createDirectiveHostEventAsts(dirMeta, sourceSpan) {
            if (dirMeta.hostListeners) {
                const targetEvents = [];
                Object.keys(dirMeta.hostListeners).forEach(propName => {
                    const expression = dirMeta.hostListeners[propName];
                    if (typeof expression === 'string') {
                        // Use the `sourceSpan` for  `keySpan` and `handlerSpan`. This isn't really accurate, but
                        // neither is the `sourceSpan`, as it represents the `sourceSpan` of the host itself
                        // rather than the source of the host binding (which doesn't exist in the template).
                        // Regardless, neither of these values are used in Ivy but are only here to satisfy the
                        // function signature. This should likely be refactored in the future so that `sourceSpan`
                        // isn't being used inaccurately.
                        this.parseEvent(propName, expression, sourceSpan, sourceSpan, [], targetEvents, sourceSpan);
                    }
                    else {
                        this._reportError(`Value of the host listener "${propName}" needs to be a string representing an expression but got "${expression}" (${typeof expression})`, sourceSpan);
                    }
                });
                return targetEvents;
            }
            return null;
        }
        parseInterpolation(value, sourceSpan) {
            const sourceInfo = sourceSpan.start.toString();
            const absoluteOffset = sourceSpan.fullStart.offset;
            try {
                const ast = this._exprParser.parseInterpolation(value, sourceInfo, absoluteOffset, this._interpolationConfig);
                if (ast)
                    this._reportExpressionParserErrors(ast.errors, sourceSpan);
                this._checkPipes(ast, sourceSpan);
                return ast;
            }
            catch (e) {
                this._reportError(`${e}`, sourceSpan);
                return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);
            }
        }
        /**
         * Similar to `parseInterpolation`, but treats the provided string as a single expression
         * element that would normally appear within the interpolation prefix and suffix (`{{` and `}}`).
         * This is used for parsing the switch expression in ICUs.
         */
        parseInterpolationExpression(expression, sourceSpan) {
            const sourceInfo = sourceSpan.start.toString();
            const absoluteOffset = sourceSpan.start.offset;
            try {
                const ast = this._exprParser.parseInterpolationExpression(expression, sourceInfo, absoluteOffset);
                if (ast)
                    this._reportExpressionParserErrors(ast.errors, sourceSpan);
                this._checkPipes(ast, sourceSpan);
                return ast;
            }
            catch (e) {
                this._reportError(`${e}`, sourceSpan);
                return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);
            }
        }
        /**
         * Parses the bindings in a microsyntax expression, and converts them to
         * `ParsedProperty` or `ParsedVariable`.
         *
         * @param tplKey template binding name
         * @param tplValue template binding value
         * @param sourceSpan span of template binding relative to entire the template
         * @param absoluteValueOffset start of the tplValue relative to the entire template
         * @param targetMatchableAttrs potential attributes to match in the template
         * @param targetProps target property bindings in the template
         * @param targetVars target variables in the template
         */
        parseInlineTemplateBinding(tplKey, tplValue, sourceSpan, absoluteValueOffset, targetMatchableAttrs, targetProps, targetVars, isIvyAst) {
            const absoluteKeyOffset = sourceSpan.start.offset + TEMPLATE_ATTR_PREFIX.length;
            const bindings = this._parseTemplateBindings(tplKey, tplValue, sourceSpan, absoluteKeyOffset, absoluteValueOffset);
            for (const binding of bindings) {
                // sourceSpan is for the entire HTML attribute. bindingSpan is for a particular
                // binding within the microsyntax expression so it's more narrow than sourceSpan.
                const bindingSpan = moveParseSourceSpan(sourceSpan, binding.sourceSpan);
                const key = binding.key.source;
                const keySpan = moveParseSourceSpan(sourceSpan, binding.key.span);
                if (binding instanceof VariableBinding) {
                    const value = binding.value ? binding.value.source : '$implicit';
                    const valueSpan = binding.value ? moveParseSourceSpan(sourceSpan, binding.value.span) : undefined;
                    targetVars.push(new ParsedVariable(key, value, bindingSpan, keySpan, valueSpan));
                }
                else if (binding.value) {
                    const srcSpan = isIvyAst ? bindingSpan : sourceSpan;
                    const valueSpan = moveParseSourceSpan(sourceSpan, binding.value.ast.sourceSpan);
                    this._parsePropertyAst(key, binding.value, srcSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps);
                }
                else {
                    targetMatchableAttrs.push([key, '' /* value */]);
                    // Since this is a literal attribute with no RHS, source span should be
                    // just the key span.
                    this.parseLiteralAttr(key, null /* value */, keySpan, absoluteValueOffset, undefined /* valueSpan */, targetMatchableAttrs, targetProps, keySpan);
                }
            }
        }
        /**
         * Parses the bindings in a microsyntax expression, e.g.
         * ```
         *    <tag *tplKey="let value1 = prop; let value2 = localVar">
         * ```
         *
         * @param tplKey template binding name
         * @param tplValue template binding value
         * @param sourceSpan span of template binding relative to entire the template
         * @param absoluteKeyOffset start of the `tplKey`
         * @param absoluteValueOffset start of the `tplValue`
         */
        _parseTemplateBindings(tplKey, tplValue, sourceSpan, absoluteKeyOffset, absoluteValueOffset) {
            const sourceInfo = sourceSpan.start.toString();
            try {
                const bindingsResult = this._exprParser.parseTemplateBindings(tplKey, tplValue, sourceInfo, absoluteKeyOffset, absoluteValueOffset);
                this._reportExpressionParserErrors(bindingsResult.errors, sourceSpan);
                bindingsResult.templateBindings.forEach((binding) => {
                    if (binding.value instanceof ASTWithSource) {
                        this._checkPipes(binding.value, sourceSpan);
                    }
                });
                bindingsResult.warnings.forEach((warning) => {
                    this._reportError(warning, sourceSpan, ParseErrorLevel.WARNING);
                });
                return bindingsResult.templateBindings;
            }
            catch (e) {
                this._reportError(`${e}`, sourceSpan);
                return [];
            }
        }
        parseLiteralAttr(name, value, sourceSpan, absoluteOffset, valueSpan, targetMatchableAttrs, 
        // TODO(atscott): keySpan is only optional here so VE template parser implementation does not
        // have to change This should be required when VE is removed.
        targetProps, keySpan) {
            if (isAnimationLabel(name)) {
                name = name.substring(1);
                if (keySpan !== undefined) {
                    keySpan = moveParseSourceSpan(keySpan, new AbsoluteSourceSpan(keySpan.start.offset + 1, keySpan.end.offset));
                }
                if (value) {
                    this._reportError(`Assigning animation triggers via @prop="exp" attributes with an expression is invalid.` +
                        ` Use property bindings (e.g. [@prop]="exp") or use an attribute without a value (e.g. @prop) instead.`, sourceSpan, ParseErrorLevel.ERROR);
                }
                this._parseAnimation(name, value, sourceSpan, absoluteOffset, keySpan, valueSpan, targetMatchableAttrs, targetProps);
            }
            else {
                targetProps.push(new ParsedProperty(name, this._exprParser.wrapLiteralPrimitive(value, '', absoluteOffset), ParsedPropertyType.LITERAL_ATTR, sourceSpan, keySpan, valueSpan));
            }
        }
        parsePropertyBinding(name, expression, isHost, sourceSpan, absoluteOffset, valueSpan, 
        // TODO(atscott): keySpan is only optional here so VE template parser implementation does not
        // have to change This should be required when VE is removed.
        targetMatchableAttrs, targetProps, keySpan) {
            if (name.length === 0) {
                this._reportError(`Property name is missing in binding`, sourceSpan);
            }
            let isAnimationProp = false;
            if (name.startsWith(ANIMATE_PROP_PREFIX)) {
                isAnimationProp = true;
                name = name.substring(ANIMATE_PROP_PREFIX.length);
                if (keySpan !== undefined) {
                    keySpan = moveParseSourceSpan(keySpan, new AbsoluteSourceSpan(keySpan.start.offset + ANIMATE_PROP_PREFIX.length, keySpan.end.offset));
                }
            }
            else if (isAnimationLabel(name)) {
                isAnimationProp = true;
                name = name.substring(1);
                if (keySpan !== undefined) {
                    keySpan = moveParseSourceSpan(keySpan, new AbsoluteSourceSpan(keySpan.start.offset + 1, keySpan.end.offset));
                }
            }
            if (isAnimationProp) {
                this._parseAnimation(name, expression, sourceSpan, absoluteOffset, keySpan, valueSpan, targetMatchableAttrs, targetProps);
            }
            else {
                this._parsePropertyAst(name, this._parseBinding(expression, isHost, valueSpan || sourceSpan, absoluteOffset), sourceSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps);
            }
        }
        parsePropertyInterpolation(name, value, sourceSpan, valueSpan, targetMatchableAttrs, 
        // TODO(atscott): keySpan is only optional here so VE template parser implementation does not
        // have to change This should be required when VE is removed.
        targetProps, keySpan) {
            const expr = this.parseInterpolation(value, valueSpan || sourceSpan);
            if (expr) {
                this._parsePropertyAst(name, expr, sourceSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps);
                return true;
            }
            return false;
        }
        _parsePropertyAst(name, ast, sourceSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps) {
            targetMatchableAttrs.push([name, ast.source]);
            targetProps.push(new ParsedProperty(name, ast, ParsedPropertyType.DEFAULT, sourceSpan, keySpan, valueSpan));
        }
        _parseAnimation(name, expression, sourceSpan, absoluteOffset, keySpan, valueSpan, targetMatchableAttrs, targetProps) {
            if (name.length === 0) {
                this._reportError('Animation trigger is missing', sourceSpan);
            }
            // This will occur when a @trigger is not paired with an expression.
            // For animations it is valid to not have an expression since */void
            // states will be applied by angular when the element is attached/detached
            const ast = this._parseBinding(expression || 'undefined', false, valueSpan || sourceSpan, absoluteOffset);
            targetMatchableAttrs.push([name, ast.source]);
            targetProps.push(new ParsedProperty(name, ast, ParsedPropertyType.ANIMATION, sourceSpan, keySpan, valueSpan));
        }
        _parseBinding(value, isHostBinding, sourceSpan, absoluteOffset) {
            const sourceInfo = (sourceSpan && sourceSpan.start || '(unknown)').toString();
            try {
                const ast = isHostBinding ?
                    this._exprParser.parseSimpleBinding(value, sourceInfo, absoluteOffset, this._interpolationConfig) :
                    this._exprParser.parseBinding(value, sourceInfo, absoluteOffset, this._interpolationConfig);
                if (ast)
                    this._reportExpressionParserErrors(ast.errors, sourceSpan);
                this._checkPipes(ast, sourceSpan);
                return ast;
            }
            catch (e) {
                this._reportError(`${e}`, sourceSpan);
                return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);
            }
        }
        createBoundElementProperty(elementSelector, boundProp, skipValidation = false, mapPropertyName = true) {
            if (boundProp.isAnimation) {
                return new BoundElementProperty(boundProp.name, 4 /* Animation */, SecurityContext.NONE, boundProp.expression, null, boundProp.sourceSpan, boundProp.keySpan, boundProp.valueSpan);
            }
            let unit = null;
            let bindingType = undefined;
            let boundPropertyName = null;
            const parts = boundProp.name.split(PROPERTY_PARTS_SEPARATOR);
            let securityContexts = undefined;
            // Check for special cases (prefix style, attr, class)
            if (parts.length > 1) {
                if (parts[0] == ATTRIBUTE_PREFIX) {
                    boundPropertyName = parts.slice(1).join(PROPERTY_PARTS_SEPARATOR);
                    if (!skipValidation) {
                        this._validatePropertyOrAttributeName(boundPropertyName, boundProp.sourceSpan, true);
                    }
                    securityContexts = calcPossibleSecurityContexts(this._schemaRegistry, elementSelector, boundPropertyName, true);
                    const nsSeparatorIdx = boundPropertyName.indexOf(':');
                    if (nsSeparatorIdx > -1) {
                        const ns = boundPropertyName.substring(0, nsSeparatorIdx);
                        const name = boundPropertyName.substring(nsSeparatorIdx + 1);
                        boundPropertyName = mergeNsAndName(ns, name);
                    }
                    bindingType = 1 /* Attribute */;
                }
                else if (parts[0] == CLASS_PREFIX) {
                    boundPropertyName = parts[1];
                    bindingType = 2 /* Class */;
                    securityContexts = [SecurityContext.NONE];
                }
                else if (parts[0] == STYLE_PREFIX) {
                    unit = parts.length > 2 ? parts[2] : null;
                    boundPropertyName = parts[1];
                    bindingType = 3 /* Style */;
                    securityContexts = [SecurityContext.STYLE];
                }
            }
            // If not a special case, use the full property name
            if (boundPropertyName === null) {
                const mappedPropName = this._schemaRegistry.getMappedPropName(boundProp.name);
                boundPropertyName = mapPropertyName ? mappedPropName : boundProp.name;
                securityContexts = calcPossibleSecurityContexts(this._schemaRegistry, elementSelector, mappedPropName, false);
                bindingType = 0 /* Property */;
                if (!skipValidation) {
                    this._validatePropertyOrAttributeName(mappedPropName, boundProp.sourceSpan, false);
                }
            }
            return new BoundElementProperty(boundPropertyName, bindingType, securityContexts[0], boundProp.expression, unit, boundProp.sourceSpan, boundProp.keySpan, boundProp.valueSpan);
        }
        // TODO: keySpan should be required but was made optional to avoid changing VE parser.
        parseEvent(name, expression, sourceSpan, handlerSpan, targetMatchableAttrs, targetEvents, keySpan) {
            if (name.length === 0) {
                this._reportError(`Event name is missing in binding`, sourceSpan);
            }
            if (isAnimationLabel(name)) {
                name = name.substr(1);
                if (keySpan !== undefined) {
                    keySpan = moveParseSourceSpan(keySpan, new AbsoluteSourceSpan(keySpan.start.offset + 1, keySpan.end.offset));
                }
                this._parseAnimationEvent(name, expression, sourceSpan, handlerSpan, targetEvents, keySpan);
            }
            else {
                this._parseRegularEvent(name, expression, sourceSpan, handlerSpan, targetMatchableAttrs, targetEvents, keySpan);
            }
        }
        calcPossibleSecurityContexts(selector, propName, isAttribute) {
            const prop = this._schemaRegistry.getMappedPropName(propName);
            return calcPossibleSecurityContexts(this._schemaRegistry, selector, prop, isAttribute);
        }
        _parseAnimationEvent(name, expression, sourceSpan, handlerSpan, targetEvents, keySpan) {
            const matches = splitAtPeriod(name, [name, '']);
            const eventName = matches[0];
            const phase = matches[1].toLowerCase();
            const ast = this._parseAction(expression, handlerSpan);
            targetEvents.push(new ParsedEvent(eventName, phase, 1 /* Animation */, ast, sourceSpan, handlerSpan, keySpan));
            if (eventName.length === 0) {
                this._reportError(`Animation event name is missing in binding`, sourceSpan);
            }
            if (phase) {
                if (phase !== 'start' && phase !== 'done') {
                    this._reportError(`The provided animation output phase value "${phase}" for "@${eventName}" is not supported (use start or done)`, sourceSpan);
                }
            }
            else {
                this._reportError(`The animation trigger output event (@${eventName}) is missing its phase value name (start or done are currently supported)`, sourceSpan);
            }
        }
        _parseRegularEvent(name, expression, sourceSpan, handlerSpan, targetMatchableAttrs, targetEvents, keySpan) {
            // long format: 'target: eventName'
            const [target, eventName] = splitAtColon(name, [null, name]);
            const ast = this._parseAction(expression, handlerSpan);
            targetMatchableAttrs.push([name, ast.source]);
            targetEvents.push(new ParsedEvent(eventName, target, 0 /* Regular */, ast, sourceSpan, handlerSpan, keySpan));
            // Don't detect directives for event names for now,
            // so don't add the event name to the matchableAttrs
        }
        _parseAction(value, sourceSpan) {
            const sourceInfo = (sourceSpan && sourceSpan.start || '(unknown').toString();
            const absoluteOffset = (sourceSpan && sourceSpan.start) ? sourceSpan.start.offset : 0;
            try {
                const ast = this._exprParser.parseAction(value, sourceInfo, absoluteOffset, this._interpolationConfig);
                if (ast) {
                    this._reportExpressionParserErrors(ast.errors, sourceSpan);
                }
                if (!ast || ast.ast instanceof EmptyExpr) {
                    this._reportError(`Empty expressions are not allowed`, sourceSpan);
                    return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);
                }
                this._checkPipes(ast, sourceSpan);
                return ast;
            }
            catch (e) {
                this._reportError(`${e}`, sourceSpan);
                return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);
            }
        }
        _reportError(message, sourceSpan, level = ParseErrorLevel.ERROR) {
            this.errors.push(new ParseError(sourceSpan, message, level));
        }
        _reportExpressionParserErrors(errors, sourceSpan) {
            for (const error of errors) {
                this._reportError(error.message, sourceSpan);
            }
        }
        // Make sure all the used pipes are known in `this.pipesByName`
        _checkPipes(ast, sourceSpan) {
            if (ast && this.pipesByName) {
                const collector = new PipeCollector();
                ast.visit(collector);
                collector.pipes.forEach((ast, pipeName) => {
                    const pipeMeta = this.pipesByName.get(pipeName);
                    if (!pipeMeta) {
                        this._reportError(`The pipe '${pipeName}' could not be found`, new ParseSourceSpan(sourceSpan.start.moveBy(ast.span.start), sourceSpan.start.moveBy(ast.span.end)));
                    }
                    else {
                        this._usedPipes.set(pipeName, pipeMeta);
                    }
                });
            }
        }
        /**
         * @param propName the name of the property / attribute
         * @param sourceSpan
         * @param isAttr true when binding to an attribute
         */
        _validatePropertyOrAttributeName(propName, sourceSpan, isAttr) {
            const report = isAttr ? this._schemaRegistry.validateAttribute(propName) :
                this._schemaRegistry.validateProperty(propName);
            if (report.error) {
                this._reportError(report.msg, sourceSpan, ParseErrorLevel.ERROR);
            }
        }
    }
    class PipeCollector extends RecursiveAstVisitor {
        constructor() {
            super(...arguments);
            this.pipes = new Map();
        }
        visitPipe(ast, context) {
            this.pipes.set(ast.name, ast);
            ast.exp.visit(this);
            this.visitAll(ast.args, context);
            return null;
        }
    }
    function isAnimationLabel(name) {
        return name[0] == '@';
    }
    function calcPossibleSecurityContexts(registry, selector, propName, isAttribute) {
        const ctxs = [];
        CssSelector.parse(selector).forEach((selector) => {
            const elementNames = selector.element ? [selector.element] : registry.allKnownElementNames();
            const notElementNames = new Set(selector.notSelectors.filter(selector => selector.isElementSelector())
                .map((selector) => selector.element));
            const possibleElementNames = elementNames.filter(elementName => !notElementNames.has(elementName));
            ctxs.push(...possibleElementNames.map(elementName => registry.securityContext(elementName, propName, isAttribute)));
        });
        return ctxs.length === 0 ? [SecurityContext.NONE] : Array.from(new Set(ctxs)).sort();
    }
    /**
     * Compute a new ParseSourceSpan based off an original `sourceSpan` by using
     * absolute offsets from the specified `absoluteSpan`.
     *
     * @param sourceSpan original source span
     * @param absoluteSpan absolute source span to move to
     */
    function moveParseSourceSpan(sourceSpan, absoluteSpan) {
        // The difference of two absolute offsets provide the relative offset
        const startDiff = absoluteSpan.start - sourceSpan.start.offset;
        const endDiff = absoluteSpan.end - sourceSpan.end.offset;
        return new ParseSourceSpan(sourceSpan.start.moveBy(startDiff), sourceSpan.end.moveBy(endDiff), sourceSpan.fullStart.moveBy(startDiff), sourceSpan.details);
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const NG_CONTENT_SELECT_ATTR = 'select';
    const LINK_ELEMENT = 'link';
    const LINK_STYLE_REL_ATTR = 'rel';
    const LINK_STYLE_HREF_ATTR = 'href';
    const LINK_STYLE_REL_VALUE = 'stylesheet';
    const STYLE_ELEMENT = 'style';
    const SCRIPT_ELEMENT = 'script';
    const NG_NON_BINDABLE_ATTR = 'ngNonBindable';
    const NG_PROJECT_AS = 'ngProjectAs';
    function preparseElement(ast) {
        let selectAttr = null;
        let hrefAttr = null;
        let relAttr = null;
        let nonBindable = false;
        let projectAs = '';
        ast.attrs.forEach(attr => {
            const lcAttrName = attr.name.toLowerCase();
            if (lcAttrName == NG_CONTENT_SELECT_ATTR) {
                selectAttr = attr.value;
            }
            else if (lcAttrName == LINK_STYLE_HREF_ATTR) {
                hrefAttr = attr.value;
            }
            else if (lcAttrName == LINK_STYLE_REL_ATTR) {
                relAttr = attr.value;
            }
            else if (attr.name == NG_NON_BINDABLE_ATTR) {
                nonBindable = true;
            }
            else if (attr.name == NG_PROJECT_AS) {
                if (attr.value.length > 0) {
                    projectAs = attr.value;
                }
            }
        });
        selectAttr = normalizeNgContentSelect(selectAttr);
        const nodeName = ast.name.toLowerCase();
        let type = PreparsedElementType.OTHER;
        if (isNgContent(nodeName)) {
            type = PreparsedElementType.NG_CONTENT;
        }
        else if (nodeName == STYLE_ELEMENT) {
            type = PreparsedElementType.STYLE;
        }
        else if (nodeName == SCRIPT_ELEMENT) {
            type = PreparsedElementType.SCRIPT;
        }
        else if (nodeName == LINK_ELEMENT && relAttr == LINK_STYLE_REL_VALUE) {
            type = PreparsedElementType.STYLESHEET;
        }
        return new PreparsedElement(type, selectAttr, hrefAttr, nonBindable, projectAs);
    }
    var PreparsedElementType;
    (function (PreparsedElementType) {
        PreparsedElementType[PreparsedElementType["NG_CONTENT"] = 0] = "NG_CONTENT";
        PreparsedElementType[PreparsedElementType["STYLE"] = 1] = "STYLE";
        PreparsedElementType[PreparsedElementType["STYLESHEET"] = 2] = "STYLESHEET";
        PreparsedElementType[PreparsedElementType["SCRIPT"] = 3] = "SCRIPT";
        PreparsedElementType[PreparsedElementType["OTHER"] = 4] = "OTHER";
    })(PreparsedElementType || (PreparsedElementType = {}));
    class PreparsedElement {
        constructor(type, selectAttr, hrefAttr, nonBindable, projectAs) {
            this.type = type;
            this.selectAttr = selectAttr;
            this.hrefAttr = hrefAttr;
            this.nonBindable = nonBindable;
            this.projectAs = projectAs;
        }
    }
    function normalizeNgContentSelect(selectAttr) {
        if (selectAttr === null || selectAttr.length === 0) {
            return '*';
        }
        return selectAttr;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const BIND_NAME_REGEXP = /^(?:(?:(?:(bind-)|(let-)|(ref-|#)|(on-)|(bindon-)|(@))(.*))|\[\(([^\)]+)\)\]|\[([^\]]+)\]|\(([^\)]+)\))$/;
    // Group 1 = "bind-"
    const KW_BIND_IDX = 1;
    // Group 2 = "let-"
    const KW_LET_IDX = 2;
    // Group 3 = "ref-/#"
    const KW_REF_IDX = 3;
    // Group 4 = "on-"
    const KW_ON_IDX = 4;
    // Group 5 = "bindon-"
    const KW_BINDON_IDX = 5;
    // Group 6 = "@"
    const KW_AT_IDX = 6;
    // Group 7 = the identifier after "bind-", "let-", "ref-/#", "on-", "bindon-" or "@"
    const IDENT_KW_IDX = 7;
    // Group 8 = identifier inside [()]
    const IDENT_BANANA_BOX_IDX = 8;
    // Group 9 = identifier inside []
    const IDENT_PROPERTY_IDX = 9;
    // Group 10 = identifier inside ()
    const IDENT_EVENT_IDX = 10;
    const TEMPLATE_ATTR_PREFIX$1 = '*';
    const CLASS_ATTR = 'class';
    let _TEXT_CSS_SELECTOR;
    function TEXT_CSS_SELECTOR() {
        if (!_TEXT_CSS_SELECTOR) {
            _TEXT_CSS_SELECTOR = CssSelector.parse('*')[0];
        }
        return _TEXT_CSS_SELECTOR;
    }
    class TemplateParseError extends ParseError {
        constructor(message, span, level) {
            super(span, message, level);
        }
    }
    class TemplateParseResult {
        constructor(templateAst, usedPipes, errors) {
            this.templateAst = templateAst;
            this.usedPipes = usedPipes;
            this.errors = errors;
        }
    }
    class TemplateParser {
        constructor(_config, _reflector, _exprParser, _schemaRegistry, _htmlParser, _console, transforms) {
            this._config = _config;
            this._reflector = _reflector;
            this._exprParser = _exprParser;
            this._schemaRegistry = _schemaRegistry;
            this._htmlParser = _htmlParser;
            this._console = _console;
            this.transforms = transforms;
        }
        get expressionParser() {
            return this._exprParser;
        }
        parse(component, template, directives, pipes, schemas, templateUrl, preserveWhitespaces) {
            var _a;
            const result = this.tryParse(component, template, directives, pipes, schemas, templateUrl, preserveWhitespaces);
            const warnings = result.errors.filter(error => error.level === ParseErrorLevel.WARNING);
            const errors = result.errors.filter(error => error.level === ParseErrorLevel.ERROR);
            if (warnings.length > 0) {
                (_a = this._console) === null || _a === void 0 ? void 0 : _a.warn(`Template parse warnings:\n${warnings.join('\n')}`);
            }
            if (errors.length > 0) {
                const errorString = errors.join('\n');
                throw syntaxError(`Template parse errors:\n${errorString}`, errors);
            }
            return { template: result.templateAst, pipes: result.usedPipes };
        }
        tryParse(component, template, directives, pipes, schemas, templateUrl, preserveWhitespaces) {
            let htmlParseResult = typeof template === 'string' ?
                this._htmlParser.parse(template, templateUrl, {
                    tokenizeExpansionForms: true,
                    interpolationConfig: this.getInterpolationConfig(component)
                }) :
                template;
            if (!preserveWhitespaces) {
                htmlParseResult = removeWhitespaces(htmlParseResult);
            }
            return this.tryParseHtml(this.expandHtml(htmlParseResult), component, directives, pipes, schemas);
        }
        tryParseHtml(htmlAstWithErrors, component, directives, pipes, schemas) {
            let result;
            const errors = htmlAstWithErrors.errors;
            const usedPipes = [];
            if (htmlAstWithErrors.rootNodes.length > 0) {
                const uniqDirectives = removeSummaryDuplicates(directives);
                const uniqPipes = removeSummaryDuplicates(pipes);
                const providerViewContext = new ProviderViewContext(this._reflector, component);
                let interpolationConfig = undefined;
                if (component.template && component.template.interpolation) {
                    interpolationConfig = {
                        start: component.template.interpolation[0],
                        end: component.template.interpolation[1]
                    };
                }
                const bindingParser = new BindingParser(this._exprParser, interpolationConfig, this._schemaRegistry, uniqPipes, errors);
                const parseVisitor = new TemplateParseVisitor(this._reflector, this._config, providerViewContext, uniqDirectives, bindingParser, this._schemaRegistry, schemas, errors);
                result = visitAll$1(parseVisitor, htmlAstWithErrors.rootNodes, EMPTY_ELEMENT_CONTEXT);
                errors.push(...providerViewContext.errors);
                usedPipes.push(...bindingParser.getUsedPipes());
            }
            else {
                result = [];
            }
            this._assertNoReferenceDuplicationOnTemplate(result, errors);
            if (errors.length > 0) {
                return new TemplateParseResult(result, usedPipes, errors);
            }
            if (this.transforms) {
                this.transforms.forEach((transform) => {
                    result = templateVisitAll(transform, result);
                });
            }
            return new TemplateParseResult(result, usedPipes, errors);
        }
        expandHtml(htmlAstWithErrors, forced = false) {
            const errors = htmlAstWithErrors.errors;
            if (errors.length == 0 || forced) {
                // Transform ICU messages to angular directives
                const expandedHtmlAst = expandNodes(htmlAstWithErrors.rootNodes);
                errors.push(...expandedHtmlAst.errors);
                htmlAstWithErrors = new ParseTreeResult(expandedHtmlAst.nodes, errors);
            }
            return htmlAstWithErrors;
        }
        getInterpolationConfig(component) {
            if (component.template) {
                return InterpolationConfig.fromArray(component.template.interpolation);
            }
            return undefined;
        }
        /** @internal */
        _assertNoReferenceDuplicationOnTemplate(result, errors) {
            const existingReferences = [];
            result.filter(element => !!element.references)
                .forEach(element => element.references.forEach((reference) => {
                const name = reference.name;
                if (existingReferences.indexOf(name) < 0) {
                    existingReferences.push(name);
                }
                else {
                    const error = new TemplateParseError(`Reference "#${name}" is defined several times`, reference.sourceSpan, ParseErrorLevel.ERROR);
                    errors.push(error);
                }
            }));
        }
    }
    class TemplateParseVisitor {
        constructor(reflector, config, providerViewContext, directives, _bindingParser, _schemaRegistry, _schemas, _targetErrors) {
            this.reflector = reflector;
            this.config = config;
            this.providerViewContext = providerViewContext;
            this._bindingParser = _bindingParser;
            this._schemaRegistry = _schemaRegistry;
            this._schemas = _schemas;
            this._targetErrors = _targetErrors;
            this.selectorMatcher = new SelectorMatcher();
            this.directivesIndex = new Map();
            this.ngContentCount = 0;
            // Note: queries start with id 1 so we can use the number in a Bloom filter!
            this.contentQueryStartId = providerViewContext.component.viewQueries.length + 1;
            directives.forEach((directive, index) => {
                const selector = CssSelector.parse(directive.selector);
                this.selectorMatcher.addSelectables(selector, directive);
                this.directivesIndex.set(directive, index);
            });
        }
        visitExpansion(expansion, context) {
            return null;
        }
        visitExpansionCase(expansionCase, context) {
            return null;
        }
        visitText(text, parent) {
            const ngContentIndex = parent.findNgContentIndex(TEXT_CSS_SELECTOR());
            const valueNoNgsp = replaceNgsp(text.value);
            const expr = this._bindingParser.parseInterpolation(valueNoNgsp, text.sourceSpan);
            return expr ? new BoundTextAst(expr, ngContentIndex, text.sourceSpan) :
                new TextAst(valueNoNgsp, ngContentIndex, text.sourceSpan);
        }
        visitAttribute(attribute, context) {
            return new AttrAst(attribute.name, attribute.value, attribute.sourceSpan);
        }
        visitComment(comment, context) {
            return null;
        }
        visitElement(element, parent) {
            const queryStartIndex = this.contentQueryStartId;
            const elName = element.name;
            const preparsedElement = preparseElement(element);
            if (preparsedElement.type === PreparsedElementType.SCRIPT ||
                preparsedElement.type === PreparsedElementType.STYLE) {
                // Skipping <script> for security reasons
                // Skipping <style> as we already processed them
                // in the StyleCompiler
                return null;
            }
            if (preparsedElement.type === PreparsedElementType.STYLESHEET &&
                isStyleUrlResolvable(preparsedElement.hrefAttr)) {
                // Skipping stylesheets with either relative urls or package scheme as we already processed
                // them in the StyleCompiler
                return null;
            }
            const matchableAttrs = [];
            const elementOrDirectiveProps = [];
            const elementOrDirectiveRefs = [];
            const elementVars = [];
            const events = [];
            const templateElementOrDirectiveProps = [];
            const templateMatchableAttrs = [];
            const templateElementVars = [];
            let hasInlineTemplates = false;
            const attrs = [];
            const isTemplateElement = isNgTemplate(element.name);
            element.attrs.forEach(attr => {
                const parsedVariables = [];
                const hasBinding = this._parseAttr(isTemplateElement, attr, matchableAttrs, elementOrDirectiveProps, events, elementOrDirectiveRefs, elementVars);
                elementVars.push(...parsedVariables.map(v => VariableAst.fromParsedVariable(v)));
                let templateValue;
                let templateKey;
                const normalizedName = this._normalizeAttributeName(attr.name);
                if (normalizedName.startsWith(TEMPLATE_ATTR_PREFIX$1)) {
                    templateValue = attr.value;
                    templateKey = normalizedName.substring(TEMPLATE_ATTR_PREFIX$1.length);
                }
                const hasTemplateBinding = templateValue != null;
                if (hasTemplateBinding) {
                    if (hasInlineTemplates) {
                        this._reportError(`Can't have multiple template bindings on one element. Use only one attribute prefixed with *`, attr.sourceSpan);
                    }
                    hasInlineTemplates = true;
                    const parsedVariables = [];
                    const absoluteOffset = (attr.valueSpan || attr.sourceSpan).start.offset;
                    this._bindingParser.parseInlineTemplateBinding(templateKey, templateValue, attr.sourceSpan, absoluteOffset, templateMatchableAttrs, templateElementOrDirectiveProps, parsedVariables, false /* isIvyAst */);
                    templateElementVars.push(...parsedVariables.map(v => VariableAst.fromParsedVariable(v)));
                }
                if (!hasBinding && !hasTemplateBinding) {
                    // don't include the bindings as attributes as well in the AST
                    attrs.push(this.visitAttribute(attr, null));
                    matchableAttrs.push([attr.name, attr.value]);
                }
            });
            const elementCssSelector = createElementCssSelector(elName, matchableAttrs);
            const { directives: directiveMetas, matchElement } = this._parseDirectives(this.selectorMatcher, elementCssSelector);
            const references = [];
            const boundDirectivePropNames = new Set();
            const directiveAsts = this._createDirectiveAsts(isTemplateElement, element.name, directiveMetas, elementOrDirectiveProps, elementOrDirectiveRefs, element.sourceSpan, references, boundDirectivePropNames);
            const elementProps = this._createElementPropertyAsts(element.name, elementOrDirectiveProps, boundDirectivePropNames);
            const isViewRoot = parent.isTemplateElement || hasInlineTemplates;
            const providerContext = new ProviderElementContext(this.providerViewContext, parent.providerContext, isViewRoot, directiveAsts, attrs, references, isTemplateElement, queryStartIndex, element.sourceSpan);
            const children = visitAll$1(preparsedElement.nonBindable ? NON_BINDABLE_VISITOR : this, element.children, ElementContext.create(isTemplateElement, directiveAsts, isTemplateElement ? parent.providerContext : providerContext));
            providerContext.afterElement();
            // Override the actual selector when the `ngProjectAs` attribute is provided
            const projectionSelector = preparsedElement.projectAs != '' ?
                CssSelector.parse(preparsedElement.projectAs)[0] :
                elementCssSelector;
            const ngContentIndex = parent.findNgContentIndex(projectionSelector);
            let parsedElement;
            if (preparsedElement.type === PreparsedElementType.NG_CONTENT) {
                // `<ng-content>` element
                if (element.children && !element.children.every(_isEmptyTextNode)) {
                    this._reportError(`<ng-content> element cannot have content.`, element.sourceSpan);
                }
                parsedElement = new NgContentAst(this.ngContentCount++, hasInlineTemplates ? null : ngContentIndex, element.sourceSpan);
            }
            else if (isTemplateElement) {
                // `<ng-template>` element
                this._assertAllEventsPublishedByDirectives(directiveAsts, events);
                this._assertNoComponentsNorElementBindingsOnTemplate(directiveAsts, elementProps, element.sourceSpan);
                parsedElement = new EmbeddedTemplateAst(attrs, events, references, elementVars, providerContext.transformedDirectiveAsts, providerContext.transformProviders, providerContext.transformedHasViewContainer, providerContext.queryMatches, children, hasInlineTemplates ? null : ngContentIndex, element.sourceSpan);
            }
            else {
                // element other than `<ng-content>` and `<ng-template>`
                this._assertElementExists(matchElement, element);
                this._assertOnlyOneComponent(directiveAsts, element.sourceSpan);
                const ngContentIndex = hasInlineTemplates ? null : parent.findNgContentIndex(projectionSelector);
                parsedElement = new ElementAst(elName, attrs, elementProps, events, references, providerContext.transformedDirectiveAsts, providerContext.transformProviders, providerContext.transformedHasViewContainer, providerContext.queryMatches, children, hasInlineTemplates ? null : ngContentIndex, element.sourceSpan, element.endSourceSpan || null);
            }
            if (hasInlineTemplates) {
                // The element as a *-attribute
                const templateQueryStartIndex = this.contentQueryStartId;
                const templateSelector = createElementCssSelector('ng-template', templateMatchableAttrs);
                const { directives } = this._parseDirectives(this.selectorMatcher, templateSelector);
                const templateBoundDirectivePropNames = new Set();
                const templateDirectiveAsts = this._createDirectiveAsts(true, elName, directives, templateElementOrDirectiveProps, [], element.sourceSpan, [], templateBoundDirectivePropNames);
                const templateElementProps = this._createElementPropertyAsts(elName, templateElementOrDirectiveProps, templateBoundDirectivePropNames);
                this._assertNoComponentsNorElementBindingsOnTemplate(templateDirectiveAsts, templateElementProps, element.sourceSpan);
                const templateProviderContext = new ProviderElementContext(this.providerViewContext, parent.providerContext, parent.isTemplateElement, templateDirectiveAsts, [], [], true, templateQueryStartIndex, element.sourceSpan);
                templateProviderContext.afterElement();
                parsedElement = new EmbeddedTemplateAst([], [], [], templateElementVars, templateProviderContext.transformedDirectiveAsts, templateProviderContext.transformProviders, templateProviderContext.transformedHasViewContainer, templateProviderContext.queryMatches, [parsedElement], ngContentIndex, element.sourceSpan);
            }
            return parsedElement;
        }
        _parseAttr(isTemplateElement, attr, targetMatchableAttrs, targetProps, targetEvents, targetRefs, targetVars) {
            const name = this._normalizeAttributeName(attr.name);
            const value = attr.value;
            const srcSpan = attr.sourceSpan;
            const absoluteOffset = attr.valueSpan ? attr.valueSpan.start.offset : srcSpan.start.offset;
            const boundEvents = [];
            const bindParts = name.match(BIND_NAME_REGEXP);
            let hasBinding = false;
            if (bindParts !== null) {
                hasBinding = true;
                if (bindParts[KW_BIND_IDX] != null) {
                    this._bindingParser.parsePropertyBinding(bindParts[IDENT_KW_IDX], value, false, srcSpan, absoluteOffset, attr.valueSpan, targetMatchableAttrs, targetProps);
                }
                else if (bindParts[KW_LET_IDX]) {
                    if (isTemplateElement) {
                        const identifier = bindParts[IDENT_KW_IDX];
                        this._parseVariable(identifier, value, srcSpan, targetVars);
                    }
                    else {
                        this._reportError(`"let-" is only supported on ng-template elements.`, srcSpan);
                    }
                }
                else if (bindParts[KW_REF_IDX]) {
                    const identifier = bindParts[IDENT_KW_IDX];
                    this._parseReference(identifier, value, srcSpan, targetRefs);
                }
                else if (bindParts[KW_ON_IDX]) {
                    this._bindingParser.parseEvent(bindParts[IDENT_KW_IDX], value, srcSpan, attr.valueSpan || srcSpan, targetMatchableAttrs, boundEvents);
                }
                else if (bindParts[KW_BINDON_IDX]) {
                    this._bindingParser.parsePropertyBinding(bindParts[IDENT_KW_IDX], value, false, srcSpan, absoluteOffset, attr.valueSpan, targetMatchableAttrs, targetProps);
                    this._parseAssignmentEvent(bindParts[IDENT_KW_IDX], value, srcSpan, attr.valueSpan || srcSpan, targetMatchableAttrs, boundEvents);
                }
                else if (bindParts[KW_AT_IDX]) {
                    this._bindingParser.parseLiteralAttr(name, value, srcSpan, absoluteOffset, attr.valueSpan, targetMatchableAttrs, targetProps);
                }
                else if (bindParts[IDENT_BANANA_BOX_IDX]) {
                    this._bindingParser.parsePropertyBinding(bindParts[IDENT_BANANA_BOX_IDX], value, false, srcSpan, absoluteOffset, attr.valueSpan, targetMatchableAttrs, targetProps);
                    this._parseAssignmentEvent(bindParts[IDENT_BANANA_BOX_IDX], value, srcSpan, attr.valueSpan || srcSpan, targetMatchableAttrs, boundEvents);
                }
                else if (bindParts[IDENT_PROPERTY_IDX]) {
                    this._bindingParser.parsePropertyBinding(bindParts[IDENT_PROPERTY_IDX], value, false, srcSpan, absoluteOffset, attr.valueSpan, targetMatchableAttrs, targetProps);
                }
                else if (bindParts[IDENT_EVENT_IDX]) {
                    this._bindingParser.parseEvent(bindParts[IDENT_EVENT_IDX], value, srcSpan, attr.valueSpan || srcSpan, targetMatchableAttrs, boundEvents);
                }
            }
            else {
                hasBinding = this._bindingParser.parsePropertyInterpolation(name, value, srcSpan, attr.valueSpan, targetMatchableAttrs, targetProps);
            }
            if (!hasBinding) {
                this._bindingParser.parseLiteralAttr(name, value, srcSpan, absoluteOffset, attr.valueSpan, targetMatchableAttrs, targetProps);
            }
            targetEvents.push(...boundEvents.map(e => BoundEventAst.fromParsedEvent(e)));
            return hasBinding;
        }
        _normalizeAttributeName(attrName) {
            return /^data-/i.test(attrName) ? attrName.substring(5) : attrName;
        }
        _parseVariable(identifier, value, sourceSpan, targetVars) {
            if (identifier.indexOf('-') > -1) {
                this._reportError(`"-" is not allowed in variable names`, sourceSpan);
            }
            else if (identifier.length === 0) {
                this._reportError(`Variable does not have a name`, sourceSpan);
            }
            targetVars.push(new VariableAst(identifier, value, sourceSpan));
        }
        _parseReference(identifier, value, sourceSpan, targetRefs) {
            if (identifier.indexOf('-') > -1) {
                this._reportError(`"-" is not allowed in reference names`, sourceSpan);
            }
            else if (identifier.length === 0) {
                this._reportError(`Reference does not have a name`, sourceSpan);
            }
            targetRefs.push(new ElementOrDirectiveRef(identifier, value, sourceSpan));
        }
        _parseAssignmentEvent(name, expression, sourceSpan, valueSpan, targetMatchableAttrs, targetEvents) {
            this._bindingParser.parseEvent(`${name}Change`, `${expression}=$event`, sourceSpan, valueSpan, targetMatchableAttrs, targetEvents);
        }
        _parseDirectives(selectorMatcher, elementCssSelector) {
            // Need to sort the directives so that we get consistent results throughout,
            // as selectorMatcher uses Maps inside.
            // Also deduplicate directives as they might match more than one time!
            const directives = newArray(this.directivesIndex.size);
            // Whether any directive selector matches on the element name
            let matchElement = false;
            selectorMatcher.match(elementCssSelector, (selector, directive) => {
                directives[this.directivesIndex.get(directive)] = directive;
                matchElement = matchElement || selector.hasElementSelector();
            });
            return {
                directives: directives.filter(dir => !!dir),
                matchElement,
            };
        }
        _createDirectiveAsts(isTemplateElement, elementName, directives, props, elementOrDirectiveRefs, elementSourceSpan, targetReferences, targetBoundDirectivePropNames) {
            const matchedReferences = new Set();
            let component = null;
            const directiveAsts = directives.map((directive) => {
                const sourceSpan = new ParseSourceSpan(elementSourceSpan.start, elementSourceSpan.end, elementSourceSpan.fullStart, `Directive ${identifierName(directive.type)}`);
                if (directive.isComponent) {
                    component = directive;
                }
                const directiveProperties = [];
                const boundProperties = this._bindingParser.createDirectiveHostPropertyAsts(directive, elementName, sourceSpan);
                let hostProperties = boundProperties.map(prop => BoundElementPropertyAst.fromBoundProperty(prop));
                // Note: We need to check the host properties here as well,
                // as we don't know the element name in the DirectiveWrapperCompiler yet.
                hostProperties = this._checkPropertiesInSchema(elementName, hostProperties);
                const parsedEvents = this._bindingParser.createDirectiveHostEventAsts(directive, sourceSpan);
                this._createDirectivePropertyAsts(directive.inputs, props, directiveProperties, targetBoundDirectivePropNames);
                elementOrDirectiveRefs.forEach((elOrDirRef) => {
                    if ((elOrDirRef.value.length === 0 && directive.isComponent) ||
                        (elOrDirRef.isReferenceToDirective(directive))) {
                        targetReferences.push(new ReferenceAst(elOrDirRef.name, createTokenForReference(directive.type.reference), elOrDirRef.value, elOrDirRef.sourceSpan));
                        matchedReferences.add(elOrDirRef.name);
                    }
                });
                const hostEvents = parsedEvents.map(e => BoundEventAst.fromParsedEvent(e));
                const contentQueryStartId = this.contentQueryStartId;
                this.contentQueryStartId += directive.queries.length;
                return new DirectiveAst(directive, directiveProperties, hostProperties, hostEvents, contentQueryStartId, sourceSpan);
            });
            elementOrDirectiveRefs.forEach((elOrDirRef) => {
                if (elOrDirRef.value.length > 0) {
                    if (!matchedReferences.has(elOrDirRef.name)) {
                        this._reportError(`There is no directive with "exportAs" set to "${elOrDirRef.value}"`, elOrDirRef.sourceSpan);
                    }
                }
                else if (!component) {
                    let refToken = null;
                    if (isTemplateElement) {
                        refToken = createTokenForExternalReference(this.reflector, Identifiers$1.TemplateRef);
                    }
                    targetReferences.push(new ReferenceAst(elOrDirRef.name, refToken, elOrDirRef.value, elOrDirRef.sourceSpan));
                }
            });
            return directiveAsts;
        }
        _createDirectivePropertyAsts(directiveProperties, boundProps, targetBoundDirectiveProps, targetBoundDirectivePropNames) {
            if (directiveProperties) {
                const boundPropsByName = new Map();
                boundProps.forEach(boundProp => {
                    const prevValue = boundPropsByName.get(boundProp.name);
                    if (!prevValue || prevValue.isLiteral) {
                        // give [a]="b" a higher precedence than a="b" on the same element
                        boundPropsByName.set(boundProp.name, boundProp);
                    }
                });
                Object.keys(directiveProperties).forEach(dirProp => {
                    const elProp = directiveProperties[dirProp];
                    const boundProp = boundPropsByName.get(elProp);
                    // Bindings are optional, so this binding only needs to be set up if an expression is given.
                    if (boundProp) {
                        targetBoundDirectivePropNames.add(boundProp.name);
                        if (!isEmptyExpression(boundProp.expression)) {
                            targetBoundDirectiveProps.push(new BoundDirectivePropertyAst(dirProp, boundProp.name, boundProp.expression, boundProp.sourceSpan));
                        }
                    }
                });
            }
        }
        _createElementPropertyAsts(elementName, props, boundDirectivePropNames) {
            const boundElementProps = [];
            props.forEach((prop) => {
                if (!prop.isLiteral && !boundDirectivePropNames.has(prop.name)) {
                    const boundProp = this._bindingParser.createBoundElementProperty(elementName, prop);
                    boundElementProps.push(BoundElementPropertyAst.fromBoundProperty(boundProp));
                }
            });
            return this._checkPropertiesInSchema(elementName, boundElementProps);
        }
        _findComponentDirectives(directives) {
            return directives.filter(directive => directive.directive.isComponent);
        }
        _findComponentDirectiveNames(directives) {
            return this._findComponentDirectives(directives)
                .map(directive => identifierName(directive.directive.type));
        }
        _assertOnlyOneComponent(directives, sourceSpan) {
            const componentTypeNames = this._findComponentDirectiveNames(directives);
            if (componentTypeNames.length > 1) {
                this._reportError(`More than one component matched on this element.\n` +
                    `Make sure that only one component's selector can match a given element.\n` +
                    `Conflicting components: ${componentTypeNames.join(',')}`, sourceSpan);
            }
        }
        /**
         * Make sure that non-angular tags conform to the schemas.
         *
         * Note: An element is considered an angular tag when at least one directive selector matches the
         * tag name.
         *
         * @param matchElement Whether any directive has matched on the tag name
         * @param element the html element
         */
        _assertElementExists(matchElement, element) {
            const elName = element.name.replace(/^:xhtml:/, '');
            if (!matchElement && !this._schemaRegistry.hasElement(elName, this._schemas)) {
                let errorMsg = `'${elName}' is not a known element:\n`;
                errorMsg += `1. If '${elName}' is an Angular component, then verify that it is part of this module.\n`;
                if (elName.indexOf('-') > -1) {
                    errorMsg += `2. If '${elName}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the '@NgModule.schemas' of this component to suppress this message.`;
                }
                else {
                    errorMsg +=
                        `2. To allow any element add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.`;
                }
                this._reportError(errorMsg, element.sourceSpan);
            }
        }
        _assertNoComponentsNorElementBindingsOnTemplate(directives, elementProps, sourceSpan) {
            const componentTypeNames = this._findComponentDirectiveNames(directives);
            if (componentTypeNames.length > 0) {
                this._reportError(`Components on an embedded template: ${componentTypeNames.join(',')}`, sourceSpan);
            }
            elementProps.forEach(prop => {
                this._reportError(`Property binding ${prop.name} not used by any directive on an embedded template. Make sure that the property name is spelled correctly and all directives are listed in the "@NgModule.declarations".`, sourceSpan);
            });
        }
        _assertAllEventsPublishedByDirectives(directives, events) {
            const allDirectiveEvents = new Set();
            directives.forEach(directive => {
                Object.keys(directive.directive.outputs).forEach(k => {
                    const eventName = directive.directive.outputs[k];
                    allDirectiveEvents.add(eventName);
                });
            });
            events.forEach(event => {
                if (event.target != null || !allDirectiveEvents.has(event.name)) {
                    this._reportError(`Event binding ${event
                    .fullName} not emitted by any directive on an embedded template. Make sure that the event name is spelled correctly and all directives are listed in the "@NgModule.declarations".`, event.sourceSpan);
                }
            });
        }
        _checkPropertiesInSchema(elementName, boundProps) {
            // Note: We can't filter out empty expressions before this method,
            // as we still want to validate them!
            return boundProps.filter((boundProp) => {
                if (boundProp.type === 0 /* Property */ &&
                    !this._schemaRegistry.hasProperty(elementName, boundProp.name, this._schemas)) {
                    let errorMsg = `Can't bind to '${boundProp.name}' since it isn't a known property of '${elementName}'.`;
                    if (elementName.startsWith('ng-')) {
                        errorMsg +=
                            `\n1. If '${boundProp
                            .name}' is an Angular directive, then add 'CommonModule' to the '@NgModule.imports' of this component.` +
                                `\n2. To allow any property add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.`;
                    }
                    else if (elementName.indexOf('-') > -1) {
                        errorMsg +=
                            `\n1. If '${elementName}' is an Angular component and it has '${boundProp.name}' input, then verify that it is part of this module.` +
                                `\n2. If '${elementName}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the '@NgModule.schemas' of this component to suppress this message.` +
                                `\n3. To allow any property add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.`;
                    }
                    this._reportError(errorMsg, boundProp.sourceSpan);
                }
                return !isEmptyExpression(boundProp.value);
            });
        }
        _reportError(message, sourceSpan, level = ParseErrorLevel.ERROR) {
            this._targetErrors.push(new ParseError(sourceSpan, message, level));
        }
    }
    class NonBindableVisitor {
        visitElement(ast, parent) {
            const preparsedElement = preparseElement(ast);
            if (preparsedElement.type === PreparsedElementType.SCRIPT ||
                preparsedElement.type === PreparsedElementType.STYLE ||
                preparsedElement.type === PreparsedElementType.STYLESHEET) {
                // Skipping <script> for security reasons
                // Skipping <style> and stylesheets as we already processed them
                // in the StyleCompiler
                return null;
            }
            const attrNameAndValues = ast.attrs.map((attr) => [attr.name, attr.value]);
            const selector = createElementCssSelector(ast.name, attrNameAndValues);
            const ngContentIndex = parent.findNgContentIndex(selector);
            const children = visitAll$1(this, ast.children, EMPTY_ELEMENT_CONTEXT);
            return new ElementAst(ast.name, visitAll$1(this, ast.attrs), [], [], [], [], [], false, [], children, ngContentIndex, ast.sourceSpan, ast.endSourceSpan);
        }
        visitComment(comment, context) {
            return null;
        }
        visitAttribute(attribute, context) {
            return new AttrAst(attribute.name, attribute.value, attribute.sourceSpan);
        }
        visitText(text, parent) {
            const ngContentIndex = parent.findNgContentIndex(TEXT_CSS_SELECTOR());
            return new TextAst(text.value, ngContentIndex, text.sourceSpan);
        }
        visitExpansion(expansion, context) {
            return expansion;
        }
        visitExpansionCase(expansionCase, context) {
            return expansionCase;
        }
    }
    /**
     * A reference to an element or directive in a template. E.g., the reference in this template:
     *
     * <div #myMenu="coolMenu">
     *
     * would be {name: 'myMenu', value: 'coolMenu', sourceSpan: ...}
     */
    class ElementOrDirectiveRef {
        constructor(name, value, sourceSpan) {
            this.name = name;
            this.value = value;
            this.sourceSpan = sourceSpan;
        }
        /** Gets whether this is a reference to the given directive. */
        isReferenceToDirective(directive) {
            return splitExportAs(directive.exportAs).indexOf(this.value) !== -1;
        }
    }
    /** Splits a raw, potentially comma-delimited `exportAs` value into an array of names. */
    function splitExportAs(exportAs) {
        return exportAs ? exportAs.split(',').map(e => e.trim()) : [];
    }
    function splitClasses(classAttrValue) {
        return classAttrValue.trim().split(/\s+/g);
    }
    class ElementContext {
        constructor(isTemplateElement, _ngContentIndexMatcher, _wildcardNgContentIndex, providerContext) {
            this.isTemplateElement = isTemplateElement;
            this._ngContentIndexMatcher = _ngContentIndexMatcher;
            this._wildcardNgContentIndex = _wildcardNgContentIndex;
            this.providerContext = providerContext;
        }
        static create(isTemplateElement, directives, providerContext) {
            const matcher = new SelectorMatcher();
            let wildcardNgContentIndex = null;
            const component = directives.find(directive => directive.directive.isComponent);
            if (component) {
                const ngContentSelectors = component.directive.template.ngContentSelectors;
                for (let i = 0; i < ngContentSelectors.length; i++) {
                    const selector = ngContentSelectors[i];
                    if (selector === '*') {
                        wildcardNgContentIndex = i;
                    }
                    else {
                        matcher.addSelectables(CssSelector.parse(ngContentSelectors[i]), i);
                    }
                }
            }
            return new ElementContext(isTemplateElement, matcher, wildcardNgContentIndex, providerContext);
        }
        findNgContentIndex(selector) {
            const ngContentIndices = [];
            this._ngContentIndexMatcher.match(selector, (selector, ngContentIndex) => {
                ngContentIndices.push(ngContentIndex);
            });
            ngContentIndices.sort();
            if (this._wildcardNgContentIndex != null) {
                ngContentIndices.push(this._wildcardNgContentIndex);
            }
            return ngContentIndices.length > 0 ? ngContentIndices[0] : null;
        }
    }
    function createElementCssSelector(elementName, attributes) {
        const cssSelector = new CssSelector();
        const elNameNoNs = splitNsName(elementName)[1];
        cssSelector.setElement(elNameNoNs);
        for (let i = 0; i < attributes.length; i++) {
            const attrName = attributes[i][0];
            const attrNameNoNs = splitNsName(attrName)[1];
            const attrValue = attributes[i][1];
            cssSelector.addAttribute(attrNameNoNs, attrValue);
            if (attrName.toLowerCase() == CLASS_ATTR) {
                const classes = splitClasses(attrValue);
                classes.forEach(className => cssSelector.addClassName(className));
            }
        }
        return cssSelector;
    }
    const EMPTY_ELEMENT_CONTEXT = new ElementContext(true, new SelectorMatcher(), null, null);
    const NON_BINDABLE_VISITOR = new NonBindableVisitor();
    function _isEmptyTextNode(node) {
        return node instanceof Text$2 && node.value.trim().length == 0;
    }
    function removeSummaryDuplicates(items) {
        const map = new Map();
        items.forEach((item) => {
            if (!map.get(item.type.reference)) {
                map.set(item.type.reference, item);
            }
        });
        return Array.from(map.values());
    }
    function isEmptyExpression(ast) {
        if (ast instanceof ASTWithSource) {
            ast = ast.ast;
        }
        return ast instanceof EmptyExpr;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Parses string representation of a style and converts it into object literal.
     *
     * @param value string representation of style as used in the `style` attribute in HTML.
     *   Example: `color: red; height: auto`.
     * @returns An array of style property name and value pairs, e.g. `['color', 'red', 'height',
     * 'auto']`
     */
    function parse(value) {
        // we use a string array here instead of a string map
        // because a string-map is not guaranteed to retain the
        // order of the entries whereas a string array can be
        // constructed in a [key, value, key, value] format.
        const styles = [];
        let i = 0;
        let parenDepth = 0;
        let quote = 0 /* QuoteNone */;
        let valueStart = 0;
        let propStart = 0;
        let currentProp = null;
        let valueHasQuotes = false;
        while (i < value.length) {
            const token = value.charCodeAt(i++);
            switch (token) {
                case 40 /* OpenParen */:
                    parenDepth++;
                    break;
                case 41 /* CloseParen */:
                    parenDepth--;
                    break;
                case 39 /* QuoteSingle */:
                    // valueStart needs to be there since prop values don't
                    // have quotes in CSS
                    valueHasQuotes = valueHasQuotes || valueStart > 0;
                    if (quote === 0 /* QuoteNone */) {
                        quote = 39 /* QuoteSingle */;
                    }
                    else if (quote === 39 /* QuoteSingle */ && value.charCodeAt(i - 1) !== 92 /* BackSlash */) {
                        quote = 0 /* QuoteNone */;
                    }
                    break;
                case 34 /* QuoteDouble */:
                    // same logic as above
                    valueHasQuotes = valueHasQuotes || valueStart > 0;
                    if (quote === 0 /* QuoteNone */) {
                        quote = 34 /* QuoteDouble */;
                    }
                    else if (quote === 34 /* QuoteDouble */ && value.charCodeAt(i - 1) !== 92 /* BackSlash */) {
                        quote = 0 /* QuoteNone */;
                    }
                    break;
                case 58 /* Colon */:
                    if (!currentProp && parenDepth === 0 && quote === 0 /* QuoteNone */) {
                        currentProp = hyphenate(value.substring(propStart, i - 1).trim());
                        valueStart = i;
                    }
                    break;
                case 59 /* Semicolon */:
                    if (currentProp && valueStart > 0 && parenDepth === 0 && quote === 0 /* QuoteNone */) {
                        const styleVal = value.substring(valueStart, i - 1).trim();
                        styles.push(currentProp, valueHasQuotes ? stripUnnecessaryQuotes(styleVal) : styleVal);
                        propStart = i;
                        valueStart = 0;
                        currentProp = null;
                        valueHasQuotes = false;
                    }
                    break;
            }
        }
        if (currentProp && valueStart) {
            const styleVal = value.substr(valueStart).trim();
            styles.push(currentProp, valueHasQuotes ? stripUnnecessaryQuotes(styleVal) : styleVal);
        }
        return styles;
    }
    function stripUnnecessaryQuotes(value) {
        const qS = value.charCodeAt(0);
        const qE = value.charCodeAt(value.length - 1);
        if (qS == qE && (qS == 39 /* QuoteSingle */ || qS == 34 /* QuoteDouble */)) {
            const tempValue = value.substring(1, value.length - 1);
            // special case to avoid using a multi-quoted string that was just chomped
            // (e.g. `font-family: "Verdana", "sans-serif"`)
            if (tempValue.indexOf('\'') == -1 && tempValue.indexOf('"') == -1) {
                value = tempValue;
            }
        }
        return value;
    }
    function hyphenate(value) {
        return value
            .replace(/[a-z][A-Z]/g, v => {
            return v.charAt(0) + '-' + v.charAt(1);
        })
            .toLowerCase();
    }

    const IMPORTANT_FLAG = '!important';
    /**
     * Minimum amount of binding slots required in the runtime for style/class bindings.
     *
     * Styling in Angular uses up two slots in the runtime LView/TData data structures to
     * record binding data, property information and metadata.
     *
     * When a binding is registered it will place the following information in the `LView`:
     *
     * slot 1) binding value
     * slot 2) cached value (all other values collected before it in string form)
     *
     * When a binding is registered it will place the following information in the `TData`:
     *
     * slot 1) prop name
     * slot 2) binding index that points to the previous style/class binding (and some extra config
     * values)
     *
     * Let's imagine we have a binding that looks like so:
     *
     * ```
     * <div [style.width]="x" [style.height]="y">
     * ```
     *
     * Our `LView` and `TData` data-structures look like so:
     *
     * ```typescript
     * LView = [
     *   // ...
     *   x, // value of x
     *   "width: x",
     *
     *   y, // value of y
     *   "width: x; height: y",
     *   // ...
     * ];
     *
     * TData = [
     *   // ...
     *   "width", // binding slot 20
     *   0,
     *
     *   "height",
     *   20,
     *   // ...
     * ];
     * ```
     *
     * */
    const MIN_STYLING_BINDING_SLOTS_REQUIRED = 2;
    /**
     * Produces creation/update instructions for all styling bindings (class and style)
     *
     * It also produces the creation instruction to register all initial styling values
     * (which are all the static class="..." and style="..." attribute values that exist
     * on an element within a template).
     *
     * The builder class below handles producing instructions for the following cases:
     *
     * - Static style/class attributes (style="..." and class="...")
     * - Dynamic style/class map bindings ([style]="map" and [class]="map|string")
     * - Dynamic style/class property bindings ([style.prop]="exp" and [class.name]="exp")
     *
     * Due to the complex relationship of all of these cases, the instructions generated
     * for these attributes/properties/bindings must be done so in the correct order. The
     * order which these must be generated is as follows:
     *
     * if (createMode) {
     *   styling(...)
     * }
     * if (updateMode) {
     *   styleMap(...)
     *   classMap(...)
     *   styleProp(...)
     *   classProp(...)
     * }
     *
     * The creation/update methods within the builder class produce these instructions.
     */
    class StylingBuilder {
        constructor(_directiveExpr) {
            this._directiveExpr = _directiveExpr;
            /** Whether or not there are any static styling values present */
            this._hasInitialValues = false;
            /**
             *  Whether or not there are any styling bindings present
             *  (i.e. `[style]`, `[class]`, `[style.prop]` or `[class.name]`)
             */
            this.hasBindings = false;
            this.hasBindingsWithPipes = false;
            /** the input for [class] (if it exists) */
            this._classMapInput = null;
            /** the input for [style] (if it exists) */
            this._styleMapInput = null;
            /** an array of each [style.prop] input */
            this._singleStyleInputs = null;
            /** an array of each [class.name] input */
            this._singleClassInputs = null;
            this._lastStylingInput = null;
            this._firstStylingInput = null;
            // maps are used instead of hash maps because a Map will
            // retain the ordering of the keys
            /**
             * Represents the location of each style binding in the template
             * (e.g. `<div [style.width]="w" [style.height]="h">` implies
             * that `width=0` and `height=1`)
             */
            this._stylesIndex = new Map();
            /**
             * Represents the location of each class binding in the template
             * (e.g. `<div [class.big]="b" [class.hidden]="h">` implies
             * that `big=0` and `hidden=1`)
             */
            this._classesIndex = new Map();
            this._initialStyleValues = [];
            this._initialClassValues = [];
        }
        /**
         * Registers a given input to the styling builder to be later used when producing AOT code.
         *
         * The code below will only accept the input if it is somehow tied to styling (whether it be
         * style/class bindings or static style/class attributes).
         */
        registerBoundInput(input) {
            // [attr.style] or [attr.class] are skipped in the code below,
            // they should not be treated as styling-based bindings since
            // they are intended to be written directly to the attr and
            // will therefore skip all style/class resolution that is present
            // with style="", [style]="" and [style.prop]="", class="",
            // [class.prop]="". [class]="" assignments
            let binding = null;
            let name = input.name;
            switch (input.type) {
                case 0 /* Property */:
                    binding = this.registerInputBasedOnName(name, input.value, input.sourceSpan);
                    break;
                case 3 /* Style */:
                    binding = this.registerStyleInput(name, false, input.value, input.sourceSpan, input.unit);
                    break;
                case 2 /* Class */:
                    binding = this.registerClassInput(name, false, input.value, input.sourceSpan);
                    break;
            }
            return binding ? true : false;
        }
        registerInputBasedOnName(name, expression, sourceSpan) {
            let binding = null;
            const prefix = name.substring(0, 6);
            const isStyle = name === 'style' || prefix === 'style.' || prefix === 'style!';
            const isClass = !isStyle && (name === 'class' || prefix === 'class.' || prefix === 'class!');
            if (isStyle || isClass) {
                const isMapBased = name.charAt(5) !== '.'; // style.prop or class.prop makes this a no
                const property = name.substr(isMapBased ? 5 : 6); // the dot explains why there's a +1
                if (isStyle) {
                    binding = this.registerStyleInput(property, isMapBased, expression, sourceSpan);
                }
                else {
                    binding = this.registerClassInput(property, isMapBased, expression, sourceSpan);
                }
            }
            return binding;
        }
        registerStyleInput(name, isMapBased, value, sourceSpan, suffix) {
            if (isEmptyExpression(value)) {
                return null;
            }
            // CSS custom properties are case-sensitive so we shouldn't normalize them.
            // See: https://www.w3.org/TR/css-variables-1/#defining-variables
            if (!isCssCustomProperty(name)) {
                name = hyphenate(name);
            }
            const { property, hasOverrideFlag, suffix: bindingSuffix } = parseProperty(name);
            suffix = typeof suffix === 'string' && suffix.length !== 0 ? suffix : bindingSuffix;
            const entry = { name: property, suffix: suffix, value, sourceSpan, hasOverrideFlag };
            if (isMapBased) {
                this._styleMapInput = entry;
            }
            else {
                (this._singleStyleInputs = this._singleStyleInputs || []).push(entry);
                registerIntoMap(this._stylesIndex, property);
            }
            this._lastStylingInput = entry;
            this._firstStylingInput = this._firstStylingInput || entry;
            this._checkForPipes(value);
            this.hasBindings = true;
            return entry;
        }
        registerClassInput(name, isMapBased, value, sourceSpan) {
            if (isEmptyExpression(value)) {
                return null;
            }
            const { property, hasOverrideFlag } = parseProperty(name);
            const entry = { name: property, value, sourceSpan, hasOverrideFlag, suffix: null };
            if (isMapBased) {
                this._classMapInput = entry;
            }
            else {
                (this._singleClassInputs = this._singleClassInputs || []).push(entry);
                registerIntoMap(this._classesIndex, property);
            }
            this._lastStylingInput = entry;
            this._firstStylingInput = this._firstStylingInput || entry;
            this._checkForPipes(value);
            this.hasBindings = true;
            return entry;
        }
        _checkForPipes(value) {
            if ((value instanceof ASTWithSource) && (value.ast instanceof BindingPipe)) {
                this.hasBindingsWithPipes = true;
            }
        }
        /**
         * Registers the element's static style string value to the builder.
         *
         * @param value the style string (e.g. `width:100px; height:200px;`)
         */
        registerStyleAttr(value) {
            this._initialStyleValues = parse(value);
            this._hasInitialValues = true;
        }
        /**
         * Registers the element's static class string value to the builder.
         *
         * @param value the className string (e.g. `disabled gold zoom`)
         */
        registerClassAttr(value) {
            this._initialClassValues = value.trim().split(/\s+/g);
            this._hasInitialValues = true;
        }
        /**
         * Appends all styling-related expressions to the provided attrs array.
         *
         * @param attrs an existing array where each of the styling expressions
         * will be inserted into.
         */
        populateInitialStylingAttrs(attrs) {
            // [CLASS_MARKER, 'foo', 'bar', 'baz' ...]
            if (this._initialClassValues.length) {
                attrs.push(literal(1 /* Classes */));
                for (let i = 0; i < this._initialClassValues.length; i++) {
                    attrs.push(literal(this._initialClassValues[i]));
                }
            }
            // [STYLE_MARKER, 'width', '200px', 'height', '100px', ...]
            if (this._initialStyleValues.length) {
                attrs.push(literal(2 /* Styles */));
                for (let i = 0; i < this._initialStyleValues.length; i += 2) {
                    attrs.push(literal(this._initialStyleValues[i]), literal(this._initialStyleValues[i + 1]));
                }
            }
        }
        /**
         * Builds an instruction with all the expressions and parameters for `elementHostAttrs`.
         *
         * The instruction generation code below is used for producing the AOT statement code which is
         * responsible for registering initial styles (within a directive hostBindings' creation block),
         * as well as any of the provided attribute values, to the directive host element.
         */
        assignHostAttrs(attrs, definitionMap) {
            if (this._directiveExpr && (attrs.length || this._hasInitialValues)) {
                this.populateInitialStylingAttrs(attrs);
                definitionMap.set('hostAttrs', literalArr(attrs));
            }
        }
        /**
         * Builds an instruction with all the expressions and parameters for `classMap`.
         *
         * The instruction data will contain all expressions for `classMap` to function
         * which includes the `[class]` expression params.
         */
        buildClassMapInstruction(valueConverter) {
            if (this._classMapInput) {
                return this._buildMapBasedInstruction(valueConverter, true, this._classMapInput);
            }
            return null;
        }
        /**
         * Builds an instruction with all the expressions and parameters for `styleMap`.
         *
         * The instruction data will contain all expressions for `styleMap` to function
         * which includes the `[style]` expression params.
         */
        buildStyleMapInstruction(valueConverter) {
            if (this._styleMapInput) {
                return this._buildMapBasedInstruction(valueConverter, false, this._styleMapInput);
            }
            return null;
        }
        _buildMapBasedInstruction(valueConverter, isClassBased, stylingInput) {
            // each styling binding value is stored in the LView
            // map-based bindings allocate two slots: one for the
            // previous binding value and another for the previous
            // className or style attribute value.
            let totalBindingSlotsRequired = MIN_STYLING_BINDING_SLOTS_REQUIRED;
            // these values must be outside of the update block so that they can
            // be evaluated (the AST visit call) during creation time so that any
            // pipes can be picked up in time before the template is built
            const mapValue = stylingInput.value.visit(valueConverter);
            let reference;
            if (mapValue instanceof Interpolation) {
                totalBindingSlotsRequired += mapValue.expressions.length;
                reference = isClassBased ? getClassMapInterpolationExpression(mapValue) :
                    getStyleMapInterpolationExpression(mapValue);
            }
            else {
                reference = isClassBased ? Identifiers.classMap : Identifiers.styleMap;
            }
            return {
                reference,
                calls: [{
                        supportsInterpolation: true,
                        sourceSpan: stylingInput.sourceSpan,
                        allocateBindingSlots: totalBindingSlotsRequired,
                        params: (convertFn) => {
                            const convertResult = convertFn(mapValue);
                            const params = Array.isArray(convertResult) ? convertResult : [convertResult];
                            return params;
                        }
                    }]
            };
        }
        _buildSingleInputs(reference, inputs, valueConverter, getInterpolationExpressionFn, isClassBased) {
            const instructions = [];
            inputs.forEach(input => {
                const previousInstruction = instructions[instructions.length - 1];
                const value = input.value.visit(valueConverter);
                let referenceForCall = reference;
                // each styling binding value is stored in the LView
                // but there are two values stored for each binding:
                //   1) the value itself
                //   2) an intermediate value (concatenation of style up to this point).
                //      We need to store the intermediate value so that we don't allocate
                //      the strings on each CD.
                let totalBindingSlotsRequired = MIN_STYLING_BINDING_SLOTS_REQUIRED;
                if (value instanceof Interpolation) {
                    totalBindingSlotsRequired += value.expressions.length;
                    if (getInterpolationExpressionFn) {
                        referenceForCall = getInterpolationExpressionFn(value);
                    }
                }
                const call = {
                    sourceSpan: input.sourceSpan,
                    allocateBindingSlots: totalBindingSlotsRequired,
                    supportsInterpolation: !!getInterpolationExpressionFn,
                    params: (convertFn) => {
                        // params => stylingProp(propName, value, suffix)
                        const params = [];
                        params.push(literal(input.name));
                        const convertResult = convertFn(value);
                        if (Array.isArray(convertResult)) {
                            params.push(...convertResult);
                        }
                        else {
                            params.push(convertResult);
                        }
                        // [style.prop] bindings may use suffix values (e.g. px, em, etc...), therefore,
                        // if that is detected then we need to pass that in as an optional param.
                        if (!isClassBased && input.suffix !== null) {
                            params.push(literal(input.suffix));
                        }
                        return params;
                    }
                };
                // If we ended up generating a call to the same instruction as the previous styling property
                // we can chain the calls together safely to save some bytes, otherwise we have to generate
                // a separate instruction call. This is primarily a concern with interpolation instructions
                // where we may start off with one `reference`, but end up using another based on the
                // number of interpolations.
                if (previousInstruction && previousInstruction.reference === referenceForCall) {
                    previousInstruction.calls.push(call);
                }
                else {
                    instructions.push({ reference: referenceForCall, calls: [call] });
                }
            });
            return instructions;
        }
        _buildClassInputs(valueConverter) {
            if (this._singleClassInputs) {
                return this._buildSingleInputs(Identifiers.classProp, this._singleClassInputs, valueConverter, null, true);
            }
            return [];
        }
        _buildStyleInputs(valueConverter) {
            if (this._singleStyleInputs) {
                return this._buildSingleInputs(Identifiers.styleProp, this._singleStyleInputs, valueConverter, getStylePropInterpolationExpression, false);
            }
            return [];
        }
        /**
         * Constructs all instructions which contain the expressions that will be placed
         * into the update block of a template function or a directive hostBindings function.
         */
        buildUpdateLevelInstructions(valueConverter) {
            const instructions = [];
            if (this.hasBindings) {
                const styleMapInstruction = this.buildStyleMapInstruction(valueConverter);
                if (styleMapInstruction) {
                    instructions.push(styleMapInstruction);
                }
                const classMapInstruction = this.buildClassMapInstruction(valueConverter);
                if (classMapInstruction) {
                    instructions.push(classMapInstruction);
                }
                instructions.push(...this._buildStyleInputs(valueConverter));
                instructions.push(...this._buildClassInputs(valueConverter));
            }
            return instructions;
        }
    }
    function registerIntoMap(map, key) {
        if (!map.has(key)) {
            map.set(key, map.size);
        }
    }
    function parseProperty(name) {
        let hasOverrideFlag = false;
        const overrideIndex = name.indexOf(IMPORTANT_FLAG);
        if (overrideIndex !== -1) {
            name = overrideIndex > 0 ? name.substring(0, overrideIndex) : '';
            hasOverrideFlag = true;
        }
        let suffix = null;
        let property = name;
        const unitIndex = name.lastIndexOf('.');
        if (unitIndex > 0) {
            suffix = name.substr(unitIndex + 1);
            property = name.substring(0, unitIndex);
        }
        return { property, suffix, hasOverrideFlag };
    }
    /**
     * Gets the instruction to generate for an interpolated class map.
     * @param interpolation An Interpolation AST
     */
    function getClassMapInterpolationExpression(interpolation) {
        switch (getInterpolationArgsLength(interpolation)) {
            case 1:
                return Identifiers.classMap;
            case 3:
                return Identifiers.classMapInterpolate1;
            case 5:
                return Identifiers.classMapInterpolate2;
            case 7:
                return Identifiers.classMapInterpolate3;
            case 9:
                return Identifiers.classMapInterpolate4;
            case 11:
                return Identifiers.classMapInterpolate5;
            case 13:
                return Identifiers.classMapInterpolate6;
            case 15:
                return Identifiers.classMapInterpolate7;
            case 17:
                return Identifiers.classMapInterpolate8;
            default:
                return Identifiers.classMapInterpolateV;
        }
    }
    /**
     * Gets the instruction to generate for an interpolated style map.
     * @param interpolation An Interpolation AST
     */
    function getStyleMapInterpolationExpression(interpolation) {
        switch (getInterpolationArgsLength(interpolation)) {
            case 1:
                return Identifiers.styleMap;
            case 3:
                return Identifiers.styleMapInterpolate1;
            case 5:
                return Identifiers.styleMapInterpolate2;
            case 7:
                return Identifiers.styleMapInterpolate3;
            case 9:
                return Identifiers.styleMapInterpolate4;
            case 11:
                return Identifiers.styleMapInterpolate5;
            case 13:
                return Identifiers.styleMapInterpolate6;
            case 15:
                return Identifiers.styleMapInterpolate7;
            case 17:
                return Identifiers.styleMapInterpolate8;
            default:
                return Identifiers.styleMapInterpolateV;
        }
    }
    /**
     * Gets the instruction to generate for an interpolated style prop.
     * @param interpolation An Interpolation AST
     */
    function getStylePropInterpolationExpression(interpolation) {
        switch (getInterpolationArgsLength(interpolation)) {
            case 1:
                return Identifiers.styleProp;
            case 3:
                return Identifiers.stylePropInterpolate1;
            case 5:
                return Identifiers.stylePropInterpolate2;
            case 7:
                return Identifiers.stylePropInterpolate3;
            case 9:
                return Identifiers.stylePropInterpolate4;
            case 11:
                return Identifiers.stylePropInterpolate5;
            case 13:
                return Identifiers.stylePropInterpolate6;
            case 15:
                return Identifiers.stylePropInterpolate7;
            case 17:
                return Identifiers.stylePropInterpolate8;
            default:
                return Identifiers.stylePropInterpolateV;
        }
    }
    /**
     * Checks whether property name is a custom CSS property.
     * See: https://www.w3.org/TR/css-variables-1
     */
    function isCssCustomProperty(name) {
        return name.startsWith('--');
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var TokenType;
    (function (TokenType) {
        TokenType[TokenType["Character"] = 0] = "Character";
        TokenType[TokenType["Identifier"] = 1] = "Identifier";
        TokenType[TokenType["PrivateIdentifier"] = 2] = "PrivateIdentifier";
        TokenType[TokenType["Keyword"] = 3] = "Keyword";
        TokenType[TokenType["String"] = 4] = "String";
        TokenType[TokenType["Operator"] = 5] = "Operator";
        TokenType[TokenType["Number"] = 6] = "Number";
        TokenType[TokenType["Error"] = 7] = "Error";
    })(TokenType || (TokenType = {}));
    const KEYWORDS = ['var', 'let', 'as', 'null', 'undefined', 'true', 'false', 'if', 'else', 'this'];
    class Lexer {
        tokenize(text) {
            const scanner = new _Scanner(text);
            const tokens = [];
            let token = scanner.scanToken();
            while (token != null) {
                tokens.push(token);
                token = scanner.scanToken();
            }
            return tokens;
        }
    }
    class Token {
        constructor(index, end, type, numValue, strValue) {
            this.index = index;
            this.end = end;
            this.type = type;
            this.numValue = numValue;
            this.strValue = strValue;
        }
        isCharacter(code) {
            return this.type == TokenType.Character && this.numValue == code;
        }
        isNumber() {
            return this.type == TokenType.Number;
        }
        isString() {
            return this.type == TokenType.String;
        }
        isOperator(operator) {
            return this.type == TokenType.Operator && this.strValue == operator;
        }
        isIdentifier() {
            return this.type == TokenType.Identifier;
        }
        isPrivateIdentifier() {
            return this.type == TokenType.PrivateIdentifier;
        }
        isKeyword() {
            return this.type == TokenType.Keyword;
        }
        isKeywordLet() {
            return this.type == TokenType.Keyword && this.strValue == 'let';
        }
        isKeywordAs() {
            return this.type == TokenType.Keyword && this.strValue == 'as';
        }
        isKeywordNull() {
            return this.type == TokenType.Keyword && this.strValue == 'null';
        }
        isKeywordUndefined() {
            return this.type == TokenType.Keyword && this.strValue == 'undefined';
        }
        isKeywordTrue() {
            return this.type == TokenType.Keyword && this.strValue == 'true';
        }
        isKeywordFalse() {
            return this.type == TokenType.Keyword && this.strValue == 'false';
        }
        isKeywordThis() {
            return this.type == TokenType.Keyword && this.strValue == 'this';
        }
        isError() {
            return this.type == TokenType.Error;
        }
        toNumber() {
            return this.type == TokenType.Number ? this.numValue : -1;
        }
        toString() {
            switch (this.type) {
                case TokenType.Character:
                case TokenType.Identifier:
                case TokenType.Keyword:
                case TokenType.Operator:
                case TokenType.PrivateIdentifier:
                case TokenType.String:
                case TokenType.Error:
                    return this.strValue;
                case TokenType.Number:
                    return this.numValue.toString();
                default:
                    return null;
            }
        }
    }
    function newCharacterToken(index, end, code) {
        return new Token(index, end, TokenType.Character, code, String.fromCharCode(code));
    }
    function newIdentifierToken(index, end, text) {
        return new Token(index, end, TokenType.Identifier, 0, text);
    }
    function newPrivateIdentifierToken(index, end, text) {
        return new Token(index, end, TokenType.PrivateIdentifier, 0, text);
    }
    function newKeywordToken(index, end, text) {
        return new Token(index, end, TokenType.Keyword, 0, text);
    }
    function newOperatorToken(index, end, text) {
        return new Token(index, end, TokenType.Operator, 0, text);
    }
    function newStringToken(index, end, text) {
        return new Token(index, end, TokenType.String, 0, text);
    }
    function newNumberToken(index, end, n) {
        return new Token(index, end, TokenType.Number, n, '');
    }
    function newErrorToken(index, end, message) {
        return new Token(index, end, TokenType.Error, 0, message);
    }
    const EOF = new Token(-1, -1, TokenType.Character, 0, '');
    class _Scanner {
        constructor(input) {
            this.input = input;
            this.peek = 0;
            this.index = -1;
            this.length = input.length;
            this.advance();
        }
        advance() {
            this.peek = ++this.index >= this.length ? $EOF : this.input.charCodeAt(this.index);
        }
        scanToken() {
            const input = this.input, length = this.length;
            let peek = this.peek, index = this.index;
            // Skip whitespace.
            while (peek <= $SPACE) {
                if (++index >= length) {
                    peek = $EOF;
                    break;
                }
                else {
                    peek = input.charCodeAt(index);
                }
            }
            this.peek = peek;
            this.index = index;
            if (index >= length) {
                return null;
            }
            // Handle identifiers and numbers.
            if (isIdentifierStart(peek))
                return this.scanIdentifier();
            if (isDigit(peek))
                return this.scanNumber(index);
            const start = index;
            switch (peek) {
                case $PERIOD:
                    this.advance();
                    return isDigit(this.peek) ? this.scanNumber(start) :
                        newCharacterToken(start, this.index, $PERIOD);
                case $LPAREN:
                case $RPAREN:
                case $LBRACE:
                case $RBRACE:
                case $LBRACKET:
                case $RBRACKET:
                case $COMMA:
                case $COLON:
                case $SEMICOLON:
                    return this.scanCharacter(start, peek);
                case $SQ:
                case $DQ:
                    return this.scanString();
                case $HASH:
                    return this.scanPrivateIdentifier();
                case $PLUS:
                case $MINUS:
                case $STAR:
                case $SLASH:
                case $PERCENT:
                case $CARET:
                    return this.scanOperator(start, String.fromCharCode(peek));
                case $QUESTION:
                    return this.scanQuestion(start);
                case $LT:
                case $GT:
                    return this.scanComplexOperator(start, String.fromCharCode(peek), $EQ, '=');
                case $BANG:
                case $EQ:
                    return this.scanComplexOperator(start, String.fromCharCode(peek), $EQ, '=', $EQ, '=');
                case $AMPERSAND:
                    return this.scanComplexOperator(start, '&', $AMPERSAND, '&');
                case $BAR:
                    return this.scanComplexOperator(start, '|', $BAR, '|');
                case $NBSP:
                    while (isWhitespace(this.peek))
                        this.advance();
                    return this.scanToken();
            }
            this.advance();
            return this.error(`Unexpected character [${String.fromCharCode(peek)}]`, 0);
        }
        scanCharacter(start, code) {
            this.advance();
            return newCharacterToken(start, this.index, code);
        }
        scanOperator(start, str) {
            this.advance();
            return newOperatorToken(start, this.index, str);
        }
        /**
         * Tokenize a 2/3 char long operator
         *
         * @param start start index in the expression
         * @param one first symbol (always part of the operator)
         * @param twoCode code point for the second symbol
         * @param two second symbol (part of the operator when the second code point matches)
         * @param threeCode code point for the third symbol
         * @param three third symbol (part of the operator when provided and matches source expression)
         */
        scanComplexOperator(start, one, twoCode, two, threeCode, three) {
            this.advance();
            let str = one;
            if (this.peek == twoCode) {
                this.advance();
                str += two;
            }
            if (threeCode != null && this.peek == threeCode) {
                this.advance();
                str += three;
            }
            return newOperatorToken(start, this.index, str);
        }
        scanIdentifier() {
            const start = this.index;
            this.advance();
            while (isIdentifierPart(this.peek))
                this.advance();
            const str = this.input.substring(start, this.index);
            return KEYWORDS.indexOf(str) > -1 ? newKeywordToken(start, this.index, str) :
                newIdentifierToken(start, this.index, str);
        }
        /** Scans an ECMAScript private identifier. */
        scanPrivateIdentifier() {
            const start = this.index;
            this.advance();
            if (!isIdentifierStart(this.peek)) {
                return this.error('Invalid character [#]', -1);
            }
            while (isIdentifierPart(this.peek))
                this.advance();
            const identifierName = this.input.substring(start, this.index);
            return newPrivateIdentifierToken(start, this.index, identifierName);
        }
        scanNumber(start) {
            let simple = (this.index === start);
            let hasSeparators = false;
            this.advance(); // Skip initial digit.
            while (true) {
                if (isDigit(this.peek)) ;
                else if (this.peek === $_) {
                    // Separators are only valid when they're surrounded by digits. E.g. `1_0_1` is
                    // valid while `_101` and `101_` are not. The separator can't be next to the decimal
                    // point or another separator either. Note that it's unlikely that we'll hit a case where
                    // the underscore is at the start, because that's a valid identifier and it will be picked
                    // up earlier in the parsing. We validate for it anyway just in case.
                    if (!isDigit(this.input.charCodeAt(this.index - 1)) ||
                        !isDigit(this.input.charCodeAt(this.index + 1))) {
                        return this.error('Invalid numeric separator', 0);
                    }
                    hasSeparators = true;
                }
                else if (this.peek === $PERIOD) {
                    simple = false;
                }
                else if (isExponentStart(this.peek)) {
                    this.advance();
                    if (isExponentSign(this.peek))
                        this.advance();
                    if (!isDigit(this.peek))
                        return this.error('Invalid exponent', -1);
                    simple = false;
                }
                else {
                    break;
                }
                this.advance();
            }
            let str = this.input.substring(start, this.index);
            if (hasSeparators) {
                str = str.replace(/_/g, '');
            }
            const value = simple ? parseIntAutoRadix(str) : parseFloat(str);
            return newNumberToken(start, this.index, value);
        }
        scanString() {
            const start = this.index;
            const quote = this.peek;
            this.advance(); // Skip initial quote.
            let buffer = '';
            let marker = this.index;
            const input = this.input;
            while (this.peek != quote) {
                if (this.peek == $BACKSLASH) {
                    buffer += input.substring(marker, this.index);
                    this.advance();
                    let unescapedCode;
                    // Workaround for TS2.1-introduced type strictness
                    this.peek = this.peek;
                    if (this.peek == $u) {
                        // 4 character hex code for unicode character.
                        const hex = input.substring(this.index + 1, this.index + 5);
                        if (/^[0-9a-f]+$/i.test(hex)) {
                            unescapedCode = parseInt(hex, 16);
                        }
                        else {
                            return this.error(`Invalid unicode escape [\\u${hex}]`, 0);
                        }
                        for (let i = 0; i < 5; i++) {
                            this.advance();
                        }
                    }
                    else {
                        unescapedCode = unescape(this.peek);
                        this.advance();
                    }
                    buffer += String.fromCharCode(unescapedCode);
                    marker = this.index;
                }
                else if (this.peek == $EOF) {
                    return this.error('Unterminated quote', 0);
                }
                else {
                    this.advance();
                }
            }
            const last = input.substring(marker, this.index);
            this.advance(); // Skip terminating quote.
            return newStringToken(start, this.index, buffer + last);
        }
        scanQuestion(start) {
            this.advance();
            let str = '?';
            // Either `a ?? b` or 'a?.b'.
            if (this.peek === $QUESTION || this.peek === $PERIOD) {
                str += this.peek === $PERIOD ? '.' : '?';
                this.advance();
            }
            return newOperatorToken(start, this.index, str);
        }
        error(message, offset) {
            const position = this.index + offset;
            return newErrorToken(position, this.index, `Lexer Error: ${message} at column ${position} in expression [${this.input}]`);
        }
    }
    function isIdentifierStart(code) {
        return ($a <= code && code <= $z) || ($A <= code && code <= $Z) ||
            (code == $_) || (code == $$);
    }
    function isIdentifier(input) {
        if (input.length == 0)
            return false;
        const scanner = new _Scanner(input);
        if (!isIdentifierStart(scanner.peek))
            return false;
        scanner.advance();
        while (scanner.peek !== $EOF) {
            if (!isIdentifierPart(scanner.peek))
                return false;
            scanner.advance();
        }
        return true;
    }
    function isIdentifierPart(code) {
        return isAsciiLetter(code) || isDigit(code) || (code == $_) ||
            (code == $$);
    }
    function isExponentStart(code) {
        return code == $e || code == $E;
    }
    function isExponentSign(code) {
        return code == $MINUS || code == $PLUS;
    }
    function unescape(code) {
        switch (code) {
            case $n:
                return $LF;
            case $f:
                return $FF;
            case $r:
                return $CR;
            case $t:
                return $TAB;
            case $v:
                return $VTAB;
            default:
                return code;
        }
    }
    function parseIntAutoRadix(text) {
        const result = parseInt(text);
        if (isNaN(result)) {
            throw new Error('Invalid integer literal when parsing ' + text);
        }
        return result;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class SplitInterpolation {
        constructor(strings, expressions, offsets) {
            this.strings = strings;
            this.expressions = expressions;
            this.offsets = offsets;
        }
    }
    class TemplateBindingParseResult {
        constructor(templateBindings, warnings, errors) {
            this.templateBindings = templateBindings;
            this.warnings = warnings;
            this.errors = errors;
        }
    }
    class Parser$1 {
        constructor(_lexer) {
            this._lexer = _lexer;
            this.errors = [];
            this.simpleExpressionChecker = SimpleExpressionChecker;
        }
        parseAction(input, location, absoluteOffset, interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {
            this._checkNoInterpolation(input, location, interpolationConfig);
            const sourceToLex = this._stripComments(input);
            const tokens = this._lexer.tokenize(this._stripComments(input));
            const ast = new _ParseAST(input, location, absoluteOffset, tokens, sourceToLex.length, true, this.errors, input.length - sourceToLex.length)
                .parseChain();
            return new ASTWithSource(ast, input, location, absoluteOffset, this.errors);
        }
        parseBinding(input, location, absoluteOffset, interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {
            const ast = this._parseBindingAst(input, location, absoluteOffset, interpolationConfig);
            return new ASTWithSource(ast, input, location, absoluteOffset, this.errors);
        }
        checkSimpleExpression(ast) {
            const checker = new this.simpleExpressionChecker();
            ast.visit(checker);
            return checker.errors;
        }
        parseSimpleBinding(input, location, absoluteOffset, interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {
            const ast = this._parseBindingAst(input, location, absoluteOffset, interpolationConfig);
            const errors = this.checkSimpleExpression(ast);
            if (errors.length > 0) {
                this._reportError(`Host binding expression cannot contain ${errors.join(' ')}`, input, location);
            }
            return new ASTWithSource(ast, input, location, absoluteOffset, this.errors);
        }
        _reportError(message, input, errLocation, ctxLocation) {
            this.errors.push(new ParserError(message, input, errLocation, ctxLocation));
        }
        _parseBindingAst(input, location, absoluteOffset, interpolationConfig) {
            // Quotes expressions use 3rd-party expression language. We don't want to use
            // our lexer or parser for that, so we check for that ahead of time.
            const quote = this._parseQuote(input, location, absoluteOffset);
            if (quote != null) {
                return quote;
            }
            this._checkNoInterpolation(input, location, interpolationConfig);
            const sourceToLex = this._stripComments(input);
            const tokens = this._lexer.tokenize(sourceToLex);
            return new _ParseAST(input, location, absoluteOffset, tokens, sourceToLex.length, false, this.errors, input.length - sourceToLex.length)
                .parseChain();
        }
        _parseQuote(input, location, absoluteOffset) {
            if (input == null)
                return null;
            const prefixSeparatorIndex = input.indexOf(':');
            if (prefixSeparatorIndex == -1)
                return null;
            const prefix = input.substring(0, prefixSeparatorIndex).trim();
            if (!isIdentifier(prefix))
                return null;
            const uninterpretedExpression = input.substring(prefixSeparatorIndex + 1);
            const span = new ParseSpan(0, input.length);
            return new Quote(span, span.toAbsolute(absoluteOffset), prefix, uninterpretedExpression, location);
        }
        /**
         * Parse microsyntax template expression and return a list of bindings or
         * parsing errors in case the given expression is invalid.
         *
         * For example,
         * ```
         *   <div *ngFor="let item of items">
         *         ^      ^ absoluteValueOffset for `templateValue`
         *         absoluteKeyOffset for `templateKey`
         * ```
         * contains three bindings:
         * 1. ngFor -> null
         * 2. item -> NgForOfContext.$implicit
         * 3. ngForOf -> items
         *
         * This is apparent from the de-sugared template:
         * ```
         *   <ng-template ngFor let-item [ngForOf]="items">
         * ```
         *
         * @param templateKey name of directive, without the * prefix. For example: ngIf, ngFor
         * @param templateValue RHS of the microsyntax attribute
         * @param templateUrl template filename if it's external, component filename if it's inline
         * @param absoluteKeyOffset start of the `templateKey`
         * @param absoluteValueOffset start of the `templateValue`
         */
        parseTemplateBindings(templateKey, templateValue, templateUrl, absoluteKeyOffset, absoluteValueOffset) {
            const tokens = this._lexer.tokenize(templateValue);
            const parser = new _ParseAST(templateValue, templateUrl, absoluteValueOffset, tokens, templateValue.length, false /* parseAction */, this.errors, 0 /* relative offset */);
            return parser.parseTemplateBindings({
                source: templateKey,
                span: new AbsoluteSourceSpan(absoluteKeyOffset, absoluteKeyOffset + templateKey.length),
            });
        }
        parseInterpolation(input, location, absoluteOffset, interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {
            const { strings, expressions, offsets } = this.splitInterpolation(input, location, interpolationConfig);
            if (expressions.length === 0)
                return null;
            const expressionNodes = [];
            for (let i = 0; i < expressions.length; ++i) {
                const expressionText = expressions[i].text;
                const sourceToLex = this._stripComments(expressionText);
                const tokens = this._lexer.tokenize(sourceToLex);
                const ast = new _ParseAST(input, location, absoluteOffset, tokens, sourceToLex.length, false, this.errors, offsets[i] + (expressionText.length - sourceToLex.length))
                    .parseChain();
                expressionNodes.push(ast);
            }
            return this.createInterpolationAst(strings.map(s => s.text), expressionNodes, input, location, absoluteOffset);
        }
        /**
         * Similar to `parseInterpolation`, but treats the provided string as a single expression
         * element that would normally appear within the interpolation prefix and suffix (`{{` and `}}`).
         * This is used for parsing the switch expression in ICUs.
         */
        parseInterpolationExpression(expression, location, absoluteOffset) {
            const sourceToLex = this._stripComments(expression);
            const tokens = this._lexer.tokenize(sourceToLex);
            const ast = new _ParseAST(expression, location, absoluteOffset, tokens, sourceToLex.length, 
            /* parseAction */ false, this.errors, 0)
                .parseChain();
            const strings = ['', '']; // The prefix and suffix strings are both empty
            return this.createInterpolationAst(strings, [ast], expression, location, absoluteOffset);
        }
        createInterpolationAst(strings, expressions, input, location, absoluteOffset) {
            const span = new ParseSpan(0, input.length);
            const interpolation = new Interpolation(span, span.toAbsolute(absoluteOffset), strings, expressions);
            return new ASTWithSource(interpolation, input, location, absoluteOffset, this.errors);
        }
        /**
         * Splits a string of text into "raw" text segments and expressions present in interpolations in
         * the string.
         * Returns `null` if there are no interpolations, otherwise a
         * `SplitInterpolation` with splits that look like
         *   <raw text> <expression> <raw text> ... <raw text> <expression> <raw text>
         */
        splitInterpolation(input, location, interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {
            const strings = [];
            const expressions = [];
            const offsets = [];
            let i = 0;
            let atInterpolation = false;
            let extendLastString = false;
            let { start: interpStart, end: interpEnd } = interpolationConfig;
            while (i < input.length) {
                if (!atInterpolation) {
                    // parse until starting {{
                    const start = i;
                    i = input.indexOf(interpStart, i);
                    if (i === -1) {
                        i = input.length;
                    }
                    const text = input.substring(start, i);
                    strings.push({ text, start, end: i });
                    atInterpolation = true;
                }
                else {
                    // parse from starting {{ to ending }} while ignoring content inside quotes.
                    const fullStart = i;
                    const exprStart = fullStart + interpStart.length;
                    const exprEnd = this._getInterpolationEndIndex(input, interpEnd, exprStart);
                    if (exprEnd === -1) {
                        // Could not find the end of the interpolation; do not parse an expression.
                        // Instead we should extend the content on the last raw string.
                        atInterpolation = false;
                        extendLastString = true;
                        break;
                    }
                    const fullEnd = exprEnd + interpEnd.length;
                    const text = input.substring(exprStart, exprEnd);
                    if (text.trim().length === 0) {
                        this._reportError('Blank expressions are not allowed in interpolated strings', input, `at column ${i} in`, location);
                    }
                    expressions.push({ text, start: fullStart, end: fullEnd });
                    offsets.push(exprStart);
                    i = fullEnd;
                    atInterpolation = false;
                }
            }
            if (!atInterpolation) {
                // If we are now at a text section, add the remaining content as a raw string.
                if (extendLastString) {
                    const piece = strings[strings.length - 1];
                    piece.text += input.substring(i);
                    piece.end = input.length;
                }
                else {
                    strings.push({ text: input.substring(i), start: i, end: input.length });
                }
            }
            return new SplitInterpolation(strings, expressions, offsets);
        }
        wrapLiteralPrimitive(input, location, absoluteOffset) {
            const span = new ParseSpan(0, input == null ? 0 : input.length);
            return new ASTWithSource(new LiteralPrimitive(span, span.toAbsolute(absoluteOffset), input), input, location, absoluteOffset, this.errors);
        }
        _stripComments(input) {
            const i = this._commentStart(input);
            return i != null ? input.substring(0, i).trim() : input;
        }
        _commentStart(input) {
            let outerQuote = null;
            for (let i = 0; i < input.length - 1; i++) {
                const char = input.charCodeAt(i);
                const nextChar = input.charCodeAt(i + 1);
                if (char === $SLASH && nextChar == $SLASH && outerQuote == null)
                    return i;
                if (outerQuote === char) {
                    outerQuote = null;
                }
                else if (outerQuote == null && isQuote(char)) {
                    outerQuote = char;
                }
            }
            return null;
        }
        _checkNoInterpolation(input, location, { start, end }) {
            let startIndex = -1;
            let endIndex = -1;
            for (const charIndex of this._forEachUnquotedChar(input, 0)) {
                if (startIndex === -1) {
                    if (input.startsWith(start)) {
                        startIndex = charIndex;
                    }
                }
                else {
                    endIndex = this._getInterpolationEndIndex(input, end, charIndex);
                    if (endIndex > -1) {
                        break;
                    }
                }
            }
            if (startIndex > -1 && endIndex > -1) {
                this._reportError(`Got interpolation (${start}${end}) where expression was expected`, input, `at column ${startIndex} in`, location);
            }
        }
        /**
         * Finds the index of the end of an interpolation expression
         * while ignoring comments and quoted content.
         */
        _getInterpolationEndIndex(input, expressionEnd, start) {
            for (const charIndex of this._forEachUnquotedChar(input, start)) {
                if (input.startsWith(expressionEnd, charIndex)) {
                    return charIndex;
                }
                // Nothing else in the expression matters after we've
                // hit a comment so look directly for the end token.
                if (input.startsWith('//', charIndex)) {
                    return input.indexOf(expressionEnd, charIndex);
                }
            }
            return -1;
        }
        /**
         * Generator used to iterate over the character indexes of a string that are outside of quotes.
         * @param input String to loop through.
         * @param start Index within the string at which to start.
         */
        *_forEachUnquotedChar(input, start) {
            let currentQuote = null;
            let escapeCount = 0;
            for (let i = start; i < input.length; i++) {
                const char = input[i];
                // Skip the characters inside quotes. Note that we only care about the outer-most
                // quotes matching up and we need to account for escape characters.
                if (isQuote(input.charCodeAt(i)) && (currentQuote === null || currentQuote === char) &&
                    escapeCount % 2 === 0) {
                    currentQuote = currentQuote === null ? char : null;
                }
                else if (currentQuote === null) {
                    yield i;
                }
                escapeCount = char === '\\' ? escapeCount + 1 : 0;
            }
        }
    }
    class IvyParser extends Parser$1 {
        constructor() {
            super(...arguments);
            this.simpleExpressionChecker = IvySimpleExpressionChecker;
        }
    }
    /** Describes a stateful context an expression parser is in. */
    var ParseContextFlags;
    (function (ParseContextFlags) {
        ParseContextFlags[ParseContextFlags["None"] = 0] = "None";
        /**
         * A Writable context is one in which a value may be written to an lvalue.
         * For example, after we see a property access, we may expect a write to the
         * property via the "=" operator.
         *   prop
         *        ^ possible "=" after
         */
        ParseContextFlags[ParseContextFlags["Writable"] = 1] = "Writable";
    })(ParseContextFlags || (ParseContextFlags = {}));
    class _ParseAST {
        constructor(input, location, absoluteOffset, tokens, inputLength, parseAction, errors, offset) {
            this.input = input;
            this.location = location;
            this.absoluteOffset = absoluteOffset;
            this.tokens = tokens;
            this.inputLength = inputLength;
            this.parseAction = parseAction;
            this.errors = errors;
            this.offset = offset;
            this.rparensExpected = 0;
            this.rbracketsExpected = 0;
            this.rbracesExpected = 0;
            this.context = ParseContextFlags.None;
            // Cache of expression start and input indeces to the absolute source span they map to, used to
            // prevent creating superfluous source spans in `sourceSpan`.
            // A serial of the expression start and input index is used for mapping because both are stateful
            // and may change for subsequent expressions visited by the parser.
            this.sourceSpanCache = new Map();
            this.index = 0;
        }
        peek(offset) {
            const i = this.index + offset;
            return i < this.tokens.length ? this.tokens[i] : EOF;
        }
        get next() {
            return this.peek(0);
        }
        /** Whether all the parser input has been processed. */
        get atEOF() {
            return this.index >= this.tokens.length;
        }
        /**
         * Index of the next token to be processed, or the end of the last token if all have been
         * processed.
         */
        get inputIndex() {
            return this.atEOF ? this.currentEndIndex : this.next.index + this.offset;
        }
        /**
         * End index of the last processed token, or the start of the first token if none have been
         * processed.
         */
        get currentEndIndex() {
            if (this.index > 0) {
                const curToken = this.peek(-1);
                return curToken.end + this.offset;
            }
            // No tokens have been processed yet; return the next token's start or the length of the input
            // if there is no token.
            if (this.tokens.length === 0) {
                return this.inputLength + this.offset;
            }
            return this.next.index + this.offset;
        }
        /**
         * Returns the absolute offset of the start of the current token.
         */
        get currentAbsoluteOffset() {
            return this.absoluteOffset + this.inputIndex;
        }
        /**
         * Retrieve a `ParseSpan` from `start` to the current position (or to `artificialEndIndex` if
         * provided).
         *
         * @param start Position from which the `ParseSpan` will start.
         * @param artificialEndIndex Optional ending index to be used if provided (and if greater than the
         *     natural ending index)
         */
        span(start, artificialEndIndex) {
            let endIndex = this.currentEndIndex;
            if (artificialEndIndex !== undefined && artificialEndIndex > this.currentEndIndex) {
                endIndex = artificialEndIndex;
            }
            // In some unusual parsing scenarios (like when certain tokens are missing and an `EmptyExpr` is
            // being created), the current token may already be advanced beyond the `currentEndIndex`. This
            // appears to be a deep-seated parser bug.
            //
            // As a workaround for now, swap the start and end indices to ensure a valid `ParseSpan`.
            // TODO(alxhub): fix the bug upstream in the parser state, and remove this workaround.
            if (start > endIndex) {
                const tmp = endIndex;
                endIndex = start;
                start = tmp;
            }
            return new ParseSpan(start, endIndex);
        }
        sourceSpan(start, artificialEndIndex) {
            const serial = `${start}@${this.inputIndex}:${artificialEndIndex}`;
            if (!this.sourceSpanCache.has(serial)) {
                this.sourceSpanCache.set(serial, this.span(start, artificialEndIndex).toAbsolute(this.absoluteOffset));
            }
            return this.sourceSpanCache.get(serial);
        }
        advance() {
            this.index++;
        }
        /**
         * Executes a callback in the provided context.
         */
        withContext(context, cb) {
            this.context |= context;
            const ret = cb();
            this.context ^= context;
            return ret;
        }
        consumeOptionalCharacter(code) {
            if (this.next.isCharacter(code)) {
                this.advance();
                return true;
            }
            else {
                return false;
            }
        }
        peekKeywordLet() {
            return this.next.isKeywordLet();
        }
        peekKeywordAs() {
            return this.next.isKeywordAs();
        }
        /**
         * Consumes an expected character, otherwise emits an error about the missing expected character
         * and skips over the token stream until reaching a recoverable point.
         *
         * See `this.error` and `this.skip` for more details.
         */
        expectCharacter(code) {
            if (this.consumeOptionalCharacter(code))
                return;
            this.error(`Missing expected ${String.fromCharCode(code)}`);
        }
        consumeOptionalOperator(op) {
            if (this.next.isOperator(op)) {
                this.advance();
                return true;
            }
            else {
                return false;
            }
        }
        expectOperator(operator) {
            if (this.consumeOptionalOperator(operator))
                return;
            this.error(`Missing expected operator ${operator}`);
        }
        prettyPrintToken(tok) {
            return tok === EOF ? 'end of input' : `token ${tok}`;
        }
        expectIdentifierOrKeyword() {
            const n = this.next;
            if (!n.isIdentifier() && !n.isKeyword()) {
                if (n.isPrivateIdentifier()) {
                    this._reportErrorForPrivateIdentifier(n, 'expected identifier or keyword');
                }
                else {
                    this.error(`Unexpected ${this.prettyPrintToken(n)}, expected identifier or keyword`);
                }
                return null;
            }
            this.advance();
            return n.toString();
        }
        expectIdentifierOrKeywordOrString() {
            const n = this.next;
            if (!n.isIdentifier() && !n.isKeyword() && !n.isString()) {
                if (n.isPrivateIdentifier()) {
                    this._reportErrorForPrivateIdentifier(n, 'expected identifier, keyword or string');
                }
                else {
                    this.error(`Unexpected ${this.prettyPrintToken(n)}, expected identifier, keyword, or string`);
                }
                return '';
            }
            this.advance();
            return n.toString();
        }
        parseChain() {
            const exprs = [];
            const start = this.inputIndex;
            while (this.index < this.tokens.length) {
                const expr = this.parsePipe();
                exprs.push(expr);
                if (this.consumeOptionalCharacter($SEMICOLON)) {
                    if (!this.parseAction) {
                        this.error('Binding expression cannot contain chained expression');
                    }
                    while (this.consumeOptionalCharacter($SEMICOLON)) {
                    } // read all semicolons
                }
                else if (this.index < this.tokens.length) {
                    this.error(`Unexpected token '${this.next}'`);
                }
            }
            if (exprs.length == 0) {
                // We have no expressions so create an empty expression that spans the entire input length
                const artificialStart = this.offset;
                const artificialEnd = this.offset + this.inputLength;
                return new EmptyExpr(this.span(artificialStart, artificialEnd), this.sourceSpan(artificialStart, artificialEnd));
            }
            if (exprs.length == 1)
                return exprs[0];
            return new Chain(this.span(start), this.sourceSpan(start), exprs);
        }
        parsePipe() {
            const start = this.inputIndex;
            let result = this.parseExpression();
            if (this.consumeOptionalOperator('|')) {
                if (this.parseAction) {
                    this.error('Cannot have a pipe in an action expression');
                }
                do {
                    const nameStart = this.inputIndex;
                    let nameId = this.expectIdentifierOrKeyword();
                    let nameSpan;
                    let fullSpanEnd = undefined;
                    if (nameId !== null) {
                        nameSpan = this.sourceSpan(nameStart);
                    }
                    else {
                        // No valid identifier was found, so we'll assume an empty pipe name ('').
                        nameId = '';
                        // However, there may have been whitespace present between the pipe character and the next
                        // token in the sequence (or the end of input). We want to track this whitespace so that
                        // the `BindingPipe` we produce covers not just the pipe character, but any trailing
                        // whitespace beyond it. Another way of thinking about this is that the zero-length name
                        // is assumed to be at the end of any whitespace beyond the pipe character.
                        //
                        // Therefore, we push the end of the `ParseSpan` for this pipe all the way up to the
                        // beginning of the next token, or until the end of input if the next token is EOF.
                        fullSpanEnd = this.next.index !== -1 ? this.next.index : this.inputLength + this.offset;
                        // The `nameSpan` for an empty pipe name is zero-length at the end of any whitespace
                        // beyond the pipe character.
                        nameSpan = new ParseSpan(fullSpanEnd, fullSpanEnd).toAbsolute(this.absoluteOffset);
                    }
                    const args = [];
                    while (this.consumeOptionalCharacter($COLON)) {
                        args.push(this.parseExpression());
                        // If there are additional expressions beyond the name, then the artificial end for the
                        // name is no longer relevant.
                    }
                    result = new BindingPipe(this.span(start), this.sourceSpan(start, fullSpanEnd), result, nameId, args, nameSpan);
                } while (this.consumeOptionalOperator('|'));
            }
            return result;
        }
        parseExpression() {
            return this.parseConditional();
        }
        parseConditional() {
            const start = this.inputIndex;
            const result = this.parseLogicalOr();
            if (this.consumeOptionalOperator('?')) {
                const yes = this.parsePipe();
                let no;
                if (!this.consumeOptionalCharacter($COLON)) {
                    const end = this.inputIndex;
                    const expression = this.input.substring(start, end);
                    this.error(`Conditional expression ${expression} requires all 3 expressions`);
                    no = new EmptyExpr(this.span(start), this.sourceSpan(start));
                }
                else {
                    no = this.parsePipe();
                }
                return new Conditional(this.span(start), this.sourceSpan(start), result, yes, no);
            }
            else {
                return result;
            }
        }
        parseLogicalOr() {
            // '||'
            const start = this.inputIndex;
            let result = this.parseLogicalAnd();
            while (this.consumeOptionalOperator('||')) {
                const right = this.parseLogicalAnd();
                result = new Binary(this.span(start), this.sourceSpan(start), '||', result, right);
            }
            return result;
        }
        parseLogicalAnd() {
            // '&&'
            const start = this.inputIndex;
            let result = this.parseNullishCoalescing();
            while (this.consumeOptionalOperator('&&')) {
                const right = this.parseNullishCoalescing();
                result = new Binary(this.span(start), this.sourceSpan(start), '&&', result, right);
            }
            return result;
        }
        parseNullishCoalescing() {
            // '??'
            const start = this.inputIndex;
            let result = this.parseEquality();
            while (this.consumeOptionalOperator('??')) {
                const right = this.parseEquality();
                result = new Binary(this.span(start), this.sourceSpan(start), '??', result, right);
            }
            return result;
        }
        parseEquality() {
            // '==','!=','===','!=='
            const start = this.inputIndex;
            let result = this.parseRelational();
            while (this.next.type == TokenType.Operator) {
                const operator = this.next.strValue;
                switch (operator) {
                    case '==':
                    case '===':
                    case '!=':
                    case '!==':
                        this.advance();
                        const right = this.parseRelational();
                        result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);
                        continue;
                }
                break;
            }
            return result;
        }
        parseRelational() {
            // '<', '>', '<=', '>='
            const start = this.inputIndex;
            let result = this.parseAdditive();
            while (this.next.type == TokenType.Operator) {
                const operator = this.next.strValue;
                switch (operator) {
                    case '<':
                    case '>':
                    case '<=':
                    case '>=':
                        this.advance();
                        const right = this.parseAdditive();
                        result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);
                        continue;
                }
                break;
            }
            return result;
        }
        parseAdditive() {
            // '+', '-'
            const start = this.inputIndex;
            let result = this.parseMultiplicative();
            while (this.next.type == TokenType.Operator) {
                const operator = this.next.strValue;
                switch (operator) {
                    case '+':
                    case '-':
                        this.advance();
                        let right = this.parseMultiplicative();
                        result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);
                        continue;
                }
                break;
            }
            return result;
        }
        parseMultiplicative() {
            // '*', '%', '/'
            const start = this.inputIndex;
            let result = this.parsePrefix();
            while (this.next.type == TokenType.Operator) {
                const operator = this.next.strValue;
                switch (operator) {
                    case '*':
                    case '%':
                    case '/':
                        this.advance();
                        let right = this.parsePrefix();
                        result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);
                        continue;
                }
                break;
            }
            return result;
        }
        parsePrefix() {
            if (this.next.type == TokenType.Operator) {
                const start = this.inputIndex;
                const operator = this.next.strValue;
                let result;
                switch (operator) {
                    case '+':
                        this.advance();
                        result = this.parsePrefix();
                        return Unary.createPlus(this.span(start), this.sourceSpan(start), result);
                    case '-':
                        this.advance();
                        result = this.parsePrefix();
                        return Unary.createMinus(this.span(start), this.sourceSpan(start), result);
                    case '!':
                        this.advance();
                        result = this.parsePrefix();
                        return new PrefixNot(this.span(start), this.sourceSpan(start), result);
                }
            }
            return this.parseCallChain();
        }
        parseCallChain() {
            const start = this.inputIndex;
            let result = this.parsePrimary();
            while (true) {
                if (this.consumeOptionalCharacter($PERIOD)) {
                    result = this.parseAccessMemberOrMethodCall(result, start, false);
                }
                else if (this.consumeOptionalOperator('?.')) {
                    result = this.consumeOptionalCharacter($LBRACKET) ?
                        this.parseKeyedReadOrWrite(result, start, true) :
                        this.parseAccessMemberOrMethodCall(result, start, true);
                }
                else if (this.consumeOptionalCharacter($LBRACKET)) {
                    result = this.parseKeyedReadOrWrite(result, start, false);
                }
                else if (this.consumeOptionalCharacter($LPAREN)) {
                    this.rparensExpected++;
                    const args = this.parseCallArguments();
                    this.rparensExpected--;
                    this.expectCharacter($RPAREN);
                    result = new FunctionCall(this.span(start), this.sourceSpan(start), result, args);
                }
                else if (this.consumeOptionalOperator('!')) {
                    result = new NonNullAssert(this.span(start), this.sourceSpan(start), result);
                }
                else {
                    return result;
                }
            }
        }
        parsePrimary() {
            const start = this.inputIndex;
            if (this.consumeOptionalCharacter($LPAREN)) {
                this.rparensExpected++;
                const result = this.parsePipe();
                this.rparensExpected--;
                this.expectCharacter($RPAREN);
                return result;
            }
            else if (this.next.isKeywordNull()) {
                this.advance();
                return new LiteralPrimitive(this.span(start), this.sourceSpan(start), null);
            }
            else if (this.next.isKeywordUndefined()) {
                this.advance();
                return new LiteralPrimitive(this.span(start), this.sourceSpan(start), void 0);
            }
            else if (this.next.isKeywordTrue()) {
                this.advance();
                return new LiteralPrimitive(this.span(start), this.sourceSpan(start), true);
            }
            else if (this.next.isKeywordFalse()) {
                this.advance();
                return new LiteralPrimitive(this.span(start), this.sourceSpan(start), false);
            }
            else if (this.next.isKeywordThis()) {
                this.advance();
                return new ThisReceiver(this.span(start), this.sourceSpan(start));
            }
            else if (this.consumeOptionalCharacter($LBRACKET)) {
                this.rbracketsExpected++;
                const elements = this.parseExpressionList($RBRACKET);
                this.rbracketsExpected--;
                this.expectCharacter($RBRACKET);
                return new LiteralArray(this.span(start), this.sourceSpan(start), elements);
            }
            else if (this.next.isCharacter($LBRACE)) {
                return this.parseLiteralMap();
            }
            else if (this.next.isIdentifier()) {
                return this.parseAccessMemberOrMethodCall(new ImplicitReceiver(this.span(start), this.sourceSpan(start)), start, false);
            }
            else if (this.next.isNumber()) {
                const value = this.next.toNumber();
                this.advance();
                return new LiteralPrimitive(this.span(start), this.sourceSpan(start), value);
            }
            else if (this.next.isString()) {
                const literalValue = this.next.toString();
                this.advance();
                return new LiteralPrimitive(this.span(start), this.sourceSpan(start), literalValue);
            }
            else if (this.next.isPrivateIdentifier()) {
                this._reportErrorForPrivateIdentifier(this.next, null);
                return new EmptyExpr(this.span(start), this.sourceSpan(start));
            }
            else if (this.index >= this.tokens.length) {
                this.error(`Unexpected end of expression: ${this.input}`);
                return new EmptyExpr(this.span(start), this.sourceSpan(start));
            }
            else {
                this.error(`Unexpected token ${this.next}`);
                return new EmptyExpr(this.span(start), this.sourceSpan(start));
            }
        }
        parseExpressionList(terminator) {
            const result = [];
            do {
                if (!this.next.isCharacter(terminator)) {
                    result.push(this.parsePipe());
                }
                else {
                    break;
                }
            } while (this.consumeOptionalCharacter($COMMA));
            return result;
        }
        parseLiteralMap() {
            const keys = [];
            const values = [];
            const start = this.inputIndex;
            this.expectCharacter($LBRACE);
            if (!this.consumeOptionalCharacter($RBRACE)) {
                this.rbracesExpected++;
                do {
                    const keyStart = this.inputIndex;
                    const quoted = this.next.isString();
                    const key = this.expectIdentifierOrKeywordOrString();
                    keys.push({ key, quoted });
                    // Properties with quoted keys can't use the shorthand syntax.
                    if (quoted) {
                        this.expectCharacter($COLON);
                        values.push(this.parsePipe());
                    }
                    else if (this.consumeOptionalCharacter($COLON)) {
                        values.push(this.parsePipe());
                    }
                    else {
                        const span = this.span(keyStart);
                        const sourceSpan = this.sourceSpan(keyStart);
                        values.push(new PropertyRead(span, sourceSpan, sourceSpan, new ImplicitReceiver(span, sourceSpan), key));
                    }
                } while (this.consumeOptionalCharacter($COMMA));
                this.rbracesExpected--;
                this.expectCharacter($RBRACE);
            }
            return new LiteralMap(this.span(start), this.sourceSpan(start), keys, values);
        }
        parseAccessMemberOrMethodCall(receiver, start, isSafe) {
            const nameStart = this.inputIndex;
            const id = this.withContext(ParseContextFlags.Writable, () => {
                var _a;
                const id = (_a = this.expectIdentifierOrKeyword()) !== null && _a !== void 0 ? _a : '';
                if (id.length === 0) {
                    this.error(`Expected identifier for property access`, receiver.span.end);
                }
                return id;
            });
            const nameSpan = this.sourceSpan(nameStart);
            if (this.consumeOptionalCharacter($LPAREN)) {
                const argumentStart = this.inputIndex;
                this.rparensExpected++;
                const args = this.parseCallArguments();
                const argumentSpan = this.span(argumentStart, this.inputIndex).toAbsolute(this.absoluteOffset);
                this.expectCharacter($RPAREN);
                this.rparensExpected--;
                const span = this.span(start);
                const sourceSpan = this.sourceSpan(start);
                return isSafe ?
                    new SafeMethodCall(span, sourceSpan, nameSpan, receiver, id, args, argumentSpan) :
                    new MethodCall(span, sourceSpan, nameSpan, receiver, id, args, argumentSpan);
            }
            else {
                if (isSafe) {
                    if (this.consumeOptionalOperator('=')) {
                        this.error('The \'?.\' operator cannot be used in the assignment');
                        return new EmptyExpr(this.span(start), this.sourceSpan(start));
                    }
                    else {
                        return new SafePropertyRead(this.span(start), this.sourceSpan(start), nameSpan, receiver, id);
                    }
                }
                else {
                    if (this.consumeOptionalOperator('=')) {
                        if (!this.parseAction) {
                            this.error('Bindings cannot contain assignments');
                            return new EmptyExpr(this.span(start), this.sourceSpan(start));
                        }
                        const value = this.parseConditional();
                        return new PropertyWrite(this.span(start), this.sourceSpan(start), nameSpan, receiver, id, value);
                    }
                    else {
                        return new PropertyRead(this.span(start), this.sourceSpan(start), nameSpan, receiver, id);
                    }
                }
            }
        }
        parseCallArguments() {
            if (this.next.isCharacter($RPAREN))
                return [];
            const positionals = [];
            do {
                positionals.push(this.parsePipe());
            } while (this.consumeOptionalCharacter($COMMA));
            return positionals;
        }
        /**
         * Parses an identifier, a keyword, a string with an optional `-` in between,
         * and returns the string along with its absolute source span.
         */
        expectTemplateBindingKey() {
            let result = '';
            let operatorFound = false;
            const start = this.currentAbsoluteOffset;
            do {
                result += this.expectIdentifierOrKeywordOrString();
                operatorFound = this.consumeOptionalOperator('-');
                if (operatorFound) {
                    result += '-';
                }
            } while (operatorFound);
            return {
                source: result,
                span: new AbsoluteSourceSpan(start, start + result.length),
            };
        }
        /**
         * Parse microsyntax template expression and return a list of bindings or
         * parsing errors in case the given expression is invalid.
         *
         * For example,
         * ```
         *   <div *ngFor="let item of items; index as i; trackBy: func">
         * ```
         * contains five bindings:
         * 1. ngFor -> null
         * 2. item -> NgForOfContext.$implicit
         * 3. ngForOf -> items
         * 4. i -> NgForOfContext.index
         * 5. ngForTrackBy -> func
         *
         * For a full description of the microsyntax grammar, see
         * https://gist.github.com/mhevery/d3530294cff2e4a1b3fe15ff75d08855
         *
         * @param templateKey name of the microsyntax directive, like ngIf, ngFor,
         * without the *, along with its absolute span.
         */
        parseTemplateBindings(templateKey) {
            const bindings = [];
            // The first binding is for the template key itself
            // In *ngFor="let item of items", key = "ngFor", value = null
            // In *ngIf="cond | pipe", key = "ngIf", value = "cond | pipe"
            bindings.push(...this.parseDirectiveKeywordBindings(templateKey));
            while (this.index < this.tokens.length) {
                // If it starts with 'let', then this must be variable declaration
                const letBinding = this.parseLetBinding();
                if (letBinding) {
                    bindings.push(letBinding);
                }
                else {
                    // Two possible cases here, either `value "as" key` or
                    // "directive-keyword expression". We don't know which case, but both
                    // "value" and "directive-keyword" are template binding key, so consume
                    // the key first.
                    const key = this.expectTemplateBindingKey();
                    // Peek at the next token, if it is "as" then this must be variable
                    // declaration.
                    const binding = this.parseAsBinding(key);
                    if (binding) {
                        bindings.push(binding);
                    }
                    else {
                        // Otherwise the key must be a directive keyword, like "of". Transform
                        // the key to actual key. Eg. of -> ngForOf, trackBy -> ngForTrackBy
                        key.source =
                            templateKey.source + key.source.charAt(0).toUpperCase() + key.source.substring(1);
                        bindings.push(...this.parseDirectiveKeywordBindings(key));
                    }
                }
                this.consumeStatementTerminator();
            }
            return new TemplateBindingParseResult(bindings, [] /* warnings */, this.errors);
        }
        parseKeyedReadOrWrite(receiver, start, isSafe) {
            return this.withContext(ParseContextFlags.Writable, () => {
                this.rbracketsExpected++;
                const key = this.parsePipe();
                if (key instanceof EmptyExpr) {
                    this.error(`Key access cannot be empty`);
                }
                this.rbracketsExpected--;
                this.expectCharacter($RBRACKET);
                if (this.consumeOptionalOperator('=')) {
                    if (isSafe) {
                        this.error('The \'?.\' operator cannot be used in the assignment');
                    }
                    else {
                        const value = this.parseConditional();
                        return new KeyedWrite(this.span(start), this.sourceSpan(start), receiver, key, value);
                    }
                }
                else {
                    return isSafe ? new SafeKeyedRead(this.span(start), this.sourceSpan(start), receiver, key) :
                        new KeyedRead(this.span(start), this.sourceSpan(start), receiver, key);
                }
                return new EmptyExpr(this.span(start), this.sourceSpan(start));
            });
        }
        /**
         * Parse a directive keyword, followed by a mandatory expression.
         * For example, "of items", "trackBy: func".
         * The bindings are: ngForOf -> items, ngForTrackBy -> func
         * There could be an optional "as" binding that follows the expression.
         * For example,
         * ```
         *   *ngFor="let item of items | slice:0:1 as collection".
         *                    ^^ ^^^^^^^^^^^^^^^^^ ^^^^^^^^^^^^^
         *               keyword    bound target   optional 'as' binding
         * ```
         *
         * @param key binding key, for example, ngFor, ngIf, ngForOf, along with its
         * absolute span.
         */
        parseDirectiveKeywordBindings(key) {
            const bindings = [];
            this.consumeOptionalCharacter($COLON); // trackBy: trackByFunction
            const value = this.getDirectiveBoundTarget();
            let spanEnd = this.currentAbsoluteOffset;
            // The binding could optionally be followed by "as". For example,
            // *ngIf="cond | pipe as x". In this case, the key in the "as" binding
            // is "x" and the value is the template key itself ("ngIf"). Note that the
            // 'key' in the current context now becomes the "value" in the next binding.
            const asBinding = this.parseAsBinding(key);
            if (!asBinding) {
                this.consumeStatementTerminator();
                spanEnd = this.currentAbsoluteOffset;
            }
            const sourceSpan = new AbsoluteSourceSpan(key.span.start, spanEnd);
            bindings.push(new ExpressionBinding(sourceSpan, key, value));
            if (asBinding) {
                bindings.push(asBinding);
            }
            return bindings;
        }
        /**
         * Return the expression AST for the bound target of a directive keyword
         * binding. For example,
         * ```
         *   *ngIf="condition | pipe"
         *          ^^^^^^^^^^^^^^^^ bound target for "ngIf"
         *   *ngFor="let item of items"
         *                       ^^^^^ bound target for "ngForOf"
         * ```
         */
        getDirectiveBoundTarget() {
            if (this.next === EOF || this.peekKeywordAs() || this.peekKeywordLet()) {
                return null;
            }
            const ast = this.parsePipe(); // example: "condition | async"
            const { start, end } = ast.span;
            const value = this.input.substring(start, end);
            return new ASTWithSource(ast, value, this.location, this.absoluteOffset + start, this.errors);
        }
        /**
         * Return the binding for a variable declared using `as`. Note that the order
         * of the key-value pair in this declaration is reversed. For example,
         * ```
         *   *ngFor="let item of items; index as i"
         *                              ^^^^^    ^
         *                              value    key
         * ```
         *
         * @param value name of the value in the declaration, "ngIf" in the example
         * above, along with its absolute span.
         */
        parseAsBinding(value) {
            if (!this.peekKeywordAs()) {
                return null;
            }
            this.advance(); // consume the 'as' keyword
            const key = this.expectTemplateBindingKey();
            this.consumeStatementTerminator();
            const sourceSpan = new AbsoluteSourceSpan(value.span.start, this.currentAbsoluteOffset);
            return new VariableBinding(sourceSpan, key, value);
        }
        /**
         * Return the binding for a variable declared using `let`. For example,
         * ```
         *   *ngFor="let item of items; let i=index;"
         *           ^^^^^^^^           ^^^^^^^^^^^
         * ```
         * In the first binding, `item` is bound to `NgForOfContext.$implicit`.
         * In the second binding, `i` is bound to `NgForOfContext.index`.
         */
        parseLetBinding() {
            if (!this.peekKeywordLet()) {
                return null;
            }
            const spanStart = this.currentAbsoluteOffset;
            this.advance(); // consume the 'let' keyword
            const key = this.expectTemplateBindingKey();
            let value = null;
            if (this.consumeOptionalOperator('=')) {
                value = this.expectTemplateBindingKey();
            }
            this.consumeStatementTerminator();
            const sourceSpan = new AbsoluteSourceSpan(spanStart, this.currentAbsoluteOffset);
            return new VariableBinding(sourceSpan, key, value);
        }
        /**
         * Consume the optional statement terminator: semicolon or comma.
         */
        consumeStatementTerminator() {
            this.consumeOptionalCharacter($SEMICOLON) || this.consumeOptionalCharacter($COMMA);
        }
        /**
         * Records an error and skips over the token stream until reaching a recoverable point. See
         * `this.skip` for more details on token skipping.
         */
        error(message, index = null) {
            this.errors.push(new ParserError(message, this.input, this.locationText(index), this.location));
            this.skip();
        }
        locationText(index = null) {
            if (index == null)
                index = this.index;
            return (index < this.tokens.length) ? `at column ${this.tokens[index].index + 1} in` :
                `at the end of the expression`;
        }
        /**
         * Records an error for an unexpected private identifier being discovered.
         * @param token Token representing a private identifier.
         * @param extraMessage Optional additional message being appended to the error.
         */
        _reportErrorForPrivateIdentifier(token, extraMessage) {
            let errorMessage = `Private identifiers are not supported. Unexpected private identifier: ${token}`;
            if (extraMessage !== null) {
                errorMessage += `, ${extraMessage}`;
            }
            this.error(errorMessage);
        }
        /**
         * Error recovery should skip tokens until it encounters a recovery point.
         *
         * The following are treated as unconditional recovery points:
         *   - end of input
         *   - ';' (parseChain() is always the root production, and it expects a ';')
         *   - '|' (since pipes may be chained and each pipe expression may be treated independently)
         *
         * The following are conditional recovery points:
         *   - ')', '}', ']' if one of calling productions is expecting one of these symbols
         *     - This allows skip() to recover from errors such as '(a.) + 1' allowing more of the AST to
         *       be retained (it doesn't skip any tokens as the ')' is retained because of the '(' begins
         *       an '(' <expr> ')' production).
         *       The recovery points of grouping symbols must be conditional as they must be skipped if
         *       none of the calling productions are not expecting the closing token else we will never
         *       make progress in the case of an extraneous group closing symbol (such as a stray ')').
         *       That is, we skip a closing symbol if we are not in a grouping production.
         *   - '=' in a `Writable` context
         *     - In this context, we are able to recover after seeing the `=` operator, which
         *       signals the presence of an independent rvalue expression following the `=` operator.
         *
         * If a production expects one of these token it increments the corresponding nesting count,
         * and then decrements it just prior to checking if the token is in the input.
         */
        skip() {
            let n = this.next;
            while (this.index < this.tokens.length && !n.isCharacter($SEMICOLON) &&
                !n.isOperator('|') && (this.rparensExpected <= 0 || !n.isCharacter($RPAREN)) &&
                (this.rbracesExpected <= 0 || !n.isCharacter($RBRACE)) &&
                (this.rbracketsExpected <= 0 || !n.isCharacter($RBRACKET)) &&
                (!(this.context & ParseContextFlags.Writable) || !n.isOperator('='))) {
                if (this.next.isError()) {
                    this.errors.push(new ParserError(this.next.toString(), this.input, this.locationText(), this.location));
                }
                this.advance();
                n = this.next;
            }
        }
    }
    class SimpleExpressionChecker {
        constructor() {
            this.errors = [];
        }
        visitImplicitReceiver(ast, context) { }
        visitThisReceiver(ast, context) { }
        visitInterpolation(ast, context) { }
        visitLiteralPrimitive(ast, context) { }
        visitPropertyRead(ast, context) { }
        visitPropertyWrite(ast, context) { }
        visitSafePropertyRead(ast, context) { }
        visitMethodCall(ast, context) { }
        visitSafeMethodCall(ast, context) { }
        visitFunctionCall(ast, context) { }
        visitLiteralArray(ast, context) {
            this.visitAll(ast.expressions, context);
        }
        visitLiteralMap(ast, context) {
            this.visitAll(ast.values, context);
        }
        visitUnary(ast, context) { }
        visitBinary(ast, context) { }
        visitPrefixNot(ast, context) { }
        visitNonNullAssert(ast, context) { }
        visitConditional(ast, context) { }
        visitPipe(ast, context) {
            this.errors.push('pipes');
        }
        visitKeyedRead(ast, context) { }
        visitKeyedWrite(ast, context) { }
        visitAll(asts, context) {
            return asts.map(node => node.visit(this, context));
        }
        visitChain(ast, context) { }
        visitQuote(ast, context) { }
        visitSafeKeyedRead(ast, context) { }
    }
    /**
     * This class implements SimpleExpressionChecker used in View Engine and performs more strict checks
     * to make sure host bindings do not contain pipes. In View Engine, having pipes in host bindings is
     * not supported as well, but in some cases (like `!(value | async)`) the error is not triggered at
     * compile time. In order to preserve View Engine behavior, more strict checks are introduced for
     * Ivy mode only.
     */
    class IvySimpleExpressionChecker extends RecursiveAstVisitor {
        constructor() {
            super(...arguments);
            this.errors = [];
        }
        visitPipe() {
            this.errors.push('pipes');
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function mapLiteral(obj, quoted = false) {
        return literalMap(Object.keys(obj).map(key => ({
            key,
            quoted,
            value: obj[key],
        })));
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    // =================================================================================================
    // =================================================================================================
    // =========== S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P  ===========
    // =================================================================================================
    // =================================================================================================
    //
    //        DO NOT EDIT THIS LIST OF SECURITY SENSITIVE PROPERTIES WITHOUT A SECURITY REVIEW!
    //                               Reach out to mprobst for details.
    //
    // =================================================================================================
    /** Map from tagName|propertyName to SecurityContext. Properties applying to all tags use '*'. */
    let _SECURITY_SCHEMA;
    function SECURITY_SCHEMA() {
        if (!_SECURITY_SCHEMA) {
            _SECURITY_SCHEMA = {};
            // Case is insignificant below, all element and attribute names are lower-cased for lookup.
            registerContext(SecurityContext.HTML, [
                'iframe|srcdoc',
                '*|innerHTML',
                '*|outerHTML',
            ]);
            registerContext(SecurityContext.STYLE, ['*|style']);
            // NB: no SCRIPT contexts here, they are never allowed due to the parser stripping them.
            registerContext(SecurityContext.URL, [
                '*|formAction', 'area|href', 'area|ping', 'audio|src', 'a|href',
                'a|ping', 'blockquote|cite', 'body|background', 'del|cite', 'form|action',
                'img|src', 'img|srcset', 'input|src', 'ins|cite', 'q|cite',
                'source|src', 'source|srcset', 'track|src', 'video|poster', 'video|src',
            ]);
            registerContext(SecurityContext.RESOURCE_URL, [
                'applet|code',
                'applet|codebase',
                'base|href',
                'embed|src',
                'frame|src',
                'head|profile',
                'html|manifest',
                'iframe|src',
                'link|href',
                'media|src',
                'object|codebase',
                'object|data',
                'script|src',
            ]);
        }
        return _SECURITY_SCHEMA;
    }
    function registerContext(ctx, specs) {
        for (const spec of specs)
            _SECURITY_SCHEMA[spec.toLowerCase()] = ctx;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class ElementSchemaRegistry {
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const BOOLEAN = 'boolean';
    const NUMBER = 'number';
    const STRING = 'string';
    const OBJECT = 'object';
    /**
     * This array represents the DOM schema. It encodes inheritance, properties, and events.
     *
     * ## Overview
     *
     * Each line represents one kind of element. The `element_inheritance` and properties are joined
     * using `element_inheritance|properties` syntax.
     *
     * ## Element Inheritance
     *
     * The `element_inheritance` can be further subdivided as `element1,element2,...^parentElement`.
     * Here the individual elements are separated by `,` (commas). Every element in the list
     * has identical properties.
     *
     * An `element` may inherit additional properties from `parentElement` If no `^parentElement` is
     * specified then `""` (blank) element is assumed.
     *
     * NOTE: The blank element inherits from root `[Element]` element, the super element of all
     * elements.
     *
     * NOTE an element prefix such as `:svg:` has no special meaning to the schema.
     *
     * ## Properties
     *
     * Each element has a set of properties separated by `,` (commas). Each property can be prefixed
     * by a special character designating its type:
     *
     * - (no prefix): property is a string.
     * - `*`: property represents an event.
     * - `!`: property is a boolean.
     * - `#`: property is a number.
     * - `%`: property is an object.
     *
     * ## Query
     *
     * The class creates an internal squas representation which allows to easily answer the query of
     * if a given property exist on a given element.
     *
     * NOTE: We don't yet support querying for types or events.
     * NOTE: This schema is auto extracted from `schema_extractor.ts` located in the test folder,
     *       see dom_element_schema_registry_spec.ts
     */
    // =================================================================================================
    // =================================================================================================
    // =========== S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P  ===========
    // =================================================================================================
    // =================================================================================================
    //
    //                       DO NOT EDIT THIS DOM SCHEMA WITHOUT A SECURITY REVIEW!
    //
    // Newly added properties must be security reviewed and assigned an appropriate SecurityContext in
    // dom_security_schema.ts. Reach out to mprobst & rjamet for details.
    //
    // =================================================================================================
    const SCHEMA = [
        '[Element]|textContent,%classList,className,id,innerHTML,*beforecopy,*beforecut,*beforepaste,*copy,*cut,*paste,*search,*selectstart,*webkitfullscreenchange,*webkitfullscreenerror,*wheel,outerHTML,#scrollLeft,#scrollTop,slot' +
            /* added manually to avoid breaking changes */
            ',*message,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored',
        '[HTMLElement]^[Element]|accessKey,contentEditable,dir,!draggable,!hidden,innerText,lang,*abort,*auxclick,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,outerText,!spellcheck,%style,#tabIndex,title,!translate',
        'abbr,address,article,aside,b,bdi,bdo,cite,code,dd,dfn,dt,em,figcaption,figure,footer,header,i,kbd,main,mark,nav,noscript,rb,rp,rt,rtc,ruby,s,samp,section,small,strong,sub,sup,u,var,wbr^[HTMLElement]|accessKey,contentEditable,dir,!draggable,!hidden,innerText,lang,*abort,*auxclick,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,outerText,!spellcheck,%style,#tabIndex,title,!translate',
        'media^[HTMLElement]|!autoplay,!controls,%controlsList,%crossOrigin,#currentTime,!defaultMuted,#defaultPlaybackRate,!disableRemotePlayback,!loop,!muted,*encrypted,*waitingforkey,#playbackRate,preload,src,%srcObject,#volume',
        ':svg:^[HTMLElement]|*abort,*auxclick,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,%style,#tabIndex',
        ':svg:graphics^:svg:|',
        ':svg:animation^:svg:|*begin,*end,*repeat',
        ':svg:geometry^:svg:|',
        ':svg:componentTransferFunction^:svg:|',
        ':svg:gradient^:svg:|',
        ':svg:textContent^:svg:graphics|',
        ':svg:textPositioning^:svg:textContent|',
        'a^[HTMLElement]|charset,coords,download,hash,host,hostname,href,hreflang,name,password,pathname,ping,port,protocol,referrerPolicy,rel,rev,search,shape,target,text,type,username',
        'area^[HTMLElement]|alt,coords,download,hash,host,hostname,href,!noHref,password,pathname,ping,port,protocol,referrerPolicy,rel,search,shape,target,username',
        'audio^media|',
        'br^[HTMLElement]|clear',
        'base^[HTMLElement]|href,target',
        'body^[HTMLElement]|aLink,background,bgColor,link,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,text,vLink',
        'button^[HTMLElement]|!autofocus,!disabled,formAction,formEnctype,formMethod,!formNoValidate,formTarget,name,type,value',
        'canvas^[HTMLElement]|#height,#width',
        'content^[HTMLElement]|select',
        'dl^[HTMLElement]|!compact',
        'datalist^[HTMLElement]|',
        'details^[HTMLElement]|!open',
        'dialog^[HTMLElement]|!open,returnValue',
        'dir^[HTMLElement]|!compact',
        'div^[HTMLElement]|align',
        'embed^[HTMLElement]|align,height,name,src,type,width',
        'fieldset^[HTMLElement]|!disabled,name',
        'font^[HTMLElement]|color,face,size',
        'form^[HTMLElement]|acceptCharset,action,autocomplete,encoding,enctype,method,name,!noValidate,target',
        'frame^[HTMLElement]|frameBorder,longDesc,marginHeight,marginWidth,name,!noResize,scrolling,src',
        'frameset^[HTMLElement]|cols,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,rows',
        'hr^[HTMLElement]|align,color,!noShade,size,width',
        'head^[HTMLElement]|',
        'h1,h2,h3,h4,h5,h6^[HTMLElement]|align',
        'html^[HTMLElement]|version',
        'iframe^[HTMLElement]|align,!allowFullscreen,frameBorder,height,longDesc,marginHeight,marginWidth,name,referrerPolicy,%sandbox,scrolling,src,srcdoc,width',
        'img^[HTMLElement]|align,alt,border,%crossOrigin,#height,#hspace,!isMap,longDesc,lowsrc,name,referrerPolicy,sizes,src,srcset,useMap,#vspace,#width',
        'input^[HTMLElement]|accept,align,alt,autocapitalize,autocomplete,!autofocus,!checked,!defaultChecked,defaultValue,dirName,!disabled,%files,formAction,formEnctype,formMethod,!formNoValidate,formTarget,#height,!incremental,!indeterminate,max,#maxLength,min,#minLength,!multiple,name,pattern,placeholder,!readOnly,!required,selectionDirection,#selectionEnd,#selectionStart,#size,src,step,type,useMap,value,%valueAsDate,#valueAsNumber,#width',
        'li^[HTMLElement]|type,#value',
        'label^[HTMLElement]|htmlFor',
        'legend^[HTMLElement]|align',
        'link^[HTMLElement]|as,charset,%crossOrigin,!disabled,href,hreflang,integrity,media,referrerPolicy,rel,%relList,rev,%sizes,target,type',
        'map^[HTMLElement]|name',
        'marquee^[HTMLElement]|behavior,bgColor,direction,height,#hspace,#loop,#scrollAmount,#scrollDelay,!trueSpeed,#vspace,width',
        'menu^[HTMLElement]|!compact',
        'meta^[HTMLElement]|content,httpEquiv,name,scheme',
        'meter^[HTMLElement]|#high,#low,#max,#min,#optimum,#value',
        'ins,del^[HTMLElement]|cite,dateTime',
        'ol^[HTMLElement]|!compact,!reversed,#start,type',
        'object^[HTMLElement]|align,archive,border,code,codeBase,codeType,data,!declare,height,#hspace,name,standby,type,useMap,#vspace,width',
        'optgroup^[HTMLElement]|!disabled,label',
        'option^[HTMLElement]|!defaultSelected,!disabled,label,!selected,text,value',
        'output^[HTMLElement]|defaultValue,%htmlFor,name,value',
        'p^[HTMLElement]|align',
        'param^[HTMLElement]|name,type,value,valueType',
        'picture^[HTMLElement]|',
        'pre^[HTMLElement]|#width',
        'progress^[HTMLElement]|#max,#value',
        'q,blockquote,cite^[HTMLElement]|',
        'script^[HTMLElement]|!async,charset,%crossOrigin,!defer,event,htmlFor,integrity,src,text,type',
        'select^[HTMLElement]|autocomplete,!autofocus,!disabled,#length,!multiple,name,!required,#selectedIndex,#size,value',
        'shadow^[HTMLElement]|',
        'slot^[HTMLElement]|name',
        'source^[HTMLElement]|media,sizes,src,srcset,type',
        'span^[HTMLElement]|',
        'style^[HTMLElement]|!disabled,media,type',
        'caption^[HTMLElement]|align',
        'th,td^[HTMLElement]|abbr,align,axis,bgColor,ch,chOff,#colSpan,headers,height,!noWrap,#rowSpan,scope,vAlign,width',
        'col,colgroup^[HTMLElement]|align,ch,chOff,#span,vAlign,width',
        'table^[HTMLElement]|align,bgColor,border,%caption,cellPadding,cellSpacing,frame,rules,summary,%tFoot,%tHead,width',
        'tr^[HTMLElement]|align,bgColor,ch,chOff,vAlign',
        'tfoot,thead,tbody^[HTMLElement]|align,ch,chOff,vAlign',
        'template^[HTMLElement]|',
        'textarea^[HTMLElement]|autocapitalize,autocomplete,!autofocus,#cols,defaultValue,dirName,!disabled,#maxLength,#minLength,name,placeholder,!readOnly,!required,#rows,selectionDirection,#selectionEnd,#selectionStart,value,wrap',
        'title^[HTMLElement]|text',
        'track^[HTMLElement]|!default,kind,label,src,srclang',
        'ul^[HTMLElement]|!compact,type',
        'unknown^[HTMLElement]|',
        'video^media|#height,poster,#width',
        ':svg:a^:svg:graphics|',
        ':svg:animate^:svg:animation|',
        ':svg:animateMotion^:svg:animation|',
        ':svg:animateTransform^:svg:animation|',
        ':svg:circle^:svg:geometry|',
        ':svg:clipPath^:svg:graphics|',
        ':svg:defs^:svg:graphics|',
        ':svg:desc^:svg:|',
        ':svg:discard^:svg:|',
        ':svg:ellipse^:svg:geometry|',
        ':svg:feBlend^:svg:|',
        ':svg:feColorMatrix^:svg:|',
        ':svg:feComponentTransfer^:svg:|',
        ':svg:feComposite^:svg:|',
        ':svg:feConvolveMatrix^:svg:|',
        ':svg:feDiffuseLighting^:svg:|',
        ':svg:feDisplacementMap^:svg:|',
        ':svg:feDistantLight^:svg:|',
        ':svg:feDropShadow^:svg:|',
        ':svg:feFlood^:svg:|',
        ':svg:feFuncA^:svg:componentTransferFunction|',
        ':svg:feFuncB^:svg:componentTransferFunction|',
        ':svg:feFuncG^:svg:componentTransferFunction|',
        ':svg:feFuncR^:svg:componentTransferFunction|',
        ':svg:feGaussianBlur^:svg:|',
        ':svg:feImage^:svg:|',
        ':svg:feMerge^:svg:|',
        ':svg:feMergeNode^:svg:|',
        ':svg:feMorphology^:svg:|',
        ':svg:feOffset^:svg:|',
        ':svg:fePointLight^:svg:|',
        ':svg:feSpecularLighting^:svg:|',
        ':svg:feSpotLight^:svg:|',
        ':svg:feTile^:svg:|',
        ':svg:feTurbulence^:svg:|',
        ':svg:filter^:svg:|',
        ':svg:foreignObject^:svg:graphics|',
        ':svg:g^:svg:graphics|',
        ':svg:image^:svg:graphics|',
        ':svg:line^:svg:geometry|',
        ':svg:linearGradient^:svg:gradient|',
        ':svg:mpath^:svg:|',
        ':svg:marker^:svg:|',
        ':svg:mask^:svg:|',
        ':svg:metadata^:svg:|',
        ':svg:path^:svg:geometry|',
        ':svg:pattern^:svg:|',
        ':svg:polygon^:svg:geometry|',
        ':svg:polyline^:svg:geometry|',
        ':svg:radialGradient^:svg:gradient|',
        ':svg:rect^:svg:geometry|',
        ':svg:svg^:svg:graphics|#currentScale,#zoomAndPan',
        ':svg:script^:svg:|type',
        ':svg:set^:svg:animation|',
        ':svg:stop^:svg:|',
        ':svg:style^:svg:|!disabled,media,title,type',
        ':svg:switch^:svg:graphics|',
        ':svg:symbol^:svg:|',
        ':svg:tspan^:svg:textPositioning|',
        ':svg:text^:svg:textPositioning|',
        ':svg:textPath^:svg:textContent|',
        ':svg:title^:svg:|',
        ':svg:use^:svg:graphics|',
        ':svg:view^:svg:|#zoomAndPan',
        'data^[HTMLElement]|value',
        'keygen^[HTMLElement]|!autofocus,challenge,!disabled,form,keytype,name',
        'menuitem^[HTMLElement]|type,label,icon,!disabled,!checked,radiogroup,!default',
        'summary^[HTMLElement]|',
        'time^[HTMLElement]|dateTime',
        ':svg:cursor^:svg:|',
    ];
    const _ATTR_TO_PROP = {
        'class': 'className',
        'for': 'htmlFor',
        'formaction': 'formAction',
        'innerHtml': 'innerHTML',
        'readonly': 'readOnly',
        'tabindex': 'tabIndex',
    };
    // Invert _ATTR_TO_PROP.
    const _PROP_TO_ATTR = Object.keys(_ATTR_TO_PROP).reduce((inverted, attr) => {
        inverted[_ATTR_TO_PROP[attr]] = attr;
        return inverted;
    }, {});
    class DomElementSchemaRegistry extends ElementSchemaRegistry {
        constructor() {
            super();
            this._schema = {};
            SCHEMA.forEach(encodedType => {
                const type = {};
                const [strType, strProperties] = encodedType.split('|');
                const properties = strProperties.split(',');
                const [typeNames, superName] = strType.split('^');
                typeNames.split(',').forEach(tag => this._schema[tag.toLowerCase()] = type);
                const superType = superName && this._schema[superName.toLowerCase()];
                if (superType) {
                    Object.keys(superType).forEach((prop) => {
                        type[prop] = superType[prop];
                    });
                }
                properties.forEach((property) => {
                    if (property.length > 0) {
                        switch (property[0]) {
                            case '*':
                                // We don't yet support events.
                                // If ever allowing to bind to events, GO THROUGH A SECURITY REVIEW, allowing events
                                // will
                                // almost certainly introduce bad XSS vulnerabilities.
                                // type[property.substring(1)] = EVENT;
                                break;
                            case '!':
                                type[property.substring(1)] = BOOLEAN;
                                break;
                            case '#':
                                type[property.substring(1)] = NUMBER;
                                break;
                            case '%':
                                type[property.substring(1)] = OBJECT;
                                break;
                            default:
                                type[property] = STRING;
                        }
                    }
                });
            });
        }
        hasProperty(tagName, propName, schemaMetas) {
            if (schemaMetas.some((schema) => schema.name === NO_ERRORS_SCHEMA.name)) {
                return true;
            }
            if (tagName.indexOf('-') > -1) {
                if (isNgContainer(tagName) || isNgContent(tagName)) {
                    return false;
                }
                if (schemaMetas.some((schema) => schema.name === CUSTOM_ELEMENTS_SCHEMA.name)) {
                    // Can't tell now as we don't know which properties a custom element will get
                    // once it is instantiated
                    return true;
                }
            }
            const elementProperties = this._schema[tagName.toLowerCase()] || this._schema['unknown'];
            return !!elementProperties[propName];
        }
        hasElement(tagName, schemaMetas) {
            if (schemaMetas.some((schema) => schema.name === NO_ERRORS_SCHEMA.name)) {
                return true;
            }
            if (tagName.indexOf('-') > -1) {
                if (isNgContainer(tagName) || isNgContent(tagName)) {
                    return true;
                }
                if (schemaMetas.some((schema) => schema.name === CUSTOM_ELEMENTS_SCHEMA.name)) {
                    // Allow any custom elements
                    return true;
                }
            }
            return !!this._schema[tagName.toLowerCase()];
        }
        /**
         * securityContext returns the security context for the given property on the given DOM tag.
         *
         * Tag and property name are statically known and cannot change at runtime, i.e. it is not
         * possible to bind a value into a changing attribute or tag name.
         *
         * The filtering is based on a list of allowed tags|attributes. All attributes in the schema
         * above are assumed to have the 'NONE' security context, i.e. that they are safe inert
         * string values. Only specific well known attack vectors are assigned their appropriate context.
         */
        securityContext(tagName, propName, isAttribute) {
            if (isAttribute) {
                // NB: For security purposes, use the mapped property name, not the attribute name.
                propName = this.getMappedPropName(propName);
            }
            // Make sure comparisons are case insensitive, so that case differences between attribute and
            // property names do not have a security impact.
            tagName = tagName.toLowerCase();
            propName = propName.toLowerCase();
            let ctx = SECURITY_SCHEMA()[tagName + '|' + propName];
            if (ctx) {
                return ctx;
            }
            ctx = SECURITY_SCHEMA()['*|' + propName];
            return ctx ? ctx : SecurityContext.NONE;
        }
        getMappedPropName(propName) {
            return _ATTR_TO_PROP[propName] || propName;
        }
        getDefaultComponentElementName() {
            return 'ng-component';
        }
        validateProperty(name) {
            if (name.toLowerCase().startsWith('on')) {
                const msg = `Binding to event property '${name}' is disallowed for security reasons, ` +
                    `please use (${name.slice(2)})=...` +
                    `\nIf '${name}' is a directive input, make sure the directive is imported by the` +
                    ` current module.`;
                return { error: true, msg: msg };
            }
            else {
                return { error: false };
            }
        }
        validateAttribute(name) {
            if (name.toLowerCase().startsWith('on')) {
                const msg = `Binding to event attribute '${name}' is disallowed for security reasons, ` +
                    `please use (${name.slice(2)})=...`;
                return { error: true, msg: msg };
            }
            else {
                return { error: false };
            }
        }
        allKnownElementNames() {
            return Object.keys(this._schema);
        }
        allKnownAttributesOfElement(tagName) {
            const elementProperties = this._schema[tagName.toLowerCase()] || this._schema['unknown'];
            // Convert properties to attributes.
            return Object.keys(elementProperties).map(prop => { var _a; return (_a = _PROP_TO_ATTR[prop]) !== null && _a !== void 0 ? _a : prop; });
        }
        normalizeAnimationStyleProperty(propName) {
            return dashCaseToCamelCase(propName);
        }
        normalizeAnimationStyleValue(camelCaseProp, userProvidedProp, val) {
            let unit = '';
            const strVal = val.toString().trim();
            let errorMsg = null;
            if (_isPixelDimensionStyle(camelCaseProp) && val !== 0 && val !== '0') {
                if (typeof val === 'number') {
                    unit = 'px';
                }
                else {
                    const valAndSuffixMatch = val.match(/^[+-]?[\d\.]+([a-z]*)$/);
                    if (valAndSuffixMatch && valAndSuffixMatch[1].length == 0) {
                        errorMsg = `Please provide a CSS unit value for ${userProvidedProp}:${val}`;
                    }
                }
            }
            return { error: errorMsg, value: strVal + unit };
        }
    }
    function _isPixelDimensionStyle(prop) {
        switch (prop) {
            case 'width':
            case 'height':
            case 'minWidth':
            case 'minHeight':
            case 'maxWidth':
            case 'maxHeight':
            case 'left':
            case 'top':
            case 'bottom':
            case 'right':
            case 'fontSize':
            case 'outlineWidth':
            case 'outlineOffset':
            case 'paddingTop':
            case 'paddingLeft':
            case 'paddingBottom':
            case 'paddingRight':
            case 'marginTop':
            case 'marginLeft':
            case 'marginBottom':
            case 'marginRight':
            case 'borderRadius':
            case 'borderWidth':
            case 'borderTopWidth':
            case 'borderLeftWidth':
            case 'borderRightWidth':
            case 'borderBottomWidth':
            case 'textIndent':
                return true;
            default:
                return false;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Set of tagName|propertyName corresponding to Trusted Types sinks. Properties applying to all
     * tags use '*'.
     *
     * Extracted from, and should be kept in sync with
     * https://w3c.github.io/webappsec-trusted-types/dist/spec/#integrations
     */
    const TRUSTED_TYPES_SINKS = new Set([
        // NOTE: All strings in this set *must* be lowercase!
        // TrustedHTML
        'iframe|srcdoc',
        '*|innerhtml',
        '*|outerhtml',
        // NB: no TrustedScript here, as the corresponding tags are stripped by the compiler.
        // TrustedScriptURL
        'embed|src',
        'object|codebase',
        'object|data',
    ]);
    /**
     * isTrustedTypesSink returns true if the given property on the given DOM tag is a Trusted Types
     * sink. In that case, use `ElementSchemaRegistry.securityContext` to determine which particular
     * Trusted Type is required for values passed to the sink:
     * - SecurityContext.HTML corresponds to TrustedHTML
     * - SecurityContext.RESOURCE_URL corresponds to TrustedScriptURL
     */
    function isTrustedTypesSink(tagName, propName) {
        // Make sure comparisons are case insensitive, so that case differences between attribute and
        // property names do not have a security impact.
        tagName = tagName.toLowerCase();
        propName = propName.toLowerCase();
        return TRUSTED_TYPES_SINKS.has(tagName + '|' + propName) ||
            TRUSTED_TYPES_SINKS.has('*|' + propName);
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const BIND_NAME_REGEXP$1 = /^(?:(bind-)|(let-)|(ref-|#)|(on-)|(bindon-)|(@))(.*)$/;
    // Group 1 = "bind-"
    const KW_BIND_IDX$1 = 1;
    // Group 2 = "let-"
    const KW_LET_IDX$1 = 2;
    // Group 3 = "ref-/#"
    const KW_REF_IDX$1 = 3;
    // Group 4 = "on-"
    const KW_ON_IDX$1 = 4;
    // Group 5 = "bindon-"
    const KW_BINDON_IDX$1 = 5;
    // Group 6 = "@"
    const KW_AT_IDX$1 = 6;
    // Group 7 = the identifier after "bind-", "let-", "ref-/#", "on-", "bindon-" or "@"
    const IDENT_KW_IDX$1 = 7;
    const BINDING_DELIMS = {
        BANANA_BOX: { start: '[(', end: ')]' },
        PROPERTY: { start: '[', end: ']' },
        EVENT: { start: '(', end: ')' },
    };
    const TEMPLATE_ATTR_PREFIX$2 = '*';
    function htmlAstToRender3Ast(htmlNodes, bindingParser, options) {
        const transformer = new HtmlAstToIvyAst(bindingParser, options);
        const ivyNodes = visitAll$1(transformer, htmlNodes);
        // Errors might originate in either the binding parser or the html to ivy transformer
        const allErrors = bindingParser.errors.concat(transformer.errors);
        const result = {
            nodes: ivyNodes,
            errors: allErrors,
            styleUrls: transformer.styleUrls,
            styles: transformer.styles,
            ngContentSelectors: transformer.ngContentSelectors
        };
        if (options.collectCommentNodes) {
            result.commentNodes = transformer.commentNodes;
        }
        return result;
    }
    class HtmlAstToIvyAst {
        constructor(bindingParser, options) {
            this.bindingParser = bindingParser;
            this.options = options;
            this.errors = [];
            this.styles = [];
            this.styleUrls = [];
            this.ngContentSelectors = [];
            // This array will be populated if `Render3ParseOptions['collectCommentNodes']` is true
            this.commentNodes = [];
            this.inI18nBlock = false;
        }
        // HTML visitor
        visitElement(element) {
            const isI18nRootElement = isI18nRootNode(element.i18n);
            if (isI18nRootElement) {
                if (this.inI18nBlock) {
                    this.reportError('Cannot mark an element as translatable inside of a translatable section. Please remove the nested i18n marker.', element.sourceSpan);
                }
                this.inI18nBlock = true;
            }
            const preparsedElement = preparseElement(element);
            if (preparsedElement.type === PreparsedElementType.SCRIPT) {
                return null;
            }
            else if (preparsedElement.type === PreparsedElementType.STYLE) {
                const contents = textContents(element);
                if (contents !== null) {
                    this.styles.push(contents);
                }
                return null;
            }
            else if (preparsedElement.type === PreparsedElementType.STYLESHEET &&
                isStyleUrlResolvable(preparsedElement.hrefAttr)) {
                this.styleUrls.push(preparsedElement.hrefAttr);
                return null;
            }
            // Whether the element is a `<ng-template>`
            const isTemplateElement = isNgTemplate(element.name);
            const parsedProperties = [];
            const boundEvents = [];
            const variables = [];
            const references = [];
            const attributes = [];
            const i18nAttrsMeta = {};
            const templateParsedProperties = [];
            const templateVariables = [];
            // Whether the element has any *-attribute
            let elementHasInlineTemplate = false;
            for (const attribute of element.attrs) {
                let hasBinding = false;
                const normalizedName = normalizeAttributeName(attribute.name);
                // `*attr` defines template bindings
                let isTemplateBinding = false;
                if (attribute.i18n) {
                    i18nAttrsMeta[attribute.name] = attribute.i18n;
                }
                if (normalizedName.startsWith(TEMPLATE_ATTR_PREFIX$2)) {
                    // *-attributes
                    if (elementHasInlineTemplate) {
                        this.reportError(`Can't have multiple template bindings on one element. Use only one attribute prefixed with *`, attribute.sourceSpan);
                    }
                    isTemplateBinding = true;
                    elementHasInlineTemplate = true;
                    const templateValue = attribute.value;
                    const templateKey = normalizedName.substring(TEMPLATE_ATTR_PREFIX$2.length);
                    const parsedVariables = [];
                    const absoluteValueOffset = attribute.valueSpan ?
                        attribute.valueSpan.start.offset :
                        // If there is no value span the attribute does not have a value, like `attr` in
                        //`<div attr></div>`. In this case, point to one character beyond the last character of
                        // the attribute name.
                        attribute.sourceSpan.start.offset + attribute.name.length;
                    this.bindingParser.parseInlineTemplateBinding(templateKey, templateValue, attribute.sourceSpan, absoluteValueOffset, [], templateParsedProperties, parsedVariables, true /* isIvyAst */);
                    templateVariables.push(...parsedVariables.map(v => new Variable(v.name, v.value, v.sourceSpan, v.keySpan, v.valueSpan)));
                }
                else {
                    // Check for variables, events, property bindings, interpolation
                    hasBinding = this.parseAttribute(isTemplateElement, attribute, [], parsedProperties, boundEvents, variables, references);
                }
                if (!hasBinding && !isTemplateBinding) {
                    // don't include the bindings as attributes as well in the AST
                    attributes.push(this.visitAttribute(attribute));
                }
            }
            const children = visitAll$1(preparsedElement.nonBindable ? NON_BINDABLE_VISITOR$1 : this, element.children);
            let parsedElement;
            if (preparsedElement.type === PreparsedElementType.NG_CONTENT) {
                // `<ng-content>`
                if (element.children &&
                    !element.children.every((node) => isEmptyTextNode(node) || isCommentNode(node))) {
                    this.reportError(`<ng-content> element cannot have content.`, element.sourceSpan);
                }
                const selector = preparsedElement.selectAttr;
                const attrs = element.attrs.map(attr => this.visitAttribute(attr));
                parsedElement = new Content(selector, attrs, element.sourceSpan, element.i18n);
                this.ngContentSelectors.push(selector);
            }
            else if (isTemplateElement) {
                // `<ng-template>`
                const attrs = this.extractAttributes(element.name, parsedProperties, i18nAttrsMeta);
                parsedElement = new Template(element.name, attributes, attrs.bound, boundEvents, [ /* no template attributes */], children, references, variables, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);
            }
            else {
                const attrs = this.extractAttributes(element.name, parsedProperties, i18nAttrsMeta);
                parsedElement = new Element(element.name, attributes, attrs.bound, boundEvents, children, references, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);
            }
            if (elementHasInlineTemplate) {
                // If this node is an inline-template (e.g. has *ngFor) then we need to create a template
                // node that contains this node.
                // Moreover, if the node is an element, then we need to hoist its attributes to the template
                // node for matching against content projection selectors.
                const attrs = this.extractAttributes('ng-template', templateParsedProperties, i18nAttrsMeta);
                const templateAttrs = [];
                attrs.literal.forEach(attr => templateAttrs.push(attr));
                attrs.bound.forEach(attr => templateAttrs.push(attr));
                const hoistedAttrs = parsedElement instanceof Element ?
                    {
                        attributes: parsedElement.attributes,
                        inputs: parsedElement.inputs,
                        outputs: parsedElement.outputs,
                    } :
                    { attributes: [], inputs: [], outputs: [] };
                // For <ng-template>s with structural directives on them, avoid passing i18n information to
                // the wrapping template to prevent unnecessary i18n instructions from being generated. The
                // necessary i18n meta information will be extracted from child elements.
                const i18n = isTemplateElement && isI18nRootElement ? undefined : element.i18n;
                // TODO(pk): test for this case
                parsedElement = new Template(parsedElement.name, hoistedAttrs.attributes, hoistedAttrs.inputs, hoistedAttrs.outputs, templateAttrs, [parsedElement], [ /* no references */], templateVariables, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, i18n);
            }
            if (isI18nRootElement) {
                this.inI18nBlock = false;
            }
            return parsedElement;
        }
        visitAttribute(attribute) {
            return new TextAttribute(attribute.name, attribute.value, attribute.sourceSpan, attribute.keySpan, attribute.valueSpan, attribute.i18n);
        }
        visitText(text) {
            return this._visitTextWithInterpolation(text.value, text.sourceSpan, text.i18n);
        }
        visitExpansion(expansion) {
            if (!expansion.i18n) {
                // do not generate Icu in case it was created
                // outside of i18n block in a template
                return null;
            }
            if (!isI18nRootNode(expansion.i18n)) {
                throw new Error(`Invalid type "${expansion.i18n.constructor}" for "i18n" property of ${expansion.sourceSpan.toString()}. Expected a "Message"`);
            }
            const message = expansion.i18n;
            const vars = {};
            const placeholders = {};
            // extract VARs from ICUs - we process them separately while
            // assembling resulting message via goog.getMsg function, since
            // we need to pass them to top-level goog.getMsg call
            Object.keys(message.placeholders).forEach(key => {
                const value = message.placeholders[key];
                if (key.startsWith(I18N_ICU_VAR_PREFIX)) {
                    // Currently when the `plural` or `select` keywords in an ICU contain trailing spaces (e.g.
                    // `{count, select , ...}`), these spaces are also included into the key names in ICU vars
                    // (e.g. "VAR_SELECT "). These trailing spaces are not desirable, since they will later be
                    // converted into `_` symbols while normalizing placeholder names, which might lead to
                    // mismatches at runtime (i.e. placeholder will not be replaced with the correct value).
                    const formattedKey = key.trim();
                    const ast = this.bindingParser.parseInterpolationExpression(value.text, value.sourceSpan);
                    vars[formattedKey] = new BoundText(ast, value.sourceSpan);
                }
                else {
                    placeholders[key] = this._visitTextWithInterpolation(value.text, value.sourceSpan);
                }
            });
            return new Icu(vars, placeholders, expansion.sourceSpan, message);
        }
        visitExpansionCase(expansionCase) {
            return null;
        }
        visitComment(comment) {
            if (this.options.collectCommentNodes) {
                this.commentNodes.push(new Comment(comment.value || '', comment.sourceSpan));
            }
            return null;
        }
        // convert view engine `ParsedProperty` to a format suitable for IVY
        extractAttributes(elementName, properties, i18nPropsMeta) {
            const bound = [];
            const literal = [];
            properties.forEach(prop => {
                const i18n = i18nPropsMeta[prop.name];
                if (prop.isLiteral) {
                    literal.push(new TextAttribute(prop.name, prop.expression.source || '', prop.sourceSpan, prop.keySpan, prop.valueSpan, i18n));
                }
                else {
                    // Note that validation is skipped and property mapping is disabled
                    // due to the fact that we need to make sure a given prop is not an
                    // input of a directive and directive matching happens at runtime.
                    const bep = this.bindingParser.createBoundElementProperty(elementName, prop, /* skipValidation */ true, /* mapPropertyName */ false);
                    bound.push(BoundAttribute.fromBoundElementProperty(bep, i18n));
                }
            });
            return { bound, literal };
        }
        parseAttribute(isTemplateElement, attribute, matchableAttributes, parsedProperties, boundEvents, variables, references) {
            const name = normalizeAttributeName(attribute.name);
            const value = attribute.value;
            const srcSpan = attribute.sourceSpan;
            const absoluteOffset = attribute.valueSpan ? attribute.valueSpan.start.offset : srcSpan.start.offset;
            function createKeySpan(srcSpan, prefix, identifier) {
                // We need to adjust the start location for the keySpan to account for the removed 'data-'
                // prefix from `normalizeAttributeName`.
                const normalizationAdjustment = attribute.name.length - name.length;
                const keySpanStart = srcSpan.start.moveBy(prefix.length + normalizationAdjustment);
                const keySpanEnd = keySpanStart.moveBy(identifier.length);
                return new ParseSourceSpan(keySpanStart, keySpanEnd, keySpanStart, identifier);
            }
            const bindParts = name.match(BIND_NAME_REGEXP$1);
            if (bindParts) {
                if (bindParts[KW_BIND_IDX$1] != null) {
                    const identifier = bindParts[IDENT_KW_IDX$1];
                    const keySpan = createKeySpan(srcSpan, bindParts[KW_BIND_IDX$1], identifier);
                    this.bindingParser.parsePropertyBinding(identifier, value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan);
                }
                else if (bindParts[KW_LET_IDX$1]) {
                    if (isTemplateElement) {
                        const identifier = bindParts[IDENT_KW_IDX$1];
                        const keySpan = createKeySpan(srcSpan, bindParts[KW_LET_IDX$1], identifier);
                        this.parseVariable(identifier, value, srcSpan, keySpan, attribute.valueSpan, variables);
                    }
                    else {
                        this.reportError(`"let-" is only supported on ng-template elements.`, srcSpan);
                    }
                }
                else if (bindParts[KW_REF_IDX$1]) {
                    const identifier = bindParts[IDENT_KW_IDX$1];
                    const keySpan = createKeySpan(srcSpan, bindParts[KW_REF_IDX$1], identifier);
                    this.parseReference(identifier, value, srcSpan, keySpan, attribute.valueSpan, references);
                }
                else if (bindParts[KW_ON_IDX$1]) {
                    const events = [];
                    const identifier = bindParts[IDENT_KW_IDX$1];
                    const keySpan = createKeySpan(srcSpan, bindParts[KW_ON_IDX$1], identifier);
                    this.bindingParser.parseEvent(identifier, value, srcSpan, attribute.valueSpan || srcSpan, matchableAttributes, events, keySpan);
                    addEvents(events, boundEvents);
                }
                else if (bindParts[KW_BINDON_IDX$1]) {
                    const identifier = bindParts[IDENT_KW_IDX$1];
                    const keySpan = createKeySpan(srcSpan, bindParts[KW_BINDON_IDX$1], identifier);
                    this.bindingParser.parsePropertyBinding(identifier, value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan);
                    this.parseAssignmentEvent(identifier, value, srcSpan, attribute.valueSpan, matchableAttributes, boundEvents, keySpan);
                }
                else if (bindParts[KW_AT_IDX$1]) {
                    const keySpan = createKeySpan(srcSpan, '', name);
                    this.bindingParser.parseLiteralAttr(name, value, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan);
                }
                return true;
            }
            // We didn't see a kw-prefixed property binding, but we have not yet checked
            // for the []/()/[()] syntax.
            let delims = null;
            if (name.startsWith(BINDING_DELIMS.BANANA_BOX.start)) {
                delims = BINDING_DELIMS.BANANA_BOX;
            }
            else if (name.startsWith(BINDING_DELIMS.PROPERTY.start)) {
                delims = BINDING_DELIMS.PROPERTY;
            }
            else if (name.startsWith(BINDING_DELIMS.EVENT.start)) {
                delims = BINDING_DELIMS.EVENT;
            }
            if (delims !== null &&
                // NOTE: older versions of the parser would match a start/end delimited
                // binding iff the property name was terminated by the ending delimiter
                // and the identifier in the binding was non-empty.
                // TODO(ayazhafiz): update this to handle malformed bindings.
                name.endsWith(delims.end) && name.length > delims.start.length + delims.end.length) {
                const identifier = name.substring(delims.start.length, name.length - delims.end.length);
                const keySpan = createKeySpan(srcSpan, delims.start, identifier);
                if (delims.start === BINDING_DELIMS.BANANA_BOX.start) {
                    this.bindingParser.parsePropertyBinding(identifier, value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan);
                    this.parseAssignmentEvent(identifier, value, srcSpan, attribute.valueSpan, matchableAttributes, boundEvents, keySpan);
                }
                else if (delims.start === BINDING_DELIMS.PROPERTY.start) {
                    this.bindingParser.parsePropertyBinding(identifier, value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan);
                }
                else {
                    const events = [];
                    this.bindingParser.parseEvent(identifier, value, srcSpan, attribute.valueSpan || srcSpan, matchableAttributes, events, keySpan);
                    addEvents(events, boundEvents);
                }
                return true;
            }
            // No explicit binding found.
            const keySpan = createKeySpan(srcSpan, '' /* prefix */, name);
            const hasBinding = this.bindingParser.parsePropertyInterpolation(name, value, srcSpan, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan);
            return hasBinding;
        }
        _visitTextWithInterpolation(value, sourceSpan, i18n) {
            const valueNoNgsp = replaceNgsp(value);
            const expr = this.bindingParser.parseInterpolation(valueNoNgsp, sourceSpan);
            return expr ? new BoundText(expr, sourceSpan, i18n) : new Text(valueNoNgsp, sourceSpan);
        }
        parseVariable(identifier, value, sourceSpan, keySpan, valueSpan, variables) {
            if (identifier.indexOf('-') > -1) {
                this.reportError(`"-" is not allowed in variable names`, sourceSpan);
            }
            else if (identifier.length === 0) {
                this.reportError(`Variable does not have a name`, sourceSpan);
            }
            variables.push(new Variable(identifier, value, sourceSpan, keySpan, valueSpan));
        }
        parseReference(identifier, value, sourceSpan, keySpan, valueSpan, references) {
            if (identifier.indexOf('-') > -1) {
                this.reportError(`"-" is not allowed in reference names`, sourceSpan);
            }
            else if (identifier.length === 0) {
                this.reportError(`Reference does not have a name`, sourceSpan);
            }
            else if (references.some(reference => reference.name === identifier)) {
                this.reportError(`Reference "#${identifier}" is defined more than once`, sourceSpan);
            }
            references.push(new Reference(identifier, value, sourceSpan, keySpan, valueSpan));
        }
        parseAssignmentEvent(name, expression, sourceSpan, valueSpan, targetMatchableAttrs, boundEvents, keySpan) {
            const events = [];
            this.bindingParser.parseEvent(`${name}Change`, `${expression}=$event`, sourceSpan, valueSpan || sourceSpan, targetMatchableAttrs, events, keySpan);
            addEvents(events, boundEvents);
        }
        reportError(message, sourceSpan, level = ParseErrorLevel.ERROR) {
            this.errors.push(new ParseError(sourceSpan, message, level));
        }
    }
    class NonBindableVisitor$1 {
        visitElement(ast) {
            const preparsedElement = preparseElement(ast);
            if (preparsedElement.type === PreparsedElementType.SCRIPT ||
                preparsedElement.type === PreparsedElementType.STYLE ||
                preparsedElement.type === PreparsedElementType.STYLESHEET) {
                // Skipping <script> for security reasons
                // Skipping <style> and stylesheets as we already processed them
                // in the StyleCompiler
                return null;
            }
            const children = visitAll$1(this, ast.children, null);
            return new Element(ast.name, visitAll$1(this, ast.attrs), 
            /* inputs */ [], /* outputs */ [], children, /* references */ [], ast.sourceSpan, ast.startSourceSpan, ast.endSourceSpan);
        }
        visitComment(comment) {
            return null;
        }
        visitAttribute(attribute) {
            return new TextAttribute(attribute.name, attribute.value, attribute.sourceSpan, attribute.keySpan, attribute.valueSpan, attribute.i18n);
        }
        visitText(text) {
            return new Text(text.value, text.sourceSpan);
        }
        visitExpansion(expansion) {
            return null;
        }
        visitExpansionCase(expansionCase) {
            return null;
        }
    }
    const NON_BINDABLE_VISITOR$1 = new NonBindableVisitor$1();
    function normalizeAttributeName(attrName) {
        return /^data-/i.test(attrName) ? attrName.substring(5) : attrName;
    }
    function addEvents(events, boundEvents) {
        boundEvents.push(...events.map(e => BoundEvent.fromParsedEvent(e)));
    }
    function isEmptyTextNode(node) {
        return node instanceof Text$2 && node.value.trim().length == 0;
    }
    function isCommentNode(node) {
        return node instanceof Comment$1;
    }
    function textContents(node) {
        if (node.children.length !== 1 || !(node.children[0] instanceof Text$2)) {
            return null;
        }
        else {
            return node.children[0].value;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var TagType;
    (function (TagType) {
        TagType[TagType["ELEMENT"] = 0] = "ELEMENT";
        TagType[TagType["TEMPLATE"] = 1] = "TEMPLATE";
    })(TagType || (TagType = {}));
    /**
     * Generates an object that is used as a shared state between parent and all child contexts.
     */
    function setupRegistry() {
        return { getUniqueId: getSeqNumberGenerator(), icus: new Map() };
    }
    /**
     * I18nContext is a helper class which keeps track of all i18n-related aspects
     * (accumulates placeholders, bindings, etc) between i18nStart and i18nEnd instructions.
     *
     * When we enter a nested template, the top-level context is being passed down
     * to the nested component, which uses this context to generate a child instance
     * of I18nContext class (to handle nested template) and at the end, reconciles it back
     * with the parent context.
     *
     * @param index Instruction index of i18nStart, which initiates this context
     * @param ref Reference to a translation const that represents the content if thus context
     * @param level Nestng level defined for child contexts
     * @param templateIndex Instruction index of a template which this context belongs to
     * @param meta Meta information (id, meaning, description, etc) associated with this context
     */
    class I18nContext {
        constructor(index, ref, level = 0, templateIndex = null, meta, registry) {
            this.index = index;
            this.ref = ref;
            this.level = level;
            this.templateIndex = templateIndex;
            this.meta = meta;
            this.registry = registry;
            this.bindings = new Set();
            this.placeholders = new Map();
            this.isEmitted = false;
            this._unresolvedCtxCount = 0;
            this._registry = registry || setupRegistry();
            this.id = this._registry.getUniqueId();
        }
        appendTag(type, node, index, closed) {
            if (node.isVoid && closed) {
                return; // ignore "close" for void tags
            }
            const ph = node.isVoid || !closed ? node.startName : node.closeName;
            const content = { type, index, ctx: this.id, isVoid: node.isVoid, closed };
            updatePlaceholderMap(this.placeholders, ph, content);
        }
        get icus() {
            return this._registry.icus;
        }
        get isRoot() {
            return this.level === 0;
        }
        get isResolved() {
            return this._unresolvedCtxCount === 0;
        }
        getSerializedPlaceholders() {
            const result = new Map();
            this.placeholders.forEach((values, key) => result.set(key, values.map(serializePlaceholderValue)));
            return result;
        }
        // public API to accumulate i18n-related content
        appendBinding(binding) {
            this.bindings.add(binding);
        }
        appendIcu(name, ref) {
            updatePlaceholderMap(this._registry.icus, name, ref);
        }
        appendBoundText(node) {
            const phs = assembleBoundTextPlaceholders(node, this.bindings.size, this.id);
            phs.forEach((values, key) => updatePlaceholderMap(this.placeholders, key, ...values));
        }
        appendTemplate(node, index) {
            // add open and close tags at the same time,
            // since we process nested templates separately
            this.appendTag(TagType.TEMPLATE, node, index, false);
            this.appendTag(TagType.TEMPLATE, node, index, true);
            this._unresolvedCtxCount++;
        }
        appendElement(node, index, closed) {
            this.appendTag(TagType.ELEMENT, node, index, closed);
        }
        appendProjection(node, index) {
            // Add open and close tags at the same time, since `<ng-content>` has no content,
            // so when we come across `<ng-content>` we can register both open and close tags.
            // Note: runtime i18n logic doesn't distinguish `<ng-content>` tag placeholders and
            // regular element tag placeholders, so we generate element placeholders for both types.
            this.appendTag(TagType.ELEMENT, node, index, false);
            this.appendTag(TagType.ELEMENT, node, index, true);
        }
        /**
         * Generates an instance of a child context based on the root one,
         * when we enter a nested template within I18n section.
         *
         * @param index Instruction index of corresponding i18nStart, which initiates this context
         * @param templateIndex Instruction index of a template which this context belongs to
         * @param meta Meta information (id, meaning, description, etc) associated with this context
         *
         * @returns I18nContext instance
         */
        forkChildContext(index, templateIndex, meta) {
            return new I18nContext(index, this.ref, this.level + 1, templateIndex, meta, this._registry);
        }
        /**
         * Reconciles child context into parent one once the end of the i18n block is reached (i18nEnd).
         *
         * @param context Child I18nContext instance to be reconciled with parent context.
         */
        reconcileChildContext(context) {
            // set the right context id for open and close
            // template tags, so we can use it as sub-block ids
            ['start', 'close'].forEach((op) => {
                const key = context.meta[`${op}Name`];
                const phs = this.placeholders.get(key) || [];
                const tag = phs.find(findTemplateFn(this.id, context.templateIndex));
                if (tag) {
                    tag.ctx = context.id;
                }
            });
            // reconcile placeholders
            const childPhs = context.placeholders;
            childPhs.forEach((values, key) => {
                const phs = this.placeholders.get(key);
                if (!phs) {
                    this.placeholders.set(key, values);
                    return;
                }
                // try to find matching template...
                const tmplIdx = phs.findIndex(findTemplateFn(context.id, context.templateIndex));
                if (tmplIdx >= 0) {
                    // ... if found - replace it with nested template content
                    const isCloseTag = key.startsWith('CLOSE');
                    const isTemplateTag = key.endsWith('NG-TEMPLATE');
                    if (isTemplateTag) {
                        // current template's content is placed before or after
                        // parent template tag, depending on the open/close atrribute
                        phs.splice(tmplIdx + (isCloseTag ? 0 : 1), 0, ...values);
                    }
                    else {
                        const idx = isCloseTag ? values.length - 1 : 0;
                        values[idx].tmpl = phs[tmplIdx];
                        phs.splice(tmplIdx, 1, ...values);
                    }
                }
                else {
                    // ... otherwise just append content to placeholder value
                    phs.push(...values);
                }
                this.placeholders.set(key, phs);
            });
            this._unresolvedCtxCount--;
        }
    }
    //
    // Helper methods
    //
    function wrap(symbol, index, contextId, closed) {
        const state = closed ? '/' : '';
        return wrapI18nPlaceholder(`${state}${symbol}${index}`, contextId);
    }
    function wrapTag(symbol, { index, ctx, isVoid }, closed) {
        return isVoid ? wrap(symbol, index, ctx) + wrap(symbol, index, ctx, true) :
            wrap(symbol, index, ctx, closed);
    }
    function findTemplateFn(ctx, templateIndex) {
        return (token) => typeof token === 'object' && token.type === TagType.TEMPLATE &&
            token.index === templateIndex && token.ctx === ctx;
    }
    function serializePlaceholderValue(value) {
        const element = (data, closed) => wrapTag('#', data, closed);
        const template = (data, closed) => wrapTag('*', data, closed);
        switch (value.type) {
            case TagType.ELEMENT:
                // close element tag
                if (value.closed) {
                    return element(value, true) + (value.tmpl ? template(value.tmpl, true) : '');
                }
                // open element tag that also initiates a template
                if (value.tmpl) {
                    return template(value.tmpl) + element(value) +
                        (value.isVoid ? template(value.tmpl, true) : '');
                }
                return element(value);
            case TagType.TEMPLATE:
                return template(value, value.closed);
            default:
                return value;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class IcuSerializerVisitor {
        visitText(text) {
            return text.value;
        }
        visitContainer(container) {
            return container.children.map(child => child.visit(this)).join('');
        }
        visitIcu(icu) {
            const strCases = Object.keys(icu.cases).map((k) => `${k} {${icu.cases[k].visit(this)}}`);
            const result = `{${icu.expressionPlaceholder}, ${icu.type}, ${strCases.join(' ')}}`;
            return result;
        }
        visitTagPlaceholder(ph) {
            return ph.isVoid ?
                this.formatPh(ph.startName) :
                `${this.formatPh(ph.startName)}${ph.children.map(child => child.visit(this)).join('')}${this.formatPh(ph.closeName)}`;
        }
        visitPlaceholder(ph) {
            return this.formatPh(ph.name);
        }
        visitIcuPlaceholder(ph, context) {
            return this.formatPh(ph.name);
        }
        formatPh(value) {
            return `{${formatI18nPlaceholderName(value, /* useCamelCase */ false)}}`;
        }
    }
    const serializer = new IcuSerializerVisitor();
    function serializeIcuNode(icu) {
        return icu.visit(serializer);
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const TAG_TO_PLACEHOLDER_NAMES = {
        'A': 'LINK',
        'B': 'BOLD_TEXT',
        'BR': 'LINE_BREAK',
        'EM': 'EMPHASISED_TEXT',
        'H1': 'HEADING_LEVEL1',
        'H2': 'HEADING_LEVEL2',
        'H3': 'HEADING_LEVEL3',
        'H4': 'HEADING_LEVEL4',
        'H5': 'HEADING_LEVEL5',
        'H6': 'HEADING_LEVEL6',
        'HR': 'HORIZONTAL_RULE',
        'I': 'ITALIC_TEXT',
        'LI': 'LIST_ITEM',
        'LINK': 'MEDIA_LINK',
        'OL': 'ORDERED_LIST',
        'P': 'PARAGRAPH',
        'Q': 'QUOTATION',
        'S': 'STRIKETHROUGH_TEXT',
        'SMALL': 'SMALL_TEXT',
        'SUB': 'SUBSTRIPT',
        'SUP': 'SUPERSCRIPT',
        'TBODY': 'TABLE_BODY',
        'TD': 'TABLE_CELL',
        'TFOOT': 'TABLE_FOOTER',
        'TH': 'TABLE_HEADER_CELL',
        'THEAD': 'TABLE_HEADER',
        'TR': 'TABLE_ROW',
        'TT': 'MONOSPACED_TEXT',
        'U': 'UNDERLINED_TEXT',
        'UL': 'UNORDERED_LIST',
    };
    /**
     * Creates unique names for placeholder with different content.
     *
     * Returns the same placeholder name when the content is identical.
     */
    class PlaceholderRegistry {
        constructor() {
            // Count the occurrence of the base name top generate a unique name
            this._placeHolderNameCounts = {};
            // Maps signature to placeholder names
            this._signatureToName = {};
        }
        getStartTagPlaceholderName(tag, attrs, isVoid) {
            const signature = this._hashTag(tag, attrs, isVoid);
            if (this._signatureToName[signature]) {
                return this._signatureToName[signature];
            }
            const upperTag = tag.toUpperCase();
            const baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;
            const name = this._generateUniqueName(isVoid ? baseName : `START_${baseName}`);
            this._signatureToName[signature] = name;
            return name;
        }
        getCloseTagPlaceholderName(tag) {
            const signature = this._hashClosingTag(tag);
            if (this._signatureToName[signature]) {
                return this._signatureToName[signature];
            }
            const upperTag = tag.toUpperCase();
            const baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;
            const name = this._generateUniqueName(`CLOSE_${baseName}`);
            this._signatureToName[signature] = name;
            return name;
        }
        getPlaceholderName(name, content) {
            const upperName = name.toUpperCase();
            const signature = `PH: ${upperName}=${content}`;
            if (this._signatureToName[signature]) {
                return this._signatureToName[signature];
            }
            const uniqueName = this._generateUniqueName(upperName);
            this._signatureToName[signature] = uniqueName;
            return uniqueName;
        }
        getUniquePlaceholder(name) {
            return this._generateUniqueName(name.toUpperCase());
        }
        // Generate a hash for a tag - does not take attribute order into account
        _hashTag(tag, attrs, isVoid) {
            const start = `<${tag}`;
            const strAttrs = Object.keys(attrs).sort().map((name) => ` ${name}=${attrs[name]}`).join('');
            const end = isVoid ? '/>' : `></${tag}>`;
            return start + strAttrs + end;
        }
        _hashClosingTag(tag) {
            return this._hashTag(`/${tag}`, {}, false);
        }
        _generateUniqueName(base) {
            const seen = this._placeHolderNameCounts.hasOwnProperty(base);
            if (!seen) {
                this._placeHolderNameCounts[base] = 1;
                return base;
            }
            const id = this._placeHolderNameCounts[base];
            this._placeHolderNameCounts[base] = id + 1;
            return `${base}_${id}`;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const _expParser = new Parser$1(new Lexer());
    /**
     * Returns a function converting html nodes to an i18n Message given an interpolationConfig
     */
    function createI18nMessageFactory(interpolationConfig) {
        const visitor = new _I18nVisitor(_expParser, interpolationConfig);
        return (nodes, meaning, description, customId, visitNodeFn) => visitor.toI18nMessage(nodes, meaning, description, customId, visitNodeFn);
    }
    function noopVisitNodeFn(_html, i18n) {
        return i18n;
    }
    class _I18nVisitor {
        constructor(_expressionParser, _interpolationConfig) {
            this._expressionParser = _expressionParser;
            this._interpolationConfig = _interpolationConfig;
        }
        toI18nMessage(nodes, meaning = '', description = '', customId = '', visitNodeFn) {
            const context = {
                isIcu: nodes.length == 1 && nodes[0] instanceof Expansion,
                icuDepth: 0,
                placeholderRegistry: new PlaceholderRegistry(),
                placeholderToContent: {},
                placeholderToMessage: {},
                visitNodeFn: visitNodeFn || noopVisitNodeFn,
            };
            const i18nodes = visitAll$1(this, nodes, context);
            return new Message(i18nodes, context.placeholderToContent, context.placeholderToMessage, meaning, description, customId);
        }
        visitElement(el, context) {
            var _a;
            const children = visitAll$1(this, el.children, context);
            const attrs = {};
            el.attrs.forEach(attr => {
                // Do not visit the attributes, translatable ones are top-level ASTs
                attrs[attr.name] = attr.value;
            });
            const isVoid = getHtmlTagDefinition(el.name).isVoid;
            const startPhName = context.placeholderRegistry.getStartTagPlaceholderName(el.name, attrs, isVoid);
            context.placeholderToContent[startPhName] = {
                text: el.startSourceSpan.toString(),
                sourceSpan: el.startSourceSpan,
            };
            let closePhName = '';
            if (!isVoid) {
                closePhName = context.placeholderRegistry.getCloseTagPlaceholderName(el.name);
                context.placeholderToContent[closePhName] = {
                    text: `</${el.name}>`,
                    sourceSpan: (_a = el.endSourceSpan) !== null && _a !== void 0 ? _a : el.sourceSpan,
                };
            }
            const node = new TagPlaceholder(el.name, attrs, startPhName, closePhName, children, isVoid, el.sourceSpan, el.startSourceSpan, el.endSourceSpan);
            return context.visitNodeFn(el, node);
        }
        visitAttribute(attribute, context) {
            const node = attribute.valueTokens === undefined || attribute.valueTokens.length === 1 ?
                new Text$1(attribute.value, attribute.valueSpan || attribute.sourceSpan) :
                this._visitTextWithInterpolation(attribute.valueTokens, attribute.valueSpan || attribute.sourceSpan, context, attribute.i18n);
            return context.visitNodeFn(attribute, node);
        }
        visitText(text, context) {
            const node = text.tokens.length === 1 ?
                new Text$1(text.value, text.sourceSpan) :
                this._visitTextWithInterpolation(text.tokens, text.sourceSpan, context, text.i18n);
            return context.visitNodeFn(text, node);
        }
        visitComment(comment, context) {
            return null;
        }
        visitExpansion(icu, context) {
            context.icuDepth++;
            const i18nIcuCases = {};
            const i18nIcu = new Icu$1(icu.switchValue, icu.type, i18nIcuCases, icu.sourceSpan);
            icu.cases.forEach((caze) => {
                i18nIcuCases[caze.value] = new Container(caze.expression.map((node) => node.visit(this, context)), caze.expSourceSpan);
            });
            context.icuDepth--;
            if (context.isIcu || context.icuDepth > 0) {
                // Returns an ICU node when:
                // - the message (vs a part of the message) is an ICU message, or
                // - the ICU message is nested.
                const expPh = context.placeholderRegistry.getUniquePlaceholder(`VAR_${icu.type}`);
                i18nIcu.expressionPlaceholder = expPh;
                context.placeholderToContent[expPh] = {
                    text: icu.switchValue,
                    sourceSpan: icu.switchValueSourceSpan,
                };
                return context.visitNodeFn(icu, i18nIcu);
            }
            // Else returns a placeholder
            // ICU placeholders should not be replaced with their original content but with the their
            // translations.
            // TODO(vicb): add a html.Node -> i18n.Message cache to avoid having to re-create the msg
            const phName = context.placeholderRegistry.getPlaceholderName('ICU', icu.sourceSpan.toString());
            context.placeholderToMessage[phName] = this.toI18nMessage([icu], '', '', '', undefined);
            const node = new IcuPlaceholder(i18nIcu, phName, icu.sourceSpan);
            return context.visitNodeFn(icu, node);
        }
        visitExpansionCase(_icuCase, _context) {
            throw new Error('Unreachable code');
        }
        /**
         * Convert, text and interpolated tokens up into text and placeholder pieces.
         *
         * @param tokens The text and interpolated tokens.
         * @param sourceSpan The span of the whole of the `text` string.
         * @param context The current context of the visitor, used to compute and store placeholders.
         * @param previousI18n Any i18n metadata associated with this `text` from a previous pass.
         */
        _visitTextWithInterpolation(tokens, sourceSpan, context, previousI18n) {
            // Return a sequence of `Text` and `Placeholder` nodes grouped in a `Container`.
            const nodes = [];
            // We will only create a container if there are actually interpolations,
            // so this flag tracks that.
            let hasInterpolation = false;
            for (const token of tokens) {
                switch (token.type) {
                    case 8 /* INTERPOLATION */:
                    case 17 /* ATTR_VALUE_INTERPOLATION */:
                        hasInterpolation = true;
                        const expression = token.parts[1];
                        const baseName = extractPlaceholderName(expression) || 'INTERPOLATION';
                        const phName = context.placeholderRegistry.getPlaceholderName(baseName, expression);
                        context.placeholderToContent[phName] = {
                            text: token.parts.join(''),
                            sourceSpan: token.sourceSpan
                        };
                        nodes.push(new Placeholder(expression, phName, token.sourceSpan));
                        break;
                    default:
                        if (token.parts[0].length > 0) {
                            // This token is text or an encoded entity.
                            // If it is following on from a previous text node then merge it into that node
                            // Otherwise, if it is following an interpolation, then add a new node.
                            const previous = nodes[nodes.length - 1];
                            if (previous instanceof Text$1) {
                                previous.value += token.parts[0];
                                previous.sourceSpan = new ParseSourceSpan(previous.sourceSpan.start, token.sourceSpan.end, previous.sourceSpan.fullStart, previous.sourceSpan.details);
                            }
                            else {
                                nodes.push(new Text$1(token.parts[0], token.sourceSpan));
                            }
                        }
                        break;
                }
            }
            if (hasInterpolation) {
                // Whitespace removal may have invalidated the interpolation source-spans.
                reusePreviousSourceSpans(nodes, previousI18n);
                return new Container(nodes, sourceSpan);
            }
            else {
                return nodes[0];
            }
        }
    }
    /**
     * Re-use the source-spans from `previousI18n` metadata for the `nodes`.
     *
     * Whitespace removal can invalidate the source-spans of interpolation nodes, so we
     * reuse the source-span stored from a previous pass before the whitespace was removed.
     *
     * @param nodes The `Text` and `Placeholder` nodes to be processed.
     * @param previousI18n Any i18n metadata for these `nodes` stored from a previous pass.
     */
    function reusePreviousSourceSpans(nodes, previousI18n) {
        if (previousI18n instanceof Message) {
            // The `previousI18n` is an i18n `Message`, so we are processing an `Attribute` with i18n
            // metadata. The `Message` should consist only of a single `Container` that contains the
            // parts (`Text` and `Placeholder`) to process.
            assertSingleContainerMessage(previousI18n);
            previousI18n = previousI18n.nodes[0];
        }
        if (previousI18n instanceof Container) {
            // The `previousI18n` is a `Container`, which means that this is a second i18n extraction pass
            // after whitespace has been removed from the AST nodes.
            assertEquivalentNodes(previousI18n.children, nodes);
            // Reuse the source-spans from the first pass.
            for (let i = 0; i < nodes.length; i++) {
                nodes[i].sourceSpan = previousI18n.children[i].sourceSpan;
            }
        }
    }
    /**
     * Asserts that the `message` contains exactly one `Container` node.
     */
    function assertSingleContainerMessage(message) {
        const nodes = message.nodes;
        if (nodes.length !== 1 || !(nodes[0] instanceof Container)) {
            throw new Error('Unexpected previous i18n message - expected it to consist of only a single `Container` node.');
        }
    }
    /**
     * Asserts that the `previousNodes` and `node` collections have the same number of elements and
     * corresponding elements have the same node type.
     */
    function assertEquivalentNodes(previousNodes, nodes) {
        if (previousNodes.length !== nodes.length) {
            throw new Error('The number of i18n message children changed between first and second pass.');
        }
        if (previousNodes.some((node, i) => nodes[i].constructor !== node.constructor)) {
            throw new Error('The types of the i18n message children changed between first and second pass.');
        }
    }
    const _CUSTOM_PH_EXP = /\/\/[\s\S]*i18n[\s\S]*\([\s\S]*ph[\s\S]*=[\s\S]*("|')([\s\S]*?)\1[\s\S]*\)/g;
    function extractPlaceholderName(input) {
        return input.split(_CUSTOM_PH_EXP)[2];
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * An i18n error.
     */
    class I18nError extends ParseError {
        constructor(span, msg) {
            super(span, msg);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const setI18nRefs = (htmlNode, i18nNode) => {
        if (htmlNode instanceof NodeWithI18n) {
            if (i18nNode instanceof IcuPlaceholder && htmlNode.i18n instanceof Message) {
                // This html node represents an ICU but this is a second processing pass, and the legacy id
                // was computed in the previous pass and stored in the `i18n` property as a message.
                // We are about to wipe out that property so capture the previous message to be reused when
                // generating the message for this ICU later. See `_generateI18nMessage()`.
                i18nNode.previousMessage = htmlNode.i18n;
            }
            htmlNode.i18n = i18nNode;
        }
        return i18nNode;
    };
    /**
     * This visitor walks over HTML parse tree and converts information stored in
     * i18n-related attributes ("i18n" and "i18n-*") into i18n meta object that is
     * stored with other element's and attribute's information.
     */
    class I18nMetaVisitor {
        constructor(interpolationConfig = DEFAULT_INTERPOLATION_CONFIG, keepI18nAttrs = false, enableI18nLegacyMessageIdFormat = false) {
            this.interpolationConfig = interpolationConfig;
            this.keepI18nAttrs = keepI18nAttrs;
            this.enableI18nLegacyMessageIdFormat = enableI18nLegacyMessageIdFormat;
            // whether visited nodes contain i18n information
            this.hasI18nMeta = false;
            this._errors = [];
            // i18n message generation factory
            this._createI18nMessage = createI18nMessageFactory(this.interpolationConfig);
        }
        _generateI18nMessage(nodes, meta = '', visitNodeFn) {
            const { meaning, description, customId } = this._parseMetadata(meta);
            const message = this._createI18nMessage(nodes, meaning, description, customId, visitNodeFn);
            this._setMessageId(message, meta);
            this._setLegacyIds(message, meta);
            return message;
        }
        visitAllWithErrors(nodes) {
            const result = nodes.map(node => node.visit(this, null));
            return new ParseTreeResult(result, this._errors);
        }
        visitElement(element) {
            if (hasI18nAttrs(element)) {
                this.hasI18nMeta = true;
                const attrs = [];
                const attrsMeta = {};
                for (const attr of element.attrs) {
                    if (attr.name === I18N_ATTR) {
                        // root 'i18n' node attribute
                        const i18n = element.i18n || attr.value;
                        const message = this._generateI18nMessage(element.children, i18n, setI18nRefs);
                        // do not assign empty i18n meta
                        if (message.nodes.length) {
                            element.i18n = message;
                        }
                    }
                    else if (attr.name.startsWith(I18N_ATTR_PREFIX)) {
                        // 'i18n-*' attributes
                        const name = attr.name.slice(I18N_ATTR_PREFIX.length);
                        if (isTrustedTypesSink(element.name, name)) {
                            this._reportError(attr, `Translating attribute '${name}' is disallowed for security reasons.`);
                        }
                        else {
                            attrsMeta[name] = attr.value;
                        }
                    }
                    else {
                        // non-i18n attributes
                        attrs.push(attr);
                    }
                }
                // set i18n meta for attributes
                if (Object.keys(attrsMeta).length) {
                    for (const attr of attrs) {
                        const meta = attrsMeta[attr.name];
                        // do not create translation for empty attributes
                        if (meta !== undefined && attr.value) {
                            attr.i18n = this._generateI18nMessage([attr], attr.i18n || meta);
                        }
                    }
                }
                if (!this.keepI18nAttrs) {
                    // update element's attributes,
                    // keeping only non-i18n related ones
                    element.attrs = attrs;
                }
            }
            visitAll$1(this, element.children, element.i18n);
            return element;
        }
        visitExpansion(expansion, currentMessage) {
            let message;
            const meta = expansion.i18n;
            this.hasI18nMeta = true;
            if (meta instanceof IcuPlaceholder) {
                // set ICU placeholder name (e.g. "ICU_1"),
                // generated while processing root element contents,
                // so we can reference it when we output translation
                const name = meta.name;
                message = this._generateI18nMessage([expansion], meta);
                const icu = icuFromI18nMessage(message);
                icu.name = name;
            }
            else {
                // ICU is a top level message, try to use metadata from container element if provided via
                // `context` argument. Note: context may not be available for standalone ICUs (without
                // wrapping element), so fallback to ICU metadata in this case.
                message = this._generateI18nMessage([expansion], currentMessage || meta);
            }
            expansion.i18n = message;
            return expansion;
        }
        visitText(text) {
            return text;
        }
        visitAttribute(attribute) {
            return attribute;
        }
        visitComment(comment) {
            return comment;
        }
        visitExpansionCase(expansionCase) {
            return expansionCase;
        }
        /**
         * Parse the general form `meta` passed into extract the explicit metadata needed to create a
         * `Message`.
         *
         * There are three possibilities for the `meta` variable
         * 1) a string from an `i18n` template attribute: parse it to extract the metadata values.
         * 2) a `Message` from a previous processing pass: reuse the metadata values in the message.
         * 4) other: ignore this and just process the message metadata as normal
         *
         * @param meta the bucket that holds information about the message
         * @returns the parsed metadata.
         */
        _parseMetadata(meta) {
            return typeof meta === 'string' ? parseI18nMeta(meta) :
                meta instanceof Message ? meta : {};
        }
        /**
         * Generate (or restore) message id if not specified already.
         */
        _setMessageId(message, meta) {
            if (!message.id) {
                message.id = meta instanceof Message && meta.id || decimalDigest(message);
            }
        }
        /**
         * Update the `message` with a `legacyId` if necessary.
         *
         * @param message the message whose legacy id should be set
         * @param meta information about the message being processed
         */
        _setLegacyIds(message, meta) {
            if (this.enableI18nLegacyMessageIdFormat) {
                message.legacyIds = [computeDigest(message), computeDecimalDigest(message)];
            }
            else if (typeof meta !== 'string') {
                // This occurs if we are doing the 2nd pass after whitespace removal (see `parseTemplate()` in
                // `packages/compiler/src/render3/view/template.ts`).
                // In that case we want to reuse the legacy message generated in the 1st pass (see
                // `setI18nRefs()`).
                const previousMessage = meta instanceof Message ?
                    meta :
                    meta instanceof IcuPlaceholder ? meta.previousMessage : undefined;
                message.legacyIds = previousMessage ? previousMessage.legacyIds : [];
            }
        }
        _reportError(node, msg) {
            this._errors.push(new I18nError(node.sourceSpan, msg));
        }
    }
    /** I18n separators for metadata **/
    const I18N_MEANING_SEPARATOR = '|';
    const I18N_ID_SEPARATOR = '@@';
    /**
     * Parses i18n metas like:
     *  - "@@id",
     *  - "description[@@id]",
     *  - "meaning|description[@@id]"
     * and returns an object with parsed output.
     *
     * @param meta String that represents i18n meta
     * @returns Object with id, meaning and description fields
     */
    function parseI18nMeta(meta = '') {
        let customId;
        let meaning;
        let description;
        meta = meta.trim();
        if (meta) {
            const idIndex = meta.indexOf(I18N_ID_SEPARATOR);
            const descIndex = meta.indexOf(I18N_MEANING_SEPARATOR);
            let meaningAndDesc;
            [meaningAndDesc, customId] =
                (idIndex > -1) ? [meta.slice(0, idIndex), meta.slice(idIndex + 2)] : [meta, ''];
            [meaning, description] = (descIndex > -1) ?
                [meaningAndDesc.slice(0, descIndex), meaningAndDesc.slice(descIndex + 1)] :
                ['', meaningAndDesc];
        }
        return { customId, meaning, description };
    }
    // Converts i18n meta information for a message (id, description, meaning)
    // to a JsDoc statement formatted as expected by the Closure compiler.
    function i18nMetaToJSDoc(meta) {
        const tags = [];
        if (meta.description) {
            tags.push({ tagName: "desc" /* Desc */, text: meta.description });
        }
        if (meta.meaning) {
            tags.push({ tagName: "meaning" /* Meaning */, text: meta.meaning });
        }
        return tags.length == 0 ? null : jsDocComment(tags);
    }

    /** Closure uses `goog.getMsg(message)` to lookup translations */
    const GOOG_GET_MSG = 'goog.getMsg';
    function createGoogleGetMsgStatements(variable$1, message, closureVar, params) {
        const messageString = serializeI18nMessageForGetMsg(message);
        const args = [literal(messageString)];
        if (Object.keys(params).length) {
            args.push(mapLiteral(params, true));
        }
        // /**
        //  * @desc description of message
        //  * @meaning meaning of message
        //  */
        // const MSG_... = goog.getMsg(..);
        // I18N_X = MSG_...;
        const googGetMsgStmt = closureVar.set(variable(GOOG_GET_MSG).callFn(args)).toConstDecl();
        const metaComment = i18nMetaToJSDoc(message);
        if (metaComment !== null) {
            googGetMsgStmt.addLeadingComment(metaComment);
        }
        const i18nAssignmentStmt = new ExpressionStatement(variable$1.set(closureVar));
        return [googGetMsgStmt, i18nAssignmentStmt];
    }
    /**
     * This visitor walks over i18n tree and generates its string representation, including ICUs and
     * placeholders in `{$placeholder}` (for plain messages) or `{PLACEHOLDER}` (inside ICUs) format.
     */
    class GetMsgSerializerVisitor {
        formatPh(value) {
            return `{$${formatI18nPlaceholderName(value)}}`;
        }
        visitText(text) {
            return text.value;
        }
        visitContainer(container) {
            return container.children.map(child => child.visit(this)).join('');
        }
        visitIcu(icu) {
            return serializeIcuNode(icu);
        }
        visitTagPlaceholder(ph) {
            return ph.isVoid ?
                this.formatPh(ph.startName) :
                `${this.formatPh(ph.startName)}${ph.children.map(child => child.visit(this)).join('')}${this.formatPh(ph.closeName)}`;
        }
        visitPlaceholder(ph) {
            return this.formatPh(ph.name);
        }
        visitIcuPlaceholder(ph, context) {
            return this.formatPh(ph.name);
        }
    }
    const serializerVisitor$1 = new GetMsgSerializerVisitor();
    function serializeI18nMessageForGetMsg(message) {
        return message.nodes.map(node => node.visit(serializerVisitor$1, null)).join('');
    }

    function createLocalizeStatements(variable, message, params) {
        const { messageParts, placeHolders } = serializeI18nMessageForLocalize(message);
        const sourceSpan = getSourceSpan(message);
        const expressions = placeHolders.map(ph => params[ph.text]);
        const localizedString$1 = localizedString(message, messageParts, placeHolders, expressions, sourceSpan);
        const variableInitialization = variable.set(localizedString$1);
        return [new ExpressionStatement(variableInitialization)];
    }
    /**
     * This visitor walks over an i18n tree, capturing literal strings and placeholders.
     *
     * The result can be used for generating the `$localize` tagged template literals.
     */
    class LocalizeSerializerVisitor {
        visitText(text, context) {
            if (context[context.length - 1] instanceof LiteralPiece) {
                // Two literal pieces in a row means that there was some comment node in-between.
                context[context.length - 1].text += text.value;
            }
            else {
                const sourceSpan = new ParseSourceSpan(text.sourceSpan.fullStart, text.sourceSpan.end, text.sourceSpan.fullStart, text.sourceSpan.details);
                context.push(new LiteralPiece(text.value, sourceSpan));
            }
        }
        visitContainer(container, context) {
            container.children.forEach(child => child.visit(this, context));
        }
        visitIcu(icu, context) {
            context.push(new LiteralPiece(serializeIcuNode(icu), icu.sourceSpan));
        }
        visitTagPlaceholder(ph, context) {
            var _a, _b;
            context.push(this.createPlaceholderPiece(ph.startName, (_a = ph.startSourceSpan) !== null && _a !== void 0 ? _a : ph.sourceSpan));
            if (!ph.isVoid) {
                ph.children.forEach(child => child.visit(this, context));
                context.push(this.createPlaceholderPiece(ph.closeName, (_b = ph.endSourceSpan) !== null && _b !== void 0 ? _b : ph.sourceSpan));
            }
        }
        visitPlaceholder(ph, context) {
            context.push(this.createPlaceholderPiece(ph.name, ph.sourceSpan));
        }
        visitIcuPlaceholder(ph, context) {
            context.push(this.createPlaceholderPiece(ph.name, ph.sourceSpan));
        }
        createPlaceholderPiece(name, sourceSpan) {
            return new PlaceholderPiece(formatI18nPlaceholderName(name, /* useCamelCase */ false), sourceSpan);
        }
    }
    const serializerVisitor$2 = new LocalizeSerializerVisitor();
    /**
     * Serialize an i18n message into two arrays: messageParts and placeholders.
     *
     * These arrays will be used to generate `$localize` tagged template literals.
     *
     * @param message The message to be serialized.
     * @returns an object containing the messageParts and placeholders.
     */
    function serializeI18nMessageForLocalize(message) {
        const pieces = [];
        message.nodes.forEach(node => node.visit(serializerVisitor$2, pieces));
        return processMessagePieces(pieces);
    }
    function getSourceSpan(message) {
        const startNode = message.nodes[0];
        const endNode = message.nodes[message.nodes.length - 1];
        return new ParseSourceSpan(startNode.sourceSpan.fullStart, endNode.sourceSpan.end, startNode.sourceSpan.fullStart, startNode.sourceSpan.details);
    }
    /**
     * Convert the list of serialized MessagePieces into two arrays.
     *
     * One contains the literal string pieces and the other the placeholders that will be replaced by
     * expressions when rendering `$localize` tagged template literals.
     *
     * @param pieces The pieces to process.
     * @returns an object containing the messageParts and placeholders.
     */
    function processMessagePieces(pieces) {
        const messageParts = [];
        const placeHolders = [];
        if (pieces[0] instanceof PlaceholderPiece) {
            // The first piece was a placeholder so we need to add an initial empty message part.
            messageParts.push(createEmptyMessagePart(pieces[0].sourceSpan.start));
        }
        for (let i = 0; i < pieces.length; i++) {
            const part = pieces[i];
            if (part instanceof LiteralPiece) {
                messageParts.push(part);
            }
            else {
                placeHolders.push(part);
                if (pieces[i - 1] instanceof PlaceholderPiece) {
                    // There were two placeholders in a row, so we need to add an empty message part.
                    messageParts.push(createEmptyMessagePart(pieces[i - 1].sourceSpan.end));
                }
            }
        }
        if (pieces[pieces.length - 1] instanceof PlaceholderPiece) {
            // The last piece was a placeholder so we need to add a final empty message part.
            messageParts.push(createEmptyMessagePart(pieces[pieces.length - 1].sourceSpan.end));
        }
        return { messageParts, placeHolders };
    }
    function createEmptyMessagePart(location) {
        return new LiteralPiece('', new ParseSourceSpan(location, location));
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    // Selector attribute name of `<ng-content>`
    const NG_CONTENT_SELECT_ATTR$1 = 'select';
    // Attribute name of `ngProjectAs`.
    const NG_PROJECT_AS_ATTR_NAME = 'ngProjectAs';
    // Global symbols available only inside event bindings.
    const EVENT_BINDING_SCOPE_GLOBALS = new Set(['$event']);
    // List of supported global targets for event listeners
    const GLOBAL_TARGET_RESOLVERS = new Map([['window', Identifiers.resolveWindow], ['document', Identifiers.resolveDocument], ['body', Identifiers.resolveBody]]);
    const LEADING_TRIVIA_CHARS = [' ', '\n', '\r', '\t'];
    //  if (rf & flags) { .. }
    function renderFlagCheckIfStmt(flags, statements) {
        return ifStmt(variable(RENDER_FLAGS).bitwiseAnd(literal(flags), null, false), statements);
    }
    function prepareEventListenerParameters(eventAst, handlerName = null, scope = null) {
        const { type, name, target, phase, handler } = eventAst;
        if (target && !GLOBAL_TARGET_RESOLVERS.has(target)) {
            throw new Error(`Unexpected global target '${target}' defined for '${name}' event.
        Supported list of global targets: ${Array.from(GLOBAL_TARGET_RESOLVERS.keys())}.`);
        }
        const eventArgumentName = '$event';
        const implicitReceiverAccesses = new Set();
        const implicitReceiverExpr = (scope === null || scope.bindingLevel === 0) ?
            variable(CONTEXT_NAME) :
            scope.getOrCreateSharedContextVar(0);
        const bindingExpr = convertActionBinding(scope, implicitReceiverExpr, handler, 'b', () => error('Unexpected interpolation'), eventAst.handlerSpan, implicitReceiverAccesses, EVENT_BINDING_SCOPE_GLOBALS);
        const statements = [];
        if (scope) {
            // `variableDeclarations` needs to run first, because
            // `restoreViewStatement` depends on the result.
            statements.push(...scope.variableDeclarations());
            statements.unshift(...scope.restoreViewStatement());
        }
        statements.push(...bindingExpr.render3Stmts);
        const eventName = type === 1 /* Animation */ ? prepareSyntheticListenerName(name, phase) : name;
        const fnName = handlerName && sanitizeIdentifier(handlerName);
        const fnArgs = [];
        if (implicitReceiverAccesses.has(eventArgumentName)) {
            fnArgs.push(new FnParam(eventArgumentName, DYNAMIC_TYPE));
        }
        const handlerFn = fn(fnArgs, statements, INFERRED_TYPE, null, fnName);
        const params = [literal(eventName), handlerFn];
        if (target) {
            params.push(literal(false), // `useCapture` flag, defaults to `false`
            importExpr(GLOBAL_TARGET_RESOLVERS.get(target)));
        }
        return params;
    }
    function createComponentDefConsts() {
        return {
            prepareStatements: [],
            constExpressions: [],
            i18nVarRefsCache: new Map(),
        };
    }
    class TemplateDefinitionBuilder {
        constructor(constantPool, parentBindingScope, level = 0, contextName, i18nContext, templateIndex, templateName, directiveMatcher, directives, pipeTypeByName, pipes, _namespace, relativeContextFilePath, i18nUseExternalIds, _constants = createComponentDefConsts()) {
            this.constantPool = constantPool;
            this.level = level;
            this.contextName = contextName;
            this.i18nContext = i18nContext;
            this.templateIndex = templateIndex;
            this.templateName = templateName;
            this.directiveMatcher = directiveMatcher;
            this.directives = directives;
            this.pipeTypeByName = pipeTypeByName;
            this.pipes = pipes;
            this._namespace = _namespace;
            this.i18nUseExternalIds = i18nUseExternalIds;
            this._constants = _constants;
            this._dataIndex = 0;
            this._bindingContext = 0;
            this._prefixCode = [];
            /**
             * List of callbacks to generate creation mode instructions. We store them here as we process
             * the template so bindings in listeners are resolved only once all nodes have been visited.
             * This ensures all local refs and context variables are available for matching.
             */
            this._creationCodeFns = [];
            /**
             * List of callbacks to generate update mode instructions. We store them here as we process
             * the template so bindings are resolved only once all nodes have been visited. This ensures
             * all local refs and context variables are available for matching.
             */
            this._updateCodeFns = [];
            /** Index of the currently-selected node. */
            this._currentIndex = 0;
            /** Temporary variable declarations generated from visiting pipes, literals, etc. */
            this._tempVariables = [];
            /**
             * List of callbacks to build nested templates. Nested templates must not be visited until
             * after the parent template has finished visiting all of its nodes. This ensures that all
             * local ref bindings in nested templates are able to find local ref values if the refs
             * are defined after the template declaration.
             */
            this._nestedTemplateFns = [];
            this._unsupported = unsupported;
            // i18n context local to this template
            this.i18n = null;
            // Number of slots to reserve for pureFunctions
            this._pureFunctionSlots = 0;
            // Number of binding slots
            this._bindingSlots = 0;
            // Projection slots found in the template. Projection slots can distribute projected
            // nodes based on a selector, or can just use the wildcard selector to match
            // all nodes which aren't matching any selector.
            this._ngContentReservedSlots = [];
            // Number of non-default selectors found in all parent templates of this template. We need to
            // track it to properly adjust projection slot index in the `projection` instruction.
            this._ngContentSelectorsOffset = 0;
            // Expression that should be used as implicit receiver when converting template
            // expressions to output AST.
            this._implicitReceiverExpr = null;
            // These should be handled in the template or element directly.
            this.visitReference = invalid$1;
            this.visitVariable = invalid$1;
            this.visitTextAttribute = invalid$1;
            this.visitBoundAttribute = invalid$1;
            this.visitBoundEvent = invalid$1;
            this._bindingScope = parentBindingScope.nestedScope(level);
            // Turn the relative context file path into an identifier by replacing non-alphanumeric
            // characters with underscores.
            this.fileBasedI18nSuffix = relativeContextFilePath.replace(/[^A-Za-z0-9]/g, '_') + '_';
            this._valueConverter = new ValueConverter(constantPool, () => this.allocateDataSlot(), (numSlots) => this.allocatePureFunctionSlots(numSlots), (name, localName, slot, value) => {
                const pipeType = pipeTypeByName.get(name);
                if (pipeType) {
                    this.pipes.add(pipeType);
                }
                this._bindingScope.set(this.level, localName, value);
                this.creationInstruction(null, Identifiers.pipe, [literal(slot), literal(name)]);
            });
        }
        buildTemplateFunction(nodes, variables, ngContentSelectorsOffset = 0, i18n) {
            this._ngContentSelectorsOffset = ngContentSelectorsOffset;
            if (this._namespace !== Identifiers.namespaceHTML) {
                this.creationInstruction(null, this._namespace);
            }
            // Create variable bindings
            variables.forEach(v => this.registerContextVariables(v));
            // Initiate i18n context in case:
            // - this template has parent i18n context
            // - or the template has i18n meta associated with it,
            //   but it's not initiated by the Element (e.g. <ng-template i18n>)
            const initI18nContext = this.i18nContext ||
                (isI18nRootNode(i18n) && !isSingleI18nIcu(i18n) &&
                    !(isSingleElementTemplate(nodes) && nodes[0].i18n === i18n));
            const selfClosingI18nInstruction = hasTextChildrenOnly(nodes);
            if (initI18nContext) {
                this.i18nStart(null, i18n, selfClosingI18nInstruction);
            }
            // This is the initial pass through the nodes of this template. In this pass, we
            // queue all creation mode and update mode instructions for generation in the second
            // pass. It's necessary to separate the passes to ensure local refs are defined before
            // resolving bindings. We also count bindings in this pass as we walk bound expressions.
            visitAll(this, nodes);
            // Add total binding count to pure function count so pure function instructions are
            // generated with the correct slot offset when update instructions are processed.
            this._pureFunctionSlots += this._bindingSlots;
            // Pipes are walked in the first pass (to enqueue `pipe()` creation instructions and
            // `pipeBind` update instructions), so we have to update the slot offsets manually
            // to account for bindings.
            this._valueConverter.updatePipeSlotOffsets(this._bindingSlots);
            // Nested templates must be processed before creation instructions so template()
            // instructions can be generated with the correct internal const count.
            this._nestedTemplateFns.forEach(buildTemplateFn => buildTemplateFn());
            // Output the `projectionDef` instruction when some `<ng-content>` tags are present.
            // The `projectionDef` instruction is only emitted for the component template and
            // is skipped for nested templates (<ng-template> tags).
            if (this.level === 0 && this._ngContentReservedSlots.length) {
                const parameters = [];
                // By default the `projectionDef` instructions creates one slot for the wildcard
                // selector if no parameters are passed. Therefore we only want to allocate a new
                // array for the projection slots if the default projection slot is not sufficient.
                if (this._ngContentReservedSlots.length > 1 || this._ngContentReservedSlots[0] !== '*') {
                    const r3ReservedSlots = this._ngContentReservedSlots.map(s => s !== '*' ? parseSelectorToR3Selector(s) : s);
                    parameters.push(this.constantPool.getConstLiteral(asLiteral(r3ReservedSlots), true));
                }
                // Since we accumulate ngContent selectors while processing template elements,
                // we *prepend* `projectionDef` to creation instructions block, to put it before
                // any `projection` instructions
                this.creationInstruction(null, Identifiers.projectionDef, parameters, /* prepend */ true);
            }
            if (initI18nContext) {
                this.i18nEnd(null, selfClosingI18nInstruction);
            }
            // Generate all the creation mode instructions (e.g. resolve bindings in listeners)
            const creationStatements = this._creationCodeFns.map((fn) => fn());
            // Generate all the update mode instructions (e.g. resolve property or text bindings)
            const updateStatements = this._updateCodeFns.map((fn) => fn());
            //  Variable declaration must occur after binding resolution so we can generate context
            //  instructions that build on each other.
            // e.g. const b = nextContext().$implicit(); const b = nextContext();
            const creationVariables = this._bindingScope.viewSnapshotStatements();
            const updateVariables = this._bindingScope.variableDeclarations().concat(this._tempVariables);
            const creationBlock = creationStatements.length > 0 ?
                [renderFlagCheckIfStmt(1 /* Create */, creationVariables.concat(creationStatements))] :
                [];
            const updateBlock = updateStatements.length > 0 ?
                [renderFlagCheckIfStmt(2 /* Update */, updateVariables.concat(updateStatements))] :
                [];
            return fn(
            // i.e. (rf: RenderFlags, ctx: any)
            [new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null)], [
                // Temporary variable declarations for query refresh (i.e. let _t: any;)
                ...this._prefixCode,
                // Creating mode (i.e. if (rf & RenderFlags.Create) { ... })
                ...creationBlock,
                // Binding and refresh mode (i.e. if (rf & RenderFlags.Update) {...})
                ...updateBlock,
            ], INFERRED_TYPE, null, this.templateName);
        }
        // LocalResolver
        getLocal(name) {
            return this._bindingScope.get(name);
        }
        // LocalResolver
        notifyImplicitReceiverUse() {
            this._bindingScope.notifyImplicitReceiverUse();
        }
        // LocalResolver
        maybeRestoreView() {
            this._bindingScope.maybeRestoreView();
        }
        i18nTranslate(message, params = {}, ref, transformFn) {
            const _ref = ref || this.i18nGenerateMainBlockVar();
            // Closure Compiler requires const names to start with `MSG_` but disallows any other const to
            // start with `MSG_`. We define a variable starting with `MSG_` just for the `goog.getMsg` call
            const closureVar = this.i18nGenerateClosureVar(message.id);
            const statements = getTranslationDeclStmts(message, _ref, closureVar, params, transformFn);
            this._constants.prepareStatements.push(...statements);
            return _ref;
        }
        registerContextVariables(variable$1) {
            const scopedName = this._bindingScope.freshReferenceName();
            const retrievalLevel = this.level;
            const lhs = variable(variable$1.name + scopedName);
            this._bindingScope.set(retrievalLevel, variable$1.name, lhs, 1 /* CONTEXT */, (scope, relativeLevel) => {
                let rhs;
                if (scope.bindingLevel === retrievalLevel) {
                    if (scope.isListenerScope() && scope.hasRestoreViewVariable()) {
                        // e.g. restoredCtx.
                        // We have to get the context from a view reference, if one is available, because
                        // the context that was passed in during creation may not be correct anymore.
                        // For more information see: https://github.com/angular/angular/pull/40360.
                        rhs = variable(RESTORED_VIEW_CONTEXT_NAME);
                        scope.notifyRestoredViewContextUse();
                    }
                    else {
                        // e.g. ctx
                        rhs = variable(CONTEXT_NAME);
                    }
                }
                else {
                    const sharedCtxVar = scope.getSharedContextName(retrievalLevel);
                    // e.g. ctx_r0   OR  x(2);
                    rhs = sharedCtxVar ? sharedCtxVar : generateNextContextExpr(relativeLevel);
                }
                // e.g. const $item$ = x(2).$implicit;
                return [lhs.set(rhs.prop(variable$1.value || IMPLICIT_REFERENCE)).toConstDecl()];
            });
        }
        i18nAppendBindings(expressions) {
            if (expressions.length > 0) {
                expressions.forEach(expression => this.i18n.appendBinding(expression));
            }
        }
        i18nBindProps(props) {
            const bound = {};
            Object.keys(props).forEach(key => {
                const prop = props[key];
                if (prop instanceof Text) {
                    bound[key] = literal(prop.value);
                }
                else {
                    const value = prop.value.visit(this._valueConverter);
                    this.allocateBindingSlots(value);
                    if (value instanceof Interpolation) {
                        const { strings, expressions } = value;
                        const { id, bindings } = this.i18n;
                        const label = assembleI18nBoundString(strings, bindings.size, id);
                        this.i18nAppendBindings(expressions);
                        bound[key] = literal(label);
                    }
                }
            });
            return bound;
        }
        // Generates top level vars for i18n blocks (i.e. `i18n_N`).
        i18nGenerateMainBlockVar() {
            return variable(this.constantPool.uniqueName(TRANSLATION_VAR_PREFIX));
        }
        // Generates vars with Closure-specific names for i18n blocks (i.e. `MSG_XXX`).
        i18nGenerateClosureVar(messageId) {
            let name;
            const suffix = this.fileBasedI18nSuffix.toUpperCase();
            if (this.i18nUseExternalIds) {
                const prefix = getTranslationConstPrefix(`EXTERNAL_`);
                const uniqueSuffix = this.constantPool.uniqueName(suffix);
                name = `${prefix}${sanitizeIdentifier(messageId)}$$${uniqueSuffix}`;
            }
            else {
                const prefix = getTranslationConstPrefix(suffix);
                name = this.constantPool.uniqueName(prefix);
            }
            return variable(name);
        }
        i18nUpdateRef(context) {
            const { icus, meta, isRoot, isResolved, isEmitted } = context;
            if (isRoot && isResolved && !isEmitted && !isSingleI18nIcu(meta)) {
                context.isEmitted = true;
                const placeholders = context.getSerializedPlaceholders();
                let icuMapping = {};
                let params = placeholders.size ? placeholdersToParams(placeholders) : {};
                if (icus.size) {
                    icus.forEach((refs, key) => {
                        if (refs.length === 1) {
                            // if we have one ICU defined for a given
                            // placeholder - just output its reference
                            params[key] = refs[0];
                        }
                        else {
                            // ... otherwise we need to activate post-processing
                            // to replace ICU placeholders with proper values
                            const placeholder = wrapI18nPlaceholder(`${I18N_ICU_MAPPING_PREFIX}${key}`);
                            params[key] = literal(placeholder);
                            icuMapping[key] = literalArr(refs);
                        }
                    });
                }
                // translation requires post processing in 2 cases:
                // - if we have placeholders with multiple values (ex. `START_DIV`: [ï¿½#1ï¿½, ï¿½#2ï¿½, ...])
                // - if we have multiple ICUs that refer to the same placeholder name
                const needsPostprocessing = Array.from(placeholders.values()).some((value) => value.length > 1) ||
                    Object.keys(icuMapping).length;
                let transformFn;
                if (needsPostprocessing) {
                    transformFn = (raw) => {
                        const args = [raw];
                        if (Object.keys(icuMapping).length) {
                            args.push(mapLiteral(icuMapping, true));
                        }
                        return instruction(null, Identifiers.i18nPostprocess, args);
                    };
                }
                this.i18nTranslate(meta, params, context.ref, transformFn);
            }
        }
        i18nStart(span = null, meta, selfClosing) {
            const index = this.allocateDataSlot();
            this.i18n = this.i18nContext ?
                this.i18nContext.forkChildContext(index, this.templateIndex, meta) :
                new I18nContext(index, this.i18nGenerateMainBlockVar(), 0, this.templateIndex, meta);
            // generate i18nStart instruction
            const { id, ref } = this.i18n;
            const params = [literal(index), this.addToConsts(ref)];
            if (id > 0) {
                // do not push 3rd argument (sub-block id)
                // into i18nStart call for top level i18n context
                params.push(literal(id));
            }
            this.creationInstruction(span, selfClosing ? Identifiers.i18n : Identifiers.i18nStart, params);
        }
        i18nEnd(span = null, selfClosing) {
            if (!this.i18n) {
                throw new Error('i18nEnd is executed with no i18n context present');
            }
            if (this.i18nContext) {
                this.i18nContext.reconcileChildContext(this.i18n);
                this.i18nUpdateRef(this.i18nContext);
            }
            else {
                this.i18nUpdateRef(this.i18n);
            }
            // setup accumulated bindings
            const { index, bindings } = this.i18n;
            if (bindings.size) {
                const chainBindings = [];
                bindings.forEach(binding => {
                    chainBindings.push({ sourceSpan: span, value: () => this.convertPropertyBinding(binding) });
                });
                // for i18n block, advance to the most recent element index (by taking the current number of
                // elements and subtracting one) before invoking `i18nExp` instructions, to make sure the
                // necessary lifecycle hooks of components/directives are properly flushed.
                this.updateInstructionChainWithAdvance(this.getConstCount() - 1, Identifiers.i18nExp, chainBindings);
                this.updateInstruction(span, Identifiers.i18nApply, [literal(index)]);
            }
            if (!selfClosing) {
                this.creationInstruction(span, Identifiers.i18nEnd);
            }
            this.i18n = null; // reset local i18n context
        }
        i18nAttributesInstruction(nodeIndex, attrs, sourceSpan) {
            let hasBindings = false;
            const i18nAttrArgs = [];
            const bindings = [];
            attrs.forEach(attr => {
                const message = attr.i18n;
                const converted = attr.value.visit(this._valueConverter);
                this.allocateBindingSlots(converted);
                if (converted instanceof Interpolation) {
                    const placeholders = assembleBoundTextPlaceholders(message);
                    const params = placeholdersToParams(placeholders);
                    i18nAttrArgs.push(literal(attr.name), this.i18nTranslate(message, params));
                    converted.expressions.forEach(expression => {
                        hasBindings = true;
                        bindings.push({
                            sourceSpan,
                            value: () => this.convertPropertyBinding(expression),
                        });
                    });
                }
            });
            if (bindings.length > 0) {
                this.updateInstructionChainWithAdvance(nodeIndex, Identifiers.i18nExp, bindings);
            }
            if (i18nAttrArgs.length > 0) {
                const index = literal(this.allocateDataSlot());
                const constIndex = this.addToConsts(literalArr(i18nAttrArgs));
                this.creationInstruction(sourceSpan, Identifiers.i18nAttributes, [index, constIndex]);
                if (hasBindings) {
                    this.updateInstruction(sourceSpan, Identifiers.i18nApply, [index]);
                }
            }
        }
        getNamespaceInstruction(namespaceKey) {
            switch (namespaceKey) {
                case 'math':
                    return Identifiers.namespaceMathML;
                case 'svg':
                    return Identifiers.namespaceSVG;
                default:
                    return Identifiers.namespaceHTML;
            }
        }
        addNamespaceInstruction(nsInstruction, element) {
            this._namespace = nsInstruction;
            this.creationInstruction(element.startSourceSpan, nsInstruction);
        }
        /**
         * Adds an update instruction for an interpolated property or attribute, such as
         * `prop="{{value}}"` or `attr.title="{{value}}"`
         */
        interpolatedUpdateInstruction(instruction, elementIndex, attrName, input, value, params) {
            this.updateInstructionWithAdvance(elementIndex, input.sourceSpan, instruction, () => [literal(attrName), ...this.getUpdateInstructionArguments(value), ...params]);
        }
        visitContent(ngContent) {
            const slot = this.allocateDataSlot();
            const projectionSlotIdx = this._ngContentSelectorsOffset + this._ngContentReservedSlots.length;
            const parameters = [literal(slot)];
            this._ngContentReservedSlots.push(ngContent.selector);
            const nonContentSelectAttributes = ngContent.attributes.filter(attr => attr.name.toLowerCase() !== NG_CONTENT_SELECT_ATTR$1);
            const attributes = this.getAttributeExpressions(ngContent.name, nonContentSelectAttributes, [], []);
            if (attributes.length > 0) {
                parameters.push(literal(projectionSlotIdx), literalArr(attributes));
            }
            else if (projectionSlotIdx !== 0) {
                parameters.push(literal(projectionSlotIdx));
            }
            this.creationInstruction(ngContent.sourceSpan, Identifiers.projection, parameters);
            if (this.i18n) {
                this.i18n.appendProjection(ngContent.i18n, slot);
            }
        }
        visitElement(element) {
            var _a, _b;
            const elementIndex = this.allocateDataSlot();
            const stylingBuilder = new StylingBuilder(null);
            let isNonBindableMode = false;
            const isI18nRootElement = isI18nRootNode(element.i18n) && !isSingleI18nIcu(element.i18n);
            const outputAttrs = [];
            const [namespaceKey, elementName] = splitNsName(element.name);
            const isNgContainer$1 = isNgContainer(element.name);
            // Handle styling, i18n, ngNonBindable attributes
            for (const attr of element.attributes) {
                const { name, value } = attr;
                if (name === NON_BINDABLE_ATTR) {
                    isNonBindableMode = true;
                }
                else if (name === 'style') {
                    stylingBuilder.registerStyleAttr(value);
                }
                else if (name === 'class') {
                    stylingBuilder.registerClassAttr(value);
                }
                else {
                    outputAttrs.push(attr);
                }
            }
            // Match directives on non i18n attributes
            this.matchDirectives(element.name, element);
            // Regular element or ng-container creation mode
            const parameters = [literal(elementIndex)];
            if (!isNgContainer$1) {
                parameters.push(literal(elementName));
            }
            // Add the attributes
            const allOtherInputs = [];
            const boundI18nAttrs = [];
            element.inputs.forEach(input => {
                const stylingInputWasSet = stylingBuilder.registerBoundInput(input);
                if (!stylingInputWasSet) {
                    if (input.type === 0 /* Property */ && input.i18n) {
                        boundI18nAttrs.push(input);
                    }
                    else {
                        allOtherInputs.push(input);
                    }
                }
            });
            // add attributes for directive and projection matching purposes
            const attributes = this.getAttributeExpressions(element.name, outputAttrs, allOtherInputs, element.outputs, stylingBuilder, [], boundI18nAttrs);
            parameters.push(this.addAttrsToConsts(attributes));
            // local refs (ex.: <div #foo #bar="baz">)
            const refs = this.prepareRefsArray(element.references);
            parameters.push(this.addToConsts(refs));
            const wasInNamespace = this._namespace;
            const currentNamespace = this.getNamespaceInstruction(namespaceKey);
            // If the namespace is changing now, include an instruction to change it
            // during element creation.
            if (currentNamespace !== wasInNamespace) {
                this.addNamespaceInstruction(currentNamespace, element);
            }
            if (this.i18n) {
                this.i18n.appendElement(element.i18n, elementIndex);
            }
            // Note that we do not append text node instructions and ICUs inside i18n section,
            // so we exclude them while calculating whether current element has children
            const hasChildren = (!isI18nRootElement && this.i18n) ? !hasTextChildrenOnly(element.children) :
                element.children.length > 0;
            const createSelfClosingInstruction = !stylingBuilder.hasBindingsWithPipes &&
                element.outputs.length === 0 && boundI18nAttrs.length === 0 && !hasChildren;
            const createSelfClosingI18nInstruction = !createSelfClosingInstruction && hasTextChildrenOnly(element.children);
            if (createSelfClosingInstruction) {
                this.creationInstruction(element.sourceSpan, isNgContainer$1 ? Identifiers.elementContainer : Identifiers.element, trimTrailingNulls(parameters));
            }
            else {
                this.creationInstruction(element.startSourceSpan, isNgContainer$1 ? Identifiers.elementContainerStart : Identifiers.elementStart, trimTrailingNulls(parameters));
                if (isNonBindableMode) {
                    this.creationInstruction(element.startSourceSpan, Identifiers.disableBindings);
                }
                if (boundI18nAttrs.length > 0) {
                    this.i18nAttributesInstruction(elementIndex, boundI18nAttrs, (_a = element.startSourceSpan) !== null && _a !== void 0 ? _a : element.sourceSpan);
                }
                // Generate Listeners (outputs)
                if (element.outputs.length > 0) {
                    const listeners = element.outputs.map((outputAst) => ({
                        sourceSpan: outputAst.sourceSpan,
                        params: this.prepareListenerParameter(element.name, outputAst, elementIndex)
                    }));
                    this.creationInstructionChain(Identifiers.listener, listeners);
                }
                // Note: it's important to keep i18n/i18nStart instructions after i18nAttributes and
                // listeners, to make sure i18nAttributes instruction targets current element at runtime.
                if (isI18nRootElement) {
                    this.i18nStart(element.startSourceSpan, element.i18n, createSelfClosingI18nInstruction);
                }
            }
            // the code here will collect all update-level styling instructions and add them to the
            // update block of the template function AOT code. Instructions like `styleProp`,
            // `styleMap`, `classMap`, `classProp`
            // are all generated and assigned in the code below.
            const stylingInstructions = stylingBuilder.buildUpdateLevelInstructions(this._valueConverter);
            const limit = stylingInstructions.length - 1;
            for (let i = 0; i <= limit; i++) {
                const instruction = stylingInstructions[i];
                this._bindingSlots += this.processStylingUpdateInstruction(elementIndex, instruction);
            }
            // the reason why `undefined` is used is because the renderer understands this as a
            // special value to symbolize that there is no RHS to this binding
            // TODO (matsko): revisit this once FW-959 is approached
            const emptyValueBindInstruction = literal(undefined);
            const propertyBindings = [];
            const attributeBindings = [];
            // Generate element input bindings
            allOtherInputs.forEach(input => {
                const inputType = input.type;
                if (inputType === 4 /* Animation */) {
                    const value = input.value.visit(this._valueConverter);
                    // animation bindings can be presented in the following formats:
                    // 1. [@binding]="fooExp"
                    // 2. [@binding]="{value:fooExp, params:{...}}"
                    // 3. [@binding]
                    // 4. @binding
                    // All formats will be valid for when a synthetic binding is created.
                    // The reasoning for this is because the renderer should get each
                    // synthetic binding value in the order of the array that they are
                    // defined in...
                    const hasValue = value instanceof LiteralPrimitive ? !!value.value : true;
                    this.allocateBindingSlots(value);
                    propertyBindings.push({
                        name: prepareSyntheticPropertyName(input.name),
                        sourceSpan: input.sourceSpan,
                        value: () => hasValue ? this.convertPropertyBinding(value) : emptyValueBindInstruction
                    });
                }
                else {
                    // we must skip attributes with associated i18n context, since these attributes are handled
                    // separately and corresponding `i18nExp` and `i18nApply` instructions will be generated
                    if (input.i18n)
                        return;
                    const value = input.value.visit(this._valueConverter);
                    if (value !== undefined) {
                        const params = [];
                        const [attrNamespace, attrName] = splitNsName(input.name);
                        const isAttributeBinding = inputType === 1 /* Attribute */;
                        const sanitizationRef = resolveSanitizationFn(input.securityContext, isAttributeBinding);
                        if (sanitizationRef)
                            params.push(sanitizationRef);
                        if (attrNamespace) {
                            const namespaceLiteral = literal(attrNamespace);
                            if (sanitizationRef) {
                                params.push(namespaceLiteral);
                            }
                            else {
                                // If there wasn't a sanitization ref, we need to add
                                // an extra param so that we can pass in the namespace.
                                params.push(literal(null), namespaceLiteral);
                            }
                        }
                        this.allocateBindingSlots(value);
                        if (inputType === 0 /* Property */) {
                            if (value instanceof Interpolation) {
                                // prop="{{value}}" and friends
                                this.interpolatedUpdateInstruction(getPropertyInterpolationExpression(value), elementIndex, attrName, input, value, params);
                            }
                            else {
                                // [prop]="value"
                                // Collect all the properties so that we can chain into a single function at the end.
                                propertyBindings.push({
                                    name: attrName,
                                    sourceSpan: input.sourceSpan,
                                    value: () => this.convertPropertyBinding(value),
                                    params
                                });
                            }
                        }
                        else if (inputType === 1 /* Attribute */) {
                            if (value instanceof Interpolation && getInterpolationArgsLength(value) > 1) {
                                // attr.name="text{{value}}" and friends
                                this.interpolatedUpdateInstruction(getAttributeInterpolationExpression(value), elementIndex, attrName, input, value, params);
                            }
                            else {
                                const boundValue = value instanceof Interpolation ? value.expressions[0] : value;
                                // [attr.name]="value" or attr.name="{{value}}"
                                // Collect the attribute bindings so that they can be chained at the end.
                                attributeBindings.push({
                                    name: attrName,
                                    sourceSpan: input.sourceSpan,
                                    value: () => this.convertPropertyBinding(boundValue),
                                    params
                                });
                            }
                        }
                        else {
                            // class prop
                            this.updateInstructionWithAdvance(elementIndex, input.sourceSpan, Identifiers.classProp, () => {
                                return [
                                    literal(elementIndex), literal(attrName), this.convertPropertyBinding(value),
                                    ...params
                                ];
                            });
                        }
                    }
                }
            });
            if (propertyBindings.length > 0) {
                this.updateInstructionChainWithAdvance(elementIndex, Identifiers.property, propertyBindings);
            }
            if (attributeBindings.length > 0) {
                this.updateInstructionChainWithAdvance(elementIndex, Identifiers.attribute, attributeBindings);
            }
            // Traverse element child nodes
            visitAll(this, element.children);
            if (!isI18nRootElement && this.i18n) {
                this.i18n.appendElement(element.i18n, elementIndex, true);
            }
            if (!createSelfClosingInstruction) {
                // Finish element construction mode.
                const span = (_b = element.endSourceSpan) !== null && _b !== void 0 ? _b : element.sourceSpan;
                if (isI18nRootElement) {
                    this.i18nEnd(span, createSelfClosingI18nInstruction);
                }
                if (isNonBindableMode) {
                    this.creationInstruction(span, Identifiers.enableBindings);
                }
                this.creationInstruction(span, isNgContainer$1 ? Identifiers.elementContainerEnd : Identifiers.elementEnd);
            }
        }
        visitTemplate(template) {
            var _a;
            const NG_TEMPLATE_TAG_NAME = 'ng-template';
            const templateIndex = this.allocateDataSlot();
            if (this.i18n) {
                this.i18n.appendTemplate(template.i18n, templateIndex);
            }
            const tagNameWithoutNamespace = template.tagName ? splitNsName(template.tagName)[1] : template.tagName;
            const contextName = `${this.contextName}${template.tagName ? '_' + sanitizeIdentifier(template.tagName) : ''}_${templateIndex}`;
            const templateName = `${contextName}_Template`;
            const parameters = [
                literal(templateIndex),
                variable(templateName),
                // We don't care about the tag's namespace here, because we infer
                // it based on the parent nodes inside the template instruction.
                literal(tagNameWithoutNamespace),
            ];
            // find directives matching on a given <ng-template> node
            this.matchDirectives(NG_TEMPLATE_TAG_NAME, template);
            // prepare attributes parameter (including attributes used for directive matching)
            const attrsExprs = this.getAttributeExpressions(NG_TEMPLATE_TAG_NAME, template.attributes, template.inputs, template.outputs, undefined /* styles */, template.templateAttrs);
            parameters.push(this.addAttrsToConsts(attrsExprs));
            // local refs (ex.: <ng-template #foo>)
            if (template.references && template.references.length) {
                const refs = this.prepareRefsArray(template.references);
                parameters.push(this.addToConsts(refs));
                parameters.push(importExpr(Identifiers.templateRefExtractor));
            }
            // Create the template function
            const templateVisitor = new TemplateDefinitionBuilder(this.constantPool, this._bindingScope, this.level + 1, contextName, this.i18n, templateIndex, templateName, this.directiveMatcher, this.directives, this.pipeTypeByName, this.pipes, this._namespace, this.fileBasedI18nSuffix, this.i18nUseExternalIds, this._constants);
            // Nested templates must not be visited until after their parent templates have completed
            // processing, so they are queued here until after the initial pass. Otherwise, we wouldn't
            // be able to support bindings in nested templates to local refs that occur after the
            // template definition. e.g. <div *ngIf="showing">{{ foo }}</div>  <div #foo></div>
            this._nestedTemplateFns.push(() => {
                const templateFunctionExpr = templateVisitor.buildTemplateFunction(template.children, template.variables, this._ngContentReservedSlots.length + this._ngContentSelectorsOffset, template.i18n);
                this.constantPool.statements.push(templateFunctionExpr.toDeclStmt(templateName));
                if (templateVisitor._ngContentReservedSlots.length) {
                    this._ngContentReservedSlots.push(...templateVisitor._ngContentReservedSlots);
                }
            });
            // e.g. template(1, MyComp_Template_1)
            this.creationInstruction(template.sourceSpan, Identifiers.templateCreate, () => {
                parameters.splice(2, 0, literal(templateVisitor.getConstCount()), literal(templateVisitor.getVarCount()));
                return trimTrailingNulls(parameters);
            });
            // handle property bindings e.g. ÉµÉµproperty('ngForOf', ctx.items), et al;
            this.templatePropertyBindings(templateIndex, template.templateAttrs);
            // Only add normal input/output binding instructions on explicit <ng-template> elements.
            if (tagNameWithoutNamespace === NG_TEMPLATE_TAG_NAME) {
                const [i18nInputs, inputs] = partitionArray(template.inputs, hasI18nMeta);
                // Add i18n attributes that may act as inputs to directives. If such attributes are present,
                // generate `i18nAttributes` instruction. Note: we generate it only for explicit <ng-template>
                // elements, in case of inline templates, corresponding instructions will be generated in the
                // nested template function.
                if (i18nInputs.length > 0) {
                    this.i18nAttributesInstruction(templateIndex, i18nInputs, (_a = template.startSourceSpan) !== null && _a !== void 0 ? _a : template.sourceSpan);
                }
                // Add the input bindings
                if (inputs.length > 0) {
                    this.templatePropertyBindings(templateIndex, inputs);
                }
                // Generate listeners for directive output
                if (template.outputs.length > 0) {
                    const listeners = template.outputs.map((outputAst) => ({
                        sourceSpan: outputAst.sourceSpan,
                        params: this.prepareListenerParameter('ng_template', outputAst, templateIndex)
                    }));
                    this.creationInstructionChain(Identifiers.listener, listeners);
                }
            }
        }
        visitBoundText(text) {
            if (this.i18n) {
                const value = text.value.visit(this._valueConverter);
                this.allocateBindingSlots(value);
                if (value instanceof Interpolation) {
                    this.i18n.appendBoundText(text.i18n);
                    this.i18nAppendBindings(value.expressions);
                }
                return;
            }
            const nodeIndex = this.allocateDataSlot();
            this.creationInstruction(text.sourceSpan, Identifiers.text, [literal(nodeIndex)]);
            const value = text.value.visit(this._valueConverter);
            this.allocateBindingSlots(value);
            if (value instanceof Interpolation) {
                this.updateInstructionWithAdvance(nodeIndex, text.sourceSpan, getTextInterpolationExpression(value), () => this.getUpdateInstructionArguments(value));
            }
            else {
                error('Text nodes should be interpolated and never bound directly.');
            }
        }
        visitText(text) {
            // when a text element is located within a translatable
            // block, we exclude this text element from instructions set,
            // since it will be captured in i18n content and processed at runtime
            if (!this.i18n) {
                this.creationInstruction(text.sourceSpan, Identifiers.text, [literal(this.allocateDataSlot()), literal(text.value)]);
            }
        }
        visitIcu(icu) {
            let initWasInvoked = false;
            // if an ICU was created outside of i18n block, we still treat
            // it as a translatable entity and invoke i18nStart and i18nEnd
            // to generate i18n context and the necessary instructions
            if (!this.i18n) {
                initWasInvoked = true;
                this.i18nStart(null, icu.i18n, true);
            }
            const i18n = this.i18n;
            const vars = this.i18nBindProps(icu.vars);
            const placeholders = this.i18nBindProps(icu.placeholders);
            // output ICU directly and keep ICU reference in context
            const message = icu.i18n;
            // we always need post-processing function for ICUs, to make sure that:
            // - all placeholders in a form of {PLACEHOLDER} are replaced with actual values (note:
            // `goog.getMsg` does not process ICUs and uses the `{PLACEHOLDER}` format for placeholders
            // inside ICUs)
            // - all ICU vars (such as `VAR_SELECT` or `VAR_PLURAL`) are replaced with correct values
            const transformFn = (raw) => {
                const params = Object.assign(Object.assign({}, vars), placeholders);
                const formatted = i18nFormatPlaceholderNames(params, /* useCamelCase */ false);
                return instruction(null, Identifiers.i18nPostprocess, [raw, mapLiteral(formatted, true)]);
            };
            // in case the whole i18n message is a single ICU - we do not need to
            // create a separate top-level translation, we can use the root ref instead
            // and make this ICU a top-level translation
            // note: ICU placeholders are replaced with actual values in `i18nPostprocess` function
            // separately, so we do not pass placeholders into `i18nTranslate` function.
            if (isSingleI18nIcu(i18n.meta)) {
                this.i18nTranslate(message, /* placeholders */ {}, i18n.ref, transformFn);
            }
            else {
                // output ICU directly and keep ICU reference in context
                const ref = this.i18nTranslate(message, /* placeholders */ {}, /* ref */ undefined, transformFn);
                i18n.appendIcu(icuFromI18nMessage(message).name, ref);
            }
            if (initWasInvoked) {
                this.i18nEnd(null, true);
            }
            return null;
        }
        allocateDataSlot() {
            return this._dataIndex++;
        }
        getConstCount() {
            return this._dataIndex;
        }
        getVarCount() {
            return this._pureFunctionSlots;
        }
        getConsts() {
            return this._constants;
        }
        getNgContentSelectors() {
            return this._ngContentReservedSlots.length ?
                this.constantPool.getConstLiteral(asLiteral(this._ngContentReservedSlots), true) :
                null;
        }
        bindingContext() {
            return `${this._bindingContext++}`;
        }
        templatePropertyBindings(templateIndex, attrs) {
            const propertyBindings = [];
            attrs.forEach(input => {
                if (input instanceof BoundAttribute) {
                    const value = input.value.visit(this._valueConverter);
                    if (value !== undefined) {
                        this.allocateBindingSlots(value);
                        if (value instanceof Interpolation) {
                            // Params typically contain attribute namespace and value sanitizer, which is applicable
                            // for regular HTML elements, but not applicable for <ng-template> (since props act as
                            // inputs to directives), so keep params array empty.
                            const params = [];
                            // prop="{{value}}" case
                            this.interpolatedUpdateInstruction(getPropertyInterpolationExpression(value), templateIndex, input.name, input, value, params);
                        }
                        else {
                            // [prop]="value" case
                            propertyBindings.push({
                                name: input.name,
                                sourceSpan: input.sourceSpan,
                                value: () => this.convertPropertyBinding(value)
                            });
                        }
                    }
                }
            });
            if (propertyBindings.length > 0) {
                this.updateInstructionChainWithAdvance(templateIndex, Identifiers.property, propertyBindings);
            }
        }
        // Bindings must only be resolved after all local refs have been visited, so all
        // instructions are queued in callbacks that execute once the initial pass has completed.
        // Otherwise, we wouldn't be able to support local refs that are defined after their
        // bindings. e.g. {{ foo }} <div #foo></div>
        instructionFn(fns, span, reference, paramsOrFn, prepend = false) {
            fns[prepend ? 'unshift' : 'push'](() => {
                const params = Array.isArray(paramsOrFn) ? paramsOrFn : paramsOrFn();
                return instruction(span, reference, params).toStmt();
            });
        }
        processStylingUpdateInstruction(elementIndex, instruction) {
            let allocateBindingSlots = 0;
            if (instruction) {
                const calls = [];
                instruction.calls.forEach(call => {
                    allocateBindingSlots += call.allocateBindingSlots;
                    calls.push({
                        sourceSpan: call.sourceSpan,
                        value: () => {
                            return call.params(value => (call.supportsInterpolation && value instanceof Interpolation) ?
                                this.getUpdateInstructionArguments(value) :
                                this.convertPropertyBinding(value));
                        }
                    });
                });
                this.updateInstructionChainWithAdvance(elementIndex, instruction.reference, calls);
            }
            return allocateBindingSlots;
        }
        creationInstruction(span, reference, paramsOrFn, prepend) {
            this.instructionFn(this._creationCodeFns, span, reference, paramsOrFn || [], prepend);
        }
        creationInstructionChain(reference, calls) {
            const span = calls.length ? calls[0].sourceSpan : null;
            this._creationCodeFns.push(() => {
                return chainedInstruction(reference, calls.map(call => call.params()), span).toStmt();
            });
        }
        updateInstructionWithAdvance(nodeIndex, span, reference, paramsOrFn) {
            this.addAdvanceInstructionIfNecessary(nodeIndex, span);
            this.updateInstruction(span, reference, paramsOrFn);
        }
        updateInstruction(span, reference, paramsOrFn) {
            this.instructionFn(this._updateCodeFns, span, reference, paramsOrFn || []);
        }
        updateInstructionChain(reference, bindings) {
            const span = bindings.length ? bindings[0].sourceSpan : null;
            this._updateCodeFns.push(() => {
                const calls = bindings.map(property => {
                    const value = property.value();
                    const fnParams = Array.isArray(value) ? value : [value];
                    if (property.params) {
                        fnParams.push(...property.params);
                    }
                    if (property.name) {
                        // We want the property name to always be the first function parameter.
                        fnParams.unshift(literal(property.name));
                    }
                    return fnParams;
                });
                return chainedInstruction(reference, calls, span).toStmt();
            });
        }
        updateInstructionChainWithAdvance(nodeIndex, reference, bindings) {
            this.addAdvanceInstructionIfNecessary(nodeIndex, bindings.length ? bindings[0].sourceSpan : null);
            this.updateInstructionChain(reference, bindings);
        }
        addAdvanceInstructionIfNecessary(nodeIndex, span) {
            if (nodeIndex !== this._currentIndex) {
                const delta = nodeIndex - this._currentIndex;
                if (delta < 1) {
                    throw new Error('advance instruction can only go forwards');
                }
                this.instructionFn(this._updateCodeFns, span, Identifiers.advance, [literal(delta)]);
                this._currentIndex = nodeIndex;
            }
        }
        allocatePureFunctionSlots(numSlots) {
            const originalSlots = this._pureFunctionSlots;
            this._pureFunctionSlots += numSlots;
            return originalSlots;
        }
        allocateBindingSlots(value) {
            this._bindingSlots += value instanceof Interpolation ? value.expressions.length : 1;
        }
        /**
         * Gets an expression that refers to the implicit receiver. The implicit
         * receiver is always the root level context.
         */
        getImplicitReceiverExpr() {
            if (this._implicitReceiverExpr) {
                return this._implicitReceiverExpr;
            }
            return this._implicitReceiverExpr = this.level === 0 ?
                variable(CONTEXT_NAME) :
                this._bindingScope.getOrCreateSharedContextVar(0);
        }
        convertPropertyBinding(value) {
            const convertedPropertyBinding = convertPropertyBinding(this, this.getImplicitReceiverExpr(), value, this.bindingContext(), BindingForm.Expression, () => error('Unexpected interpolation'));
            const valExpr = convertedPropertyBinding.currValExpr;
            this._tempVariables.push(...convertedPropertyBinding.stmts);
            return valExpr;
        }
        /**
         * Gets a list of argument expressions to pass to an update instruction expression. Also updates
         * the temp variables state with temp variables that were identified as needing to be created
         * while visiting the arguments.
         * @param value The original expression we will be resolving an arguments list from.
         */
        getUpdateInstructionArguments(value) {
            const { args, stmts } = convertUpdateArguments(this, this.getImplicitReceiverExpr(), value, this.bindingContext());
            this._tempVariables.push(...stmts);
            return args;
        }
        matchDirectives(elementName, elOrTpl) {
            if (this.directiveMatcher) {
                const selector = createCssSelector(elementName, getAttrsForDirectiveMatching(elOrTpl));
                this.directiveMatcher.match(selector, (cssSelector, staticType) => {
                    this.directives.add(staticType);
                });
            }
        }
        /**
         * Prepares all attribute expression values for the `TAttributes` array.
         *
         * The purpose of this function is to properly construct an attributes array that
         * is passed into the `elementStart` (or just `element`) functions. Because there
         * are many different types of attributes, the array needs to be constructed in a
         * special way so that `elementStart` can properly evaluate them.
         *
         * The format looks like this:
         *
         * ```
         * attrs = [prop, value, prop2, value2,
         *   PROJECT_AS, selector,
         *   CLASSES, class1, class2,
         *   STYLES, style1, value1, style2, value2,
         *   BINDINGS, name1, name2, name3,
         *   TEMPLATE, name4, name5, name6,
         *   I18N, name7, name8, ...]
         * ```
         *
         * Note that this function will fully ignore all synthetic (@foo) attribute values
         * because those values are intended to always be generated as property instructions.
         */
        getAttributeExpressions(elementName, renderAttributes, inputs, outputs, styles, templateAttrs = [], boundI18nAttrs = []) {
            const alreadySeen = new Set();
            const attrExprs = [];
            let ngProjectAsAttr;
            for (const attr of renderAttributes) {
                if (attr.name === NG_PROJECT_AS_ATTR_NAME) {
                    ngProjectAsAttr = attr;
                }
                // Note that static i18n attributes aren't in the i18n array,
                // because they're treated in the same way as regular attributes.
                if (attr.i18n) {
                    // When i18n attributes are present on elements with structural directives
                    // (e.g. `<div *ngIf title="Hello" i18n-title>`), we want to avoid generating
                    // duplicate i18n translation blocks for `ÉµÉµtemplate` and `ÉµÉµelement` instruction
                    // attributes. So we do a cache lookup to see if suitable i18n translation block
                    // already exists.
                    const { i18nVarRefsCache } = this._constants;
                    let i18nVarRef;
                    if (i18nVarRefsCache.has(attr.i18n)) {
                        i18nVarRef = i18nVarRefsCache.get(attr.i18n);
                    }
                    else {
                        i18nVarRef = this.i18nTranslate(attr.i18n);
                        i18nVarRefsCache.set(attr.i18n, i18nVarRef);
                    }
                    attrExprs.push(literal(attr.name), i18nVarRef);
                }
                else {
                    attrExprs.push(...getAttributeNameLiterals(attr.name), trustedConstAttribute(elementName, attr));
                }
            }
            // Keep ngProjectAs next to the other name, value pairs so we can verify that we match
            // ngProjectAs marker in the attribute name slot.
            if (ngProjectAsAttr) {
                attrExprs.push(...getNgProjectAsLiteral(ngProjectAsAttr));
            }
            function addAttrExpr(key, value) {
                if (typeof key === 'string') {
                    if (!alreadySeen.has(key)) {
                        attrExprs.push(...getAttributeNameLiterals(key));
                        value !== undefined && attrExprs.push(value);
                        alreadySeen.add(key);
                    }
                }
                else {
                    attrExprs.push(literal(key));
                }
            }
            // it's important that this occurs before BINDINGS and TEMPLATE because once `elementStart`
            // comes across the BINDINGS or TEMPLATE markers then it will continue reading each value as
            // as single property value cell by cell.
            if (styles) {
                styles.populateInitialStylingAttrs(attrExprs);
            }
            if (inputs.length || outputs.length) {
                const attrsLengthBeforeInputs = attrExprs.length;
                for (let i = 0; i < inputs.length; i++) {
                    const input = inputs[i];
                    // We don't want the animation and attribute bindings in the
                    // attributes array since they aren't used for directive matching.
                    if (input.type !== 4 /* Animation */ && input.type !== 1 /* Attribute */) {
                        addAttrExpr(input.name);
                    }
                }
                for (let i = 0; i < outputs.length; i++) {
                    const output = outputs[i];
                    if (output.type !== 1 /* Animation */) {
                        addAttrExpr(output.name);
                    }
                }
                // this is a cheap way of adding the marker only after all the input/output
                // values have been filtered (by not including the animation ones) and added
                // to the expressions. The marker is important because it tells the runtime
                // code that this is where attributes without values start...
                if (attrExprs.length !== attrsLengthBeforeInputs) {
                    attrExprs.splice(attrsLengthBeforeInputs, 0, literal(3 /* Bindings */));
                }
            }
            if (templateAttrs.length) {
                attrExprs.push(literal(4 /* Template */));
                templateAttrs.forEach(attr => addAttrExpr(attr.name));
            }
            if (boundI18nAttrs.length) {
                attrExprs.push(literal(6 /* I18n */));
                boundI18nAttrs.forEach(attr => addAttrExpr(attr.name));
            }
            return attrExprs;
        }
        addToConsts(expression) {
            if (isNull(expression)) {
                return TYPED_NULL_EXPR;
            }
            const consts = this._constants.constExpressions;
            // Try to reuse a literal that's already in the array, if possible.
            for (let i = 0; i < consts.length; i++) {
                if (consts[i].isEquivalent(expression)) {
                    return literal(i);
                }
            }
            return literal(consts.push(expression) - 1);
        }
        addAttrsToConsts(attrs) {
            return attrs.length > 0 ? this.addToConsts(literalArr(attrs)) : TYPED_NULL_EXPR;
        }
        prepareRefsArray(references) {
            if (!references || references.length === 0) {
                return TYPED_NULL_EXPR;
            }
            const refsParam = flatten(references.map(reference => {
                const slot = this.allocateDataSlot();
                // Generate the update temporary.
                const variableName = this._bindingScope.freshReferenceName();
                const retrievalLevel = this.level;
                const lhs = variable(variableName);
                this._bindingScope.set(retrievalLevel, reference.name, lhs, 0 /* DEFAULT */, (scope, relativeLevel) => {
                    // e.g. nextContext(2);
                    const nextContextStmt = relativeLevel > 0 ? [generateNextContextExpr(relativeLevel).toStmt()] : [];
                    // e.g. const $foo$ = reference(1);
                    const refExpr = lhs.set(importExpr(Identifiers.reference).callFn([literal(slot)]));
                    return nextContextStmt.concat(refExpr.toConstDecl());
                }, true);
                return [reference.name, reference.value];
            }));
            return asLiteral(refsParam);
        }
        prepareListenerParameter(tagName, outputAst, index) {
            return () => {
                const eventName = outputAst.name;
                const bindingFnName = outputAst.type === 1 /* Animation */ ?
                    // synthetic @listener.foo values are treated the exact same as are standard listeners
                    prepareSyntheticListenerFunctionName(eventName, outputAst.phase) :
                    sanitizeIdentifier(eventName);
                const handlerName = `${this.templateName}_${tagName}_${bindingFnName}_${index}_listener`;
                const scope = this._bindingScope.nestedScope(this._bindingScope.bindingLevel, EVENT_BINDING_SCOPE_GLOBALS);
                return prepareEventListenerParameters(outputAst, handlerName, scope);
            };
        }
    }
    class ValueConverter extends AstMemoryEfficientTransformer {
        constructor(constantPool, allocateSlot, allocatePureFunctionSlots, definePipe) {
            super();
            this.constantPool = constantPool;
            this.allocateSlot = allocateSlot;
            this.allocatePureFunctionSlots = allocatePureFunctionSlots;
            this.definePipe = definePipe;
            this._pipeBindExprs = [];
        }
        // AstMemoryEfficientTransformer
        visitPipe(pipe, context) {
            // Allocate a slot to create the pipe
            const slot = this.allocateSlot();
            const slotPseudoLocal = `PIPE:${slot}`;
            // Allocate one slot for the result plus one slot per pipe argument
            const pureFunctionSlot = this.allocatePureFunctionSlots(2 + pipe.args.length);
            const target = new PropertyRead(pipe.span, pipe.sourceSpan, pipe.nameSpan, new ImplicitReceiver(pipe.span, pipe.sourceSpan), slotPseudoLocal);
            const { identifier, isVarLength } = pipeBindingCallInfo(pipe.args);
            this.definePipe(pipe.name, slotPseudoLocal, slot, importExpr(identifier));
            const args = [pipe.exp, ...pipe.args];
            const convertedArgs = isVarLength ?
                this.visitAll([new LiteralArray(pipe.span, pipe.sourceSpan, args)]) :
                this.visitAll(args);
            const pipeBindExpr = new FunctionCall(pipe.span, pipe.sourceSpan, target, [
                new LiteralPrimitive(pipe.span, pipe.sourceSpan, slot),
                new LiteralPrimitive(pipe.span, pipe.sourceSpan, pureFunctionSlot),
                ...convertedArgs,
            ]);
            this._pipeBindExprs.push(pipeBindExpr);
            return pipeBindExpr;
        }
        updatePipeSlotOffsets(bindingSlots) {
            this._pipeBindExprs.forEach((pipe) => {
                // update the slot offset arg (index 1) to account for binding slots
                const slotOffset = pipe.args[1];
                slotOffset.value += bindingSlots;
            });
        }
        visitLiteralArray(array, context) {
            return new BuiltinFunctionCall(array.span, array.sourceSpan, this.visitAll(array.expressions), values => {
                // If the literal has calculated (non-literal) elements transform it into
                // calls to literal factories that compose the literal and will cache intermediate
                // values.
                const literal = literalArr(values);
                return getLiteralFactory(this.constantPool, literal, this.allocatePureFunctionSlots);
            });
        }
        visitLiteralMap(map, context) {
            return new BuiltinFunctionCall(map.span, map.sourceSpan, this.visitAll(map.values), values => {
                // If the literal has calculated (non-literal) elements  transform it into
                // calls to literal factories that compose the literal and will cache intermediate
                // values.
                const literal = literalMap(values.map((value, index) => ({ key: map.keys[index].key, value, quoted: map.keys[index].quoted })));
                return getLiteralFactory(this.constantPool, literal, this.allocatePureFunctionSlots);
            });
        }
    }
    // Pipes always have at least one parameter, the value they operate on
    const pipeBindingIdentifiers = [Identifiers.pipeBind1, Identifiers.pipeBind2, Identifiers.pipeBind3, Identifiers.pipeBind4];
    function pipeBindingCallInfo(args) {
        const identifier = pipeBindingIdentifiers[args.length];
        return {
            identifier: identifier || Identifiers.pipeBindV,
            isVarLength: !identifier,
        };
    }
    const pureFunctionIdentifiers = [
        Identifiers.pureFunction0, Identifiers.pureFunction1, Identifiers.pureFunction2, Identifiers.pureFunction3, Identifiers.pureFunction4,
        Identifiers.pureFunction5, Identifiers.pureFunction6, Identifiers.pureFunction7, Identifiers.pureFunction8
    ];
    function pureFunctionCallInfo(args) {
        const identifier = pureFunctionIdentifiers[args.length];
        return {
            identifier: identifier || Identifiers.pureFunctionV,
            isVarLength: !identifier,
        };
    }
    function instruction(span, reference, params) {
        return importExpr(reference, null, span).callFn(params, span);
    }
    // e.g. x(2);
    function generateNextContextExpr(relativeLevelDiff) {
        return importExpr(Identifiers.nextContext)
            .callFn(relativeLevelDiff > 1 ? [literal(relativeLevelDiff)] : []);
    }
    function getLiteralFactory(constantPool, literal$1, allocateSlots) {
        const { literalFactory, literalFactoryArguments } = constantPool.getLiteralFactory(literal$1);
        // Allocate 1 slot for the result plus 1 per argument
        const startSlot = allocateSlots(1 + literalFactoryArguments.length);
        const { identifier, isVarLength } = pureFunctionCallInfo(literalFactoryArguments);
        // Literal factories are pure functions that only need to be re-invoked when the parameters
        // change.
        const args = [literal(startSlot), literalFactory];
        if (isVarLength) {
            args.push(literalArr(literalFactoryArguments));
        }
        else {
            args.push(...literalFactoryArguments);
        }
        return importExpr(identifier).callFn(args);
    }
    /**
     * Gets an array of literals that can be added to an expression
     * to represent the name and namespace of an attribute. E.g.
     * `:xlink:href` turns into `[AttributeMarker.NamespaceURI, 'xlink', 'href']`.
     *
     * @param name Name of the attribute, including the namespace.
     */
    function getAttributeNameLiterals(name) {
        const [attributeNamespace, attributeName] = splitNsName(name);
        const nameLiteral = literal(attributeName);
        if (attributeNamespace) {
            return [
                literal(0 /* NamespaceURI */), literal(attributeNamespace), nameLiteral
            ];
        }
        return [nameLiteral];
    }
    /** The prefix used to get a shared context in BindingScope's map. */
    const SHARED_CONTEXT_KEY = '$$shared_ctx$$';
    class BindingScope {
        constructor(bindingLevel = 0, parent = null, globals) {
            this.bindingLevel = bindingLevel;
            this.parent = parent;
            this.globals = globals;
            /** Keeps a map from local variables to their BindingData. */
            this.map = new Map();
            this.referenceNameIndex = 0;
            this.restoreViewVariable = null;
            this.usesRestoredViewContext = false;
            if (globals !== undefined) {
                for (const name of globals) {
                    this.set(0, name, variable(name));
                }
            }
        }
        static createRootScope() {
            return new BindingScope();
        }
        get(name) {
            let current = this;
            while (current) {
                let value = current.map.get(name);
                if (value != null) {
                    if (current !== this) {
                        // make a local copy and reset the `declare` state
                        value = {
                            retrievalLevel: value.retrievalLevel,
                            lhs: value.lhs,
                            declareLocalCallback: value.declareLocalCallback,
                            declare: false,
                            priority: value.priority
                        };
                        // Cache the value locally.
                        this.map.set(name, value);
                        // Possibly generate a shared context var
                        this.maybeGenerateSharedContextVar(value);
                        this.maybeRestoreView();
                    }
                    if (value.declareLocalCallback && !value.declare) {
                        value.declare = true;
                    }
                    return value.lhs;
                }
                current = current.parent;
            }
            // If we get to this point, we are looking for a property on the top level component
            // - If level === 0, we are on the top and don't need to re-declare `ctx`.
            // - If level > 0, we are in an embedded view. We need to retrieve the name of the
            // local var we used to store the component context, e.g. const $comp$ = x();
            return this.bindingLevel === 0 ? null : this.getComponentProperty(name);
        }
        /**
         * Create a local variable for later reference.
         *
         * @param retrievalLevel The level from which this value can be retrieved
         * @param name Name of the variable.
         * @param lhs AST representing the left hand side of the `let lhs = rhs;`.
         * @param priority The sorting priority of this var
         * @param declareLocalCallback The callback to invoke when declaring this local var
         * @param localRef Whether or not this is a local ref
         */
        set(retrievalLevel, name, lhs, priority = 0 /* DEFAULT */, declareLocalCallback, localRef) {
            if (this.map.has(name)) {
                if (localRef) {
                    // Do not throw an error if it's a local ref and do not update existing value,
                    // so the first defined ref is always returned.
                    return this;
                }
                error(`The name ${name} is already defined in scope to be ${this.map.get(name)}`);
            }
            this.map.set(name, {
                retrievalLevel: retrievalLevel,
                lhs: lhs,
                declare: false,
                declareLocalCallback: declareLocalCallback,
                priority: priority,
            });
            return this;
        }
        // Implemented as part of LocalResolver.
        getLocal(name) {
            return this.get(name);
        }
        // Implemented as part of LocalResolver.
        notifyImplicitReceiverUse() {
            if (this.bindingLevel !== 0) {
                // Since the implicit receiver is accessed in an embedded view, we need to
                // ensure that we declare a shared context variable for the current template
                // in the update variables.
                this.map.get(SHARED_CONTEXT_KEY + 0).declare = true;
            }
        }
        nestedScope(level, globals) {
            const newScope = new BindingScope(level, this, globals);
            if (level > 0)
                newScope.generateSharedContextVar(0);
            return newScope;
        }
        /**
         * Gets or creates a shared context variable and returns its expression. Note that
         * this does not mean that the shared variable will be declared. Variables in the
         * binding scope will be only declared if they are used.
         */
        getOrCreateSharedContextVar(retrievalLevel) {
            const bindingKey = SHARED_CONTEXT_KEY + retrievalLevel;
            if (!this.map.has(bindingKey)) {
                this.generateSharedContextVar(retrievalLevel);
            }
            // Shared context variables are always generated as "ReadVarExpr".
            return this.map.get(bindingKey).lhs;
        }
        getSharedContextName(retrievalLevel) {
            const sharedCtxObj = this.map.get(SHARED_CONTEXT_KEY + retrievalLevel);
            // Shared context variables are always generated as "ReadVarExpr".
            return sharedCtxObj && sharedCtxObj.declare ? sharedCtxObj.lhs : null;
        }
        maybeGenerateSharedContextVar(value) {
            if (value.priority === 1 /* CONTEXT */ &&
                value.retrievalLevel < this.bindingLevel) {
                const sharedCtxObj = this.map.get(SHARED_CONTEXT_KEY + value.retrievalLevel);
                if (sharedCtxObj) {
                    sharedCtxObj.declare = true;
                }
                else {
                    this.generateSharedContextVar(value.retrievalLevel);
                }
            }
        }
        generateSharedContextVar(retrievalLevel) {
            const lhs = variable(CONTEXT_NAME + this.freshReferenceName());
            this.map.set(SHARED_CONTEXT_KEY + retrievalLevel, {
                retrievalLevel: retrievalLevel,
                lhs: lhs,
                declareLocalCallback: (scope, relativeLevel) => {
                    // const ctx_r0 = nextContext(2);
                    return [lhs.set(generateNextContextExpr(relativeLevel)).toConstDecl()];
                },
                declare: false,
                priority: 2 /* SHARED_CONTEXT */,
            });
        }
        getComponentProperty(name) {
            const componentValue = this.map.get(SHARED_CONTEXT_KEY + 0);
            componentValue.declare = true;
            this.maybeRestoreView();
            return componentValue.lhs.prop(name);
        }
        maybeRestoreView() {
            // View restoration is required for listener instructions inside embedded views, because
            // they only run in creation mode and they can have references to the context object.
            // If the context object changes in update mode, the reference will be incorrect, because
            // it was established during creation.
            if (this.isListenerScope()) {
                if (!this.parent.restoreViewVariable) {
                    // parent saves variable to generate a shared `const $s$ = getCurrentView();` instruction
                    this.parent.restoreViewVariable = variable(this.parent.freshReferenceName());
                }
                this.restoreViewVariable = this.parent.restoreViewVariable;
            }
        }
        restoreViewStatement() {
            const statements = [];
            if (this.restoreViewVariable) {
                const restoreCall = instruction(null, Identifiers.restoreView, [this.restoreViewVariable]);
                // Either `const restoredCtx = restoreView($state$);` or `restoreView($state$);`
                // depending on whether it is being used.
                statements.push(this.usesRestoredViewContext ?
                    variable(RESTORED_VIEW_CONTEXT_NAME).set(restoreCall).toConstDecl() :
                    restoreCall.toStmt());
            }
            return statements;
        }
        viewSnapshotStatements() {
            // const $state$ = getCurrentView();
            return this.restoreViewVariable ?
                [this.restoreViewVariable.set(instruction(null, Identifiers.getCurrentView, [])).toConstDecl()] :
                [];
        }
        isListenerScope() {
            return this.parent && this.parent.bindingLevel === this.bindingLevel;
        }
        variableDeclarations() {
            let currentContextLevel = 0;
            return Array.from(this.map.values())
                .filter(value => value.declare)
                .sort((a, b) => b.retrievalLevel - a.retrievalLevel || b.priority - a.priority)
                .reduce((stmts, value) => {
                const levelDiff = this.bindingLevel - value.retrievalLevel;
                const currStmts = value.declareLocalCallback(this, levelDiff - currentContextLevel);
                currentContextLevel = levelDiff;
                return stmts.concat(currStmts);
            }, []);
        }
        freshReferenceName() {
            let current = this;
            // Find the top scope as it maintains the global reference count
            while (current.parent)
                current = current.parent;
            const ref = `${REFERENCE_PREFIX}${current.referenceNameIndex++}`;
            return ref;
        }
        hasRestoreViewVariable() {
            return !!this.restoreViewVariable;
        }
        notifyRestoredViewContextUse() {
            this.usesRestoredViewContext = true;
        }
    }
    /**
     * Creates a `CssSelector` given a tag name and a map of attributes
     */
    function createCssSelector(elementName, attributes) {
        const cssSelector = new CssSelector();
        const elementNameNoNs = splitNsName(elementName)[1];
        cssSelector.setElement(elementNameNoNs);
        Object.getOwnPropertyNames(attributes).forEach((name) => {
            const nameNoNs = splitNsName(name)[1];
            const value = attributes[name];
            cssSelector.addAttribute(nameNoNs, value);
            if (name.toLowerCase() === 'class') {
                const classes = value.trim().split(/\s+/);
                classes.forEach(className => cssSelector.addClassName(className));
            }
        });
        return cssSelector;
    }
    /**
     * Creates an array of expressions out of an `ngProjectAs` attributes
     * which can be added to the instruction parameters.
     */
    function getNgProjectAsLiteral(attribute) {
        // Parse the attribute value into a CssSelectorList. Note that we only take the
        // first selector, because we don't support multiple selectors in ngProjectAs.
        const parsedR3Selector = parseSelectorToR3Selector(attribute.value)[0];
        return [literal(5 /* ProjectAs */), asLiteral(parsedR3Selector)];
    }
    /**
     * Gets the instruction to generate for an interpolated property
     * @param interpolation An Interpolation AST
     */
    function getPropertyInterpolationExpression(interpolation) {
        switch (getInterpolationArgsLength(interpolation)) {
            case 1:
                return Identifiers.propertyInterpolate;
            case 3:
                return Identifiers.propertyInterpolate1;
            case 5:
                return Identifiers.propertyInterpolate2;
            case 7:
                return Identifiers.propertyInterpolate3;
            case 9:
                return Identifiers.propertyInterpolate4;
            case 11:
                return Identifiers.propertyInterpolate5;
            case 13:
                return Identifiers.propertyInterpolate6;
            case 15:
                return Identifiers.propertyInterpolate7;
            case 17:
                return Identifiers.propertyInterpolate8;
            default:
                return Identifiers.propertyInterpolateV;
        }
    }
    /**
     * Gets the instruction to generate for an interpolated attribute
     * @param interpolation An Interpolation AST
     */
    function getAttributeInterpolationExpression(interpolation) {
        switch (getInterpolationArgsLength(interpolation)) {
            case 3:
                return Identifiers.attributeInterpolate1;
            case 5:
                return Identifiers.attributeInterpolate2;
            case 7:
                return Identifiers.attributeInterpolate3;
            case 9:
                return Identifiers.attributeInterpolate4;
            case 11:
                return Identifiers.attributeInterpolate5;
            case 13:
                return Identifiers.attributeInterpolate6;
            case 15:
                return Identifiers.attributeInterpolate7;
            case 17:
                return Identifiers.attributeInterpolate8;
            default:
                return Identifiers.attributeInterpolateV;
        }
    }
    /**
     * Gets the instruction to generate for interpolated text.
     * @param interpolation An Interpolation AST
     */
    function getTextInterpolationExpression(interpolation) {
        switch (getInterpolationArgsLength(interpolation)) {
            case 1:
                return Identifiers.textInterpolate;
            case 3:
                return Identifiers.textInterpolate1;
            case 5:
                return Identifiers.textInterpolate2;
            case 7:
                return Identifiers.textInterpolate3;
            case 9:
                return Identifiers.textInterpolate4;
            case 11:
                return Identifiers.textInterpolate5;
            case 13:
                return Identifiers.textInterpolate6;
            case 15:
                return Identifiers.textInterpolate7;
            case 17:
                return Identifiers.textInterpolate8;
            default:
                return Identifiers.textInterpolateV;
        }
    }
    /**
     * Parse a template into render3 `Node`s and additional metadata, with no other dependencies.
     *
     * @param template text of the template to parse
     * @param templateUrl URL to use for source mapping of the parsed template
     * @param options options to modify how the template is parsed
     */
    function parseTemplate(template, templateUrl, options = {}) {
        const { interpolationConfig, preserveWhitespaces, enableI18nLegacyMessageIdFormat } = options;
        const bindingParser = makeBindingParser(interpolationConfig);
        const htmlParser = new HtmlParser();
        const parseResult = htmlParser.parse(template, templateUrl, Object.assign(Object.assign({ leadingTriviaChars: LEADING_TRIVIA_CHARS }, options), { tokenizeExpansionForms: true }));
        if (!options.alwaysAttemptHtmlToR3AstConversion && parseResult.errors &&
            parseResult.errors.length > 0) {
            const parsedTemplate = {
                interpolationConfig,
                preserveWhitespaces,
                errors: parseResult.errors,
                nodes: [],
                styleUrls: [],
                styles: [],
                ngContentSelectors: []
            };
            if (options.collectCommentNodes) {
                parsedTemplate.commentNodes = [];
            }
            return parsedTemplate;
        }
        let rootNodes = parseResult.rootNodes;
        // process i18n meta information (scan attributes, generate ids)
        // before we run whitespace removal process, because existing i18n
        // extraction process (ng extract-i18n) relies on a raw content to generate
        // message ids
        const i18nMetaVisitor = new I18nMetaVisitor(interpolationConfig, /* keepI18nAttrs */ !preserveWhitespaces, enableI18nLegacyMessageIdFormat);
        const i18nMetaResult = i18nMetaVisitor.visitAllWithErrors(rootNodes);
        if (!options.alwaysAttemptHtmlToR3AstConversion && i18nMetaResult.errors &&
            i18nMetaResult.errors.length > 0) {
            const parsedTemplate = {
                interpolationConfig,
                preserveWhitespaces,
                errors: i18nMetaResult.errors,
                nodes: [],
                styleUrls: [],
                styles: [],
                ngContentSelectors: []
            };
            if (options.collectCommentNodes) {
                parsedTemplate.commentNodes = [];
            }
            return parsedTemplate;
        }
        rootNodes = i18nMetaResult.rootNodes;
        if (!preserveWhitespaces) {
            rootNodes = visitAll$1(new WhitespaceVisitor(), rootNodes);
            // run i18n meta visitor again in case whitespaces are removed (because that might affect
            // generated i18n message content) and first pass indicated that i18n content is present in a
            // template. During this pass i18n IDs generated at the first pass will be preserved, so we can
            // mimic existing extraction process (ng extract-i18n)
            if (i18nMetaVisitor.hasI18nMeta) {
                rootNodes = visitAll$1(new I18nMetaVisitor(interpolationConfig, /* keepI18nAttrs */ false), rootNodes);
            }
        }
        const { nodes, errors, styleUrls, styles, ngContentSelectors, commentNodes } = htmlAstToRender3Ast(rootNodes, bindingParser, { collectCommentNodes: !!options.collectCommentNodes });
        errors.push(...parseResult.errors, ...i18nMetaResult.errors);
        const parsedTemplate = {
            interpolationConfig,
            preserveWhitespaces,
            errors: errors.length > 0 ? errors : null,
            nodes,
            styleUrls,
            styles,
            ngContentSelectors
        };
        if (options.collectCommentNodes) {
            parsedTemplate.commentNodes = commentNodes;
        }
        return parsedTemplate;
    }
    const elementRegistry = new DomElementSchemaRegistry();
    /**
     * Construct a `BindingParser` with a default configuration.
     */
    function makeBindingParser(interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {
        return new BindingParser(new IvyParser(new Lexer()), interpolationConfig, elementRegistry, null, []);
    }
    function resolveSanitizationFn(context, isAttribute) {
        switch (context) {
            case SecurityContext.HTML:
                return importExpr(Identifiers.sanitizeHtml);
            case SecurityContext.SCRIPT:
                return importExpr(Identifiers.sanitizeScript);
            case SecurityContext.STYLE:
                // the compiler does not fill in an instruction for [style.prop?] binding
                // values because the style algorithm knows internally what props are subject
                // to sanitization (only [attr.style] values are explicitly sanitized)
                return isAttribute ? importExpr(Identifiers.sanitizeStyle) : null;
            case SecurityContext.URL:
                return importExpr(Identifiers.sanitizeUrl);
            case SecurityContext.RESOURCE_URL:
                return importExpr(Identifiers.sanitizeResourceUrl);
            default:
                return null;
        }
    }
    function trustedConstAttribute(tagName, attr) {
        const value = asLiteral(attr.value);
        if (isTrustedTypesSink(tagName, attr.name)) {
            switch (elementRegistry.securityContext(tagName, attr.name, /* isAttribute */ true)) {
                case SecurityContext.HTML:
                    return taggedTemplate(importExpr(Identifiers.trustConstantHtml), new TemplateLiteral([new TemplateLiteralElement(attr.value)], []), undefined, attr.valueSpan);
                // NB: no SecurityContext.SCRIPT here, as the corresponding tags are stripped by the compiler.
                case SecurityContext.RESOURCE_URL:
                    return taggedTemplate(importExpr(Identifiers.trustConstantResourceUrl), new TemplateLiteral([new TemplateLiteralElement(attr.value)], []), undefined, attr.valueSpan);
                default:
                    return value;
            }
        }
        else {
            return value;
        }
    }
    function isSingleElementTemplate(children) {
        return children.length === 1 && children[0] instanceof Element;
    }
    function isTextNode(node) {
        return node instanceof Text || node instanceof BoundText || node instanceof Icu;
    }
    function hasTextChildrenOnly(children) {
        return children.every(isTextNode);
    }
    /** Name of the global variable that is used to determine if we use Closure translations or not */
    const NG_I18N_CLOSURE_MODE = 'ngI18nClosureMode';
    /**
     * Generate statements that define a given translation message.
     *
     * ```
     * var I18N_1;
     * if (typeof ngI18nClosureMode !== undefined && ngI18nClosureMode) {
     *     var MSG_EXTERNAL_XXX = goog.getMsg(
     *          "Some message with {$interpolation}!",
     *          { "interpolation": "\uFFFD0\uFFFD" }
     *     );
     *     I18N_1 = MSG_EXTERNAL_XXX;
     * }
     * else {
     *     I18N_1 = $localize`Some message with ${'\uFFFD0\uFFFD'}!`;
     * }
     * ```
     *
     * @param message The original i18n AST message node
     * @param variable The variable that will be assigned the translation, e.g. `I18N_1`.
     * @param closureVar The variable for Closure `goog.getMsg` calls, e.g. `MSG_EXTERNAL_XXX`.
     * @param params Object mapping placeholder names to their values (e.g.
     * `{ "interpolation": "\uFFFD0\uFFFD" }`).
     * @param transformFn Optional transformation function that will be applied to the translation (e.g.
     * post-processing).
     * @returns An array of statements that defined a given translation.
     */
    function getTranslationDeclStmts(message, variable, closureVar, params = {}, transformFn) {
        const statements = [
            declareI18nVariable(variable),
            ifStmt(createClosureModeGuard(), createGoogleGetMsgStatements(variable, message, closureVar, i18nFormatPlaceholderNames(params, /* useCamelCase */ true)), createLocalizeStatements(variable, message, i18nFormatPlaceholderNames(params, /* useCamelCase */ false))),
        ];
        if (transformFn) {
            statements.push(new ExpressionStatement(variable.set(transformFn(variable))));
        }
        return statements;
    }
    /**
     * Create the expression that will be used to guard the closure mode block
     * It is equivalent to:
     *
     * ```
     * typeof ngI18nClosureMode !== undefined && ngI18nClosureMode
     * ```
     */
    function createClosureModeGuard() {
        return typeofExpr(variable(NG_I18N_CLOSURE_MODE))
            .notIdentical(literal('undefined', STRING_TYPE))
            .and(variable(NG_I18N_CLOSURE_MODE));
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    // This regex matches any binding names that contain the "attr." prefix, e.g. "attr.required"
    // If there is a match, the first matching group will contain the attribute name to bind.
    const ATTR_REGEX = /attr\.([^\]]+)/;
    function baseDirectiveFields(meta, constantPool, bindingParser) {
        const definitionMap = new DefinitionMap();
        const selectors = parseSelectorToR3Selector(meta.selector);
        // e.g. `type: MyDirective`
        definitionMap.set('type', meta.internalType);
        // e.g. `selectors: [['', 'someDir', '']]`
        if (selectors.length > 0) {
            definitionMap.set('selectors', asLiteral(selectors));
        }
        if (meta.queries.length > 0) {
            // e.g. `contentQueries: (rf, ctx, dirIndex) => { ... }
            definitionMap.set('contentQueries', createContentQueriesFunction(meta.queries, constantPool, meta.name));
        }
        if (meta.viewQueries.length) {
            definitionMap.set('viewQuery', createViewQueriesFunction(meta.viewQueries, constantPool, meta.name));
        }
        // e.g. `hostBindings: (rf, ctx) => { ... }
        definitionMap.set('hostBindings', createHostBindingsFunction(meta.host, meta.typeSourceSpan, bindingParser, constantPool, meta.selector || '', meta.name, definitionMap));
        // e.g 'inputs: {a: 'a'}`
        definitionMap.set('inputs', conditionallyCreateMapObjectLiteral(meta.inputs, true));
        // e.g 'outputs: {a: 'a'}`
        definitionMap.set('outputs', conditionallyCreateMapObjectLiteral(meta.outputs));
        if (meta.exportAs !== null) {
            definitionMap.set('exportAs', literalArr(meta.exportAs.map(e => literal(e))));
        }
        return definitionMap;
    }
    /**
     * Add features to the definition map.
     */
    function addFeatures(definitionMap, meta) {
        // e.g. `features: [NgOnChangesFeature]`
        const features = [];
        const providers = meta.providers;
        const viewProviders = meta.viewProviders;
        if (providers || viewProviders) {
            const args = [providers || new LiteralArrayExpr([])];
            if (viewProviders) {
                args.push(viewProviders);
            }
            features.push(importExpr(Identifiers.ProvidersFeature).callFn(args));
        }
        if (meta.usesInheritance) {
            features.push(importExpr(Identifiers.InheritDefinitionFeature));
        }
        if (meta.fullInheritance) {
            features.push(importExpr(Identifiers.CopyDefinitionFeature));
        }
        if (meta.lifecycle.usesOnChanges) {
            features.push(importExpr(Identifiers.NgOnChangesFeature));
        }
        if (features.length) {
            definitionMap.set('features', literalArr(features));
        }
    }
    /**
     * Compile a directive for the render3 runtime as defined by the `R3DirectiveMetadata`.
     */
    function compileDirectiveFromMetadata(meta, constantPool, bindingParser) {
        const definitionMap = baseDirectiveFields(meta, constantPool, bindingParser);
        addFeatures(definitionMap, meta);
        const expression = importExpr(Identifiers.defineDirective).callFn([definitionMap.toLiteralMap()], undefined, true);
        const type = createDirectiveType(meta);
        return { expression, type, statements: [] };
    }
    /**
     * Compile a component for the render3 runtime as defined by the `R3ComponentMetadata`.
     */
    function compileComponentFromMetadata(meta, constantPool, bindingParser) {
        const definitionMap = baseDirectiveFields(meta, constantPool, bindingParser);
        addFeatures(definitionMap, meta);
        const selector = meta.selector && CssSelector.parse(meta.selector);
        const firstSelector = selector && selector[0];
        // e.g. `attr: ["class", ".my.app"]`
        // This is optional an only included if the first selector of a component specifies attributes.
        if (firstSelector) {
            const selectorAttributes = firstSelector.getAttrs();
            if (selectorAttributes.length) {
                definitionMap.set('attrs', constantPool.getConstLiteral(literalArr(selectorAttributes.map(value => value != null ? literal(value) : literal(undefined))), 
                /* forceShared */ true));
            }
        }
        // Generate the CSS matcher that recognize directive
        let directiveMatcher = null;
        if (meta.directives.length > 0) {
            const matcher = new SelectorMatcher();
            for (const { selector, type } of meta.directives) {
                matcher.addSelectables(CssSelector.parse(selector), type);
            }
            directiveMatcher = matcher;
        }
        // e.g. `template: function MyComponent_Template(_ctx, _cm) {...}`
        const templateTypeName = meta.name;
        const templateName = templateTypeName ? `${templateTypeName}_Template` : null;
        const directivesUsed = new Set();
        const pipesUsed = new Set();
        const changeDetection = meta.changeDetection;
        const template = meta.template;
        const templateBuilder = new TemplateDefinitionBuilder(constantPool, BindingScope.createRootScope(), 0, templateTypeName, null, null, templateName, directiveMatcher, directivesUsed, meta.pipes, pipesUsed, Identifiers.namespaceHTML, meta.relativeContextFilePath, meta.i18nUseExternalIds);
        const templateFunctionExpression = templateBuilder.buildTemplateFunction(template.nodes, []);
        // We need to provide this so that dynamically generated components know what
        // projected content blocks to pass through to the component when it is instantiated.
        const ngContentSelectors = templateBuilder.getNgContentSelectors();
        if (ngContentSelectors) {
            definitionMap.set('ngContentSelectors', ngContentSelectors);
        }
        // e.g. `decls: 2`
        definitionMap.set('decls', literal(templateBuilder.getConstCount()));
        // e.g. `vars: 2`
        definitionMap.set('vars', literal(templateBuilder.getVarCount()));
        // Generate `consts` section of ComponentDef:
        // - either as an array:
        //   `consts: [['one', 'two'], ['three', 'four']]`
        // - or as a factory function in case additional statements are present (to support i18n):
        //   `consts: function() { var i18n_0; if (ngI18nClosureMode) {...} else {...} return [i18n_0]; }`
        const { constExpressions, prepareStatements } = templateBuilder.getConsts();
        if (constExpressions.length > 0) {
            let constsExpr = literalArr(constExpressions);
            // Prepare statements are present - turn `consts` into a function.
            if (prepareStatements.length > 0) {
                constsExpr = fn([], [...prepareStatements, new ReturnStatement(constsExpr)]);
            }
            definitionMap.set('consts', constsExpr);
        }
        definitionMap.set('template', templateFunctionExpression);
        // e.g. `directives: [MyDirective]`
        if (directivesUsed.size) {
            const directivesList = literalArr(Array.from(directivesUsed));
            const directivesExpr = compileDeclarationList(directivesList, meta.declarationListEmitMode);
            definitionMap.set('directives', directivesExpr);
        }
        // e.g. `pipes: [MyPipe]`
        if (pipesUsed.size) {
            const pipesList = literalArr(Array.from(pipesUsed));
            const pipesExpr = compileDeclarationList(pipesList, meta.declarationListEmitMode);
            definitionMap.set('pipes', pipesExpr);
        }
        if (meta.encapsulation === null) {
            meta.encapsulation = ViewEncapsulation.Emulated;
        }
        // e.g. `styles: [str1, str2]`
        if (meta.styles && meta.styles.length) {
            const styleValues = meta.encapsulation == ViewEncapsulation.Emulated ?
                compileStyles(meta.styles, CONTENT_ATTR, HOST_ATTR) :
                meta.styles;
            const strings = styleValues.map(str => constantPool.getConstLiteral(literal(str)));
            definitionMap.set('styles', literalArr(strings));
        }
        else if (meta.encapsulation === ViewEncapsulation.Emulated) {
            // If there is no style, don't generate css selectors on elements
            meta.encapsulation = ViewEncapsulation.None;
        }
        // Only set view encapsulation if it's not the default value
        if (meta.encapsulation !== ViewEncapsulation.Emulated) {
            definitionMap.set('encapsulation', literal(meta.encapsulation));
        }
        // e.g. `animation: [trigger('123', [])]`
        if (meta.animations !== null) {
            definitionMap.set('data', literalMap([{ key: 'animation', value: meta.animations, quoted: false }]));
        }
        // Only set the change detection flag if it's defined and it's not the default.
        if (changeDetection != null && changeDetection !== ChangeDetectionStrategy.Default) {
            definitionMap.set('changeDetection', literal(changeDetection));
        }
        const expression = importExpr(Identifiers.defineComponent).callFn([definitionMap.toLiteralMap()], undefined, true);
        const type = createComponentType(meta);
        return { expression, type, statements: [] };
    }
    /**
     * Creates the type specification from the component meta. This type is inserted into .d.ts files
     * to be consumed by upstream compilations.
     */
    function createComponentType(meta) {
        const typeParams = createDirectiveTypeParams(meta);
        typeParams.push(stringArrayAsType(meta.template.ngContentSelectors));
        return expressionType(importExpr(Identifiers.ComponentDeclaration, typeParams));
    }
    /**
     * Compiles the array literal of declarations into an expression according to the provided emit
     * mode.
     */
    function compileDeclarationList(list, mode) {
        switch (mode) {
            case 0 /* Direct */:
                // directives: [MyDir],
                return list;
            case 1 /* Closure */:
                // directives: function () { return [MyDir]; }
                return fn([], [new ReturnStatement(list)]);
            case 2 /* ClosureResolved */:
                // directives: function () { return [MyDir].map(ng.resolveForwardRef); }
                const resolvedList = list.callMethod('map', [importExpr(Identifiers.resolveForwardRef)]);
                return fn([], [new ReturnStatement(resolvedList)]);
        }
    }
    function prepareQueryParams(query, constantPool) {
        const parameters = [getQueryPredicate(query, constantPool), literal(toQueryFlags(query))];
        if (query.read) {
            parameters.push(query.read);
        }
        return parameters;
    }
    /**
     * Translates query flags into `TQueryFlags` type in packages/core/src/render3/interfaces/query.ts
     * @param query
     */
    function toQueryFlags(query) {
        return (query.descendants ? 1 /* descendants */ : 0 /* none */) |
            (query.static ? 2 /* isStatic */ : 0 /* none */) |
            (query.emitDistinctChangesOnly ? 4 /* emitDistinctChangesOnly */ : 0 /* none */);
    }
    function convertAttributesToExpressions(attributes) {
        const values = [];
        for (let key of Object.getOwnPropertyNames(attributes)) {
            const value = attributes[key];
            values.push(literal(key), value);
        }
        return values;
    }
    // Define and update any content queries
    function createContentQueriesFunction(queries, constantPool, name) {
        const createStatements = [];
        const updateStatements = [];
        const tempAllocator = temporaryAllocator(updateStatements, TEMPORARY_NAME);
        for (const query of queries) {
            // creation, e.g. r3.contentQuery(dirIndex, somePredicate, true, null);
            createStatements.push(importExpr(Identifiers.contentQuery)
                .callFn([variable('dirIndex'), ...prepareQueryParams(query, constantPool)])
                .toStmt());
            // update, e.g. (r3.queryRefresh(tmp = r3.loadQuery()) && (ctx.someDir = tmp));
            const temporary = tempAllocator();
            const getQueryList = importExpr(Identifiers.loadQuery).callFn([]);
            const refresh = importExpr(Identifiers.queryRefresh).callFn([temporary.set(getQueryList)]);
            const updateDirective = variable(CONTEXT_NAME)
                .prop(query.propertyName)
                .set(query.first ? temporary.prop('first') : temporary);
            updateStatements.push(refresh.and(updateDirective).toStmt());
        }
        const contentQueriesFnName = name ? `${name}_ContentQueries` : null;
        return fn([
            new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null),
            new FnParam('dirIndex', null)
        ], [
            renderFlagCheckIfStmt(1 /* Create */, createStatements),
            renderFlagCheckIfStmt(2 /* Update */, updateStatements)
        ], INFERRED_TYPE, null, contentQueriesFnName);
    }
    function stringAsType(str) {
        return expressionType(literal(str));
    }
    function stringMapAsType(map) {
        const mapValues = Object.keys(map).map(key => {
            const value = Array.isArray(map[key]) ? map[key][0] : map[key];
            return {
                key,
                value: literal(value),
                quoted: true,
            };
        });
        return expressionType(literalMap(mapValues));
    }
    function stringArrayAsType(arr) {
        return arr.length > 0 ? expressionType(literalArr(arr.map(value => literal(value)))) :
            NONE_TYPE;
    }
    function createDirectiveTypeParams(meta) {
        // On the type side, remove newlines from the selector as it will need to fit into a TypeScript
        // string literal, which must be on one line.
        const selectorForType = meta.selector !== null ? meta.selector.replace(/\n/g, '') : null;
        return [
            typeWithParameters(meta.type.type, meta.typeArgumentCount),
            selectorForType !== null ? stringAsType(selectorForType) : NONE_TYPE,
            meta.exportAs !== null ? stringArrayAsType(meta.exportAs) : NONE_TYPE,
            stringMapAsType(meta.inputs),
            stringMapAsType(meta.outputs),
            stringArrayAsType(meta.queries.map(q => q.propertyName)),
        ];
    }
    /**
     * Creates the type specification from the directive meta. This type is inserted into .d.ts files
     * to be consumed by upstream compilations.
     */
    function createDirectiveType(meta) {
        const typeParams = createDirectiveTypeParams(meta);
        return expressionType(importExpr(Identifiers.DirectiveDeclaration, typeParams));
    }
    // Define and update any view queries
    function createViewQueriesFunction(viewQueries, constantPool, name) {
        const createStatements = [];
        const updateStatements = [];
        const tempAllocator = temporaryAllocator(updateStatements, TEMPORARY_NAME);
        viewQueries.forEach((query) => {
            // creation, e.g. r3.viewQuery(somePredicate, true);
            const queryDefinition = importExpr(Identifiers.viewQuery).callFn(prepareQueryParams(query, constantPool));
            createStatements.push(queryDefinition.toStmt());
            // update, e.g. (r3.queryRefresh(tmp = r3.loadQuery()) && (ctx.someDir = tmp));
            const temporary = tempAllocator();
            const getQueryList = importExpr(Identifiers.loadQuery).callFn([]);
            const refresh = importExpr(Identifiers.queryRefresh).callFn([temporary.set(getQueryList)]);
            const updateDirective = variable(CONTEXT_NAME)
                .prop(query.propertyName)
                .set(query.first ? temporary.prop('first') : temporary);
            updateStatements.push(refresh.and(updateDirective).toStmt());
        });
        const viewQueryFnName = name ? `${name}_Query` : null;
        return fn([new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null)], [
            renderFlagCheckIfStmt(1 /* Create */, createStatements),
            renderFlagCheckIfStmt(2 /* Update */, updateStatements)
        ], INFERRED_TYPE, null, viewQueryFnName);
    }
    // Return a host binding function or null if one is not necessary.
    function createHostBindingsFunction(hostBindingsMetadata, typeSourceSpan, bindingParser, constantPool, selector, name, definitionMap) {
        const bindingContext = variable(CONTEXT_NAME);
        const styleBuilder = new StylingBuilder(bindingContext);
        const { styleAttr, classAttr } = hostBindingsMetadata.specialAttributes;
        if (styleAttr !== undefined) {
            styleBuilder.registerStyleAttr(styleAttr);
        }
        if (classAttr !== undefined) {
            styleBuilder.registerClassAttr(classAttr);
        }
        const createStatements = [];
        const updateStatements = [];
        const hostBindingSourceSpan = typeSourceSpan;
        const directiveSummary = metadataAsSummary(hostBindingsMetadata);
        // Calculate host event bindings
        const eventBindings = bindingParser.createDirectiveHostEventAsts(directiveSummary, hostBindingSourceSpan);
        if (eventBindings && eventBindings.length) {
            const listeners = createHostListeners(eventBindings, name);
            createStatements.push(...listeners);
        }
        // Calculate the host property bindings
        const bindings = bindingParser.createBoundHostProperties(directiveSummary, hostBindingSourceSpan);
        const allOtherBindings = [];
        // We need to calculate the total amount of binding slots required by
        // all the instructions together before any value conversions happen.
        // Value conversions may require additional slots for interpolation and
        // bindings with pipes. These calculates happen after this block.
        let totalHostVarsCount = 0;
        bindings && bindings.forEach((binding) => {
            const stylingInputWasSet = styleBuilder.registerInputBasedOnName(binding.name, binding.expression, hostBindingSourceSpan);
            if (stylingInputWasSet) {
                totalHostVarsCount += MIN_STYLING_BINDING_SLOTS_REQUIRED;
            }
            else {
                allOtherBindings.push(binding);
                totalHostVarsCount++;
            }
        });
        let valueConverter;
        const getValueConverter = () => {
            if (!valueConverter) {
                const hostVarsCountFn = (numSlots) => {
                    const originalVarsCount = totalHostVarsCount;
                    totalHostVarsCount += numSlots;
                    return originalVarsCount;
                };
                valueConverter = new ValueConverter(constantPool, () => error('Unexpected node'), // new nodes are illegal here
                hostVarsCountFn, () => error('Unexpected pipe')); // pipes are illegal here
            }
            return valueConverter;
        };
        const propertyBindings = [];
        const attributeBindings = [];
        const syntheticHostBindings = [];
        allOtherBindings.forEach((binding) => {
            // resolve literal arrays and literal objects
            const value = binding.expression.visit(getValueConverter());
            const bindingExpr = bindingFn(bindingContext, value);
            const { bindingName, instruction, isAttribute } = getBindingNameAndInstruction(binding);
            const securityContexts = bindingParser.calcPossibleSecurityContexts(selector, bindingName, isAttribute)
                .filter(context => context !== SecurityContext.NONE);
            let sanitizerFn = null;
            if (securityContexts.length) {
                if (securityContexts.length === 2 &&
                    securityContexts.indexOf(SecurityContext.URL) > -1 &&
                    securityContexts.indexOf(SecurityContext.RESOURCE_URL) > -1) {
                    // Special case for some URL attributes (such as "src" and "href") that may be a part
                    // of different security contexts. In this case we use special sanitization function and
                    // select the actual sanitizer at runtime based on a tag name that is provided while
                    // invoking sanitization function.
                    sanitizerFn = importExpr(Identifiers.sanitizeUrlOrResourceUrl);
                }
                else {
                    sanitizerFn = resolveSanitizationFn(securityContexts[0], isAttribute);
                }
            }
            const instructionParams = [literal(bindingName), bindingExpr.currValExpr];
            if (sanitizerFn) {
                instructionParams.push(sanitizerFn);
            }
            updateStatements.push(...bindingExpr.stmts);
            if (instruction === Identifiers.hostProperty) {
                propertyBindings.push(instructionParams);
            }
            else if (instruction === Identifiers.attribute) {
                attributeBindings.push(instructionParams);
            }
            else if (instruction === Identifiers.syntheticHostProperty) {
                syntheticHostBindings.push(instructionParams);
            }
            else {
                updateStatements.push(importExpr(instruction).callFn(instructionParams).toStmt());
            }
        });
        if (propertyBindings.length > 0) {
            updateStatements.push(chainedInstruction(Identifiers.hostProperty, propertyBindings).toStmt());
        }
        if (attributeBindings.length > 0) {
            updateStatements.push(chainedInstruction(Identifiers.attribute, attributeBindings).toStmt());
        }
        if (syntheticHostBindings.length > 0) {
            updateStatements.push(chainedInstruction(Identifiers.syntheticHostProperty, syntheticHostBindings).toStmt());
        }
        // since we're dealing with directives/components and both have hostBinding
        // functions, we need to generate a special hostAttrs instruction that deals
        // with both the assignment of styling as well as static attributes to the host
        // element. The instruction below will instruct all initial styling (styling
        // that is inside of a host binding within a directive/component) to be attached
        // to the host element alongside any of the provided host attributes that were
        // collected earlier.
        const hostAttrs = convertAttributesToExpressions(hostBindingsMetadata.attributes);
        styleBuilder.assignHostAttrs(hostAttrs, definitionMap);
        if (styleBuilder.hasBindings) {
            // finally each binding that was registered in the statement above will need to be added to
            // the update block of a component/directive templateFn/hostBindingsFn so that the bindings
            // are evaluated and updated for the element.
            styleBuilder.buildUpdateLevelInstructions(getValueConverter()).forEach(instruction => {
                if (instruction.calls.length > 0) {
                    const calls = [];
                    instruction.calls.forEach(call => {
                        // we subtract a value of `1` here because the binding slot was already allocated
                        // at the top of this method when all the input bindings were counted.
                        totalHostVarsCount +=
                            Math.max(call.allocateBindingSlots - MIN_STYLING_BINDING_SLOTS_REQUIRED, 0);
                        calls.push(convertStylingCall(call, bindingContext, bindingFn));
                    });
                    updateStatements.push(chainedInstruction(instruction.reference, calls).toStmt());
                }
            });
        }
        if (totalHostVarsCount) {
            definitionMap.set('hostVars', literal(totalHostVarsCount));
        }
        if (createStatements.length > 0 || updateStatements.length > 0) {
            const hostBindingsFnName = name ? `${name}_HostBindings` : null;
            const statements = [];
            if (createStatements.length > 0) {
                statements.push(renderFlagCheckIfStmt(1 /* Create */, createStatements));
            }
            if (updateStatements.length > 0) {
                statements.push(renderFlagCheckIfStmt(2 /* Update */, updateStatements));
            }
            return fn([new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null)], statements, INFERRED_TYPE, null, hostBindingsFnName);
        }
        return null;
    }
    function bindingFn(implicit, value) {
        return convertPropertyBinding(null, implicit, value, 'b', BindingForm.Expression, () => error('Unexpected interpolation'));
    }
    function convertStylingCall(call, bindingContext, bindingFn) {
        return call.params(value => bindingFn(bindingContext, value).currValExpr);
    }
    function getBindingNameAndInstruction(binding) {
        let bindingName = binding.name;
        let instruction;
        // Check to see if this is an attr binding or a property binding
        const attrMatches = bindingName.match(ATTR_REGEX);
        if (attrMatches) {
            bindingName = attrMatches[1];
            instruction = Identifiers.attribute;
        }
        else {
            if (binding.isAnimation) {
                bindingName = prepareSyntheticPropertyName(bindingName);
                // host bindings that have a synthetic property (e.g. @foo) should always be rendered
                // in the context of the component and not the parent. Therefore there is a special
                // compatibility instruction available for this purpose.
                instruction = Identifiers.syntheticHostProperty;
            }
            else {
                instruction = Identifiers.hostProperty;
            }
        }
        return { bindingName, instruction, isAttribute: !!attrMatches };
    }
    function createHostListeners(eventBindings, name) {
        const listeners = [];
        const syntheticListeners = [];
        const instructions = [];
        eventBindings.forEach(binding => {
            let bindingName = binding.name && sanitizeIdentifier(binding.name);
            const bindingFnName = binding.type === 1 /* Animation */ ?
                prepareSyntheticListenerFunctionName(bindingName, binding.targetOrPhase) :
                bindingName;
            const handlerName = name && bindingName ? `${name}_${bindingFnName}_HostBindingHandler` : null;
            const params = prepareEventListenerParameters(BoundEvent.fromParsedEvent(binding), handlerName);
            if (binding.type == 1 /* Animation */) {
                syntheticListeners.push(params);
            }
            else {
                listeners.push(params);
            }
        });
        if (syntheticListeners.length > 0) {
            instructions.push(chainedInstruction(Identifiers.syntheticHostListener, syntheticListeners).toStmt());
        }
        if (listeners.length > 0) {
            instructions.push(chainedInstruction(Identifiers.listener, listeners).toStmt());
        }
        return instructions;
    }
    function metadataAsSummary(meta) {
        // clang-format off
        return {
            // This is used by the BindingParser, which only deals with listeners and properties. There's no
            // need to pass attributes to it.
            hostAttributes: {},
            hostListeners: meta.listeners,
            hostProperties: meta.properties,
        };
        // clang-format on
    }
    const HOST_REG_EXP$1 = /^(?:\[([^\]]+)\])|(?:\(([^\)]+)\))$/;
    function parseHostBindings(host) {
        const attributes = {};
        const listeners = {};
        const properties = {};
        const specialAttributes = {};
        for (const key of Object.keys(host)) {
            const value = host[key];
            const matches = key.match(HOST_REG_EXP$1);
            if (matches === null) {
                switch (key) {
                    case 'class':
                        if (typeof value !== 'string') {
                            // TODO(alxhub): make this a diagnostic.
                            throw new Error(`Class binding must be string`);
                        }
                        specialAttributes.classAttr = value;
                        break;
                    case 'style':
                        if (typeof value !== 'string') {
                            // TODO(alxhub): make this a diagnostic.
                            throw new Error(`Style binding must be string`);
                        }
                        specialAttributes.styleAttr = value;
                        break;
                    default:
                        if (typeof value === 'string') {
                            attributes[key] = literal(value);
                        }
                        else {
                            attributes[key] = value;
                        }
                }
            }
            else if (matches[1 /* Binding */] != null) {
                if (typeof value !== 'string') {
                    // TODO(alxhub): make this a diagnostic.
                    throw new Error(`Property binding must be string`);
                }
                // synthetic properties (the ones that have a `@` as a prefix)
                // are still treated the same as regular properties. Therefore
                // there is no point in storing them in a separate map.
                properties[matches[1 /* Binding */]] = value;
            }
            else if (matches[2 /* Event */] != null) {
                if (typeof value !== 'string') {
                    // TODO(alxhub): make this a diagnostic.
                    throw new Error(`Event binding must be string`);
                }
                listeners[matches[2 /* Event */]] = value;
            }
        }
        return { attributes, listeners, properties, specialAttributes };
    }
    /**
     * Verifies host bindings and returns the list of errors (if any). Empty array indicates that a
     * given set of host bindings has no errors.
     *
     * @param bindings set of host bindings to verify.
     * @param sourceSpan source span where host bindings were defined.
     * @returns array of errors associated with a given set of host bindings.
     */
    function verifyHostBindings(bindings, sourceSpan) {
        const summary = metadataAsSummary(bindings);
        // TODO: abstract out host bindings verification logic and use it instead of
        // creating events and properties ASTs to detect errors (FW-996)
        const bindingParser = makeBindingParser();
        bindingParser.createDirectiveHostEventAsts(summary, sourceSpan);
        bindingParser.createBoundHostProperties(summary, sourceSpan);
        return bindingParser.errors;
    }
    function compileStyles(styles, selector, hostSelector) {
        const shadowCss = new ShadowCss();
        return styles.map(style => {
            return shadowCss.shimCssText(style, selector, hostSelector);
        });
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * An interface for retrieving documents by URL that the compiler uses to
     * load templates.
     *
     * This is an abstract class, rather than an interface, so that it can be used
     * as injection token.
     */
    class ResourceLoader {
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class CompilerFacadeImpl {
        constructor(jitEvaluator = new JitEvaluator()) {
            this.jitEvaluator = jitEvaluator;
            this.FactoryTarget = FactoryTarget;
            this.ResourceLoader = ResourceLoader;
            this.elementSchemaRegistry = new DomElementSchemaRegistry();
        }
        compilePipe(angularCoreEnv, sourceMapUrl, facade) {
            const metadata = {
                name: facade.name,
                type: wrapReference(facade.type),
                internalType: new WrappedNodeExpr(facade.type),
                typeArgumentCount: 0,
                deps: null,
                pipeName: facade.pipeName,
                pure: facade.pure,
            };
            const res = compilePipeFromMetadata(metadata);
            return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);
        }
        compilePipeDeclaration(angularCoreEnv, sourceMapUrl, declaration) {
            const meta = convertDeclarePipeFacadeToMetadata(declaration);
            const res = compilePipeFromMetadata(meta);
            return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);
        }
        compileInjectable(angularCoreEnv, sourceMapUrl, facade) {
            var _a;
            const { expression, statements } = compileInjectable({
                name: facade.name,
                type: wrapReference(facade.type),
                internalType: new WrappedNodeExpr(facade.type),
                typeArgumentCount: facade.typeArgumentCount,
                providedIn: computeProvidedIn(facade.providedIn),
                useClass: convertToProviderExpression(facade, USE_CLASS),
                useFactory: wrapExpression(facade, USE_FACTORY),
                useValue: convertToProviderExpression(facade, USE_VALUE),
                useExisting: convertToProviderExpression(facade, USE_EXISTING),
                deps: (_a = facade.deps) === null || _a === void 0 ? void 0 : _a.map(convertR3DependencyMetadata),
            }, 
            /* resolveForwardRefs */ true);
            return this.jitExpression(expression, angularCoreEnv, sourceMapUrl, statements);
        }
        compileInjectableDeclaration(angularCoreEnv, sourceMapUrl, facade) {
            var _a;
            const { expression, statements } = compileInjectable({
                name: facade.type.name,
                type: wrapReference(facade.type),
                internalType: new WrappedNodeExpr(facade.type),
                typeArgumentCount: 0,
                providedIn: computeProvidedIn(facade.providedIn),
                useClass: convertToProviderExpression(facade, USE_CLASS),
                useFactory: wrapExpression(facade, USE_FACTORY),
                useValue: convertToProviderExpression(facade, USE_VALUE),
                useExisting: convertToProviderExpression(facade, USE_EXISTING),
                deps: (_a = facade.deps) === null || _a === void 0 ? void 0 : _a.map(convertR3DeclareDependencyMetadata),
            }, 
            /* resolveForwardRefs */ true);
            return this.jitExpression(expression, angularCoreEnv, sourceMapUrl, statements);
        }
        compileInjector(angularCoreEnv, sourceMapUrl, facade) {
            const meta = {
                name: facade.name,
                type: wrapReference(facade.type),
                internalType: new WrappedNodeExpr(facade.type),
                providers: new WrappedNodeExpr(facade.providers),
                imports: facade.imports.map(i => new WrappedNodeExpr(i)),
            };
            const res = compileInjector(meta);
            return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);
        }
        compileInjectorDeclaration(angularCoreEnv, sourceMapUrl, declaration) {
            const meta = convertDeclareInjectorFacadeToMetadata(declaration);
            const res = compileInjector(meta);
            return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);
        }
        compileNgModule(angularCoreEnv, sourceMapUrl, facade) {
            const meta = {
                type: wrapReference(facade.type),
                internalType: new WrappedNodeExpr(facade.type),
                adjacentType: new WrappedNodeExpr(facade.type),
                bootstrap: facade.bootstrap.map(wrapReference),
                declarations: facade.declarations.map(wrapReference),
                imports: facade.imports.map(wrapReference),
                exports: facade.exports.map(wrapReference),
                emitInline: true,
                containsForwardDecls: false,
                schemas: facade.schemas ? facade.schemas.map(wrapReference) : null,
                id: facade.id ? new WrappedNodeExpr(facade.id) : null,
            };
            const res = compileNgModule(meta);
            return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);
        }
        compileNgModuleDeclaration(angularCoreEnv, sourceMapUrl, declaration) {
            const expression = compileNgModuleDeclarationExpression(declaration);
            return this.jitExpression(expression, angularCoreEnv, sourceMapUrl, []);
        }
        compileDirective(angularCoreEnv, sourceMapUrl, facade) {
            const meta = convertDirectiveFacadeToMetadata(facade);
            return this.compileDirectiveFromMeta(angularCoreEnv, sourceMapUrl, meta);
        }
        compileDirectiveDeclaration(angularCoreEnv, sourceMapUrl, declaration) {
            const typeSourceSpan = this.createParseSourceSpan('Directive', declaration.type.name, sourceMapUrl);
            const meta = convertDeclareDirectiveFacadeToMetadata(declaration, typeSourceSpan);
            return this.compileDirectiveFromMeta(angularCoreEnv, sourceMapUrl, meta);
        }
        compileDirectiveFromMeta(angularCoreEnv, sourceMapUrl, meta) {
            const constantPool = new ConstantPool();
            const bindingParser = makeBindingParser();
            const res = compileDirectiveFromMetadata(meta, constantPool, bindingParser);
            return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, constantPool.statements);
        }
        compileComponent(angularCoreEnv, sourceMapUrl, facade) {
            // Parse the template and check for errors.
            const { template, interpolation } = parseJitTemplate(facade.template, facade.name, sourceMapUrl, facade.preserveWhitespaces, facade.interpolation);
            // Compile the component metadata, including template, into an expression.
            const meta = Object.assign(Object.assign(Object.assign({}, facade), convertDirectiveFacadeToMetadata(facade)), { selector: facade.selector || this.elementSchemaRegistry.getDefaultComponentElementName(), template, declarationListEmitMode: 0 /* Direct */, styles: [...facade.styles, ...template.styles], encapsulation: facade.encapsulation, interpolation, changeDetection: facade.changeDetection, animations: facade.animations != null ? new WrappedNodeExpr(facade.animations) : null, viewProviders: facade.viewProviders != null ? new WrappedNodeExpr(facade.viewProviders) :
                    null, relativeContextFilePath: '', i18nUseExternalIds: true });
            const jitExpressionSourceMap = `ng:///${facade.name}.js`;
            return this.compileComponentFromMeta(angularCoreEnv, jitExpressionSourceMap, meta);
        }
        compileComponentDeclaration(angularCoreEnv, sourceMapUrl, declaration) {
            const typeSourceSpan = this.createParseSourceSpan('Component', declaration.type.name, sourceMapUrl);
            const meta = convertDeclareComponentFacadeToMetadata(declaration, typeSourceSpan, sourceMapUrl);
            return this.compileComponentFromMeta(angularCoreEnv, sourceMapUrl, meta);
        }
        compileComponentFromMeta(angularCoreEnv, sourceMapUrl, meta) {
            const constantPool = new ConstantPool();
            const bindingParser = makeBindingParser(meta.interpolation);
            const res = compileComponentFromMetadata(meta, constantPool, bindingParser);
            return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, constantPool.statements);
        }
        compileFactory(angularCoreEnv, sourceMapUrl, meta) {
            const factoryRes = compileFactoryFunction({
                name: meta.name,
                type: wrapReference(meta.type),
                internalType: new WrappedNodeExpr(meta.type),
                typeArgumentCount: meta.typeArgumentCount,
                deps: convertR3DependencyMetadataArray(meta.deps),
                target: meta.target,
            });
            return this.jitExpression(factoryRes.expression, angularCoreEnv, sourceMapUrl, factoryRes.statements);
        }
        compileFactoryDeclaration(angularCoreEnv, sourceMapUrl, meta) {
            const factoryRes = compileFactoryFunction({
                name: meta.type.name,
                type: wrapReference(meta.type),
                internalType: new WrappedNodeExpr(meta.type),
                typeArgumentCount: 0,
                deps: Array.isArray(meta.deps) ? meta.deps.map(convertR3DeclareDependencyMetadata) :
                    meta.deps,
                target: meta.target,
            });
            return this.jitExpression(factoryRes.expression, angularCoreEnv, sourceMapUrl, factoryRes.statements);
        }
        createParseSourceSpan(kind, typeName, sourceUrl) {
            return r3JitTypeSourceSpan(kind, typeName, sourceUrl);
        }
        /**
         * JIT compiles an expression and returns the result of executing that expression.
         *
         * @param def the definition which will be compiled and executed to get the value to patch
         * @param context an object map of @angular/core symbol names to symbols which will be available
         * in the context of the compiled expression
         * @param sourceUrl a URL to use for the source map of the compiled expression
         * @param preStatements a collection of statements that should be evaluated before the expression.
         */
        jitExpression(def, context, sourceUrl, preStatements) {
            // The ConstantPool may contain Statements which declare variables used in the final expression.
            // Therefore, its statements need to precede the actual JIT operation. The final statement is a
            // declaration of $def which is set to the expression being compiled.
            const statements = [
                ...preStatements,
                new DeclareVarStmt('$def', def, undefined, [StmtModifier.Exported]),
            ];
            const res = this.jitEvaluator.evaluateStatements(sourceUrl, statements, new R3JitReflector(context), /* enableSourceMaps */ true);
            return res['$def'];
        }
    }
    const USE_CLASS = Object.keys({ useClass: null })[0];
    const USE_FACTORY = Object.keys({ useFactory: null })[0];
    const USE_VALUE = Object.keys({ useValue: null })[0];
    const USE_EXISTING = Object.keys({ useExisting: null })[0];
    function convertToR3QueryMetadata(facade) {
        return Object.assign(Object.assign({}, facade), { predicate: Array.isArray(facade.predicate) ? facade.predicate :
                new WrappedNodeExpr(facade.predicate), read: facade.read ? new WrappedNodeExpr(facade.read) : null, static: facade.static, emitDistinctChangesOnly: facade.emitDistinctChangesOnly });
    }
    function convertQueryDeclarationToMetadata(declaration) {
        var _a, _b, _c, _d;
        return {
            propertyName: declaration.propertyName,
            first: (_a = declaration.first) !== null && _a !== void 0 ? _a : false,
            predicate: Array.isArray(declaration.predicate) ? declaration.predicate :
                new WrappedNodeExpr(declaration.predicate),
            descendants: (_b = declaration.descendants) !== null && _b !== void 0 ? _b : false,
            read: declaration.read ? new WrappedNodeExpr(declaration.read) : null,
            static: (_c = declaration.static) !== null && _c !== void 0 ? _c : false,
            emitDistinctChangesOnly: (_d = declaration.emitDistinctChangesOnly) !== null && _d !== void 0 ? _d : true,
        };
    }
    function convertDirectiveFacadeToMetadata(facade) {
        const inputsFromMetadata = parseInputOutputs(facade.inputs || []);
        const outputsFromMetadata = parseInputOutputs(facade.outputs || []);
        const propMetadata = facade.propMetadata;
        const inputsFromType = {};
        const outputsFromType = {};
        for (const field in propMetadata) {
            if (propMetadata.hasOwnProperty(field)) {
                propMetadata[field].forEach(ann => {
                    if (isInput(ann)) {
                        inputsFromType[field] =
                            ann.bindingPropertyName ? [ann.bindingPropertyName, field] : field;
                    }
                    else if (isOutput(ann)) {
                        outputsFromType[field] = ann.bindingPropertyName || field;
                    }
                });
            }
        }
        return Object.assign(Object.assign({}, facade), { typeArgumentCount: 0, typeSourceSpan: facade.typeSourceSpan, type: wrapReference(facade.type), internalType: new WrappedNodeExpr(facade.type), deps: null, host: extractHostBindings(facade.propMetadata, facade.typeSourceSpan, facade.host), inputs: Object.assign(Object.assign({}, inputsFromMetadata), inputsFromType), outputs: Object.assign(Object.assign({}, outputsFromMetadata), outputsFromType), queries: facade.queries.map(convertToR3QueryMetadata), providers: facade.providers != null ? new WrappedNodeExpr(facade.providers) : null, viewQueries: facade.viewQueries.map(convertToR3QueryMetadata), fullInheritance: false });
    }
    function convertDeclareDirectiveFacadeToMetadata(declaration, typeSourceSpan) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        return {
            name: declaration.type.name,
            type: wrapReference(declaration.type),
            typeSourceSpan,
            internalType: new WrappedNodeExpr(declaration.type),
            selector: (_a = declaration.selector) !== null && _a !== void 0 ? _a : null,
            inputs: (_b = declaration.inputs) !== null && _b !== void 0 ? _b : {},
            outputs: (_c = declaration.outputs) !== null && _c !== void 0 ? _c : {},
            host: convertHostDeclarationToMetadata(declaration.host),
            queries: ((_d = declaration.queries) !== null && _d !== void 0 ? _d : []).map(convertQueryDeclarationToMetadata),
            viewQueries: ((_e = declaration.viewQueries) !== null && _e !== void 0 ? _e : []).map(convertQueryDeclarationToMetadata),
            providers: declaration.providers !== undefined ? new WrappedNodeExpr(declaration.providers) :
                null,
            exportAs: (_f = declaration.exportAs) !== null && _f !== void 0 ? _f : null,
            usesInheritance: (_g = declaration.usesInheritance) !== null && _g !== void 0 ? _g : false,
            lifecycle: { usesOnChanges: (_h = declaration.usesOnChanges) !== null && _h !== void 0 ? _h : false },
            deps: null,
            typeArgumentCount: 0,
            fullInheritance: false,
        };
    }
    function convertHostDeclarationToMetadata(host = {}) {
        var _a, _b, _c;
        return {
            attributes: convertOpaqueValuesToExpressions((_a = host.attributes) !== null && _a !== void 0 ? _a : {}),
            listeners: (_b = host.listeners) !== null && _b !== void 0 ? _b : {},
            properties: (_c = host.properties) !== null && _c !== void 0 ? _c : {},
            specialAttributes: {
                classAttr: host.classAttribute,
                styleAttr: host.styleAttribute,
            },
        };
    }
    function convertOpaqueValuesToExpressions(obj) {
        const result = {};
        for (const key of Object.keys(obj)) {
            result[key] = new WrappedNodeExpr(obj[key]);
        }
        return result;
    }
    function convertDeclareComponentFacadeToMetadata(declaration, typeSourceSpan, sourceMapUrl) {
        var _a, _b, _c, _d, _e, _f;
        const { template, interpolation } = parseJitTemplate(declaration.template, declaration.type.name, sourceMapUrl, (_a = declaration.preserveWhitespaces) !== null && _a !== void 0 ? _a : false, declaration.interpolation);
        return Object.assign(Object.assign({}, convertDeclareDirectiveFacadeToMetadata(declaration, typeSourceSpan)), { template, styles: (_b = declaration.styles) !== null && _b !== void 0 ? _b : [], directives: ((_c = declaration.components) !== null && _c !== void 0 ? _c : [])
                .concat((_d = declaration.directives) !== null && _d !== void 0 ? _d : [])
                .map(convertUsedDirectiveDeclarationToMetadata), pipes: convertUsedPipesToMetadata(declaration.pipes), viewProviders: declaration.viewProviders !== undefined ?
                new WrappedNodeExpr(declaration.viewProviders) :
                null, animations: declaration.animations !== undefined ? new WrappedNodeExpr(declaration.animations) :
                null, changeDetection: (_e = declaration.changeDetection) !== null && _e !== void 0 ? _e : ChangeDetectionStrategy.Default, encapsulation: (_f = declaration.encapsulation) !== null && _f !== void 0 ? _f : ViewEncapsulation.Emulated, interpolation, declarationListEmitMode: 2 /* ClosureResolved */, relativeContextFilePath: '', i18nUseExternalIds: true });
    }
    function convertUsedDirectiveDeclarationToMetadata(declaration) {
        var _a, _b, _c;
        return {
            selector: declaration.selector,
            type: new WrappedNodeExpr(declaration.type),
            inputs: (_a = declaration.inputs) !== null && _a !== void 0 ? _a : [],
            outputs: (_b = declaration.outputs) !== null && _b !== void 0 ? _b : [],
            exportAs: (_c = declaration.exportAs) !== null && _c !== void 0 ? _c : null,
        };
    }
    function convertUsedPipesToMetadata(declaredPipes) {
        const pipes = new Map();
        if (declaredPipes === undefined) {
            return pipes;
        }
        for (const pipeName of Object.keys(declaredPipes)) {
            const pipeType = declaredPipes[pipeName];
            pipes.set(pipeName, new WrappedNodeExpr(pipeType));
        }
        return pipes;
    }
    function parseJitTemplate(template, typeName, sourceMapUrl, preserveWhitespaces, interpolation) {
        const interpolationConfig = interpolation ? InterpolationConfig.fromArray(interpolation) : DEFAULT_INTERPOLATION_CONFIG;
        // Parse the template and check for errors.
        const parsed = parseTemplate(template, sourceMapUrl, { preserveWhitespaces: preserveWhitespaces, interpolationConfig });
        if (parsed.errors !== null) {
            const errors = parsed.errors.map(err => err.toString()).join(', ');
            throw new Error(`Errors during JIT compilation of template for ${typeName}: ${errors}`);
        }
        return { template: parsed, interpolation: interpolationConfig };
    }
    /**
     * Convert the expression, if present to an `R3ProviderExpression`.
     *
     * In JIT mode we do not want the compiler to wrap the expression in a `forwardRef()` call because,
     * if it is referencing a type that has not yet been defined, it will have already been wrapped in
     * a `forwardRef()` - either by the application developer or during partial-compilation. Thus we can
     * set `isForwardRef` to `false`.
     */
    function convertToProviderExpression(obj, property) {
        if (obj.hasOwnProperty(property)) {
            return createR3ProviderExpression(new WrappedNodeExpr(obj[property]), /* isForwardRef */ false);
        }
        else {
            return undefined;
        }
    }
    function wrapExpression(obj, property) {
        if (obj.hasOwnProperty(property)) {
            return new WrappedNodeExpr(obj[property]);
        }
        else {
            return undefined;
        }
    }
    function computeProvidedIn(providedIn) {
        const expression = (providedIn == null || typeof providedIn === 'string') ?
            new LiteralExpr(providedIn !== null && providedIn !== void 0 ? providedIn : null) :
            new WrappedNodeExpr(providedIn);
        // See `convertToProviderExpression()` for why `isForwardRef` is false.
        return createR3ProviderExpression(expression, /* isForwardRef */ false);
    }
    function convertR3DependencyMetadataArray(facades) {
        return facades == null ? null : facades.map(convertR3DependencyMetadata);
    }
    function convertR3DependencyMetadata(facade) {
        const isAttributeDep = facade.attribute != null; // both `null` and `undefined`
        const rawToken = facade.token === null ? null : new WrappedNodeExpr(facade.token);
        // In JIT mode, if the dep is an `@Attribute()` then we use the attribute name given in
        // `attribute` rather than the `token`.
        const token = isAttributeDep ? new WrappedNodeExpr(facade.attribute) : rawToken;
        return createR3DependencyMetadata(token, isAttributeDep, facade.host, facade.optional, facade.self, facade.skipSelf);
    }
    function convertR3DeclareDependencyMetadata(facade) {
        var _a, _b, _c, _d, _e;
        const isAttributeDep = (_a = facade.attribute) !== null && _a !== void 0 ? _a : false;
        const token = facade.token === null ? null : new WrappedNodeExpr(facade.token);
        return createR3DependencyMetadata(token, isAttributeDep, (_b = facade.host) !== null && _b !== void 0 ? _b : false, (_c = facade.optional) !== null && _c !== void 0 ? _c : false, (_d = facade.self) !== null && _d !== void 0 ? _d : false, (_e = facade.skipSelf) !== null && _e !== void 0 ? _e : false);
    }
    function createR3DependencyMetadata(token, isAttributeDep, host, optional, self, skipSelf) {
        // If the dep is an `@Attribute()` the `attributeNameType` ought to be the `unknown` type.
        // But types are not available at runtime so we just use a literal `"<unknown>"` string as a dummy
        // marker.
        const attributeNameType = isAttributeDep ? literal('unknown') : null;
        return { token, attributeNameType, host, optional, self, skipSelf };
    }
    function extractHostBindings(propMetadata, sourceSpan, host) {
        // First parse the declarations from the metadata.
        const bindings = parseHostBindings(host || {});
        // After that check host bindings for errors
        const errors = verifyHostBindings(bindings, sourceSpan);
        if (errors.length) {
            throw new Error(errors.map((error) => error.msg).join('\n'));
        }
        // Next, loop over the properties of the object, looking for @HostBinding and @HostListener.
        for (const field in propMetadata) {
            if (propMetadata.hasOwnProperty(field)) {
                propMetadata[field].forEach(ann => {
                    if (isHostBinding(ann)) {
                        // Since this is a decorator, we know that the value is a class member. Always access it
                        // through `this` so that further down the line it can't be confused for a literal value
                        // (e.g. if there's a property called `true`).
                        bindings.properties[ann.hostPropertyName || field] =
                            getSafePropertyAccessString('this', field);
                    }
                    else if (isHostListener(ann)) {
                        bindings.listeners[ann.eventName || field] = `${field}(${(ann.args || []).join(',')})`;
                    }
                });
            }
        }
        return bindings;
    }
    function isHostBinding(value) {
        return value.ngMetadataName === 'HostBinding';
    }
    function isHostListener(value) {
        return value.ngMetadataName === 'HostListener';
    }
    function isInput(value) {
        return value.ngMetadataName === 'Input';
    }
    function isOutput(value) {
        return value.ngMetadataName === 'Output';
    }
    function parseInputOutputs(values) {
        return values.reduce((map, value) => {
            const [field, property] = value.split(',').map(piece => piece.trim());
            map[field] = property || field;
            return map;
        }, {});
    }
    function convertDeclarePipeFacadeToMetadata(declaration) {
        var _a;
        return {
            name: declaration.type.name,
            type: wrapReference(declaration.type),
            internalType: new WrappedNodeExpr(declaration.type),
            typeArgumentCount: 0,
            pipeName: declaration.name,
            deps: null,
            pure: (_a = declaration.pure) !== null && _a !== void 0 ? _a : true,
        };
    }
    function convertDeclareInjectorFacadeToMetadata(declaration) {
        return {
            name: declaration.type.name,
            type: wrapReference(declaration.type),
            internalType: new WrappedNodeExpr(declaration.type),
            providers: declaration.providers !== undefined ? new WrappedNodeExpr(declaration.providers) :
                null,
            imports: declaration.imports !== undefined ?
                declaration.imports.map(i => new WrappedNodeExpr(i)) :
                [],
        };
    }
    function publishFacade(global) {
        const ng = global.ng || (global.ng = {});
        ng.ÉµcompilerFacade = new CompilerFacadeImpl();
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const VERSION$1 = new Version('12.2.12');

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class CompilerConfig {
        constructor({ defaultEncapsulation = ViewEncapsulation.Emulated, useJit = true, jitDevMode = false, missingTranslation = null, preserveWhitespaces, strictInjectionParameters } = {}) {
            this.defaultEncapsulation = defaultEncapsulation;
            this.useJit = !!useJit;
            this.jitDevMode = !!jitDevMode;
            this.missingTranslation = missingTranslation;
            this.preserveWhitespaces = preserveWhitespacesDefault(noUndefined(preserveWhitespaces));
            this.strictInjectionParameters = strictInjectionParameters === true;
        }
    }
    function preserveWhitespacesDefault(preserveWhitespacesOption, defaultSetting = false) {
        return preserveWhitespacesOption === null ? defaultSetting : preserveWhitespacesOption;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class DirectiveNormalizer {
        constructor(_resourceLoader, _urlResolver, _htmlParser, _config) {
            this._resourceLoader = _resourceLoader;
            this._urlResolver = _urlResolver;
            this._htmlParser = _htmlParser;
            this._config = _config;
            this._resourceLoaderCache = new Map();
        }
        clearCache() {
            this._resourceLoaderCache.clear();
        }
        clearCacheFor(normalizedDirective) {
            if (!normalizedDirective.isComponent) {
                return;
            }
            const template = normalizedDirective.template;
            this._resourceLoaderCache.delete(template.templateUrl);
            template.externalStylesheets.forEach((stylesheet) => {
                this._resourceLoaderCache.delete(stylesheet.moduleUrl);
            });
        }
        _fetch(url) {
            let result = this._resourceLoaderCache.get(url);
            if (!result) {
                result = this._resourceLoader.get(url);
                this._resourceLoaderCache.set(url, result);
            }
            return result;
        }
        normalizeTemplate(prenormData) {
            if (isDefined(prenormData.template)) {
                if (isDefined(prenormData.templateUrl)) {
                    throw syntaxError(`'${stringify(prenormData
                    .componentType)}' component cannot define both template and templateUrl`);
                }
                if (typeof prenormData.template !== 'string') {
                    throw syntaxError(`The template specified for component ${stringify(prenormData.componentType)} is not a string`);
                }
            }
            else if (isDefined(prenormData.templateUrl)) {
                if (typeof prenormData.templateUrl !== 'string') {
                    throw syntaxError(`The templateUrl specified for component ${stringify(prenormData.componentType)} is not a string`);
                }
            }
            else {
                throw syntaxError(`No template specified for component ${stringify(prenormData.componentType)}`);
            }
            if (isDefined(prenormData.preserveWhitespaces) &&
                typeof prenormData.preserveWhitespaces !== 'boolean') {
                throw syntaxError(`The preserveWhitespaces option for component ${stringify(prenormData.componentType)} must be a boolean`);
            }
            return SyncAsync.then(this._preParseTemplate(prenormData), (preparsedTemplate) => this._normalizeTemplateMetadata(prenormData, preparsedTemplate));
        }
        _preParseTemplate(prenomData) {
            let template;
            let templateUrl;
            if (prenomData.template != null) {
                template = prenomData.template;
                templateUrl = prenomData.moduleUrl;
            }
            else {
                templateUrl = this._urlResolver.resolve(prenomData.moduleUrl, prenomData.templateUrl);
                template = this._fetch(templateUrl);
            }
            return SyncAsync.then(template, (template) => this._preparseLoadedTemplate(prenomData, template, templateUrl));
        }
        _preparseLoadedTemplate(prenormData, template, templateAbsUrl) {
            const isInline = !!prenormData.template;
            const interpolationConfig = InterpolationConfig.fromArray(prenormData.interpolation);
            const templateUrl = templateSourceUrl({ reference: prenormData.ngModuleType }, { type: { reference: prenormData.componentType } }, { isInline, templateUrl: templateAbsUrl });
            const rootNodesAndErrors = this._htmlParser.parse(template, templateUrl, { tokenizeExpansionForms: true, interpolationConfig });
            if (rootNodesAndErrors.errors.length > 0) {
                const errorString = rootNodesAndErrors.errors.join('\n');
                throw syntaxError(`Template parse errors:\n${errorString}`);
            }
            const templateMetadataStyles = this._normalizeStylesheet(new CompileStylesheetMetadata({ styles: prenormData.styles, moduleUrl: prenormData.moduleUrl }));
            const visitor = new TemplatePreparseVisitor();
            visitAll$1(visitor, rootNodesAndErrors.rootNodes);
            const templateStyles = this._normalizeStylesheet(new CompileStylesheetMetadata({ styles: visitor.styles, styleUrls: visitor.styleUrls, moduleUrl: templateAbsUrl }));
            const styles = templateMetadataStyles.styles.concat(templateStyles.styles);
            const inlineStyleUrls = templateMetadataStyles.styleUrls.concat(templateStyles.styleUrls);
            const styleUrls = this
                ._normalizeStylesheet(new CompileStylesheetMetadata({ styleUrls: prenormData.styleUrls, moduleUrl: prenormData.moduleUrl }))
                .styleUrls;
            return {
                template,
                templateUrl: templateAbsUrl,
                isInline,
                htmlAst: rootNodesAndErrors,
                styles,
                inlineStyleUrls,
                styleUrls,
                ngContentSelectors: visitor.ngContentSelectors,
            };
        }
        _normalizeTemplateMetadata(prenormData, preparsedTemplate) {
            return SyncAsync.then(this._loadMissingExternalStylesheets(preparsedTemplate.styleUrls.concat(preparsedTemplate.inlineStyleUrls)), (externalStylesheets) => this._normalizeLoadedTemplateMetadata(prenormData, preparsedTemplate, externalStylesheets));
        }
        _normalizeLoadedTemplateMetadata(prenormData, preparsedTemplate, stylesheets) {
            // Algorithm:
            // - produce exactly 1 entry per original styleUrl in
            // CompileTemplateMetadata.externalStylesheets with all styles inlined
            // - inline all styles that are referenced by the template into CompileTemplateMetadata.styles.
            // Reason: be able to determine how many stylesheets there are even without loading
            // the template nor the stylesheets, so we can create a stub for TypeScript always synchronously
            // (as resource loading may be async)
            const styles = [...preparsedTemplate.styles];
            this._inlineStyles(preparsedTemplate.inlineStyleUrls, stylesheets, styles);
            const styleUrls = preparsedTemplate.styleUrls;
            const externalStylesheets = styleUrls.map(styleUrl => {
                const stylesheet = stylesheets.get(styleUrl);
                const styles = [...stylesheet.styles];
                this._inlineStyles(stylesheet.styleUrls, stylesheets, styles);
                return new CompileStylesheetMetadata({ moduleUrl: styleUrl, styles: styles });
            });
            let encapsulation = prenormData.encapsulation;
            if (encapsulation == null) {
                encapsulation = this._config.defaultEncapsulation;
            }
            if (encapsulation === ViewEncapsulation.Emulated && styles.length === 0 &&
                styleUrls.length === 0) {
                encapsulation = ViewEncapsulation.None;
            }
            return new CompileTemplateMetadata({
                encapsulation,
                template: preparsedTemplate.template,
                templateUrl: preparsedTemplate.templateUrl,
                htmlAst: preparsedTemplate.htmlAst,
                styles,
                styleUrls,
                ngContentSelectors: preparsedTemplate.ngContentSelectors,
                animations: prenormData.animations,
                interpolation: prenormData.interpolation,
                isInline: preparsedTemplate.isInline,
                externalStylesheets,
                preserveWhitespaces: preserveWhitespacesDefault(prenormData.preserveWhitespaces, this._config.preserveWhitespaces),
            });
        }
        _inlineStyles(styleUrls, stylesheets, targetStyles) {
            styleUrls.forEach(styleUrl => {
                const stylesheet = stylesheets.get(styleUrl);
                stylesheet.styles.forEach(style => targetStyles.push(style));
                this._inlineStyles(stylesheet.styleUrls, stylesheets, targetStyles);
            });
        }
        _loadMissingExternalStylesheets(styleUrls, loadedStylesheets = new Map()) {
            return SyncAsync.then(SyncAsync.all(styleUrls.filter((styleUrl) => !loadedStylesheets.has(styleUrl))
                .map(styleUrl => SyncAsync.then(this._fetch(styleUrl), (loadedStyle) => {
                const stylesheet = this._normalizeStylesheet(new CompileStylesheetMetadata({ styles: [loadedStyle], moduleUrl: styleUrl }));
                loadedStylesheets.set(styleUrl, stylesheet);
                return this._loadMissingExternalStylesheets(stylesheet.styleUrls, loadedStylesheets);
            }))), (_) => loadedStylesheets);
        }
        _normalizeStylesheet(stylesheet) {
            const moduleUrl = stylesheet.moduleUrl;
            const allStyleUrls = stylesheet.styleUrls.filter(isStyleUrlResolvable)
                .map(url => this._urlResolver.resolve(moduleUrl, url));
            const allStyles = stylesheet.styles.map(style => {
                const styleWithImports = extractStyleUrls(this._urlResolver, moduleUrl, style);
                allStyleUrls.push(...styleWithImports.styleUrls);
                return styleWithImports.style;
            });
            return new CompileStylesheetMetadata({ styles: allStyles, styleUrls: allStyleUrls, moduleUrl: moduleUrl });
        }
    }
    class TemplatePreparseVisitor {
        constructor() {
            this.ngContentSelectors = [];
            this.styles = [];
            this.styleUrls = [];
            this.ngNonBindableStackCount = 0;
        }
        visitElement(ast, context) {
            const preparsedElement = preparseElement(ast);
            switch (preparsedElement.type) {
                case PreparsedElementType.NG_CONTENT:
                    if (this.ngNonBindableStackCount === 0) {
                        this.ngContentSelectors.push(preparsedElement.selectAttr);
                    }
                    break;
                case PreparsedElementType.STYLE:
                    let textContent = '';
                    ast.children.forEach(child => {
                        if (child instanceof Text$2) {
                            textContent += child.value;
                        }
                    });
                    this.styles.push(textContent);
                    break;
                case PreparsedElementType.STYLESHEET:
                    this.styleUrls.push(preparsedElement.hrefAttr);
                    break;
            }
            if (preparsedElement.nonBindable) {
                this.ngNonBindableStackCount++;
            }
            visitAll$1(this, ast.children);
            if (preparsedElement.nonBindable) {
                this.ngNonBindableStackCount--;
            }
            return null;
        }
        visitExpansion(ast, context) {
            visitAll$1(this, ast.cases);
        }
        visitExpansionCase(ast, context) {
            visitAll$1(this, ast.expression);
        }
        visitComment(ast, context) {
            return null;
        }
        visitAttribute(ast, context) {
            return null;
        }
        visitText(ast, context) {
            return null;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const QUERY_METADATA_IDENTIFIERS = [
        createViewChild,
        createViewChildren,
        createContentChild,
        createContentChildren,
    ];
    /*
     * Resolve a `Type` for {@link Directive}.
     *
     * This interface can be overridden by the application developer to create custom behavior.
     *
     * See {@link Compiler}
     */
    class DirectiveResolver {
        constructor(_reflector) {
            this._reflector = _reflector;
        }
        isDirective(type) {
            const typeMetadata = this._reflector.annotations(resolveForwardRef(type));
            return typeMetadata && typeMetadata.some(isDirectiveMetadata);
        }
        resolve(type, throwIfNotFound = true) {
            const typeMetadata = this._reflector.annotations(resolveForwardRef(type));
            if (typeMetadata) {
                const metadata = findLast(typeMetadata, isDirectiveMetadata);
                if (metadata) {
                    const propertyMetadata = this._reflector.propMetadata(type);
                    const guards = this._reflector.guards(type);
                    return this._mergeWithPropertyMetadata(metadata, propertyMetadata, guards, type);
                }
            }
            if (throwIfNotFound) {
                throw new Error(`No Directive annotation found on ${stringify(type)}`);
            }
            return null;
        }
        _mergeWithPropertyMetadata(dm, propertyMetadata, guards, directiveType) {
            const inputs = [];
            const outputs = [];
            const host = {};
            const queries = {};
            Object.keys(propertyMetadata).forEach((propName) => {
                const input = findLast(propertyMetadata[propName], (a) => createInput.isTypeOf(a));
                if (input) {
                    if (input.bindingPropertyName) {
                        inputs.push(`${propName}: ${input.bindingPropertyName}`);
                    }
                    else {
                        inputs.push(propName);
                    }
                }
                const output = findLast(propertyMetadata[propName], (a) => createOutput.isTypeOf(a));
                if (output) {
                    if (output.bindingPropertyName) {
                        outputs.push(`${propName}: ${output.bindingPropertyName}`);
                    }
                    else {
                        outputs.push(propName);
                    }
                }
                const hostBindings = propertyMetadata[propName].filter(a => createHostBinding.isTypeOf(a));
                hostBindings.forEach(hostBinding => {
                    if (hostBinding.hostPropertyName) {
                        const startWith = hostBinding.hostPropertyName[0];
                        if (startWith === '(') {
                            throw new Error(`@HostBinding can not bind to events. Use @HostListener instead.`);
                        }
                        else if (startWith === '[') {
                            throw new Error(`@HostBinding parameter should be a property name, 'class.<name>', or 'attr.<name>'.`);
                        }
                        host[`[${hostBinding.hostPropertyName}]`] = propName;
                    }
                    else {
                        host[`[${propName}]`] = propName;
                    }
                });
                const hostListeners = propertyMetadata[propName].filter(a => createHostListener.isTypeOf(a));
                hostListeners.forEach(hostListener => {
                    const args = hostListener.args || [];
                    host[`(${hostListener.eventName})`] = `${propName}(${args.join(',')})`;
                });
                const query = findLast(propertyMetadata[propName], (a) => QUERY_METADATA_IDENTIFIERS.some(i => i.isTypeOf(a)));
                if (query) {
                    queries[propName] = query;
                }
            });
            return this._merge(dm, inputs, outputs, host, queries, guards, directiveType);
        }
        _extractPublicName(def) {
            return splitAtColon(def, [null, def])[1].trim();
        }
        _dedupeBindings(bindings) {
            const names = new Set();
            const publicNames = new Set();
            const reversedResult = [];
            // go last to first to allow later entries to overwrite previous entries
            for (let i = bindings.length - 1; i >= 0; i--) {
                const binding = bindings[i];
                const name = this._extractPublicName(binding);
                publicNames.add(name);
                if (!names.has(name)) {
                    names.add(name);
                    reversedResult.push(binding);
                }
            }
            return reversedResult.reverse();
        }
        _merge(directive, inputs, outputs, host, queries, guards, directiveType) {
            const mergedInputs = this._dedupeBindings(directive.inputs ? directive.inputs.concat(inputs) : inputs);
            const mergedOutputs = this._dedupeBindings(directive.outputs ? directive.outputs.concat(outputs) : outputs);
            const mergedHost = directive.host ? Object.assign(Object.assign({}, directive.host), host) : host;
            const mergedQueries = directive.queries ? Object.assign(Object.assign({}, directive.queries), queries) : queries;
            if (createComponent.isTypeOf(directive)) {
                const comp = directive;
                return createComponent({
                    selector: comp.selector,
                    inputs: mergedInputs,
                    outputs: mergedOutputs,
                    host: mergedHost,
                    exportAs: comp.exportAs,
                    moduleId: comp.moduleId,
                    queries: mergedQueries,
                    changeDetection: comp.changeDetection,
                    providers: comp.providers,
                    viewProviders: comp.viewProviders,
                    entryComponents: comp.entryComponents,
                    template: comp.template,
                    templateUrl: comp.templateUrl,
                    styles: comp.styles,
                    styleUrls: comp.styleUrls,
                    encapsulation: comp.encapsulation,
                    animations: comp.animations,
                    interpolation: comp.interpolation,
                    preserveWhitespaces: directive.preserveWhitespaces,
                });
            }
            else {
                return createDirective({
                    selector: directive.selector,
                    inputs: mergedInputs,
                    outputs: mergedOutputs,
                    host: mergedHost,
                    exportAs: directive.exportAs,
                    queries: mergedQueries,
                    providers: directive.providers,
                    guards
                });
            }
        }
    }
    function isDirectiveMetadata(type) {
        return createDirective.isTypeOf(type) || createComponent.isTypeOf(type);
    }
    function findLast(arr, condition) {
        for (let i = arr.length - 1; i >= 0; i--) {
            if (condition(arr[i])) {
                return arr[i];
            }
        }
        return null;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var _VisitorMode;
    (function (_VisitorMode) {
        _VisitorMode[_VisitorMode["Extract"] = 0] = "Extract";
        _VisitorMode[_VisitorMode["Merge"] = 1] = "Merge";
    })(_VisitorMode || (_VisitorMode = {}));

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const STRIP_SRC_FILE_SUFFIXES = /(\.ts|\.d\.ts|\.js|\.jsx|\.tsx)$/;
    const GENERATED_FILE = /\.ngfactory\.|\.ngsummary\./;
    const JIT_SUMMARY_FILE = /\.ngsummary\./;
    const JIT_SUMMARY_NAME = /NgSummary$/;
    function ngfactoryFilePath(filePath, forceSourceFile = false) {
        const urlWithSuffix = splitTypescriptSuffix(filePath, forceSourceFile);
        return `${urlWithSuffix[0]}.ngfactory${normalizeGenFileSuffix(urlWithSuffix[1])}`;
    }
    function stripGeneratedFileSuffix(filePath) {
        return filePath.replace(GENERATED_FILE, '.');
    }
    function isGeneratedFile(filePath) {
        return GENERATED_FILE.test(filePath);
    }
    function splitTypescriptSuffix(path, forceSourceFile = false) {
        if (path.endsWith('.d.ts')) {
            return [path.slice(0, -5), forceSourceFile ? '.ts' : '.d.ts'];
        }
        const lastDot = path.lastIndexOf('.');
        if (lastDot !== -1) {
            return [path.substring(0, lastDot), path.substring(lastDot)];
        }
        return [path, ''];
    }
    function normalizeGenFileSuffix(srcFileSuffix) {
        return srcFileSuffix === '.tsx' ? '.ts' : srcFileSuffix;
    }
    function summaryFileName(fileName) {
        const fileNameWithoutSuffix = fileName.replace(STRIP_SRC_FILE_SUFFIXES, '');
        return `${fileNameWithoutSuffix}.ngsummary.json`;
    }
    function summaryForJitFileName(fileName, forceSourceFile = false) {
        const urlWithSuffix = splitTypescriptSuffix(stripGeneratedFileSuffix(fileName), forceSourceFile);
        return `${urlWithSuffix[0]}.ngsummary${urlWithSuffix[1]}`;
    }
    function stripSummaryForJitFileSuffix(filePath) {
        return filePath.replace(JIT_SUMMARY_FILE, '.');
    }
    function summaryForJitName(symbolName) {
        return `${symbolName}NgSummary`;
    }
    function stripSummaryForJitNameSuffix(symbolName) {
        return symbolName.replace(JIT_SUMMARY_NAME, '');
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var LifecycleHooks;
    (function (LifecycleHooks) {
        LifecycleHooks[LifecycleHooks["OnInit"] = 0] = "OnInit";
        LifecycleHooks[LifecycleHooks["OnDestroy"] = 1] = "OnDestroy";
        LifecycleHooks[LifecycleHooks["DoCheck"] = 2] = "DoCheck";
        LifecycleHooks[LifecycleHooks["OnChanges"] = 3] = "OnChanges";
        LifecycleHooks[LifecycleHooks["AfterContentInit"] = 4] = "AfterContentInit";
        LifecycleHooks[LifecycleHooks["AfterContentChecked"] = 5] = "AfterContentChecked";
        LifecycleHooks[LifecycleHooks["AfterViewInit"] = 6] = "AfterViewInit";
        LifecycleHooks[LifecycleHooks["AfterViewChecked"] = 7] = "AfterViewChecked";
    })(LifecycleHooks || (LifecycleHooks = {}));
    const LIFECYCLE_HOOKS_VALUES = [
        LifecycleHooks.OnInit, LifecycleHooks.OnDestroy, LifecycleHooks.DoCheck, LifecycleHooks.OnChanges,
        LifecycleHooks.AfterContentInit, LifecycleHooks.AfterContentChecked, LifecycleHooks.AfterViewInit,
        LifecycleHooks.AfterViewChecked
    ];
    function hasLifecycleHook(reflector, hook, token) {
        return reflector.hasLifecycleHook(token, getHookName(hook));
    }
    function getAllLifecycleHooks(reflector, token) {
        return LIFECYCLE_HOOKS_VALUES.filter(hook => hasLifecycleHook(reflector, hook, token));
    }
    function getHookName(hook) {
        switch (hook) {
            case LifecycleHooks.OnInit:
                return 'ngOnInit';
            case LifecycleHooks.OnDestroy:
                return 'ngOnDestroy';
            case LifecycleHooks.DoCheck:
                return 'ngDoCheck';
            case LifecycleHooks.OnChanges:
                return 'ngOnChanges';
            case LifecycleHooks.AfterContentInit:
                return 'ngAfterContentInit';
            case LifecycleHooks.AfterContentChecked:
                return 'ngAfterContentChecked';
            case LifecycleHooks.AfterViewInit:
                return 'ngAfterViewInit';
            case LifecycleHooks.AfterViewChecked:
                return 'ngAfterViewChecked';
            default:
                // This default case is not needed by TypeScript compiler, as the switch is exhaustive.
                // However Closure Compiler does not understand that and reports an error in typed mode.
                // The `throw new Error` below works around the problem, and the unexpected: never variable
                // makes sure tsc still checks this code is unreachable.
                const unexpected = hook;
                throw new Error(`unexpected ${unexpected}`);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const ERROR_COMPONENT_TYPE = 'ngComponentType';
    const MISSING_NG_MODULE_METADATA_ERROR_DATA = 'ngMissingNgModuleMetadataErrorData';
    // Design notes:
    // - don't lazily create metadata:
    //   For some metadata, we need to do async work sometimes,
    //   so the user has to kick off this loading.
    //   But we want to report errors even when the async work is
    //   not required to check that the user would have been able
    //   to wait correctly.
    class CompileMetadataResolver {
        constructor(_config, _htmlParser, _ngModuleResolver, _directiveResolver, _pipeResolver, _summaryResolver, _schemaRegistry, _directiveNormalizer, _console, _staticSymbolCache, _reflector, _errorCollector) {
            this._config = _config;
            this._htmlParser = _htmlParser;
            this._ngModuleResolver = _ngModuleResolver;
            this._directiveResolver = _directiveResolver;
            this._pipeResolver = _pipeResolver;
            this._summaryResolver = _summaryResolver;
            this._schemaRegistry = _schemaRegistry;
            this._directiveNormalizer = _directiveNormalizer;
            this._console = _console;
            this._staticSymbolCache = _staticSymbolCache;
            this._reflector = _reflector;
            this._errorCollector = _errorCollector;
            this._nonNormalizedDirectiveCache = new Map();
            this._directiveCache = new Map();
            this._summaryCache = new Map();
            this._pipeCache = new Map();
            this._ngModuleCache = new Map();
            this._ngModuleOfTypes = new Map();
            this._shallowModuleCache = new Map();
        }
        getReflector() {
            return this._reflector;
        }
        clearCacheFor(type) {
            const dirMeta = this._directiveCache.get(type);
            this._directiveCache.delete(type);
            this._nonNormalizedDirectiveCache.delete(type);
            this._summaryCache.delete(type);
            this._pipeCache.delete(type);
            this._ngModuleOfTypes.delete(type);
            // Clear all of the NgModule as they contain transitive information!
            this._ngModuleCache.clear();
            if (dirMeta) {
                this._directiveNormalizer.clearCacheFor(dirMeta);
            }
        }
        clearCache() {
            this._directiveCache.clear();
            this._nonNormalizedDirectiveCache.clear();
            this._summaryCache.clear();
            this._pipeCache.clear();
            this._ngModuleCache.clear();
            this._ngModuleOfTypes.clear();
            this._directiveNormalizer.clearCache();
        }
        _createProxyClass(baseType, name) {
            let delegate = null;
            const proxyClass = function () {
                if (!delegate) {
                    throw new Error(`Illegal state: Class ${name} for type ${stringify(baseType)} is not compiled yet!`);
                }
                return delegate.apply(this, arguments);
            };
            proxyClass.setDelegate = (d) => {
                delegate = d;
                proxyClass.prototype = d.prototype;
            };
            // Make stringify work correctly
            proxyClass.overriddenName = name;
            return proxyClass;
        }
        getGeneratedClass(dirType, name) {
            if (dirType instanceof StaticSymbol) {
                return this._staticSymbolCache.get(ngfactoryFilePath(dirType.filePath), name);
            }
            else {
                return this._createProxyClass(dirType, name);
            }
        }
        getComponentViewClass(dirType) {
            return this.getGeneratedClass(dirType, viewClassName(dirType, 0));
        }
        getHostComponentViewClass(dirType) {
            return this.getGeneratedClass(dirType, hostViewClassName(dirType));
        }
        getHostComponentType(dirType) {
            const name = `${identifierName({ reference: dirType })}_Host`;
            if (dirType instanceof StaticSymbol) {
                return this._staticSymbolCache.get(dirType.filePath, name);
            }
            return this._createProxyClass(dirType, name);
        }
        getRendererType(dirType) {
            if (dirType instanceof StaticSymbol) {
                return this._staticSymbolCache.get(ngfactoryFilePath(dirType.filePath), rendererTypeName(dirType));
            }
            else {
                // returning an object as proxy,
                // that we fill later during runtime compilation.
                return {};
            }
        }
        getComponentFactory(selector, dirType, inputs, outputs) {
            if (dirType instanceof StaticSymbol) {
                return this._staticSymbolCache.get(ngfactoryFilePath(dirType.filePath), componentFactoryName(dirType));
            }
            else {
                const hostView = this.getHostComponentViewClass(dirType);
                // Note: ngContentSelectors will be filled later once the template is
                // loaded.
                const createComponentFactory = this._reflector.resolveExternalReference(Identifiers$1.createComponentFactory);
                return createComponentFactory(selector, dirType, hostView, inputs, outputs, []);
            }
        }
        initComponentFactory(factory, ngContentSelectors) {
            if (!(factory instanceof StaticSymbol)) {
                factory.ngContentSelectors.push(...ngContentSelectors);
            }
        }
        _loadSummary(type, kind) {
            let typeSummary = this._summaryCache.get(type);
            if (!typeSummary) {
                const summary = this._summaryResolver.resolveSummary(type);
                typeSummary = summary ? summary.type : null;
                this._summaryCache.set(type, typeSummary || null);
            }
            return typeSummary && typeSummary.summaryKind === kind ? typeSummary : null;
        }
        getHostComponentMetadata(compMeta, hostViewType) {
            const hostType = this.getHostComponentType(compMeta.type.reference);
            if (!hostViewType) {
                hostViewType = this.getHostComponentViewClass(hostType);
            }
            // Note: ! is ok here as this method should only be called with normalized directive
            // metadata, which always fills in the selector.
            const template = CssSelector.parse(compMeta.selector)[0].getMatchingElementTemplate();
            const templateUrl = '';
            const htmlAst = this._htmlParser.parse(template, templateUrl);
            return CompileDirectiveMetadata.create({
                isHost: true,
                type: { reference: hostType, diDeps: [], lifecycleHooks: [] },
                template: new CompileTemplateMetadata({
                    encapsulation: ViewEncapsulation.None,
                    template,
                    templateUrl,
                    htmlAst,
                    styles: [],
                    styleUrls: [],
                    ngContentSelectors: [],
                    animations: [],
                    isInline: true,
                    externalStylesheets: [],
                    interpolation: null,
                    preserveWhitespaces: false,
                }),
                exportAs: null,
                changeDetection: ChangeDetectionStrategy.Default,
                inputs: [],
                outputs: [],
                host: {},
                isComponent: true,
                selector: '*',
                providers: [],
                viewProviders: [],
                queries: [],
                guards: {},
                viewQueries: [],
                componentViewType: hostViewType,
                rendererType: { id: '__Host__', encapsulation: ViewEncapsulation.None, styles: [], data: {} },
                entryComponents: [],
                componentFactory: null
            });
        }
        loadDirectiveMetadata(ngModuleType, directiveType, isSync) {
            if (this._directiveCache.has(directiveType)) {
                return null;
            }
            directiveType = resolveForwardRef(directiveType);
            const { annotation, metadata } = this.getNonNormalizedDirectiveMetadata(directiveType);
            const createDirectiveMetadata = (templateMetadata) => {
                const normalizedDirMeta = new CompileDirectiveMetadata({
                    isHost: false,
                    type: metadata.type,
                    isComponent: metadata.isComponent,
                    selector: metadata.selector,
                    exportAs: metadata.exportAs,
                    changeDetection: metadata.changeDetection,
                    inputs: metadata.inputs,
                    outputs: metadata.outputs,
                    hostListeners: metadata.hostListeners,
                    hostProperties: metadata.hostProperties,
                    hostAttributes: metadata.hostAttributes,
                    providers: metadata.providers,
                    viewProviders: metadata.viewProviders,
                    queries: metadata.queries,
                    guards: metadata.guards,
                    viewQueries: metadata.viewQueries,
                    entryComponents: metadata.entryComponents,
                    componentViewType: metadata.componentViewType,
                    rendererType: metadata.rendererType,
                    componentFactory: metadata.componentFactory,
                    template: templateMetadata
                });
                if (templateMetadata) {
                    this.initComponentFactory(metadata.componentFactory, templateMetadata.ngContentSelectors);
                }
                this._directiveCache.set(directiveType, normalizedDirMeta);
                this._summaryCache.set(directiveType, normalizedDirMeta.toSummary());
                return null;
            };
            if (metadata.isComponent) {
                const template = metadata.template;
                const templateMeta = this._directiveNormalizer.normalizeTemplate({
                    ngModuleType,
                    componentType: directiveType,
                    moduleUrl: this._reflector.componentModuleUrl(directiveType, annotation),
                    encapsulation: template.encapsulation,
                    template: template.template,
                    templateUrl: template.templateUrl,
                    styles: template.styles,
                    styleUrls: template.styleUrls,
                    animations: template.animations,
                    interpolation: template.interpolation,
                    preserveWhitespaces: template.preserveWhitespaces
                });
                if (isPromise(templateMeta) && isSync) {
                    this._reportError(componentStillLoadingError(directiveType), directiveType);
                    return null;
                }
                return SyncAsync.then(templateMeta, createDirectiveMetadata);
            }
            else {
                // directive
                createDirectiveMetadata(null);
                return null;
            }
        }
        getNonNormalizedDirectiveMetadata(directiveType) {
            directiveType = resolveForwardRef(directiveType);
            if (!directiveType) {
                return null;
            }
            let cacheEntry = this._nonNormalizedDirectiveCache.get(directiveType);
            if (cacheEntry) {
                return cacheEntry;
            }
            const dirMeta = this._directiveResolver.resolve(directiveType, false);
            if (!dirMeta) {
                return null;
            }
            let nonNormalizedTemplateMetadata = undefined;
            if (createComponent.isTypeOf(dirMeta)) {
                // component
                const compMeta = dirMeta;
                assertArrayOfStrings('styles', compMeta.styles);
                assertArrayOfStrings('styleUrls', compMeta.styleUrls);
                assertInterpolationSymbols('interpolation', compMeta.interpolation);
                const animations = compMeta.animations;
                nonNormalizedTemplateMetadata = new CompileTemplateMetadata({
                    encapsulation: noUndefined(compMeta.encapsulation),
                    template: noUndefined(compMeta.template),
                    templateUrl: noUndefined(compMeta.templateUrl),
                    htmlAst: null,
                    styles: compMeta.styles || [],
                    styleUrls: compMeta.styleUrls || [],
                    animations: animations || [],
                    interpolation: noUndefined(compMeta.interpolation),
                    isInline: !!compMeta.template,
                    externalStylesheets: [],
                    ngContentSelectors: [],
                    preserveWhitespaces: noUndefined(dirMeta.preserveWhitespaces),
                });
            }
            let changeDetectionStrategy = null;
            let viewProviders = [];
            let entryComponentMetadata = [];
            let selector = dirMeta.selector;
            if (createComponent.isTypeOf(dirMeta)) {
                // Component
                const compMeta = dirMeta;
                changeDetectionStrategy = compMeta.changeDetection;
                if (compMeta.viewProviders) {
                    viewProviders = this._getProvidersMetadata(compMeta.viewProviders, entryComponentMetadata, `viewProviders for "${stringifyType(directiveType)}"`, [], directiveType);
                }
                if (compMeta.entryComponents) {
                    entryComponentMetadata = flattenAndDedupeArray(compMeta.entryComponents)
                        .map((type) => this._getEntryComponentMetadata(type))
                        .concat(entryComponentMetadata);
                }
                if (!selector) {
                    selector = this._schemaRegistry.getDefaultComponentElementName();
                }
            }
            else {
                // Directive
                if (!selector) {
                    selector = null;
                }
            }
            let providers = [];
            if (dirMeta.providers != null) {
                providers = this._getProvidersMetadata(dirMeta.providers, entryComponentMetadata, `providers for "${stringifyType(directiveType)}"`, [], directiveType);
            }
            let queries = [];
            let viewQueries = [];
            if (dirMeta.queries != null) {
                queries = this._getQueriesMetadata(dirMeta.queries, false, directiveType);
                viewQueries = this._getQueriesMetadata(dirMeta.queries, true, directiveType);
            }
            const metadata = CompileDirectiveMetadata.create({
                isHost: false,
                selector: selector,
                exportAs: noUndefined(dirMeta.exportAs),
                isComponent: !!nonNormalizedTemplateMetadata,
                type: this._getTypeMetadata(directiveType),
                template: nonNormalizedTemplateMetadata,
                changeDetection: changeDetectionStrategy,
                inputs: dirMeta.inputs || [],
                outputs: dirMeta.outputs || [],
                host: dirMeta.host || {},
                providers: providers || [],
                viewProviders: viewProviders || [],
                queries: queries || [],
                guards: dirMeta.guards || {},
                viewQueries: viewQueries || [],
                entryComponents: entryComponentMetadata,
                componentViewType: nonNormalizedTemplateMetadata ? this.getComponentViewClass(directiveType) :
                    null,
                rendererType: nonNormalizedTemplateMetadata ? this.getRendererType(directiveType) : null,
                componentFactory: null
            });
            if (nonNormalizedTemplateMetadata) {
                metadata.componentFactory =
                    this.getComponentFactory(selector, directiveType, metadata.inputs, metadata.outputs);
            }
            cacheEntry = { metadata, annotation: dirMeta };
            this._nonNormalizedDirectiveCache.set(directiveType, cacheEntry);
            return cacheEntry;
        }
        /**
         * Gets the metadata for the given directive.
         * This assumes `loadNgModuleDirectiveAndPipeMetadata` has been called first.
         */
        getDirectiveMetadata(directiveType) {
            const dirMeta = this._directiveCache.get(directiveType);
            if (!dirMeta) {
                this._reportError(syntaxError(`Illegal state: getDirectiveMetadata can only be called after loadNgModuleDirectiveAndPipeMetadata for a module that declares it. Directive ${stringifyType(directiveType)}.`), directiveType);
            }
            return dirMeta;
        }
        getDirectiveSummary(dirType) {
            const dirSummary = this._loadSummary(dirType, CompileSummaryKind.Directive);
            if (!dirSummary) {
                this._reportError(syntaxError(`Illegal state: Could not load the summary for directive ${stringifyType(dirType)}.`), dirType);
            }
            return dirSummary;
        }
        isDirective(type) {
            return !!this._loadSummary(type, CompileSummaryKind.Directive) ||
                this._directiveResolver.isDirective(type);
        }
        isAbstractDirective(type) {
            const summary = this._loadSummary(type, CompileSummaryKind.Directive);
            if (summary && !summary.isComponent) {
                return !summary.selector;
            }
            const meta = this._directiveResolver.resolve(type, false);
            if (meta && !createComponent.isTypeOf(meta)) {
                return !meta.selector;
            }
            return false;
        }
        isPipe(type) {
            return !!this._loadSummary(type, CompileSummaryKind.Pipe) ||
                this._pipeResolver.isPipe(type);
        }
        isNgModule(type) {
            return !!this._loadSummary(type, CompileSummaryKind.NgModule) ||
                this._ngModuleResolver.isNgModule(type);
        }
        getNgModuleSummary(moduleType, alreadyCollecting = null) {
            let moduleSummary = this._loadSummary(moduleType, CompileSummaryKind.NgModule);
            if (!moduleSummary) {
                const moduleMeta = this.getNgModuleMetadata(moduleType, false, alreadyCollecting);
                moduleSummary = moduleMeta ? moduleMeta.toSummary() : null;
                if (moduleSummary) {
                    this._summaryCache.set(moduleType, moduleSummary);
                }
            }
            return moduleSummary;
        }
        /**
         * Loads the declared directives and pipes of an NgModule.
         */
        loadNgModuleDirectiveAndPipeMetadata(moduleType, isSync, throwIfNotFound = true) {
            const ngModule = this.getNgModuleMetadata(moduleType, throwIfNotFound);
            const loading = [];
            if (ngModule) {
                ngModule.declaredDirectives.forEach((id) => {
                    const promise = this.loadDirectiveMetadata(moduleType, id.reference, isSync);
                    if (promise) {
                        loading.push(promise);
                    }
                });
                ngModule.declaredPipes.forEach((id) => this._loadPipeMetadata(id.reference));
            }
            return Promise.all(loading);
        }
        getShallowModuleMetadata(moduleType) {
            let compileMeta = this._shallowModuleCache.get(moduleType);
            if (compileMeta) {
                return compileMeta;
            }
            const ngModuleMeta = findLast(this._reflector.shallowAnnotations(moduleType), createNgModule.isTypeOf);
            compileMeta = {
                type: this._getTypeMetadata(moduleType),
                rawExports: ngModuleMeta.exports,
                rawImports: ngModuleMeta.imports,
                rawProviders: ngModuleMeta.providers,
            };
            this._shallowModuleCache.set(moduleType, compileMeta);
            return compileMeta;
        }
        getNgModuleMetadata(moduleType, throwIfNotFound = true, alreadyCollecting = null) {
            moduleType = resolveForwardRef(moduleType);
            let compileMeta = this._ngModuleCache.get(moduleType);
            if (compileMeta) {
                return compileMeta;
            }
            const meta = this._ngModuleResolver.resolve(moduleType, throwIfNotFound);
            if (!meta) {
                return null;
            }
            const declaredDirectives = [];
            const exportedNonModuleIdentifiers = [];
            const declaredPipes = [];
            const importedModules = [];
            const exportedModules = [];
            const providers = [];
            const entryComponents = [];
            const bootstrapComponents = [];
            const schemas = [];
            if (meta.imports) {
                flattenAndDedupeArray(meta.imports).forEach((importedType) => {
                    let importedModuleType = undefined;
                    if (isValidType(importedType)) {
                        importedModuleType = importedType;
                    }
                    else if (importedType && importedType.ngModule) {
                        const moduleWithProviders = importedType;
                        importedModuleType = moduleWithProviders.ngModule;
                        if (moduleWithProviders.providers) {
                            providers.push(...this._getProvidersMetadata(moduleWithProviders.providers, entryComponents, `provider for the NgModule '${stringifyType(importedModuleType)}'`, [], importedType));
                        }
                    }
                    if (importedModuleType) {
                        if (this._checkSelfImport(moduleType, importedModuleType))
                            return;
                        if (!alreadyCollecting)
                            alreadyCollecting = new Set();
                        if (alreadyCollecting.has(importedModuleType)) {
                            this._reportError(syntaxError(`${this._getTypeDescriptor(importedModuleType)} '${stringifyType(importedType)}' is imported recursively by the module '${stringifyType(moduleType)}'.`), moduleType);
                            return;
                        }
                        alreadyCollecting.add(importedModuleType);
                        const importedModuleSummary = this.getNgModuleSummary(importedModuleType, alreadyCollecting);
                        alreadyCollecting.delete(importedModuleType);
                        if (!importedModuleSummary) {
                            const err = syntaxError(`Unexpected ${this._getTypeDescriptor(importedType)} '${stringifyType(importedType)}' imported by the module '${stringifyType(moduleType)}'. Please add a @NgModule annotation.`);
                            // If possible, record additional context for this error to enable more useful
                            // diagnostics on the compiler side.
                            if (importedType instanceof StaticSymbol) {
                                err[MISSING_NG_MODULE_METADATA_ERROR_DATA] = {
                                    fileName: importedType.filePath,
                                    className: importedType.name,
                                };
                            }
                            this._reportError(err, moduleType);
                            return;
                        }
                        importedModules.push(importedModuleSummary);
                    }
                    else {
                        this._reportError(syntaxError(`Unexpected value '${stringifyType(importedType)}' imported by the module '${stringifyType(moduleType)}'`), moduleType);
                        return;
                    }
                });
            }
            if (meta.exports) {
                flattenAndDedupeArray(meta.exports).forEach((exportedType) => {
                    if (!isValidType(exportedType)) {
                        this._reportError(syntaxError(`Unexpected value '${stringifyType(exportedType)}' exported by the module '${stringifyType(moduleType)}'`), moduleType);
                        return;
                    }
                    if (!alreadyCollecting)
                        alreadyCollecting = new Set();
                    if (alreadyCollecting.has(exportedType)) {
                        this._reportError(syntaxError(`${this._getTypeDescriptor(exportedType)} '${stringify(exportedType)}' is exported recursively by the module '${stringifyType(moduleType)}'`), moduleType);
                        return;
                    }
                    alreadyCollecting.add(exportedType);
                    const exportedModuleSummary = this.getNgModuleSummary(exportedType, alreadyCollecting);
                    alreadyCollecting.delete(exportedType);
                    if (exportedModuleSummary) {
                        exportedModules.push(exportedModuleSummary);
                    }
                    else {
                        exportedNonModuleIdentifiers.push(this._getIdentifierMetadata(exportedType));
                    }
                });
            }
            // Note: This will be modified later, so we rely on
            // getting a new instance every time!
            const transitiveModule = this._getTransitiveNgModuleMetadata(importedModules, exportedModules);
            if (meta.declarations) {
                flattenAndDedupeArray(meta.declarations).forEach((declaredType) => {
                    if (!isValidType(declaredType)) {
                        this._reportError(syntaxError(`Unexpected value '${stringifyType(declaredType)}' declared by the module '${stringifyType(moduleType)}'`), moduleType);
                        return;
                    }
                    const declaredIdentifier = this._getIdentifierMetadata(declaredType);
                    if (this.isDirective(declaredType)) {
                        if (this.isAbstractDirective(declaredType)) {
                            this._reportError(syntaxError(`Directive ${stringifyType(declaredType)} has no selector, please add it!`), declaredType);
                        }
                        transitiveModule.addDirective(declaredIdentifier);
                        declaredDirectives.push(declaredIdentifier);
                        this._addTypeToModule(declaredType, moduleType);
                    }
                    else if (this.isPipe(declaredType)) {
                        transitiveModule.addPipe(declaredIdentifier);
                        transitiveModule.pipes.push(declaredIdentifier);
                        declaredPipes.push(declaredIdentifier);
                        this._addTypeToModule(declaredType, moduleType);
                    }
                    else {
                        this._reportError(syntaxError(`Unexpected ${this._getTypeDescriptor(declaredType)} '${stringifyType(declaredType)}' declared by the module '${stringifyType(moduleType)}'. Please add a @Pipe/@Directive/@Component annotation.`), moduleType);
                        return;
                    }
                });
            }
            const exportedDirectives = [];
            const exportedPipes = [];
            exportedNonModuleIdentifiers.forEach((exportedId) => {
                if (transitiveModule.directivesSet.has(exportedId.reference)) {
                    exportedDirectives.push(exportedId);
                    transitiveModule.addExportedDirective(exportedId);
                }
                else if (transitiveModule.pipesSet.has(exportedId.reference)) {
                    exportedPipes.push(exportedId);
                    transitiveModule.addExportedPipe(exportedId);
                }
                else {
                    this._reportError(syntaxError(`Can't export ${this._getTypeDescriptor(exportedId.reference)} ${stringifyType(exportedId.reference)} from ${stringifyType(moduleType)} as it was neither declared nor imported!`), moduleType);
                    return;
                }
            });
            // The providers of the module have to go last
            // so that they overwrite any other provider we already added.
            if (meta.providers) {
                providers.push(...this._getProvidersMetadata(meta.providers, entryComponents, `provider for the NgModule '${stringifyType(moduleType)}'`, [], moduleType));
            }
            if (meta.entryComponents) {
                entryComponents.push(...flattenAndDedupeArray(meta.entryComponents)
                    .map(type => this._getEntryComponentMetadata(type)));
            }
            if (meta.bootstrap) {
                flattenAndDedupeArray(meta.bootstrap).forEach(type => {
                    if (!isValidType(type)) {
                        this._reportError(syntaxError(`Unexpected value '${stringifyType(type)}' used in the bootstrap property of module '${stringifyType(moduleType)}'`), moduleType);
                        return;
                    }
                    bootstrapComponents.push(this._getIdentifierMetadata(type));
                });
            }
            entryComponents.push(...bootstrapComponents.map(type => this._getEntryComponentMetadata(type.reference)));
            if (meta.schemas) {
                schemas.push(...flattenAndDedupeArray(meta.schemas));
            }
            compileMeta = new CompileNgModuleMetadata({
                type: this._getTypeMetadata(moduleType),
                providers,
                entryComponents,
                bootstrapComponents,
                schemas,
                declaredDirectives,
                exportedDirectives,
                declaredPipes,
                exportedPipes,
                importedModules,
                exportedModules,
                transitiveModule,
                id: meta.id || null,
            });
            entryComponents.forEach((id) => transitiveModule.addEntryComponent(id));
            providers.forEach((provider) => transitiveModule.addProvider(provider, compileMeta.type));
            transitiveModule.addModule(compileMeta.type);
            this._ngModuleCache.set(moduleType, compileMeta);
            return compileMeta;
        }
        _checkSelfImport(moduleType, importedModuleType) {
            if (moduleType === importedModuleType) {
                this._reportError(syntaxError(`'${stringifyType(moduleType)}' module can't import itself`), moduleType);
                return true;
            }
            return false;
        }
        _getTypeDescriptor(type) {
            if (isValidType(type)) {
                if (this.isDirective(type)) {
                    return 'directive';
                }
                if (this.isPipe(type)) {
                    return 'pipe';
                }
                if (this.isNgModule(type)) {
                    return 'module';
                }
            }
            if (type.provide) {
                return 'provider';
            }
            return 'value';
        }
        _addTypeToModule(type, moduleType) {
            const oldModule = this._ngModuleOfTypes.get(type);
            if (oldModule && oldModule !== moduleType) {
                this._reportError(syntaxError(`Type ${stringifyType(type)} is part of the declarations of 2 modules: ${stringifyType(oldModule)} and ${stringifyType(moduleType)}! ` +
                    `Please consider moving ${stringifyType(type)} to a higher module that imports ${stringifyType(oldModule)} and ${stringifyType(moduleType)}. ` +
                    `You can also create a new NgModule that exports and includes ${stringifyType(type)} then import that NgModule in ${stringifyType(oldModule)} and ${stringifyType(moduleType)}.`), moduleType);
                return;
            }
            this._ngModuleOfTypes.set(type, moduleType);
        }
        _getTransitiveNgModuleMetadata(importedModules, exportedModules) {
            // collect `providers` / `entryComponents` from all imported and all exported modules
            const result = new TransitiveCompileNgModuleMetadata();
            const modulesByToken = new Map();
            importedModules.concat(exportedModules).forEach((modSummary) => {
                modSummary.modules.forEach((mod) => result.addModule(mod));
                modSummary.entryComponents.forEach((comp) => result.addEntryComponent(comp));
                const addedTokens = new Set();
                modSummary.providers.forEach((entry) => {
                    const tokenRef = tokenReference(entry.provider.token);
                    let prevModules = modulesByToken.get(tokenRef);
                    if (!prevModules) {
                        prevModules = new Set();
                        modulesByToken.set(tokenRef, prevModules);
                    }
                    const moduleRef = entry.module.reference;
                    // Note: the providers of one module may still contain multiple providers
                    // per token (e.g. for multi providers), and we need to preserve these.
                    if (addedTokens.has(tokenRef) || !prevModules.has(moduleRef)) {
                        prevModules.add(moduleRef);
                        addedTokens.add(tokenRef);
                        result.addProvider(entry.provider, entry.module);
                    }
                });
            });
            exportedModules.forEach((modSummary) => {
                modSummary.exportedDirectives.forEach((id) => result.addExportedDirective(id));
                modSummary.exportedPipes.forEach((id) => result.addExportedPipe(id));
            });
            importedModules.forEach((modSummary) => {
                modSummary.exportedDirectives.forEach((id) => result.addDirective(id));
                modSummary.exportedPipes.forEach((id) => result.addPipe(id));
            });
            return result;
        }
        _getIdentifierMetadata(type) {
            type = resolveForwardRef(type);
            return { reference: type };
        }
        isInjectable(type) {
            const annotations = this._reflector.tryAnnotations(type);
            return annotations.some(ann => createInjectable.isTypeOf(ann));
        }
        getInjectableSummary(type) {
            return {
                summaryKind: CompileSummaryKind.Injectable,
                type: this._getTypeMetadata(type, null, false)
            };
        }
        getInjectableMetadata(type, dependencies = null, throwOnUnknownDeps = true) {
            const typeSummary = this._loadSummary(type, CompileSummaryKind.Injectable);
            const typeMetadata = typeSummary ?
                typeSummary.type :
                this._getTypeMetadata(type, dependencies, throwOnUnknownDeps);
            const annotations = this._reflector.annotations(type).filter(ann => createInjectable.isTypeOf(ann));
            if (annotations.length === 0) {
                return null;
            }
            const meta = annotations[annotations.length - 1];
            return {
                symbol: type,
                type: typeMetadata,
                providedIn: meta.providedIn,
                useValue: meta.useValue,
                useClass: meta.useClass,
                useExisting: meta.useExisting,
                useFactory: meta.useFactory,
                deps: meta.deps,
            };
        }
        _getTypeMetadata(type, dependencies = null, throwOnUnknownDeps = true) {
            const identifier = this._getIdentifierMetadata(type);
            return {
                reference: identifier.reference,
                diDeps: this._getDependenciesMetadata(identifier.reference, dependencies, throwOnUnknownDeps),
                lifecycleHooks: getAllLifecycleHooks(this._reflector, identifier.reference),
            };
        }
        _getFactoryMetadata(factory, dependencies = null) {
            factory = resolveForwardRef(factory);
            return { reference: factory, diDeps: this._getDependenciesMetadata(factory, dependencies) };
        }
        /**
         * Gets the metadata for the given pipe.
         * This assumes `loadNgModuleDirectiveAndPipeMetadata` has been called first.
         */
        getPipeMetadata(pipeType) {
            const pipeMeta = this._pipeCache.get(pipeType);
            if (!pipeMeta) {
                this._reportError(syntaxError(`Illegal state: getPipeMetadata can only be called after loadNgModuleDirectiveAndPipeMetadata for a module that declares it. Pipe ${stringifyType(pipeType)}.`), pipeType);
            }
            return pipeMeta || null;
        }
        getPipeSummary(pipeType) {
            const pipeSummary = this._loadSummary(pipeType, CompileSummaryKind.Pipe);
            if (!pipeSummary) {
                this._reportError(syntaxError(`Illegal state: Could not load the summary for pipe ${stringifyType(pipeType)}.`), pipeType);
            }
            return pipeSummary;
        }
        getOrLoadPipeMetadata(pipeType) {
            let pipeMeta = this._pipeCache.get(pipeType);
            if (!pipeMeta) {
                pipeMeta = this._loadPipeMetadata(pipeType);
            }
            return pipeMeta;
        }
        _loadPipeMetadata(pipeType) {
            pipeType = resolveForwardRef(pipeType);
            const pipeAnnotation = this._pipeResolver.resolve(pipeType);
            const pipeMeta = new CompilePipeMetadata({
                type: this._getTypeMetadata(pipeType),
                name: pipeAnnotation.name,
                pure: !!pipeAnnotation.pure
            });
            this._pipeCache.set(pipeType, pipeMeta);
            this._summaryCache.set(pipeType, pipeMeta.toSummary());
            return pipeMeta;
        }
        _getDependenciesMetadata(typeOrFunc, dependencies, throwOnUnknownDeps = true) {
            let hasUnknownDeps = false;
            const params = dependencies || this._reflector.parameters(typeOrFunc) || [];
            const dependenciesMetadata = params.map((param) => {
                let isAttribute = false;
                let isHost = false;
                let isSelf = false;
                let isSkipSelf = false;
                let isOptional = false;
                let token = null;
                if (Array.isArray(param)) {
                    param.forEach((paramEntry) => {
                        if (createHost.isTypeOf(paramEntry)) {
                            isHost = true;
                        }
                        else if (createSelf.isTypeOf(paramEntry)) {
                            isSelf = true;
                        }
                        else if (createSkipSelf.isTypeOf(paramEntry)) {
                            isSkipSelf = true;
                        }
                        else if (createOptional.isTypeOf(paramEntry)) {
                            isOptional = true;
                        }
                        else if (createAttribute.isTypeOf(paramEntry)) {
                            isAttribute = true;
                            token = paramEntry.attributeName;
                        }
                        else if (createInject.isTypeOf(paramEntry)) {
                            token = paramEntry.token;
                        }
                        else if (createInjectionToken.isTypeOf(paramEntry) ||
                            paramEntry instanceof StaticSymbol) {
                            token = paramEntry;
                        }
                        else if (isValidType(paramEntry) && token == null) {
                            token = paramEntry;
                        }
                    });
                }
                else {
                    token = param;
                }
                if (token == null) {
                    hasUnknownDeps = true;
                    return {};
                }
                return {
                    isAttribute,
                    isHost,
                    isSelf,
                    isSkipSelf,
                    isOptional,
                    token: this._getTokenMetadata(token)
                };
            });
            if (hasUnknownDeps) {
                const depsTokens = dependenciesMetadata.map((dep) => dep.token ? stringifyType(dep.token) : '?').join(', ');
                const message = `Can't resolve all parameters for ${stringifyType(typeOrFunc)}: (${depsTokens}).`;
                if (throwOnUnknownDeps || this._config.strictInjectionParameters) {
                    this._reportError(syntaxError(message), typeOrFunc);
                }
            }
            return dependenciesMetadata;
        }
        _getTokenMetadata(token) {
            token = resolveForwardRef(token);
            let compileToken;
            if (typeof token === 'string') {
                compileToken = { value: token };
            }
            else {
                compileToken = { identifier: { reference: token } };
            }
            return compileToken;
        }
        _getProvidersMetadata(providers, targetEntryComponents, debugInfo, compileProviders = [], type) {
            providers.forEach((provider, providerIdx) => {
                if (Array.isArray(provider)) {
                    this._getProvidersMetadata(provider, targetEntryComponents, debugInfo, compileProviders);
                }
                else {
                    provider = resolveForwardRef(provider);
                    let providerMeta = undefined;
                    if (provider && typeof provider === 'object' && provider.hasOwnProperty('provide')) {
                        this._validateProvider(provider);
                        providerMeta = new ProviderMeta(provider.provide, provider);
                    }
                    else if (isValidType(provider)) {
                        providerMeta = new ProviderMeta(provider, { useClass: provider });
                    }
                    else if (provider === void 0) {
                        this._reportError(syntaxError(`Encountered undefined provider! Usually this means you have a circular dependencies. This might be caused by using 'barrel' index.ts files.`));
                        return;
                    }
                    else {
                        const providersInfo = providers
                            .reduce((soFar, seenProvider, seenProviderIdx) => {
                            if (seenProviderIdx < providerIdx) {
                                soFar.push(`${stringifyType(seenProvider)}`);
                            }
                            else if (seenProviderIdx == providerIdx) {
                                soFar.push(`?${stringifyType(seenProvider)}?`);
                            }
                            else if (seenProviderIdx == providerIdx + 1) {
                                soFar.push('...');
                            }
                            return soFar;
                        }, [])
                            .join(', ');
                        this._reportError(syntaxError(`Invalid ${debugInfo ?
                        debugInfo :
                        'provider'} - only instances of Provider and Type are allowed, got: [${providersInfo}]`), type);
                        return;
                    }
                    if (providerMeta.token ===
                        this._reflector.resolveExternalReference(Identifiers$1.ANALYZE_FOR_ENTRY_COMPONENTS)) {
                        targetEntryComponents.push(...this._getEntryComponentsFromProvider(providerMeta, type));
                    }
                    else {
                        compileProviders.push(this.getProviderMetadata(providerMeta));
                    }
                }
            });
            return compileProviders;
        }
        _validateProvider(provider) {
            if (provider.hasOwnProperty('useClass') && provider.useClass == null) {
                this._reportError(syntaxError(`Invalid provider for ${stringifyType(provider.provide)}. useClass cannot be ${provider.useClass}.
           Usually it happens when:
           1. There's a circular dependency (might be caused by using index.ts (barrel) files).
           2. Class was used before it was declared. Use forwardRef in this case.`));
            }
        }
        _getEntryComponentsFromProvider(provider, type) {
            const components = [];
            const collectedIdentifiers = [];
            if (provider.useFactory || provider.useExisting || provider.useClass) {
                this._reportError(syntaxError(`The ANALYZE_FOR_ENTRY_COMPONENTS token only supports useValue!`), type);
                return [];
            }
            if (!provider.multi) {
                this._reportError(syntaxError(`The ANALYZE_FOR_ENTRY_COMPONENTS token only supports 'multi = true'!`), type);
                return [];
            }
            extractIdentifiers(provider.useValue, collectedIdentifiers);
            collectedIdentifiers.forEach((identifier) => {
                const entry = this._getEntryComponentMetadata(identifier.reference, false);
                if (entry) {
                    components.push(entry);
                }
            });
            return components;
        }
        _getEntryComponentMetadata(dirType, throwIfNotFound = true) {
            const dirMeta = this.getNonNormalizedDirectiveMetadata(dirType);
            if (dirMeta && dirMeta.metadata.isComponent) {
                return { componentType: dirType, componentFactory: dirMeta.metadata.componentFactory };
            }
            const dirSummary = this._loadSummary(dirType, CompileSummaryKind.Directive);
            if (dirSummary && dirSummary.isComponent) {
                return { componentType: dirType, componentFactory: dirSummary.componentFactory };
            }
            if (throwIfNotFound) {
                throw syntaxError(`${dirType.name} cannot be used as an entry component.`);
            }
            return null;
        }
        _getInjectableTypeMetadata(type, dependencies = null) {
            const typeSummary = this._loadSummary(type, CompileSummaryKind.Injectable);
            if (typeSummary) {
                return typeSummary.type;
            }
            return this._getTypeMetadata(type, dependencies);
        }
        getProviderMetadata(provider) {
            let compileDeps = undefined;
            let compileTypeMetadata = null;
            let compileFactoryMetadata = null;
            let token = this._getTokenMetadata(provider.token);
            if (provider.useClass) {
                compileTypeMetadata =
                    this._getInjectableTypeMetadata(provider.useClass, provider.dependencies);
                compileDeps = compileTypeMetadata.diDeps;
                if (provider.token === provider.useClass) {
                    // use the compileTypeMetadata as it contains information about lifecycleHooks...
                    token = { identifier: compileTypeMetadata };
                }
            }
            else if (provider.useFactory) {
                compileFactoryMetadata = this._getFactoryMetadata(provider.useFactory, provider.dependencies);
                compileDeps = compileFactoryMetadata.diDeps;
            }
            return {
                token: token,
                useClass: compileTypeMetadata,
                useValue: provider.useValue,
                useFactory: compileFactoryMetadata,
                useExisting: provider.useExisting ? this._getTokenMetadata(provider.useExisting) : undefined,
                deps: compileDeps,
                multi: provider.multi
            };
        }
        _getQueriesMetadata(queries, isViewQuery, directiveType) {
            const res = [];
            Object.keys(queries).forEach((propertyName) => {
                const query = queries[propertyName];
                if (query.isViewQuery === isViewQuery) {
                    res.push(this._getQueryMetadata(query, propertyName, directiveType));
                }
            });
            return res;
        }
        _queryVarBindings(selector) {
            return selector.split(/\s*,\s*/);
        }
        _getQueryMetadata(q, propertyName, typeOrFunc) {
            let selectors;
            if (typeof q.selector === 'string') {
                selectors =
                    this._queryVarBindings(q.selector).map(varName => this._getTokenMetadata(varName));
            }
            else {
                if (!q.selector) {
                    this._reportError(syntaxError(`Can't construct a query for the property "${propertyName}" of "${stringifyType(typeOrFunc)}" since the query selector wasn't defined.`), typeOrFunc);
                    selectors = [];
                }
                else {
                    selectors = [this._getTokenMetadata(q.selector)];
                }
            }
            return {
                selectors,
                first: q.first,
                descendants: q.descendants,
                emitDistinctChangesOnly: q.emitDistinctChangesOnly,
                propertyName,
                read: q.read ? this._getTokenMetadata(q.read) : null,
                static: q.static
            };
        }
        _reportError(error, type, otherType) {
            if (this._errorCollector) {
                this._errorCollector(error, type);
                if (otherType) {
                    this._errorCollector(error, otherType);
                }
            }
            else {
                throw error;
            }
        }
    }
    function flattenArray(tree, out = []) {
        if (tree) {
            for (let i = 0; i < tree.length; i++) {
                const item = resolveForwardRef(tree[i]);
                if (Array.isArray(item)) {
                    flattenArray(item, out);
                }
                else {
                    out.push(item);
                }
            }
        }
        return out;
    }
    function dedupeArray(array) {
        if (array) {
            return Array.from(new Set(array));
        }
        return [];
    }
    function flattenAndDedupeArray(tree) {
        return dedupeArray(flattenArray(tree));
    }
    function isValidType(value) {
        return (value instanceof StaticSymbol) || (value instanceof Type);
    }
    function extractIdentifiers(value, targetIdentifiers) {
        visitValue(value, new _CompileValueConverter(), targetIdentifiers);
    }
    class _CompileValueConverter extends ValueTransformer {
        visitOther(value, targetIdentifiers) {
            targetIdentifiers.push({ reference: value });
        }
    }
    function stringifyType(type) {
        if (type instanceof StaticSymbol) {
            return `${type.name} in ${type.filePath}`;
        }
        else {
            return stringify(type);
        }
    }
    /**
     * Indicates that a component is still being loaded in a synchronous compile.
     */
    function componentStillLoadingError(compType) {
        const error = Error(`Can't compile synchronously as ${stringify(compType)} is still being loaded!`);
        error[ERROR_COMPONENT_TYPE] = compType;
        return error;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const LOG_VAR = variable('_l');

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Resolves types to {@link NgModule}.
     */
    class NgModuleResolver {
        constructor(_reflector) {
            this._reflector = _reflector;
        }
        isNgModule(type) {
            return this._reflector.annotations(type).some(createNgModule.isTypeOf);
        }
        resolve(type, throwIfNotFound = true) {
            const ngModuleMeta = findLast(this._reflector.annotations(type), createNgModule.isTypeOf);
            if (ngModuleMeta) {
                return ngModuleMeta;
            }
            else {
                if (throwIfNotFound) {
                    throw new Error(`No NgModule metadata found for '${stringify(type)}'.`);
                }
                return null;
            }
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Resolve a `Type` for {@link Pipe}.
     *
     * This interface can be overridden by the application developer to create custom behavior.
     *
     * See {@link Compiler}
     */
    class PipeResolver {
        constructor(_reflector) {
            this._reflector = _reflector;
        }
        isPipe(type) {
            const typeMetadata = this._reflector.annotations(resolveForwardRef(type));
            return typeMetadata && typeMetadata.some(createPipe.isTypeOf);
        }
        /**
         * Return {@link Pipe} for a given `Type`.
         */
        resolve(type, throwIfNotFound = true) {
            const metas = this._reflector.annotations(resolveForwardRef(type));
            if (metas) {
                const annotation = findLast(metas, createPipe.isTypeOf);
                if (annotation) {
                    return annotation;
                }
            }
            if (throwIfNotFound) {
                throw new Error(`No Pipe decorator found on ${stringify(type)}`);
            }
            return null;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const LOG_VAR$1 = variable('_l');
    const VIEW_VAR = variable('_v');
    const CHECK_VAR = variable('_ck');
    const COMP_VAR = variable('_co');
    const EVENT_NAME_VAR = variable('en');
    const ALLOW_DEFAULT_VAR = variable(`ad`);

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const TS = /^(?!.*\.d\.ts$).*\.ts$/;
    class ResolvedStaticSymbol {
        constructor(symbol, metadata) {
            this.symbol = symbol;
            this.metadata = metadata;
        }
    }
    const SUPPORTED_SCHEMA_VERSION = 4;
    /**
     * This class is responsible for loading metadata per symbol,
     * and normalizing references between symbols.
     *
     * Internally, it only uses symbols without members,
     * and deduces the values for symbols with members based
     * on these symbols.
     */
    class StaticSymbolResolver {
        constructor(host, staticSymbolCache, summaryResolver, errorRecorder) {
            this.host = host;
            this.staticSymbolCache = staticSymbolCache;
            this.summaryResolver = summaryResolver;
            this.errorRecorder = errorRecorder;
            this.metadataCache = new Map();
            // Note: this will only contain StaticSymbols without members!
            this.resolvedSymbols = new Map();
            // Note: this will only contain StaticSymbols without members!
            this.importAs = new Map();
            this.symbolResourcePaths = new Map();
            this.symbolFromFile = new Map();
            this.knownFileNameToModuleNames = new Map();
        }
        resolveSymbol(staticSymbol) {
            if (staticSymbol.members.length > 0) {
                return this._resolveSymbolMembers(staticSymbol);
            }
            // Note: always ask for a summary first,
            // as we might have read shallow metadata via a .d.ts file
            // for the symbol.
            const resultFromSummary = this._resolveSymbolFromSummary(staticSymbol);
            if (resultFromSummary) {
                return resultFromSummary;
            }
            const resultFromCache = this.resolvedSymbols.get(staticSymbol);
            if (resultFromCache) {
                return resultFromCache;
            }
            // Note: Some users use libraries that were not compiled with ngc, i.e. they don't
            // have summaries, only .d.ts files. So we always need to check both, the summary
            // and metadata.
            this._createSymbolsOf(staticSymbol.filePath);
            return this.resolvedSymbols.get(staticSymbol);
        }
        /**
         * getImportAs produces a symbol that can be used to import the given symbol.
         * The import might be different than the symbol if the symbol is exported from
         * a library with a summary; in which case we want to import the symbol from the
         * ngfactory re-export instead of directly to avoid introducing a direct dependency
         * on an otherwise indirect dependency.
         *
         * @param staticSymbol the symbol for which to generate a import symbol
         */
        getImportAs(staticSymbol, useSummaries = true) {
            if (staticSymbol.members.length) {
                const baseSymbol = this.getStaticSymbol(staticSymbol.filePath, staticSymbol.name);
                const baseImportAs = this.getImportAs(baseSymbol, useSummaries);
                return baseImportAs ?
                    this.getStaticSymbol(baseImportAs.filePath, baseImportAs.name, staticSymbol.members) :
                    null;
            }
            const summarizedFileName = stripSummaryForJitFileSuffix(staticSymbol.filePath);
            if (summarizedFileName !== staticSymbol.filePath) {
                const summarizedName = stripSummaryForJitNameSuffix(staticSymbol.name);
                const baseSymbol = this.getStaticSymbol(summarizedFileName, summarizedName, staticSymbol.members);
                const baseImportAs = this.getImportAs(baseSymbol, useSummaries);
                return baseImportAs ? this.getStaticSymbol(summaryForJitFileName(baseImportAs.filePath), summaryForJitName(baseImportAs.name), baseSymbol.members) :
                    null;
            }
            let result = (useSummaries && this.summaryResolver.getImportAs(staticSymbol)) || null;
            if (!result) {
                result = this.importAs.get(staticSymbol);
            }
            return result;
        }
        /**
         * getResourcePath produces the path to the original location of the symbol and should
         * be used to determine the relative location of resource references recorded in
         * symbol metadata.
         */
        getResourcePath(staticSymbol) {
            return this.symbolResourcePaths.get(staticSymbol) || staticSymbol.filePath;
        }
        /**
         * getTypeArity returns the number of generic type parameters the given symbol
         * has. If the symbol is not a type the result is null.
         */
        getTypeArity(staticSymbol) {
            // If the file is a factory/ngsummary file, don't resolve the symbol as doing so would
            // cause the metadata for an factory/ngsummary file to be loaded which doesn't exist.
            // All references to generated classes must include the correct arity whenever
            // generating code.
            if (isGeneratedFile(staticSymbol.filePath)) {
                return null;
            }
            let resolvedSymbol = unwrapResolvedMetadata(this.resolveSymbol(staticSymbol));
            while (resolvedSymbol && resolvedSymbol.metadata instanceof StaticSymbol) {
                resolvedSymbol = unwrapResolvedMetadata(this.resolveSymbol(resolvedSymbol.metadata));
            }
            return (resolvedSymbol && resolvedSymbol.metadata && resolvedSymbol.metadata.arity) || null;
        }
        getKnownModuleName(filePath) {
            return this.knownFileNameToModuleNames.get(filePath) || null;
        }
        recordImportAs(sourceSymbol, targetSymbol) {
            sourceSymbol.assertNoMembers();
            targetSymbol.assertNoMembers();
            this.importAs.set(sourceSymbol, targetSymbol);
        }
        recordModuleNameForFileName(fileName, moduleName) {
            this.knownFileNameToModuleNames.set(fileName, moduleName);
        }
        /**
         * Invalidate all information derived from the given file and return the
         * static symbols contained in the file.
         *
         * @param fileName the file to invalidate
         */
        invalidateFile(fileName) {
            this.metadataCache.delete(fileName);
            const symbols = this.symbolFromFile.get(fileName);
            if (!symbols) {
                return [];
            }
            this.symbolFromFile.delete(fileName);
            for (const symbol of symbols) {
                this.resolvedSymbols.delete(symbol);
                this.importAs.delete(symbol);
                this.symbolResourcePaths.delete(symbol);
            }
            return symbols;
        }
        /** @internal */
        ignoreErrorsFor(cb) {
            const recorder = this.errorRecorder;
            this.errorRecorder = () => { };
            try {
                return cb();
            }
            finally {
                this.errorRecorder = recorder;
            }
        }
        _resolveSymbolMembers(staticSymbol) {
            const members = staticSymbol.members;
            const baseResolvedSymbol = this.resolveSymbol(this.getStaticSymbol(staticSymbol.filePath, staticSymbol.name));
            if (!baseResolvedSymbol) {
                return null;
            }
            let baseMetadata = unwrapResolvedMetadata(baseResolvedSymbol.metadata);
            if (baseMetadata instanceof StaticSymbol) {
                return new ResolvedStaticSymbol(staticSymbol, this.getStaticSymbol(baseMetadata.filePath, baseMetadata.name, members));
            }
            else if (baseMetadata && baseMetadata.__symbolic === 'class') {
                if (baseMetadata.statics && members.length === 1) {
                    return new ResolvedStaticSymbol(staticSymbol, baseMetadata.statics[members[0]]);
                }
            }
            else {
                let value = baseMetadata;
                for (let i = 0; i < members.length && value; i++) {
                    value = value[members[i]];
                }
                return new ResolvedStaticSymbol(staticSymbol, value);
            }
            return null;
        }
        _resolveSymbolFromSummary(staticSymbol) {
            const summary = this.summaryResolver.resolveSummary(staticSymbol);
            return summary ? new ResolvedStaticSymbol(staticSymbol, summary.metadata) : null;
        }
        /**
         * getStaticSymbol produces a Type whose metadata is known but whose implementation is not loaded.
         * All types passed to the StaticResolver should be pseudo-types returned by this method.
         *
         * @param declarationFile the absolute path of the file where the symbol is declared
         * @param name the name of the type.
         * @param members a symbol for a static member of the named type
         */
        getStaticSymbol(declarationFile, name, members) {
            return this.staticSymbolCache.get(declarationFile, name, members);
        }
        /**
         * hasDecorators checks a file's metadata for the presence of decorators without evaluating the
         * metadata.
         *
         * @param filePath the absolute path to examine for decorators.
         * @returns true if any class in the file has a decorator.
         */
        hasDecorators(filePath) {
            const metadata = this.getModuleMetadata(filePath);
            if (metadata['metadata']) {
                return Object.keys(metadata['metadata']).some((metadataKey) => {
                    const entry = metadata['metadata'][metadataKey];
                    return entry && entry.__symbolic === 'class' && entry.decorators;
                });
            }
            return false;
        }
        getSymbolsOf(filePath) {
            const summarySymbols = this.summaryResolver.getSymbolsOf(filePath);
            if (summarySymbols) {
                return summarySymbols;
            }
            // Note: Some users use libraries that were not compiled with ngc, i.e. they don't
            // have summaries, only .d.ts files, but `summaryResolver.isLibraryFile` returns true.
            this._createSymbolsOf(filePath);
            return this.symbolFromFile.get(filePath) || [];
        }
        _createSymbolsOf(filePath) {
            if (this.symbolFromFile.has(filePath)) {
                return;
            }
            const resolvedSymbols = [];
            const metadata = this.getModuleMetadata(filePath);
            if (metadata['importAs']) {
                // Index bundle indices should use the importAs module name defined
                // in the bundle.
                this.knownFileNameToModuleNames.set(filePath, metadata['importAs']);
            }
            // handle the symbols in one of the re-export location
            if (metadata['exports']) {
                for (const moduleExport of metadata['exports']) {
                    // handle the symbols in the list of explicitly re-exported symbols.
                    if (moduleExport.export) {
                        moduleExport.export.forEach((exportSymbol) => {
                            let symbolName;
                            if (typeof exportSymbol === 'string') {
                                symbolName = exportSymbol;
                            }
                            else {
                                symbolName = exportSymbol.as;
                            }
                            symbolName = unescapeIdentifier(symbolName);
                            let symName = symbolName;
                            if (typeof exportSymbol !== 'string') {
                                symName = unescapeIdentifier(exportSymbol.name);
                            }
                            const resolvedModule = this.resolveModule(moduleExport.from, filePath);
                            if (resolvedModule) {
                                const targetSymbol = this.getStaticSymbol(resolvedModule, symName);
                                const sourceSymbol = this.getStaticSymbol(filePath, symbolName);
                                resolvedSymbols.push(this.createExport(sourceSymbol, targetSymbol));
                            }
                        });
                    }
                    else {
                        // Handle the symbols loaded by 'export *' directives.
                        const resolvedModule = this.resolveModule(moduleExport.from, filePath);
                        if (resolvedModule && resolvedModule !== filePath) {
                            const nestedExports = this.getSymbolsOf(resolvedModule);
                            nestedExports.forEach((targetSymbol) => {
                                const sourceSymbol = this.getStaticSymbol(filePath, targetSymbol.name);
                                resolvedSymbols.push(this.createExport(sourceSymbol, targetSymbol));
                            });
                        }
                    }
                }
            }
            // handle the actual metadata. Has to be after the exports
            // as there might be collisions in the names, and we want the symbols
            // of the current module to win ofter reexports.
            if (metadata['metadata']) {
                // handle direct declarations of the symbol
                const topLevelSymbolNames = new Set(Object.keys(metadata['metadata']).map(unescapeIdentifier));
                const origins = metadata['origins'] || {};
                Object.keys(metadata['metadata']).forEach((metadataKey) => {
                    const symbolMeta = metadata['metadata'][metadataKey];
                    const name = unescapeIdentifier(metadataKey);
                    const symbol = this.getStaticSymbol(filePath, name);
                    const origin = origins.hasOwnProperty(metadataKey) && origins[metadataKey];
                    if (origin) {
                        // If the symbol is from a bundled index, use the declaration location of the
                        // symbol so relative references (such as './my.html') will be calculated
                        // correctly.
                        const originFilePath = this.resolveModule(origin, filePath);
                        if (!originFilePath) {
                            this.reportError(new Error(`Couldn't resolve original symbol for ${origin} from ${this.host.getOutputName(filePath)}`));
                        }
                        else {
                            this.symbolResourcePaths.set(symbol, originFilePath);
                        }
                    }
                    resolvedSymbols.push(this.createResolvedSymbol(symbol, filePath, topLevelSymbolNames, symbolMeta));
                });
            }
            const uniqueSymbols = new Set();
            for (const resolvedSymbol of resolvedSymbols) {
                this.resolvedSymbols.set(resolvedSymbol.symbol, resolvedSymbol);
                uniqueSymbols.add(resolvedSymbol.symbol);
            }
            this.symbolFromFile.set(filePath, Array.from(uniqueSymbols));
        }
        createResolvedSymbol(sourceSymbol, topLevelPath, topLevelSymbolNames, metadata) {
            // For classes that don't have Angular summaries / metadata,
            // we only keep their arity, but nothing else
            // (e.g. their constructor parameters).
            // We do this to prevent introducing deep imports
            // as we didn't generate .ngfactory.ts files with proper reexports.
            const isTsFile = TS.test(sourceSymbol.filePath);
            if (this.summaryResolver.isLibraryFile(sourceSymbol.filePath) && !isTsFile && metadata &&
                metadata['__symbolic'] === 'class') {
                const transformedMeta = { __symbolic: 'class', arity: metadata.arity };
                return new ResolvedStaticSymbol(sourceSymbol, transformedMeta);
            }
            let _originalFileMemo;
            const getOriginalName = () => {
                if (!_originalFileMemo) {
                    // Guess what the original file name is from the reference. If it has a `.d.ts` extension
                    // replace it with `.ts`. If it already has `.ts` just leave it in place. If it doesn't have
                    // .ts or .d.ts, append `.ts'. Also, if it is in `node_modules`, trim the `node_module`
                    // location as it is not important to finding the file.
                    _originalFileMemo =
                        this.host.getOutputName(topLevelPath.replace(/((\.ts)|(\.d\.ts)|)$/, '.ts')
                            .replace(/^.*node_modules[/\\]/, ''));
                }
                return _originalFileMemo;
            };
            const self = this;
            class ReferenceTransformer extends ValueTransformer {
                visitStringMap(map, functionParams) {
                    const symbolic = map['__symbolic'];
                    if (symbolic === 'function') {
                        const oldLen = functionParams.length;
                        functionParams.push(...(map['parameters'] || []));
                        const result = super.visitStringMap(map, functionParams);
                        functionParams.length = oldLen;
                        return result;
                    }
                    else if (symbolic === 'reference') {
                        const module = map['module'];
                        const name = map['name'] ? unescapeIdentifier(map['name']) : map['name'];
                        if (!name) {
                            return null;
                        }
                        let filePath;
                        if (module) {
                            filePath = self.resolveModule(module, sourceSymbol.filePath);
                            if (!filePath) {
                                return {
                                    __symbolic: 'error',
                                    message: `Could not resolve ${module} relative to ${self.host.getMetadataFor(sourceSymbol.filePath)}.`,
                                    line: map['line'],
                                    character: map['character'],
                                    fileName: getOriginalName()
                                };
                            }
                            return {
                                __symbolic: 'resolved',
                                symbol: self.getStaticSymbol(filePath, name),
                                line: map['line'],
                                character: map['character'],
                                fileName: getOriginalName()
                            };
                        }
                        else if (functionParams.indexOf(name) >= 0) {
                            // reference to a function parameter
                            return { __symbolic: 'reference', name: name };
                        }
                        else {
                            if (topLevelSymbolNames.has(name)) {
                                return self.getStaticSymbol(topLevelPath, name);
                            }
                        }
                    }
                    else if (symbolic === 'error') {
                        return Object.assign(Object.assign({}, map), { fileName: getOriginalName() });
                    }
                    else {
                        return super.visitStringMap(map, functionParams);
                    }
                }
            }
            const transformedMeta = visitValue(metadata, new ReferenceTransformer(), []);
            let unwrappedTransformedMeta = unwrapResolvedMetadata(transformedMeta);
            if (unwrappedTransformedMeta instanceof StaticSymbol) {
                return this.createExport(sourceSymbol, unwrappedTransformedMeta);
            }
            return new ResolvedStaticSymbol(sourceSymbol, transformedMeta);
        }
        createExport(sourceSymbol, targetSymbol) {
            sourceSymbol.assertNoMembers();
            targetSymbol.assertNoMembers();
            if (this.summaryResolver.isLibraryFile(sourceSymbol.filePath) &&
                this.summaryResolver.isLibraryFile(targetSymbol.filePath)) {
                // This case is for an ng library importing symbols from a plain ts library
                // transitively.
                // Note: We rely on the fact that we discover symbols in the direction
                // from source files to library files
                this.importAs.set(targetSymbol, this.getImportAs(sourceSymbol) || sourceSymbol);
            }
            return new ResolvedStaticSymbol(sourceSymbol, targetSymbol);
        }
        reportError(error, context, path) {
            if (this.errorRecorder) {
                this.errorRecorder(error, (context && context.filePath) || path);
            }
            else {
                throw error;
            }
        }
        /**
         * @param module an absolute path to a module file.
         */
        getModuleMetadata(module) {
            let moduleMetadata = this.metadataCache.get(module);
            if (!moduleMetadata) {
                const moduleMetadatas = this.host.getMetadataFor(module);
                if (moduleMetadatas) {
                    let maxVersion = -1;
                    moduleMetadatas.forEach((md) => {
                        if (md && md['version'] > maxVersion) {
                            maxVersion = md['version'];
                            moduleMetadata = md;
                        }
                    });
                }
                if (!moduleMetadata) {
                    moduleMetadata =
                        { __symbolic: 'module', version: SUPPORTED_SCHEMA_VERSION, module: module, metadata: {} };
                }
                if (moduleMetadata['version'] != SUPPORTED_SCHEMA_VERSION) {
                    const errorMessage = moduleMetadata['version'] == 2 ?
                        `Unsupported metadata version ${moduleMetadata['version']} for module ${module}. This module should be compiled with a newer version of ngc` :
                        `Metadata version mismatch for module ${this.host.getOutputName(module)}, found version ${moduleMetadata['version']}, expected ${SUPPORTED_SCHEMA_VERSION}`;
                    this.reportError(new Error(errorMessage));
                }
                this.metadataCache.set(module, moduleMetadata);
            }
            return moduleMetadata;
        }
        getSymbolByModule(module, symbolName, containingFile) {
            const filePath = this.resolveModule(module, containingFile);
            if (!filePath) {
                this.reportError(new Error(`Could not resolve module ${module}${containingFile ? ' relative to ' + this.host.getOutputName(containingFile) : ''}`));
                return this.getStaticSymbol(`ERROR:${module}`, symbolName);
            }
            return this.getStaticSymbol(filePath, symbolName);
        }
        resolveModule(module, containingFile) {
            try {
                return this.host.moduleNameToFileName(module, containingFile);
            }
            catch (e) {
                console.error(`Could not resolve module '${module}' relative to file ${containingFile}`);
                this.reportError(e, undefined, containingFile);
            }
            return null;
        }
    }
    // Remove extra underscore from escaped identifier.
    // See https://github.com/Microsoft/TypeScript/blob/master/src/compiler/utilities.ts
    function unescapeIdentifier(identifier) {
        return identifier.startsWith('___') ? identifier.substr(1) : identifier;
    }
    function unwrapResolvedMetadata(metadata) {
        if (metadata && metadata.__symbolic === 'resolved') {
            return metadata.symbol;
        }
        return metadata;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function deserializeSummaries(symbolCache, summaryResolver, libraryFileName, json) {
        const deserializer = new FromJsonDeserializer(symbolCache, summaryResolver);
        return deserializer.deserialize(libraryFileName, json);
    }
    class FromJsonDeserializer extends ValueTransformer {
        constructor(symbolCache, summaryResolver) {
            super();
            this.symbolCache = symbolCache;
            this.summaryResolver = summaryResolver;
        }
        deserialize(libraryFileName, json) {
            const data = JSON.parse(json);
            const allImportAs = [];
            this.symbols = data.symbols.map((serializedSymbol) => this.symbolCache.get(this.summaryResolver.fromSummaryFileName(serializedSymbol.filePath, libraryFileName), serializedSymbol.name));
            data.symbols.forEach((serializedSymbol, index) => {
                const symbol = this.symbols[index];
                const importAs = serializedSymbol.importAs;
                if (typeof importAs === 'number') {
                    allImportAs.push({ symbol, importAs: this.symbols[importAs] });
                }
                else if (typeof importAs === 'string') {
                    allImportAs.push({ symbol, importAs: this.symbolCache.get(ngfactoryFilePath(libraryFileName), importAs) });
                }
            });
            const summaries = visitValue(data.summaries, this, null);
            return { moduleName: data.moduleName, summaries, importAs: allImportAs };
        }
        visitStringMap(map, context) {
            if ('__symbol' in map) {
                const baseSymbol = this.symbols[map['__symbol']];
                const members = map['members'];
                return members.length ? this.symbolCache.get(baseSymbol.filePath, baseSymbol.name, members) :
                    baseSymbol;
            }
            else {
                return super.visitStringMap(map, context);
            }
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function analyzeNgModules(fileNames, host, staticSymbolResolver, metadataResolver) {
        const files = _analyzeFilesIncludingNonProgramFiles(fileNames, host, staticSymbolResolver, metadataResolver);
        return mergeAnalyzedFiles(files);
    }
    // Analyzes all of the program files,
    // including files that are not part of the program
    // but are referenced by an NgModule.
    function _analyzeFilesIncludingNonProgramFiles(fileNames, host, staticSymbolResolver, metadataResolver) {
        const seenFiles = new Set();
        const files = [];
        const visitFile = (fileName) => {
            if (seenFiles.has(fileName) || !host.isSourceFile(fileName)) {
                return false;
            }
            seenFiles.add(fileName);
            const analyzedFile = analyzeFile(host, staticSymbolResolver, metadataResolver, fileName);
            files.push(analyzedFile);
            analyzedFile.ngModules.forEach(ngModule => {
                ngModule.transitiveModule.modules.forEach(modMeta => visitFile(modMeta.reference.filePath));
            });
        };
        fileNames.forEach((fileName) => visitFile(fileName));
        return files;
    }
    function analyzeFile(host, staticSymbolResolver, metadataResolver, fileName) {
        const abstractDirectives = [];
        const directives = [];
        const pipes = [];
        const injectables = [];
        const ngModules = [];
        const hasDecorators = staticSymbolResolver.hasDecorators(fileName);
        let exportsNonSourceFiles = false;
        const isDeclarationFile = fileName.endsWith('.d.ts');
        // Don't analyze .d.ts files that have no decorators as a shortcut
        // to speed up the analysis. This prevents us from
        // resolving the references in these files.
        // Note: exportsNonSourceFiles is only needed when compiling with summaries,
        // which is not the case when .d.ts files are treated as input files.
        if (!isDeclarationFile || hasDecorators) {
            staticSymbolResolver.getSymbolsOf(fileName).forEach((symbol) => {
                const resolvedSymbol = staticSymbolResolver.resolveSymbol(symbol);
                const symbolMeta = resolvedSymbol.metadata;
                if (!symbolMeta || symbolMeta.__symbolic === 'error') {
                    return;
                }
                let isNgSymbol = false;
                if (symbolMeta.__symbolic === 'class') {
                    if (metadataResolver.isDirective(symbol)) {
                        isNgSymbol = true;
                        // This directive either has a selector or doesn't. Selector-less directives get tracked
                        // in abstractDirectives, not directives. The compiler doesn't deal with selector-less
                        // directives at all, really, other than to persist their metadata. This is done so that
                        // apps will have an easier time migrating to Ivy, which requires the selector-less
                        // annotations to be applied.
                        if (!metadataResolver.isAbstractDirective(symbol)) {
                            // The directive is an ordinary directive.
                            directives.push(symbol);
                        }
                        else {
                            // The directive has no selector and is an "abstract" directive, so track it
                            // accordingly.
                            abstractDirectives.push(symbol);
                        }
                    }
                    else if (metadataResolver.isPipe(symbol)) {
                        isNgSymbol = true;
                        pipes.push(symbol);
                    }
                    else if (metadataResolver.isNgModule(symbol)) {
                        const ngModule = metadataResolver.getNgModuleMetadata(symbol, false);
                        if (ngModule) {
                            isNgSymbol = true;
                            ngModules.push(ngModule);
                        }
                    }
                    else if (metadataResolver.isInjectable(symbol)) {
                        isNgSymbol = true;
                        const injectable = metadataResolver.getInjectableMetadata(symbol, null, false);
                        if (injectable) {
                            injectables.push(injectable);
                        }
                    }
                }
                if (!isNgSymbol) {
                    exportsNonSourceFiles =
                        exportsNonSourceFiles || isValueExportingNonSourceFile(host, symbolMeta);
                }
            });
        }
        return {
            fileName,
            directives,
            abstractDirectives,
            pipes,
            ngModules,
            injectables,
            exportsNonSourceFiles,
        };
    }
    function isValueExportingNonSourceFile(host, metadata) {
        let exportsNonSourceFiles = false;
        class Visitor {
            visitArray(arr, context) {
                arr.forEach(v => visitValue(v, this, context));
            }
            visitStringMap(map, context) {
                Object.keys(map).forEach((key) => visitValue(map[key], this, context));
            }
            visitPrimitive(value, context) { }
            visitOther(value, context) {
                if (value instanceof StaticSymbol && !host.isSourceFile(value.filePath)) {
                    exportsNonSourceFiles = true;
                }
            }
        }
        visitValue(metadata, new Visitor(), null);
        return exportsNonSourceFiles;
    }
    function mergeAnalyzedFiles(analyzedFiles) {
        const allNgModules = [];
        const ngModuleByPipeOrDirective = new Map();
        const allPipesAndDirectives = new Set();
        analyzedFiles.forEach(af => {
            af.ngModules.forEach(ngModule => {
                allNgModules.push(ngModule);
                ngModule.declaredDirectives.forEach(d => ngModuleByPipeOrDirective.set(d.reference, ngModule));
                ngModule.declaredPipes.forEach(p => ngModuleByPipeOrDirective.set(p.reference, ngModule));
            });
            af.directives.forEach(d => allPipesAndDirectives.add(d));
            af.pipes.forEach(p => allPipesAndDirectives.add(p));
        });
        const symbolsMissingModule = [];
        allPipesAndDirectives.forEach(ref => {
            if (!ngModuleByPipeOrDirective.has(ref)) {
                symbolsMissingModule.push(ref);
            }
        });
        return {
            ngModules: allNgModules,
            ngModuleByPipeOrDirective,
            symbolsMissingModule,
            files: analyzedFiles
        };
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const FORMATTED_MESSAGE = 'ngFormattedMessage';
    function indentStr(level) {
        if (level <= 0)
            return '';
        if (level < 6)
            return ['', ' ', '  ', '   ', '    ', '     '][level];
        const half = indentStr(Math.floor(level / 2));
        return half + half + (level % 2 === 1 ? ' ' : '');
    }
    function formatChain(chain, indent = 0) {
        if (!chain)
            return '';
        const position = chain.position ?
            `${chain.position.fileName}(${chain.position.line + 1},${chain.position.column + 1})` :
            '';
        const prefix = position && indent === 0 ? `${position}: ` : '';
        const postfix = position && indent !== 0 ? ` at ${position}` : '';
        let message = `${prefix}${chain.message}${postfix}`;
        if (chain.next) {
            for (const kid of chain.next) {
                message += '\n' + formatChain(kid, indent + 2);
            }
        }
        return `${indentStr(indent)}${message}`;
    }
    function formattedError(chain) {
        const message = formatChain(chain) + '.';
        const error = syntaxError(message);
        error[FORMATTED_MESSAGE] = true;
        error.chain = chain;
        error.position = chain.position;
        return error;
    }
    function isFormattedError(error) {
        return !!error[FORMATTED_MESSAGE];
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const ANGULAR_CORE = '@angular/core';
    const ANGULAR_ROUTER = '@angular/router';
    const HIDDEN_KEY = /^\$.*\$$/;
    const IGNORE = {
        __symbolic: 'ignore'
    };
    const USE_VALUE$1 = 'useValue';
    const PROVIDE = 'provide';
    const REFERENCE_SET = new Set([USE_VALUE$1, 'useFactory', 'data', 'id', 'loadChildren']);
    const TYPEGUARD_POSTFIX = 'TypeGuard';
    const USE_IF = 'UseIf';
    function shouldIgnore(value) {
        return value && value.__symbolic == 'ignore';
    }
    /**
     * A static reflector implements enough of the Reflector API that is necessary to compile
     * templates statically.
     */
    class StaticReflector {
        constructor(summaryResolver, symbolResolver, knownMetadataClasses = [], knownMetadataFunctions = [], errorRecorder) {
            this.summaryResolver = summaryResolver;
            this.symbolResolver = symbolResolver;
            this.errorRecorder = errorRecorder;
            this.annotationCache = new Map();
            this.shallowAnnotationCache = new Map();
            this.propertyCache = new Map();
            this.parameterCache = new Map();
            this.methodCache = new Map();
            this.staticCache = new Map();
            this.conversionMap = new Map();
            this.resolvedExternalReferences = new Map();
            this.annotationForParentClassWithSummaryKind = new Map();
            this.initializeConversionMap();
            knownMetadataClasses.forEach((kc) => this._registerDecoratorOrConstructor(this.getStaticSymbol(kc.filePath, kc.name), kc.ctor));
            knownMetadataFunctions.forEach((kf) => this._registerFunction(this.getStaticSymbol(kf.filePath, kf.name), kf.fn));
            this.annotationForParentClassWithSummaryKind.set(CompileSummaryKind.Directive, [createDirective, createComponent]);
            this.annotationForParentClassWithSummaryKind.set(CompileSummaryKind.Pipe, [createPipe]);
            this.annotationForParentClassWithSummaryKind.set(CompileSummaryKind.NgModule, [createNgModule]);
            this.annotationForParentClassWithSummaryKind.set(CompileSummaryKind.Injectable, [createInjectable, createPipe, createDirective, createComponent, createNgModule]);
        }
        componentModuleUrl(typeOrFunc) {
            const staticSymbol = this.findSymbolDeclaration(typeOrFunc);
            return this.symbolResolver.getResourcePath(staticSymbol);
        }
        /**
         * Invalidate the specified `symbols` on program change.
         * @param symbols
         */
        invalidateSymbols(symbols) {
            for (const symbol of symbols) {
                this.annotationCache.delete(symbol);
                this.shallowAnnotationCache.delete(symbol);
                this.propertyCache.delete(symbol);
                this.parameterCache.delete(symbol);
                this.methodCache.delete(symbol);
                this.staticCache.delete(symbol);
                this.conversionMap.delete(symbol);
            }
        }
        resolveExternalReference(ref, containingFile) {
            let key = undefined;
            if (!containingFile) {
                key = `${ref.moduleName}:${ref.name}`;
                const declarationSymbol = this.resolvedExternalReferences.get(key);
                if (declarationSymbol)
                    return declarationSymbol;
            }
            const refSymbol = this.symbolResolver.getSymbolByModule(ref.moduleName, ref.name, containingFile);
            const declarationSymbol = this.findSymbolDeclaration(refSymbol);
            if (!containingFile) {
                this.symbolResolver.recordModuleNameForFileName(refSymbol.filePath, ref.moduleName);
                this.symbolResolver.recordImportAs(declarationSymbol, refSymbol);
            }
            if (key) {
                this.resolvedExternalReferences.set(key, declarationSymbol);
            }
            return declarationSymbol;
        }
        findDeclaration(moduleUrl, name, containingFile) {
            return this.findSymbolDeclaration(this.symbolResolver.getSymbolByModule(moduleUrl, name, containingFile));
        }
        tryFindDeclaration(moduleUrl, name, containingFile) {
            return this.symbolResolver.ignoreErrorsFor(() => this.findDeclaration(moduleUrl, name, containingFile));
        }
        findSymbolDeclaration(symbol) {
            const resolvedSymbol = this.symbolResolver.resolveSymbol(symbol);
            if (resolvedSymbol) {
                let resolvedMetadata = resolvedSymbol.metadata;
                if (resolvedMetadata && resolvedMetadata.__symbolic === 'resolved') {
                    resolvedMetadata = resolvedMetadata.symbol;
                }
                if (resolvedMetadata instanceof StaticSymbol) {
                    return this.findSymbolDeclaration(resolvedSymbol.metadata);
                }
            }
            return symbol;
        }
        tryAnnotations(type) {
            const originalRecorder = this.errorRecorder;
            this.errorRecorder = (error, fileName) => { };
            try {
                return this.annotations(type);
            }
            finally {
                this.errorRecorder = originalRecorder;
            }
        }
        annotations(type) {
            return this._annotations(type, (type, decorators) => this.simplify(type, decorators), this.annotationCache);
        }
        shallowAnnotations(type) {
            return this._annotations(type, (type, decorators) => this.simplify(type, decorators, true), this.shallowAnnotationCache);
        }
        _annotations(type, simplify, annotationCache) {
            let annotations = annotationCache.get(type);
            if (!annotations) {
                annotations = [];
                const classMetadata = this.getTypeMetadata(type);
                const parentType = this.findParentType(type, classMetadata);
                if (parentType) {
                    const parentAnnotations = this.annotations(parentType);
                    annotations.push(...parentAnnotations);
                }
                let ownAnnotations = [];
                if (classMetadata['decorators']) {
                    ownAnnotations = simplify(type, classMetadata['decorators']);
                    if (ownAnnotations) {
                        annotations.push(...ownAnnotations);
                    }
                }
                if (parentType && !this.summaryResolver.isLibraryFile(type.filePath) &&
                    this.summaryResolver.isLibraryFile(parentType.filePath)) {
                    const summary = this.summaryResolver.resolveSummary(parentType);
                    if (summary && summary.type) {
                        const requiredAnnotationTypes = this.annotationForParentClassWithSummaryKind.get(summary.type.summaryKind);
                        const typeHasRequiredAnnotation = requiredAnnotationTypes.some((requiredType) => ownAnnotations.some(ann => requiredType.isTypeOf(ann)));
                        if (!typeHasRequiredAnnotation) {
                            this.reportError(formatMetadataError(metadataError(`Class ${type.name} in ${type.filePath} extends from a ${CompileSummaryKind[summary.type.summaryKind]} in another compilation unit without duplicating the decorator`, 
                            /* summary */ undefined, `Please add a ${requiredAnnotationTypes.map((type) => type.ngMetadataName)
                            .join(' or ')} decorator to the class`), type), type);
                        }
                    }
                }
                annotationCache.set(type, annotations.filter(ann => !!ann));
            }
            return annotations;
        }
        propMetadata(type) {
            let propMetadata = this.propertyCache.get(type);
            if (!propMetadata) {
                const classMetadata = this.getTypeMetadata(type);
                propMetadata = {};
                const parentType = this.findParentType(type, classMetadata);
                if (parentType) {
                    const parentPropMetadata = this.propMetadata(parentType);
                    Object.keys(parentPropMetadata).forEach((parentProp) => {
                        propMetadata[parentProp] = parentPropMetadata[parentProp];
                    });
                }
                const members = classMetadata['members'] || {};
                Object.keys(members).forEach((propName) => {
                    const propData = members[propName];
                    const prop = propData
                        .find(a => a['__symbolic'] == 'property' || a['__symbolic'] == 'method');
                    const decorators = [];
                    // hasOwnProperty() is used here to make sure we do not look up methods
                    // on `Object.prototype`.
                    if (propMetadata === null || propMetadata === void 0 ? void 0 : propMetadata.hasOwnProperty(propName)) {
                        decorators.push(...propMetadata[propName]);
                    }
                    propMetadata[propName] = decorators;
                    if (prop && prop['decorators']) {
                        decorators.push(...this.simplify(type, prop['decorators']));
                    }
                });
                this.propertyCache.set(type, propMetadata);
            }
            return propMetadata;
        }
        parameters(type) {
            if (!(type instanceof StaticSymbol)) {
                this.reportError(new Error(`parameters received ${JSON.stringify(type)} which is not a StaticSymbol`), type);
                return [];
            }
            try {
                let parameters = this.parameterCache.get(type);
                if (!parameters) {
                    const classMetadata = this.getTypeMetadata(type);
                    const parentType = this.findParentType(type, classMetadata);
                    const members = classMetadata ? classMetadata['members'] : null;
                    const ctorData = members ? members['__ctor__'] : null;
                    if (ctorData) {
                        const ctor = ctorData.find(a => a['__symbolic'] == 'constructor');
                        const rawParameterTypes = ctor['parameters'] || [];
                        const parameterDecorators = this.simplify(type, ctor['parameterDecorators'] || []);
                        parameters = [];
                        rawParameterTypes.forEach((rawParamType, index) => {
                            const nestedResult = [];
                            const paramType = this.trySimplify(type, rawParamType);
                            if (paramType)
                                nestedResult.push(paramType);
                            const decorators = parameterDecorators ? parameterDecorators[index] : null;
                            if (decorators) {
                                nestedResult.push(...decorators);
                            }
                            parameters.push(nestedResult);
                        });
                    }
                    else if (parentType) {
                        parameters = this.parameters(parentType);
                    }
                    if (!parameters) {
                        parameters = [];
                    }
                    this.parameterCache.set(type, parameters);
                }
                return parameters;
            }
            catch (e) {
                console.error(`Failed on type ${JSON.stringify(type)} with error ${e}`);
                throw e;
            }
        }
        _methodNames(type) {
            let methodNames = this.methodCache.get(type);
            if (!methodNames) {
                const classMetadata = this.getTypeMetadata(type);
                methodNames = {};
                const parentType = this.findParentType(type, classMetadata);
                if (parentType) {
                    const parentMethodNames = this._methodNames(parentType);
                    Object.keys(parentMethodNames).forEach((parentProp) => {
                        methodNames[parentProp] = parentMethodNames[parentProp];
                    });
                }
                const members = classMetadata['members'] || {};
                Object.keys(members).forEach((propName) => {
                    const propData = members[propName];
                    const isMethod = propData.some(a => a['__symbolic'] == 'method');
                    methodNames[propName] = methodNames[propName] || isMethod;
                });
                this.methodCache.set(type, methodNames);
            }
            return methodNames;
        }
        _staticMembers(type) {
            let staticMembers = this.staticCache.get(type);
            if (!staticMembers) {
                const classMetadata = this.getTypeMetadata(type);
                const staticMemberData = classMetadata['statics'] || {};
                staticMembers = Object.keys(staticMemberData);
                this.staticCache.set(type, staticMembers);
            }
            return staticMembers;
        }
        findParentType(type, classMetadata) {
            const parentType = this.trySimplify(type, classMetadata['extends']);
            if (parentType instanceof StaticSymbol) {
                return parentType;
            }
        }
        hasLifecycleHook(type, lcProperty) {
            if (!(type instanceof StaticSymbol)) {
                this.reportError(new Error(`hasLifecycleHook received ${JSON.stringify(type)} which is not a StaticSymbol`), type);
            }
            try {
                return !!this._methodNames(type)[lcProperty];
            }
            catch (e) {
                console.error(`Failed on type ${JSON.stringify(type)} with error ${e}`);
                throw e;
            }
        }
        guards(type) {
            if (!(type instanceof StaticSymbol)) {
                this.reportError(new Error(`guards received ${JSON.stringify(type)} which is not a StaticSymbol`), type);
                return {};
            }
            const staticMembers = this._staticMembers(type);
            const result = {};
            for (let name of staticMembers) {
                if (name.endsWith(TYPEGUARD_POSTFIX)) {
                    let property = name.substr(0, name.length - TYPEGUARD_POSTFIX.length);
                    let value;
                    if (property.endsWith(USE_IF)) {
                        property = name.substr(0, property.length - USE_IF.length);
                        value = USE_IF;
                    }
                    else {
                        value = this.getStaticSymbol(type.filePath, type.name, [name]);
                    }
                    result[property] = value;
                }
            }
            return result;
        }
        _registerDecoratorOrConstructor(type, ctor) {
            this.conversionMap.set(type, (context, args) => new ctor(...args));
        }
        _registerFunction(type, fn) {
            this.conversionMap.set(type, (context, args) => fn.apply(undefined, args));
        }
        initializeConversionMap() {
            this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Injectable'), createInjectable);
            this.injectionToken = this.findDeclaration(ANGULAR_CORE, 'InjectionToken');
            this.opaqueToken = this.findDeclaration(ANGULAR_CORE, 'OpaqueToken');
            this.ROUTES = this.tryFindDeclaration(ANGULAR_ROUTER, 'ROUTES');
            this.ANALYZE_FOR_ENTRY_COMPONENTS =
                this.findDeclaration(ANGULAR_CORE, 'ANALYZE_FOR_ENTRY_COMPONENTS');
            this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Host'), createHost);
            this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Self'), createSelf);
            this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'SkipSelf'), createSkipSelf);
            this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Inject'), createInject);
            this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Optional'), createOptional);
            this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Attribute'), createAttribute);
            this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'ContentChild'), createContentChild);
            this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'ContentChildren'), createContentChildren);
            this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'ViewChild'), createViewChild);
            this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'ViewChildren'), createViewChildren);
            this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Input'), createInput);
            this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Output'), createOutput);
            this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Pipe'), createPipe);
            this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'HostBinding'), createHostBinding);
            this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'HostListener'), createHostListener);
            this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Directive'), createDirective);
            this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Component'), createComponent);
            this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'NgModule'), createNgModule);
            // Note: Some metadata classes can be used directly with Provider.deps.
            this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Host'), createHost);
            this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Self'), createSelf);
            this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'SkipSelf'), createSkipSelf);
            this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Optional'), createOptional);
        }
        /**
         * getStaticSymbol produces a Type whose metadata is known but whose implementation is not loaded.
         * All types passed to the StaticResolver should be pseudo-types returned by this method.
         *
         * @param declarationFile the absolute path of the file where the symbol is declared
         * @param name the name of the type.
         */
        getStaticSymbol(declarationFile, name, members) {
            return this.symbolResolver.getStaticSymbol(declarationFile, name, members);
        }
        /**
         * Simplify but discard any errors
         */
        trySimplify(context, value) {
            const originalRecorder = this.errorRecorder;
            this.errorRecorder = (error, fileName) => { };
            const result = this.simplify(context, value);
            this.errorRecorder = originalRecorder;
            return result;
        }
        /** @internal */
        simplify(context, value, lazy = false) {
            const self = this;
            let scope = BindingScope$1.empty;
            const calling = new Map();
            function simplifyInContext(context, value, depth, references) {
                function resolveReferenceValue(staticSymbol) {
                    const resolvedSymbol = self.symbolResolver.resolveSymbol(staticSymbol);
                    return resolvedSymbol ? resolvedSymbol.metadata : null;
                }
                function simplifyEagerly(value) {
                    return simplifyInContext(context, value, depth, 0);
                }
                function simplifyLazily(value) {
                    return simplifyInContext(context, value, depth, references + 1);
                }
                function simplifyNested(nestedContext, value) {
                    if (nestedContext === context) {
                        // If the context hasn't changed let the exception propagate unmodified.
                        return simplifyInContext(nestedContext, value, depth + 1, references);
                    }
                    try {
                        return simplifyInContext(nestedContext, value, depth + 1, references);
                    }
                    catch (e) {
                        if (isMetadataError(e)) {
                            // Propagate the message text up but add a message to the chain that explains how we got
                            // here.
                            // e.chain implies e.symbol
                            const summaryMsg = e.chain ? 'references \'' + e.symbol.name + '\'' : errorSummary(e);
                            const summary = `'${nestedContext.name}' ${summaryMsg}`;
                            const chain = { message: summary, position: e.position, next: e.chain };
                            // TODO(chuckj): retrieve the position information indirectly from the collectors node
                            // map if the metadata is from a .ts file.
                            self.error({
                                message: e.message,
                                advise: e.advise,
                                context: e.context,
                                chain,
                                symbol: nestedContext
                            }, context);
                        }
                        else {
                            // It is probably an internal error.
                            throw e;
                        }
                    }
                }
                function simplifyCall(functionSymbol, targetFunction, args, targetExpression) {
                    if (targetFunction && targetFunction['__symbolic'] == 'function') {
                        if (calling.get(functionSymbol)) {
                            self.error({
                                message: 'Recursion is not supported',
                                summary: `called '${functionSymbol.name}' recursively`,
                                value: targetFunction
                            }, functionSymbol);
                        }
                        try {
                            const value = targetFunction['value'];
                            if (value && (depth != 0 || value.__symbolic != 'error')) {
                                const parameters = targetFunction['parameters'];
                                const defaults = targetFunction.defaults;
                                args = args.map(arg => simplifyNested(context, arg))
                                    .map(arg => shouldIgnore(arg) ? undefined : arg);
                                if (defaults && defaults.length > args.length) {
                                    args.push(...defaults.slice(args.length).map((value) => simplify(value)));
                                }
                                calling.set(functionSymbol, true);
                                const functionScope = BindingScope$1.build();
                                for (let i = 0; i < parameters.length; i++) {
                                    functionScope.define(parameters[i], args[i]);
                                }
                                const oldScope = scope;
                                let result;
                                try {
                                    scope = functionScope.done();
                                    result = simplifyNested(functionSymbol, value);
                                }
                                finally {
                                    scope = oldScope;
                                }
                                return result;
                            }
                        }
                        finally {
                            calling.delete(functionSymbol);
                        }
                    }
                    if (depth === 0) {
                        // If depth is 0 we are evaluating the top level expression that is describing element
                        // decorator. In this case, it is a decorator we don't understand, such as a custom
                        // non-angular decorator, and we should just ignore it.
                        return IGNORE;
                    }
                    let position = undefined;
                    if (targetExpression && targetExpression.__symbolic == 'resolved') {
                        const line = targetExpression.line;
                        const character = targetExpression.character;
                        const fileName = targetExpression.fileName;
                        if (fileName != null && line != null && character != null) {
                            position = { fileName, line, column: character };
                        }
                    }
                    self.error({
                        message: FUNCTION_CALL_NOT_SUPPORTED,
                        context: functionSymbol,
                        value: targetFunction,
                        position
                    }, context);
                }
                function simplify(expression) {
                    if (isPrimitive(expression)) {
                        return expression;
                    }
                    if (Array.isArray(expression)) {
                        const result = [];
                        for (const item of expression) {
                            // Check for a spread expression
                            if (item && item.__symbolic === 'spread') {
                                // We call with references as 0 because we require the actual value and cannot
                                // tolerate a reference here.
                                const spreadArray = simplifyEagerly(item.expression);
                                if (Array.isArray(spreadArray)) {
                                    for (const spreadItem of spreadArray) {
                                        result.push(spreadItem);
                                    }
                                    continue;
                                }
                            }
                            const value = simplify(item);
                            if (shouldIgnore(value)) {
                                continue;
                            }
                            result.push(value);
                        }
                        return result;
                    }
                    if (expression instanceof StaticSymbol) {
                        // Stop simplification at builtin symbols or if we are in a reference context and
                        // the symbol doesn't have members.
                        if (expression === self.injectionToken || self.conversionMap.has(expression) ||
                            (references > 0 && !expression.members.length)) {
                            return expression;
                        }
                        else {
                            const staticSymbol = expression;
                            const declarationValue = resolveReferenceValue(staticSymbol);
                            if (declarationValue != null) {
                                return simplifyNested(staticSymbol, declarationValue);
                            }
                            else {
                                return staticSymbol;
                            }
                        }
                    }
                    if (expression) {
                        if (expression['__symbolic']) {
                            let staticSymbol;
                            switch (expression['__symbolic']) {
                                case 'binop':
                                    let left = simplify(expression['left']);
                                    if (shouldIgnore(left))
                                        return left;
                                    let right = simplify(expression['right']);
                                    if (shouldIgnore(right))
                                        return right;
                                    switch (expression['operator']) {
                                        case '&&':
                                            return left && right;
                                        case '||':
                                            return left || right;
                                        case '|':
                                            return left | right;
                                        case '^':
                                            return left ^ right;
                                        case '&':
                                            return left & right;
                                        case '==':
                                            return left == right;
                                        case '!=':
                                            return left != right;
                                        case '===':
                                            return left === right;
                                        case '!==':
                                            return left !== right;
                                        case '<':
                                            return left < right;
                                        case '>':
                                            return left > right;
                                        case '<=':
                                            return left <= right;
                                        case '>=':
                                            return left >= right;
                                        case '<<':
                                            return left << right;
                                        case '>>':
                                            return left >> right;
                                        case '+':
                                            return left + right;
                                        case '-':
                                            return left - right;
                                        case '*':
                                            return left * right;
                                        case '/':
                                            return left / right;
                                        case '%':
                                            return left % right;
                                        case '??':
                                            return left !== null && left !== void 0 ? left : right;
                                    }
                                    return null;
                                case 'if':
                                    let condition = simplify(expression['condition']);
                                    return condition ? simplify(expression['thenExpression']) :
                                        simplify(expression['elseExpression']);
                                case 'pre':
                                    let operand = simplify(expression['operand']);
                                    if (shouldIgnore(operand))
                                        return operand;
                                    switch (expression['operator']) {
                                        case '+':
                                            return operand;
                                        case '-':
                                            return -operand;
                                        case '!':
                                            return !operand;
                                        case '~':
                                            return ~operand;
                                    }
                                    return null;
                                case 'index':
                                    let indexTarget = simplifyEagerly(expression['expression']);
                                    let index = simplifyEagerly(expression['index']);
                                    if (indexTarget && isPrimitive(index))
                                        return indexTarget[index];
                                    return null;
                                case 'select':
                                    const member = expression['member'];
                                    let selectContext = context;
                                    let selectTarget = simplify(expression['expression']);
                                    if (selectTarget instanceof StaticSymbol) {
                                        const members = selectTarget.members.concat(member);
                                        selectContext =
                                            self.getStaticSymbol(selectTarget.filePath, selectTarget.name, members);
                                        const declarationValue = resolveReferenceValue(selectContext);
                                        if (declarationValue != null) {
                                            return simplifyNested(selectContext, declarationValue);
                                        }
                                        else {
                                            return selectContext;
                                        }
                                    }
                                    if (selectTarget && isPrimitive(member))
                                        return simplifyNested(selectContext, selectTarget[member]);
                                    return null;
                                case 'reference':
                                    // Note: This only has to deal with variable references, as symbol references have
                                    // been converted into 'resolved'
                                    // in the StaticSymbolResolver.
                                    const name = expression['name'];
                                    const localValue = scope.resolve(name);
                                    if (localValue != BindingScope$1.missing) {
                                        return localValue;
                                    }
                                    break;
                                case 'resolved':
                                    try {
                                        return simplify(expression.symbol);
                                    }
                                    catch (e) {
                                        // If an error is reported evaluating the symbol record the position of the
                                        // reference in the error so it can
                                        // be reported in the error message generated from the exception.
                                        if (isMetadataError(e) && expression.fileName != null &&
                                            expression.line != null && expression.character != null) {
                                            e.position = {
                                                fileName: expression.fileName,
                                                line: expression.line,
                                                column: expression.character
                                            };
                                        }
                                        throw e;
                                    }
                                case 'class':
                                    return context;
                                case 'function':
                                    return context;
                                case 'new':
                                case 'call':
                                    // Determine if the function is a built-in conversion
                                    staticSymbol = simplifyInContext(context, expression['expression'], depth + 1, /* references */ 0);
                                    if (staticSymbol instanceof StaticSymbol) {
                                        if (staticSymbol === self.injectionToken || staticSymbol === self.opaqueToken) {
                                            // if somebody calls new InjectionToken, don't create an InjectionToken,
                                            // but rather return the symbol to which the InjectionToken is assigned to.
                                            // OpaqueToken is supported too as it is required by the language service to
                                            // support v4 and prior versions of Angular.
                                            return context;
                                        }
                                        const argExpressions = expression['arguments'] || [];
                                        let converter = self.conversionMap.get(staticSymbol);
                                        if (converter) {
                                            const args = argExpressions.map(arg => simplifyNested(context, arg))
                                                .map(arg => shouldIgnore(arg) ? undefined : arg);
                                            return converter(context, args);
                                        }
                                        else {
                                            // Determine if the function is one we can simplify.
                                            const targetFunction = resolveReferenceValue(staticSymbol);
                                            return simplifyCall(staticSymbol, targetFunction, argExpressions, expression['expression']);
                                        }
                                    }
                                    return IGNORE;
                                case 'error':
                                    let message = expression.message;
                                    if (expression['line'] != null) {
                                        self.error({
                                            message,
                                            context: expression.context,
                                            value: expression,
                                            position: {
                                                fileName: expression['fileName'],
                                                line: expression['line'],
                                                column: expression['character']
                                            }
                                        }, context);
                                    }
                                    else {
                                        self.error({ message, context: expression.context }, context);
                                    }
                                    return IGNORE;
                                case 'ignore':
                                    return expression;
                            }
                            return null;
                        }
                        return mapStringMap(expression, (value, name) => {
                            if (REFERENCE_SET.has(name)) {
                                if (name === USE_VALUE$1 && PROVIDE in expression) {
                                    // If this is a provider expression, check for special tokens that need the value
                                    // during analysis.
                                    const provide = simplify(expression.provide);
                                    if (provide === self.ROUTES || provide == self.ANALYZE_FOR_ENTRY_COMPONENTS) {
                                        return simplify(value);
                                    }
                                }
                                return simplifyLazily(value);
                            }
                            return simplify(value);
                        });
                    }
                    return IGNORE;
                }
                return simplify(value);
            }
            let result;
            try {
                result = simplifyInContext(context, value, 0, lazy ? 1 : 0);
            }
            catch (e) {
                if (this.errorRecorder) {
                    this.reportError(e, context);
                }
                else {
                    throw formatMetadataError(e, context);
                }
            }
            if (shouldIgnore(result)) {
                return undefined;
            }
            return result;
        }
        getTypeMetadata(type) {
            const resolvedSymbol = this.symbolResolver.resolveSymbol(type);
            return resolvedSymbol && resolvedSymbol.metadata ? resolvedSymbol.metadata :
                { __symbolic: 'class' };
        }
        reportError(error, context, path) {
            if (this.errorRecorder) {
                this.errorRecorder(formatMetadataError(error, context), (context && context.filePath) || path);
            }
            else {
                throw error;
            }
        }
        error({ message, summary, advise, position, context, value, symbol, chain }, reportingContext) {
            this.reportError(metadataError(message, summary, advise, position, symbol, context, chain), reportingContext);
        }
    }
    const METADATA_ERROR = 'ngMetadataError';
    function metadataError(message, summary, advise, position, symbol, context, chain) {
        const error = syntaxError(message);
        error[METADATA_ERROR] = true;
        if (advise)
            error.advise = advise;
        if (position)
            error.position = position;
        if (summary)
            error.summary = summary;
        if (context)
            error.context = context;
        if (chain)
            error.chain = chain;
        if (symbol)
            error.symbol = symbol;
        return error;
    }
    function isMetadataError(error) {
        return !!error[METADATA_ERROR];
    }
    const REFERENCE_TO_NONEXPORTED_CLASS = 'Reference to non-exported class';
    const VARIABLE_NOT_INITIALIZED = 'Variable not initialized';
    const DESTRUCTURE_NOT_SUPPORTED = 'Destructuring not supported';
    const COULD_NOT_RESOLVE_TYPE = 'Could not resolve type';
    const FUNCTION_CALL_NOT_SUPPORTED = 'Function call not supported';
    const REFERENCE_TO_LOCAL_SYMBOL = 'Reference to a local symbol';
    const LAMBDA_NOT_SUPPORTED = 'Lambda not supported';
    function expandedMessage(message, context) {
        switch (message) {
            case REFERENCE_TO_NONEXPORTED_CLASS:
                if (context && context.className) {
                    return `References to a non-exported class are not supported in decorators but ${context.className} was referenced.`;
                }
                break;
            case VARIABLE_NOT_INITIALIZED:
                return 'Only initialized variables and constants can be referenced in decorators because the value of this variable is needed by the template compiler';
            case DESTRUCTURE_NOT_SUPPORTED:
                return 'Referencing an exported destructured variable or constant is not supported in decorators and this value is needed by the template compiler';
            case COULD_NOT_RESOLVE_TYPE:
                if (context && context.typeName) {
                    return `Could not resolve type ${context.typeName}`;
                }
                break;
            case FUNCTION_CALL_NOT_SUPPORTED:
                if (context && context.name) {
                    return `Function calls are not supported in decorators but '${context.name}' was called`;
                }
                return 'Function calls are not supported in decorators';
            case REFERENCE_TO_LOCAL_SYMBOL:
                if (context && context.name) {
                    return `Reference to a local (non-exported) symbols are not supported in decorators but '${context.name}' was referenced`;
                }
                break;
            case LAMBDA_NOT_SUPPORTED:
                return `Function expressions are not supported in decorators`;
        }
        return message;
    }
    function messageAdvise(message, context) {
        switch (message) {
            case REFERENCE_TO_NONEXPORTED_CLASS:
                if (context && context.className) {
                    return `Consider exporting '${context.className}'`;
                }
                break;
            case DESTRUCTURE_NOT_SUPPORTED:
                return 'Consider simplifying to avoid destructuring';
            case REFERENCE_TO_LOCAL_SYMBOL:
                if (context && context.name) {
                    return `Consider exporting '${context.name}'`;
                }
                break;
            case LAMBDA_NOT_SUPPORTED:
                return `Consider changing the function expression into an exported function`;
        }
        return undefined;
    }
    function errorSummary(error) {
        if (error.summary) {
            return error.summary;
        }
        switch (error.message) {
            case REFERENCE_TO_NONEXPORTED_CLASS:
                if (error.context && error.context.className) {
                    return `references non-exported class ${error.context.className}`;
                }
                break;
            case VARIABLE_NOT_INITIALIZED:
                return 'is not initialized';
            case DESTRUCTURE_NOT_SUPPORTED:
                return 'is a destructured variable';
            case COULD_NOT_RESOLVE_TYPE:
                return 'could not be resolved';
            case FUNCTION_CALL_NOT_SUPPORTED:
                if (error.context && error.context.name) {
                    return `calls '${error.context.name}'`;
                }
                return `calls a function`;
            case REFERENCE_TO_LOCAL_SYMBOL:
                if (error.context && error.context.name) {
                    return `references local variable ${error.context.name}`;
                }
                return `references a local variable`;
        }
        return 'contains the error';
    }
    function mapStringMap(input, transform) {
        if (!input)
            return {};
        const result = {};
        Object.keys(input).forEach((key) => {
            const value = transform(input[key], key);
            if (!shouldIgnore(value)) {
                if (HIDDEN_KEY.test(key)) {
                    Object.defineProperty(result, key, { enumerable: false, configurable: true, value: value });
                }
                else {
                    result[key] = value;
                }
            }
        });
        return result;
    }
    function isPrimitive(o) {
        return o === null || (typeof o !== 'function' && typeof o !== 'object');
    }
    class BindingScope$1 {
        static build() {
            const current = new Map();
            return {
                define: function (name, value) {
                    current.set(name, value);
                    return this;
                },
                done: function () {
                    return current.size > 0 ? new PopulatedScope(current) : BindingScope$1.empty;
                }
            };
        }
    }
    BindingScope$1.missing = {};
    BindingScope$1.empty = { resolve: name => BindingScope$1.missing };
    class PopulatedScope extends BindingScope$1 {
        constructor(bindings) {
            super();
            this.bindings = bindings;
        }
        resolve(name) {
            return this.bindings.has(name) ? this.bindings.get(name) : BindingScope$1.missing;
        }
    }
    function formatMetadataMessageChain(chain, advise) {
        const expanded = expandedMessage(chain.message, chain.context);
        const nesting = chain.symbol ? ` in '${chain.symbol.name}'` : '';
        const message = `${expanded}${nesting}`;
        const position = chain.position;
        const next = chain.next ?
            formatMetadataMessageChain(chain.next, advise) :
            advise ? { message: advise } : undefined;
        return { message, position, next: next ? [next] : undefined };
    }
    function formatMetadataError(e, context) {
        if (isMetadataError(e)) {
            // Produce a formatted version of the and leaving enough information in the original error
            // to recover the formatting information to eventually produce a diagnostic error message.
            const position = e.position;
            const chain = {
                message: `Error during template compile of '${context.name}'`,
                position: position,
                next: { message: e.message, next: e.chain, context: e.context, symbol: e.symbol }
            };
            const advise = e.advise || messageAdvise(e.message, e.context);
            return formattedError(formatMetadataMessageChain(chain, advise));
        }
        return e;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class AotSummaryResolver {
        constructor(host, staticSymbolCache) {
            this.host = host;
            this.staticSymbolCache = staticSymbolCache;
            // Note: this will only contain StaticSymbols without members!
            this.summaryCache = new Map();
            this.loadedFilePaths = new Map();
            // Note: this will only contain StaticSymbols without members!
            this.importAs = new Map();
            this.knownFileNameToModuleNames = new Map();
        }
        isLibraryFile(filePath) {
            // Note: We need to strip the .ngfactory. file path,
            // so this method also works for generated files
            // (for which host.isSourceFile will always return false).
            return !this.host.isSourceFile(stripGeneratedFileSuffix(filePath));
        }
        toSummaryFileName(filePath, referringSrcFileName) {
            return this.host.toSummaryFileName(filePath, referringSrcFileName);
        }
        fromSummaryFileName(fileName, referringLibFileName) {
            return this.host.fromSummaryFileName(fileName, referringLibFileName);
        }
        resolveSummary(staticSymbol) {
            const rootSymbol = staticSymbol.members.length ?
                this.staticSymbolCache.get(staticSymbol.filePath, staticSymbol.name) :
                staticSymbol;
            let summary = this.summaryCache.get(rootSymbol);
            if (!summary) {
                this._loadSummaryFile(staticSymbol.filePath);
                summary = this.summaryCache.get(staticSymbol);
            }
            return (rootSymbol === staticSymbol && summary) || null;
        }
        getSymbolsOf(filePath) {
            if (this._loadSummaryFile(filePath)) {
                return Array.from(this.summaryCache.keys()).filter((symbol) => symbol.filePath === filePath);
            }
            return null;
        }
        getImportAs(staticSymbol) {
            staticSymbol.assertNoMembers();
            return this.importAs.get(staticSymbol);
        }
        /**
         * Converts a file path to a module name that can be used as an `import`.
         */
        getKnownModuleName(importedFilePath) {
            return this.knownFileNameToModuleNames.get(importedFilePath) || null;
        }
        addSummary(summary) {
            this.summaryCache.set(summary.symbol, summary);
        }
        _loadSummaryFile(filePath) {
            let hasSummary = this.loadedFilePaths.get(filePath);
            if (hasSummary != null) {
                return hasSummary;
            }
            let json = null;
            if (this.isLibraryFile(filePath)) {
                const summaryFilePath = summaryFileName(filePath);
                try {
                    json = this.host.loadSummary(summaryFilePath);
                }
                catch (e) {
                    console.error(`Error loading summary file ${summaryFilePath}`);
                    throw e;
                }
            }
            hasSummary = json != null;
            this.loadedFilePaths.set(filePath, hasSummary);
            if (json) {
                const { moduleName, summaries, importAs } = deserializeSummaries(this.staticSymbolCache, this, filePath, json);
                summaries.forEach((summary) => this.summaryCache.set(summary.symbol, summary));
                if (moduleName) {
                    this.knownFileNameToModuleNames.set(filePath, moduleName);
                }
                importAs.forEach((importAs) => {
                    this.importAs.set(importAs.symbol, importAs.importAs);
                });
            }
            return hasSummary;
        }
    }

    class JitSummaryResolver {
        constructor() {
            this._summaries = new Map();
        }
        isLibraryFile() {
            return false;
        }
        toSummaryFileName(fileName) {
            return fileName;
        }
        fromSummaryFileName(fileName) {
            return fileName;
        }
        resolveSummary(reference) {
            return this._summaries.get(reference) || null;
        }
        getSymbolsOf() {
            return [];
        }
        getImportAs(reference) {
            return reference;
        }
        getKnownModuleName(fileName) {
            return null;
        }
        addSummary(summary) {
            this._summaries.set(summary.symbol, summary);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * The index of each URI component in the return value of goog.uri.utils.split.
     * @enum {number}
     */
    var _ComponentIndex;
    (function (_ComponentIndex) {
        _ComponentIndex[_ComponentIndex["Scheme"] = 1] = "Scheme";
        _ComponentIndex[_ComponentIndex["UserInfo"] = 2] = "UserInfo";
        _ComponentIndex[_ComponentIndex["Domain"] = 3] = "Domain";
        _ComponentIndex[_ComponentIndex["Port"] = 4] = "Port";
        _ComponentIndex[_ComponentIndex["Path"] = 5] = "Path";
        _ComponentIndex[_ComponentIndex["QueryData"] = 6] = "QueryData";
        _ComponentIndex[_ComponentIndex["Fragment"] = 7] = "Fragment";
    })(_ComponentIndex || (_ComponentIndex = {}));

    var FactoryTarget$1;
    (function (FactoryTarget) {
        FactoryTarget[FactoryTarget["Directive"] = 0] = "Directive";
        FactoryTarget[FactoryTarget["Component"] = 1] = "Component";
        FactoryTarget[FactoryTarget["Injectable"] = 2] = "Injectable";
        FactoryTarget[FactoryTarget["Pipe"] = 3] = "Pipe";
        FactoryTarget[FactoryTarget["NgModule"] = 4] = "NgModule";
    })(FactoryTarget$1 || (FactoryTarget$1 = {}));

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    // This file only reexports content of the `src` folder. Keep it that way.
    // This function call has a global side effects and publishes the compiler into global namespace for
    // the late binding of the Compiler to the @angular/core for jit compilation.
    publishFacade(_global);

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Matches an Angular attribute to a binding type. See `ATTR` for more details.
     *
     * This is adapted from packages/compiler/src/render3/r3_template_transform.ts
     * to allow empty binding names and match template attributes.
     */
    const BIND_NAME_REGEXP$2 = /^(?:(?:(?:(bind-)|(let-)|(ref-|#)|(on-)|(bindon-)|(@)|(\*))(.*))|\[\(([^\)]*)\)\]|\[([^\]]*)\]|\(([^\)]*)\))$/;
    /**
     * Represents possible Angular attribute bindings, as indices on a match of `BIND_NAME_REGEXP`.
     */
    var ATTR;
    (function (ATTR) {
        /** "bind-" */
        ATTR[ATTR["KW_BIND"] = 1] = "KW_BIND";
        /** "let-" */
        ATTR[ATTR["KW_LET"] = 2] = "KW_LET";
        /** "ref-/#" */
        ATTR[ATTR["KW_REF"] = 3] = "KW_REF";
        /** "on-" */
        ATTR[ATTR["KW_ON"] = 4] = "KW_ON";
        /** "bindon-" */
        ATTR[ATTR["KW_BINDON"] = 5] = "KW_BINDON";
        /** "@" */
        ATTR[ATTR["KW_AT"] = 6] = "KW_AT";
        /**
         * "*"
         * Microsyntax template starts with '*'. See https://angular.io/api/core/TemplateRef
         */
        ATTR[ATTR["KW_MICROSYNTAX"] = 7] = "KW_MICROSYNTAX";
        /** The identifier after "bind-", "let-", "ref-/#", "on-", "bindon-", "@", or "*" */
        ATTR[ATTR["IDENT_KW"] = 8] = "IDENT_KW";
        /** Identifier inside [()] */
        ATTR[ATTR["IDENT_BANANA_BOX"] = 9] = "IDENT_BANANA_BOX";
        /** Identifier inside [] */
        ATTR[ATTR["IDENT_PROPERTY"] = 10] = "IDENT_PROPERTY";
        /** Identifier inside () */
        ATTR[ATTR["IDENT_EVENT"] = 11] = "IDENT_EVENT";
    })(ATTR || (ATTR = {}));
    /**
     * Returns a descriptor for a given Angular attribute, or undefined if the attribute is
     * not an Angular attribute.
     */
    function getBindingDescriptor(attribute) {
        const bindParts = attribute.match(BIND_NAME_REGEXP$2);
        if (!bindParts)
            return;
        // The first match element is skipped because it matches the entire attribute text, including the
        // binding part.
        const kind = bindParts.findIndex((val, i) => i > 0 && val !== undefined);
        if (!(kind in ATTR)) {
            throw TypeError(`"${kind}" is not a valid Angular binding kind for "${attribute}"`);
        }
        return {
            kind,
            name: bindParts[ATTR.IDENT_KW],
        };
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const Diagnostic = {
        directive_not_in_module: {
            message: `%1 '%2' is not included in a module and will not be available inside a template. Consider adding it to a NgModule declaration.`,
            kind: 'Suggestion',
        },
        missing_template_and_templateurl: {
            message: `Component '%1' must have a template or templateUrl`,
            kind: 'Error',
        },
        both_template_and_templateurl: {
            message: `Component '%1' must not have both template and templateUrl`,
            kind: 'Error',
        },
        invalid_templateurl: {
            message: `URL does not point to a valid file`,
            kind: 'Error',
        },
        template_context_missing_member: {
            message: `The template context of '%1' does not define %2.\n` +
                `If the context type is a base type or 'any', consider refining it to a more specific type.`,
            kind: 'Suggestion',
        },
        callable_expression_expected_method_call: {
            message: 'Unexpected callable expression. Expected a method call',
            kind: 'Warning',
        },
        call_target_not_callable: {
            message: `Call target '%1' has non-callable type '%2'.`,
            kind: 'Error',
        },
        expression_might_be_null: {
            message: 'The expression might be null',
            kind: 'Error',
        },
        expected_a_number_type: {
            message: 'Expected a number type',
            kind: 'Error',
        },
        expected_a_string_or_number_type: {
            message: 'Expected operands to be a string or number type',
            kind: 'Error',
        },
        expected_operands_of_comparable_types_or_any: {
            message: 'Expected operands to be of comparable types or any',
            kind: 'Error',
        },
        unrecognized_operator: {
            message: 'Unrecognized operator %1',
            kind: 'Error',
        },
        unrecognized_primitive: {
            message: 'Unrecognized primitive %1',
            kind: 'Error',
        },
        no_pipe_found: {
            message: 'No pipe of name %1 found',
            kind: 'Error',
        },
        // TODO: Consider a better error message here.
        unable_to_resolve_compatible_call_signature: {
            message: 'Unable to resolve compatible call signature',
            kind: 'Error',
        },
        unable_to_resolve_signature: {
            message: 'Unable to resolve signature for call of %1',
            kind: 'Error',
        },
        could_not_resolve_type: {
            message: `Could not resolve the type of '%1'`,
            kind: 'Error',
        },
        identifier_not_callable: {
            message: `'%1' is not callable`,
            kind: 'Error',
        },
        identifier_possibly_undefined: {
            message: `'%1' is possibly undefined. Consider using the safe navigation operator (%2) or non-null assertion operator (%3).`,
            kind: 'Suggestion',
        },
        identifier_not_defined_in_app_context: {
            message: `Identifier '%1' is not defined. The component declaration, template variable declarations, and element references do not contain such a member`,
            kind: 'Error',
        },
        identifier_not_defined_on_receiver: {
            message: `Identifier '%1' is not defined. '%2' does not contain such a member`,
            kind: 'Error',
        },
        identifier_is_private: {
            message: `Identifier '%1' refers to a private member of %2`,
            kind: 'Warning',
        },
    };
    /**
     * Creates a language service diagnostic.
     * @param span location the diagnostic for
     * @param dm diagnostic message
     * @param formatArgs run-time arguments to format the diagnostic message with (see the messages in
     *        the `Diagnostic` object for an example).
     * @returns a created diagnostic
     */
    function createDiagnostic(span, dm, ...formatArgs) {
        // Formats "%1 %2" with formatArgs ['a', 'b'] as "a b"
        const formattedMessage = dm.message.replace(/%(\d+)/g, (_, index) => formatArgs[+index - 1]);
        return {
            kind: ts.DiagnosticCategory[dm.kind],
            message: formattedMessage,
            span,
        };
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * An enumeration of basic types.
     *
     * @publicApi
     */
    var BuiltinType$1;
    (function (BuiltinType) {
        /**
         * The type is a type that can hold any other type.
         */
        BuiltinType[BuiltinType["Any"] = -1] = "Any";
        /** Unknown types are functionally identical to any. */
        BuiltinType[BuiltinType["Unknown"] = -1] = "Unknown";
        /**
         * The type of a string literal.
         */
        BuiltinType[BuiltinType["String"] = 1] = "String";
        /**
         * The type of a numeric literal.
         */
        BuiltinType[BuiltinType["Number"] = 2] = "Number";
        /**
         * The type of the `true` and `false` literals.
         */
        BuiltinType[BuiltinType["Boolean"] = 4] = "Boolean";
        /**
         * The type of the `undefined` literal.
         */
        BuiltinType[BuiltinType["Undefined"] = 8] = "Undefined";
        /**
         * the type of the `null` literal.
         */
        BuiltinType[BuiltinType["Null"] = 16] = "Null";
        /**
         * the type is an unbound type parameter.
         */
        BuiltinType[BuiltinType["Unbound"] = 32] = "Unbound";
        /**
         * Not a built-in type.
         */
        BuiltinType[BuiltinType["Other"] = 64] = "Other";
        BuiltinType[BuiltinType["Object"] = 128] = "Object";
    })(BuiltinType$1 || (BuiltinType$1 = {}));

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function isParseSourceSpan(value) {
        return value && !!value.start;
    }
    function spanOf(span) {
        if (!span)
            return undefined;
        if (isParseSourceSpan(span)) {
            return { start: span.start.offset, end: span.end.offset };
        }
        else {
            if (span.endSourceSpan) {
                return { start: span.sourceSpan.start.offset, end: span.endSourceSpan.end.offset };
            }
            else if (span.children && span.children.length) {
                return {
                    start: span.sourceSpan.start.offset,
                    end: spanOf(span.children[span.children.length - 1]).end
                };
            }
            return { start: span.sourceSpan.start.offset, end: span.sourceSpan.end.offset };
        }
    }
    function inSpan(position, span, exclusive) {
        return span != null &&
            (exclusive ? position >= span.start && position < span.end :
                position >= span.start && position <= span.end);
    }
    function offsetSpan(span, amount) {
        return { start: span.start + amount, end: span.end + amount };
    }
    function isNarrower(spanA, spanB) {
        return spanA.start >= spanB.start && spanA.end <= spanB.end;
    }
    function isStructuralDirective(type) {
        var _a;
        for (const diDep of type.diDeps) {
            const diDepName = identifierName((_a = diDep.token) === null || _a === void 0 ? void 0 : _a.identifier);
            if (diDepName === Identifiers$1.TemplateRef.name ||
                diDepName === Identifiers$1.ViewContainerRef.name) {
                return true;
            }
        }
        return false;
    }
    function getSelectors(info) {
        const map = new Map();
        const results = [];
        for (const directive of info.directives) {
            const selectors = CssSelector.parse(directive.selector);
            for (const selector of selectors) {
                results.push(selector);
                map.set(selector, directive);
            }
        }
        return { selectors: results, map };
    }
    function diagnosticInfoFromTemplateInfo(info) {
        return {
            fileName: info.template.fileName,
            offset: info.template.span.start,
            query: info.template.query,
            members: info.template.members,
            htmlAst: info.htmlAst,
            templateAst: info.templateAst,
            source: info.template.source,
        };
    }
    function findTemplateAstAt(ast, position) {
        const path = [];
        const visitor = new class extends RecursiveTemplateAstVisitor {
            visit(ast) {
                let span = spanOf(ast);
                if (inSpan(position, span)) {
                    const len = path.length;
                    if (!len || isNarrower(span, spanOf(path[len - 1]))) {
                        path.push(ast);
                    }
                }
                else {
                    // Returning a value here will result in the children being skipped.
                    return true;
                }
            }
            visitEmbeddedTemplate(ast, context) {
                return this.visitChildren(context, visit => {
                    // Ignore reference, variable and providers
                    visit(ast.attrs);
                    visit(ast.directives);
                    visit(ast.children);
                });
            }
            visitElement(ast, context) {
                return this.visitChildren(context, visit => {
                    // Ingnore providers
                    visit(ast.attrs);
                    visit(ast.inputs);
                    visit(ast.outputs);
                    visit(ast.references);
                    visit(ast.directives);
                    visit(ast.children);
                });
            }
            visitDirective(ast, context) {
                // Ignore the host properties of a directive
                const result = this.visitChildren(context, visit => {
                    visit(ast.inputs);
                });
                // We never care about the diretive itself, just its inputs.
                if (path[path.length - 1] === ast) {
                    path.pop();
                }
                return result;
            }
        };
        templateVisitAll(visitor, ast);
        return new AstPath(path, position);
    }
    /**
     * Find the tightest node at the specified `position` from the AST `nodes`, and
     * return the path to the node.
     * @param nodes HTML AST nodes
     * @param position
     */
    function getPathToNodeAtPosition(nodes, position) {
        const path = [];
        const visitor = new class extends RecursiveVisitor {
            visit(ast) {
                const span = spanOf(ast);
                if (inSpan(position, span)) {
                    path.push(ast);
                }
                else {
                    // Returning a truthy value here will skip all children and terminate
                    // the visit.
                    return true;
                }
            }
        };
        visitAll$1(visitor, nodes);
        return new AstPath(path, position);
    }
    /**
     * Inverts an object's key-value pairs.
     */
    function invertMap(obj) {
        const result = {};
        for (const name of Object.keys(obj)) {
            const v = obj[name];
            result[v] = name;
        }
        return result;
    }
    /**
     * Finds the directive member providing a template output binding, if one exists.
     * @param info aggregate template AST information
     * @param path narrowing
     */
    function findOutputBinding(binding, path, query) {
        const element = path.first(ElementAst);
        if (element) {
            for (const directive of element.directives) {
                const invertedOutputs = invertMap(directive.directive.outputs);
                const fieldName = invertedOutputs[binding.name];
                if (fieldName) {
                    const classSymbol = query.getTypeSymbol(directive.directive.type.reference);
                    if (classSymbol) {
                        return classSymbol.members().get(fieldName);
                    }
                }
            }
        }
    }
    /**
     * Returns an absolute path from the text in `node`. If the text is already
     * an absolute path, return it as is, otherwise join the path with the filename
     * of the source file.
     */
    function extractAbsoluteFilePath(node) {
        const url = node.text;
        return path.isAbsolute(url) ? url : path.join(path.dirname(node.getSourceFile().fileName), url);
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    // AstType calculatetype of the ast given AST element.
    class AstType {
        constructor(scope, query, context, source) {
            this.scope = scope;
            this.query = query;
            this.context = context;
            this.source = source;
            this.diagnostics = [];
        }
        getType(ast) {
            return ast.visit(this);
        }
        getDiagnostics(ast) {
            const type = ast.visit(this);
            if (this.context.inEvent && type.callable) {
                this.diagnostics.push(createDiagnostic(refinedSpan(ast), Diagnostic.callable_expression_expected_method_call));
            }
            return this.diagnostics;
        }
        visitUnary(ast) {
            // Visit the child to produce diagnostics.
            ast.expr.visit(this);
            // The unary plus and minus operator are always of type number.
            // https://github.com/Microsoft/TypeScript/blob/v1.8.10/doc/spec.md#4.18
            switch (ast.operator) {
                case '-':
                case '+':
                    return this.query.getBuiltinType(BuiltinType$1.Number);
            }
            this.diagnostics.push(createDiagnostic(refinedSpan(ast), Diagnostic.unrecognized_operator, ast.operator));
            return this.anyType;
        }
        visitBinary(ast) {
            const getType = (ast, operation) => {
                const type = this.getType(ast);
                if (type.nullable) {
                    switch (operation) {
                        case '&&':
                        case '||':
                        case '==':
                        case '!=':
                        case '===':
                        case '!==':
                            // Nullable allowed.
                            break;
                        default:
                            this.diagnostics.push(createDiagnostic(refinedSpan(ast), Diagnostic.expression_might_be_null));
                            break;
                    }
                }
                return type;
            };
            const leftType = getType(ast.left, ast.operation);
            const rightType = getType(ast.right, ast.operation);
            const leftKind = this.query.getTypeKind(leftType);
            const rightKind = this.query.getTypeKind(rightType);
            // The following swtich implements operator typing similar to the
            // type production tables in the TypeScript specification.
            // https://github.com/Microsoft/TypeScript/blob/v1.8.10/doc/spec.md#4.19
            const operKind = leftKind << 8 | rightKind;
            switch (ast.operation) {
                case '*':
                case '/':
                case '%':
                case '-':
                case '<<':
                case '>>':
                case '>>>':
                case '&':
                case '^':
                case '|':
                    switch (operKind) {
                        case BuiltinType$1.Any << 8 | BuiltinType$1.Any:
                        case BuiltinType$1.Number << 8 | BuiltinType$1.Any:
                        case BuiltinType$1.Any << 8 | BuiltinType$1.Number:
                        case BuiltinType$1.Number << 8 | BuiltinType$1.Number:
                            return this.query.getBuiltinType(BuiltinType$1.Number);
                        default:
                            let errorAst = ast.left;
                            switch (leftKind) {
                                case BuiltinType$1.Any:
                                case BuiltinType$1.Number:
                                    errorAst = ast.right;
                                    break;
                            }
                            this.diagnostics.push(createDiagnostic(errorAst.span, Diagnostic.expected_a_number_type));
                            return this.anyType;
                    }
                case '+':
                    switch (operKind) {
                        case BuiltinType$1.Any << 8 | BuiltinType$1.Any:
                        case BuiltinType$1.Any << 8 | BuiltinType$1.Boolean:
                        case BuiltinType$1.Any << 8 | BuiltinType$1.Number:
                        case BuiltinType$1.Any << 8 | BuiltinType$1.Other:
                        case BuiltinType$1.Boolean << 8 | BuiltinType$1.Any:
                        case BuiltinType$1.Number << 8 | BuiltinType$1.Any:
                        case BuiltinType$1.Other << 8 | BuiltinType$1.Any:
                            return this.anyType;
                        case BuiltinType$1.Any << 8 | BuiltinType$1.String:
                        case BuiltinType$1.Boolean << 8 | BuiltinType$1.String:
                        case BuiltinType$1.Number << 8 | BuiltinType$1.String:
                        case BuiltinType$1.String << 8 | BuiltinType$1.Any:
                        case BuiltinType$1.String << 8 | BuiltinType$1.Boolean:
                        case BuiltinType$1.String << 8 | BuiltinType$1.Number:
                        case BuiltinType$1.String << 8 | BuiltinType$1.String:
                        case BuiltinType$1.String << 8 | BuiltinType$1.Other:
                        case BuiltinType$1.Other << 8 | BuiltinType$1.String:
                            return this.query.getBuiltinType(BuiltinType$1.String);
                        case BuiltinType$1.Number << 8 | BuiltinType$1.Number:
                            return this.query.getBuiltinType(BuiltinType$1.Number);
                        case BuiltinType$1.Boolean << 8 | BuiltinType$1.Number:
                        case BuiltinType$1.Other << 8 | BuiltinType$1.Number:
                            this.diagnostics.push(createDiagnostic(ast.left.span, Diagnostic.expected_a_number_type));
                            return this.anyType;
                        case BuiltinType$1.Number << 8 | BuiltinType$1.Boolean:
                        case BuiltinType$1.Number << 8 | BuiltinType$1.Other:
                            this.diagnostics.push(createDiagnostic(ast.right.span, Diagnostic.expected_a_number_type));
                            return this.anyType;
                        default:
                            this.diagnostics.push(createDiagnostic(refinedSpan(ast), Diagnostic.expected_a_string_or_number_type));
                            return this.anyType;
                    }
                case '>':
                case '<':
                case '<=':
                case '>=':
                case '==':
                case '!=':
                case '===':
                case '!==':
                    if (!(leftKind & rightKind) &&
                        !((leftKind | rightKind) & (BuiltinType$1.Null | BuiltinType$1.Undefined))) {
                        // Two values are comparable only if
                        //   - they have some type overlap, or
                        //   - at least one is not defined
                        this.diagnostics.push(createDiagnostic(refinedSpan(ast), Diagnostic.expected_operands_of_comparable_types_or_any));
                    }
                    return this.query.getBuiltinType(BuiltinType$1.Boolean);
                case '&&':
                    return rightType;
                case '||':
                    return this.query.getTypeUnion(leftType, rightType);
            }
            this.diagnostics.push(createDiagnostic(refinedSpan(ast), Diagnostic.unrecognized_operator, ast.operation));
            return this.anyType;
        }
        visitChain(ast) {
            // If we are producing diagnostics, visit the children
            for (const expr of ast.expressions) {
                expr.visit(this);
            }
            // The type of a chain is always undefined.
            return this.query.getBuiltinType(BuiltinType$1.Undefined);
        }
        visitConditional(ast) {
            // The type of a conditional is the union of the true and false conditions.
            ast.condition.visit(this);
            ast.trueExp.visit(this);
            ast.falseExp.visit(this);
            return this.query.getTypeUnion(this.getType(ast.trueExp), this.getType(ast.falseExp));
        }
        visitFunctionCall(ast) {
            // The type of a function call is the return type of the selected signature.
            // The signature is selected based on the types of the arguments. Angular doesn't
            // support contextual typing of arguments so this is simpler than TypeScript's
            // version.
            const args = ast.args.map(arg => this.getType(arg));
            const target = this.getType(ast.target);
            if (!target || !target.callable) {
                this.diagnostics.push(createDiagnostic(refinedSpan(ast), Diagnostic.call_target_not_callable, this.sourceOf(ast.target), target.name));
                return this.anyType;
            }
            const signature = target.selectSignature(args);
            if (signature) {
                return signature.result;
            }
            // TODO: Consider a better error message here. See `typescript_symbols#selectSignature` for more
            // details.
            this.diagnostics.push(createDiagnostic(refinedSpan(ast), Diagnostic.unable_to_resolve_compatible_call_signature));
            return this.anyType;
        }
        visitImplicitReceiver(_ast) {
            const _this = this;
            // Return a pseudo-symbol for the implicit receiver.
            // The members of the implicit receiver are what is defined by the
            // scope passed into this class.
            return {
                name: '$implicit',
                kind: 'component',
                language: 'ng-template',
                type: undefined,
                container: undefined,
                callable: false,
                nullable: false,
                public: true,
                definition: undefined,
                documentation: [],
                members() {
                    return _this.scope;
                },
                signatures() {
                    return [];
                },
                selectSignature(_types) {
                    return undefined;
                },
                indexed(_argument) {
                    return undefined;
                },
                typeArguments() {
                    return undefined;
                },
            };
        }
        visitThisReceiver(_ast) {
            return this.visitImplicitReceiver(_ast);
        }
        visitInterpolation(ast) {
            // If we are producing diagnostics, visit the children.
            for (const expr of ast.expressions) {
                expr.visit(this);
            }
            return this.undefinedType;
        }
        visitKeyedRead(ast) {
            const targetType = this.getType(ast.receiver);
            const keyType = this.getType(ast.key);
            const result = targetType.indexed(keyType, ast.key instanceof LiteralPrimitive ? ast.key.value : undefined);
            return result || this.anyType;
        }
        visitKeyedWrite(ast) {
            // The write of a type is the type of the value being written.
            return this.getType(ast.value);
        }
        visitLiteralArray(ast) {
            // A type literal is an array type of the union of the elements
            return this.query.getArrayType(this.query.getTypeUnion(...ast.expressions.map(element => this.getType(element))));
        }
        visitLiteralMap(ast) {
            // If we are producing diagnostics, visit the children
            for (const value of ast.values) {
                value.visit(this);
            }
            // TODO: Return a composite type.
            return this.anyType;
        }
        visitLiteralPrimitive(ast) {
            // The type of a literal primitive depends on the value of the literal.
            switch (ast.value) {
                case true:
                case false:
                    return this.query.getBuiltinType(BuiltinType$1.Boolean);
                case null:
                    return this.query.getBuiltinType(BuiltinType$1.Null);
                case undefined:
                    return this.query.getBuiltinType(BuiltinType$1.Undefined);
                default:
                    switch (typeof ast.value) {
                        case 'string':
                            return this.query.getBuiltinType(BuiltinType$1.String);
                        case 'number':
                            return this.query.getBuiltinType(BuiltinType$1.Number);
                        default:
                            this.diagnostics.push(createDiagnostic(refinedSpan(ast), Diagnostic.unrecognized_primitive, typeof ast.value));
                            return this.anyType;
                    }
            }
        }
        visitMethodCall(ast) {
            return this.resolveMethodCall(this.getType(ast.receiver), ast);
        }
        visitPipe(ast) {
            // The type of a pipe node is the return type of the pipe's transform method. The table returned
            // by getPipes() is expected to contain symbols with the corresponding transform method type.
            const pipe = this.query.getPipes().get(ast.name);
            if (!pipe) {
                this.diagnostics.push(createDiagnostic(refinedSpan(ast), Diagnostic.no_pipe_found, ast.name));
                return this.anyType;
            }
            const expType = this.getType(ast.exp);
            const signature = pipe.selectSignature([expType].concat(ast.args.map(arg => this.getType(arg))));
            if (!signature) {
                this.diagnostics.push(createDiagnostic(refinedSpan(ast), Diagnostic.unable_to_resolve_signature, ast.name));
                return this.anyType;
            }
            return signature.result;
        }
        visitPrefixNot(ast) {
            // If we are producing diagnostics, visit the children
            ast.expression.visit(this);
            // The type of a prefix ! is always boolean.
            return this.query.getBuiltinType(BuiltinType$1.Boolean);
        }
        visitNonNullAssert(ast) {
            const expressionType = this.getType(ast.expression);
            return this.query.getNonNullableType(expressionType);
        }
        visitPropertyRead(ast) {
            return this.resolvePropertyRead(this.getType(ast.receiver), ast);
        }
        visitPropertyWrite(ast) {
            // The type of a write is the type of the value being written.
            return this.getType(ast.value);
        }
        visitQuote(_ast) {
            // The type of a quoted expression is any.
            return this.query.getBuiltinType(BuiltinType$1.Any);
        }
        visitSafeMethodCall(ast) {
            return this.resolveMethodCall(this.query.getNonNullableType(this.getType(ast.receiver)), ast);
        }
        visitSafePropertyRead(ast) {
            return this.resolvePropertyRead(this.query.getNonNullableType(this.getType(ast.receiver)), ast);
        }
        visitSafeKeyedRead(ast) {
            const targetType = this.query.getNonNullableType(this.getType(ast.receiver));
            const keyType = this.getType(ast.key);
            const result = targetType.indexed(keyType, ast.key instanceof LiteralPrimitive ? ast.key.value : undefined);
            return result || this.anyType;
        }
        /**
         * Gets the source of an expession AST.
         * The AST's sourceSpan is relative to the start of the template source code, which is contained
         * at this.source.
         */
        sourceOf(ast) {
            return this.source.substring(ast.sourceSpan.start, ast.sourceSpan.end);
        }
        get anyType() {
            let result = this._anyType;
            if (!result) {
                result = this._anyType = this.query.getBuiltinType(BuiltinType$1.Any);
            }
            return result;
        }
        get undefinedType() {
            let result = this._undefinedType;
            if (!result) {
                result = this._undefinedType = this.query.getBuiltinType(BuiltinType$1.Undefined);
            }
            return result;
        }
        resolveMethodCall(receiverType, ast) {
            if (this.isAny(receiverType)) {
                return this.anyType;
            }
            const methodType = this.resolvePropertyRead(receiverType, ast);
            if (!methodType) {
                this.diagnostics.push(createDiagnostic(refinedSpan(ast), Diagnostic.could_not_resolve_type, ast.name));
                return this.anyType;
            }
            if (this.isAny(methodType)) {
                return this.anyType;
            }
            if (!methodType.callable) {
                this.diagnostics.push(createDiagnostic(refinedSpan(ast), Diagnostic.identifier_not_callable, ast.name));
                return this.anyType;
            }
            const signature = methodType.selectSignature(ast.args.map(arg => this.getType(arg)));
            if (!signature) {
                this.diagnostics.push(createDiagnostic(refinedSpan(ast), Diagnostic.unable_to_resolve_signature, ast.name));
                return this.anyType;
            }
            return signature.result;
        }
        resolvePropertyRead(receiverType, ast) {
            if (this.isAny(receiverType)) {
                return this.anyType;
            }
            // The type of a property read is the seelcted member's type.
            const member = receiverType.members().get(ast.name);
            if (!member) {
                if (receiverType.name === '$implicit') {
                    this.diagnostics.push(createDiagnostic(refinedSpan(ast), Diagnostic.identifier_not_defined_in_app_context, ast.name));
                }
                else if (receiverType.nullable && ast.receiver instanceof PropertyRead) {
                    const receiver = ast.receiver.name;
                    this.diagnostics.push(createDiagnostic(refinedSpan(ast), Diagnostic.identifier_possibly_undefined, receiver, `${receiver}?.${ast.name}`, `${receiver}!.${ast.name}`));
                }
                else {
                    this.diagnostics.push(createDiagnostic(refinedSpan(ast), Diagnostic.identifier_not_defined_on_receiver, ast.name, receiverType.name));
                }
                return this.anyType;
            }
            if (!member.public) {
                const container = receiverType.name === '$implicit' ? 'the component' : `'${receiverType.name}'`;
                this.diagnostics.push(createDiagnostic(refinedSpan(ast), Diagnostic.identifier_is_private, ast.name, container));
            }
            return member.type;
        }
        isAny(symbol) {
            return !symbol || this.query.getTypeKind(symbol) === BuiltinType$1.Any ||
                (!!symbol.type && this.isAny(symbol.type));
        }
    }
    function refinedSpan(ast) {
        // nameSpan is an absolute span, but the spans returned by the expression visitor are expected to
        // be relative to the start of the expression.
        // TODO: migrate to only using absolute spans
        const absoluteOffset = ast.sourceSpan.start - ast.span.start;
        if (ast instanceof ASTWithName) {
            return offsetSpan(ast.nameSpan, -absoluteOffset);
        }
        return offsetSpan(ast.sourceSpan, -absoluteOffset);
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function getTemplateExpressionDiagnostics(info) {
        const visitor = new ExpressionDiagnosticsVisitor(info, (path) => getExpressionScope(info, path));
        templateVisitAll(visitor, info.templateAst);
        return visitor.diagnostics;
    }
    function getReferences(info) {
        const result = [];
        function processReferences(references) {
            for (const reference of references) {
                let type = undefined;
                if (reference.value) {
                    type = info.query.getTypeSymbol(tokenReference(reference.value));
                }
                result.push({
                    name: reference.name,
                    kind: 'reference',
                    type: type || info.query.getBuiltinType(BuiltinType$1.Any),
                    get definition() {
                        return getDefinitionOf(info, reference);
                    }
                });
            }
        }
        const visitor = new class extends RecursiveTemplateAstVisitor {
            visitEmbeddedTemplate(ast, context) {
                super.visitEmbeddedTemplate(ast, context);
                processReferences(ast.references);
            }
            visitElement(ast, context) {
                super.visitElement(ast, context);
                processReferences(ast.references);
            }
        };
        templateVisitAll(visitor, info.templateAst);
        return result;
    }
    function getDefinitionOf(info, ast) {
        if (info.fileName) {
            const templateOffset = info.offset;
            return [{
                    fileName: info.fileName,
                    span: {
                        start: ast.sourceSpan.start.offset + templateOffset,
                        end: ast.sourceSpan.end.offset + templateOffset
                    }
                }];
        }
    }
    /**
     * Resolve all variable declarations in a template by traversing the specified
     * `path`.
     * @param info
     * @param path template AST path
     */
    function getVarDeclarations(info, path) {
        const results = [];
        for (let current = path.head; current; current = path.childOf(current)) {
            if (!(current instanceof EmbeddedTemplateAst)) {
                continue;
            }
            for (const variable of current.variables) {
                let symbol = getVariableTypeFromDirectiveContext(variable.value, info.query, current);
                const kind = info.query.getTypeKind(symbol);
                if (kind === BuiltinType$1.Any || kind === BuiltinType$1.Unbound) {
                    // For special cases such as ngFor and ngIf, the any type is not very useful.
                    // We can do better by resolving the binding value.
                    const symbolsInScope = info.query.mergeSymbolTable([
                        info.members,
                        // Since we are traversing the AST path from head to tail, any variables
                        // that have been declared so far are also in scope.
                        info.query.createSymbolTable(results),
                    ]);
                    symbol = refinedVariableType(variable.value, symbolsInScope, info, current);
                }
                results.push({
                    name: variable.name,
                    kind: 'variable',
                    type: symbol,
                    get definition() {
                        return getDefinitionOf(info, variable);
                    },
                });
            }
        }
        return results;
    }
    /**
     * Resolve the type for the variable in `templateElement` by finding the structural
     * directive which has the context member. Returns any when not found.
     * @param value variable value name
     * @param query type symbol query
     * @param templateElement
     */
    function getVariableTypeFromDirectiveContext(value, query, templateElement) {
        for (const { directive } of templateElement.directives) {
            const context = query.getTemplateContext(directive.type.reference);
            if (context) {
                const member = context.get(value);
                if (member && member.type) {
                    return member.type;
                }
            }
        }
        return query.getBuiltinType(BuiltinType$1.Any);
    }
    /**
     * Resolve a more specific type for the variable in `templateElement` by inspecting
     * all variables that are in scope in the `mergedTable`. This function is a special
     * case for `ngFor` and `ngIf`. If resolution fails, return the `any` type.
     * @param value variable value name
     * @param mergedTable symbol table for all variables in scope
     * @param info available template information
     * @param templateElement
     */
    function refinedVariableType(value, mergedTable, info, templateElement) {
        if (value === '$implicit') {
            // Special case: ngFor directive
            const ngForDirective = templateElement.directives.find(d => {
                const name = identifierName(d.directive.type);
                return name == 'NgFor' || name == 'NgForOf';
            });
            if (ngForDirective) {
                const ngForOfBinding = ngForDirective.inputs.find(i => i.directiveName == 'ngForOf');
                if (ngForOfBinding) {
                    // Check if there is a known type for the ngFor binding.
                    const bindingType = new AstType(mergedTable, info.query, {}, info.source).getType(ngForOfBinding.value);
                    if (bindingType) {
                        const result = info.query.getElementType(bindingType);
                        if (result) {
                            return result;
                        }
                    }
                }
            }
        }
        if (value === 'ngIf' || value === '$implicit') {
            const ngIfDirective = templateElement.directives.find(d => identifierName(d.directive.type) === 'NgIf');
            if (ngIfDirective) {
                // Special case: ngIf directive. The NgIf structural directive owns a template context with
                // "$implicit" and "ngIf" members. These properties are typed as generics. Until the language
                // service uses an Ivy and TypecheckBlock backend, we cannot bind these values to a concrete
                // type without manual inference. To get the concrete type, look up the type of the "ngIf"
                // import on the NgIf directive bound to the template.
                //
                // See @angular/common/ng_if.ts for more information.
                const ngIfBinding = ngIfDirective.inputs.find(i => i.directiveName === 'ngIf');
                if (ngIfBinding) {
                    // Check if there is a known type bound to the ngIf input.
                    const bindingType = new AstType(mergedTable, info.query, {}, info.source).getType(ngIfBinding.value);
                    if (bindingType) {
                        return bindingType;
                    }
                }
            }
        }
        // We can't do better, return any
        return info.query.getBuiltinType(BuiltinType$1.Any);
    }
    function getEventDeclaration(info, path) {
        const event = path.tail;
        if (!(event instanceof BoundEventAst)) {
            // No event available in this context.
            return;
        }
        const genericEvent = {
            name: '$event',
            kind: 'variable',
            type: info.query.getBuiltinType(BuiltinType$1.Any),
        };
        const outputSymbol = findOutputBinding(event, path, info.query);
        if (!outputSymbol) {
            // The `$event` variable doesn't belong to an output, so its type can't be refined.
            // TODO: type `$event` variables in bindings to DOM events.
            return genericEvent;
        }
        // The raw event type is wrapped in a generic, like EventEmitter<T> or Observable<T>.
        const ta = outputSymbol.typeArguments();
        if (!ta || ta.length !== 1)
            return genericEvent;
        const eventType = ta[0];
        return Object.assign(Object.assign({}, genericEvent), { type: eventType });
    }
    /**
     * Returns the symbols available in a particular scope of a template.
     * @param info parsed template information
     * @param path path of template nodes narrowing to the context the expression scope should be
     * derived for.
     */
    function getExpressionScope(info, path) {
        let result = info.members;
        const references = getReferences(info);
        const variables = getVarDeclarations(info, path);
        const event = getEventDeclaration(info, path);
        if (references.length || variables.length || event) {
            const referenceTable = info.query.createSymbolTable(references);
            const variableTable = info.query.createSymbolTable(variables);
            const eventsTable = info.query.createSymbolTable(event ? [event] : []);
            result = info.query.mergeSymbolTable([result, referenceTable, variableTable, eventsTable]);
        }
        return result;
    }
    class ExpressionDiagnosticsVisitor extends RecursiveTemplateAstVisitor {
        constructor(info, getExpressionScope) {
            super();
            this.info = info;
            this.getExpressionScope = getExpressionScope;
            this.diagnostics = [];
            this.path = new AstPath([]);
        }
        visitDirective(ast, context) {
            // Override the default child visitor to ignore the host properties of a directive.
            if (ast.inputs && ast.inputs.length) {
                templateVisitAll(this, ast.inputs, context);
            }
        }
        visitBoundText(ast) {
            this.push(ast);
            this.diagnoseExpression(ast.value, ast.sourceSpan.start.offset, false);
            this.pop();
        }
        visitDirectiveProperty(ast) {
            this.push(ast);
            this.diagnoseExpression(ast.value, this.attributeValueLocation(ast), false);
            this.pop();
        }
        visitElementProperty(ast) {
            this.push(ast);
            this.diagnoseExpression(ast.value, this.attributeValueLocation(ast), false);
            this.pop();
        }
        visitEvent(ast) {
            this.push(ast);
            this.diagnoseExpression(ast.handler, this.attributeValueLocation(ast), true);
            this.pop();
        }
        visitVariable(ast) {
            const directive = this.directiveSummary;
            if (directive && ast.value) {
                const context = this.info.query.getTemplateContext(directive.type.reference);
                if (context && !context.has(ast.value)) {
                    const missingMember = ast.value === '$implicit' ? 'an implicit value' : `a member called '${ast.value}'`;
                    const span = this.absSpan(spanOf$1(ast.sourceSpan));
                    this.diagnostics.push(createDiagnostic(span, Diagnostic.template_context_missing_member, directive.type.reference.name, missingMember));
                }
            }
        }
        visitElement(ast, context) {
            this.push(ast);
            super.visitElement(ast, context);
            this.pop();
        }
        visitEmbeddedTemplate(ast, context) {
            const previousDirectiveSummary = this.directiveSummary;
            this.push(ast);
            // Find directive that references this template
            this.directiveSummary =
                ast.directives.map(d => d.directive).find(d => hasTemplateReference(d.type));
            // Process children
            super.visitEmbeddedTemplate(ast, context);
            this.pop();
            this.directiveSummary = previousDirectiveSummary;
        }
        attributeValueLocation(ast) {
            const path = getPathToNodeAtPosition(this.info.htmlAst, ast.sourceSpan.start.offset);
            const last = path.tail;
            if (last instanceof Attribute && last.valueSpan) {
                return last.valueSpan.start.offset;
            }
            return ast.sourceSpan.start.offset;
        }
        diagnoseExpression(ast, offset, inEvent) {
            const scope = this.getExpressionScope(this.path, inEvent);
            const analyzer = new AstType(scope, this.info.query, { inEvent }, this.info.source);
            for (const diagnostic of analyzer.getDiagnostics(ast)) {
                diagnostic.span = this.absSpan(diagnostic.span, offset);
                this.diagnostics.push(diagnostic);
            }
        }
        push(ast) {
            this.path.push(ast);
        }
        pop() {
            this.path.pop();
        }
        absSpan(span, additionalOffset = 0) {
            return {
                start: span.start + this.info.offset + additionalOffset,
                end: span.end + this.info.offset + additionalOffset,
            };
        }
    }
    function hasTemplateReference(type) {
        if (type.diDeps) {
            for (let diDep of type.diDeps) {
                if (diDep.token && diDep.token.identifier &&
                    identifierName(diDep.token.identifier) == 'TemplateRef')
                    return true;
            }
        }
        return false;
    }
    function spanOf$1(sourceSpan) {
        return { start: sourceSpan.start.offset, end: sourceSpan.end.offset };
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * The type of Angular directive. Used for QuickInfo in template.
     */
    var DirectiveKind;
    (function (DirectiveKind) {
        DirectiveKind["COMPONENT"] = "component";
        DirectiveKind["DIRECTIVE"] = "directive";
        DirectiveKind["EVENT"] = "event";
    })(DirectiveKind || (DirectiveKind = {}));
    /**
     * ScriptElementKind for completion.
     */
    var CompletionKind;
    (function (CompletionKind) {
        CompletionKind["ANGULAR_ELEMENT"] = "angular element";
        CompletionKind["ATTRIBUTE"] = "attribute";
        CompletionKind["COMPONENT"] = "component";
        CompletionKind["ELEMENT"] = "element";
        CompletionKind["ENTITY"] = "entity";
        CompletionKind["HTML_ATTRIBUTE"] = "html attribute";
        CompletionKind["HTML_ELEMENT"] = "html element";
        CompletionKind["KEY"] = "key";
        CompletionKind["METHOD"] = "method";
        CompletionKind["PIPE"] = "pipe";
        CompletionKind["PROPERTY"] = "property";
        CompletionKind["REFERENCE"] = "reference";
        CompletionKind["TYPE"] = "type";
        CompletionKind["VARIABLE"] = "variable";
    })(CompletionKind || (CompletionKind = {}));

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function findAstAt(ast, position, excludeEmpty = false) {
        const path = [];
        const visitor = new class extends RecursiveAstVisitor {
            visit(ast) {
                if ((!excludeEmpty || ast.sourceSpan.start < ast.sourceSpan.end) &&
                    inSpan(position, ast.sourceSpan)) {
                    const isNotNarrower = path.length && !isNarrower(ast.span, path[path.length - 1].span);
                    if (!isNotNarrower) {
                        path.push(ast);
                    }
                    ast.visit(this);
                }
            }
        };
        // We never care about the ASTWithSource node and its visit() method calls its ast's visit so
        // the visit() method above would never see it.
        if (ast instanceof ASTWithSource) {
            ast = ast.ast;
        }
        // `Interpolation` is useless here except the `expressions` of it.
        if (ast instanceof Interpolation) {
            ast = ast.expressions.filter((_ast) => inSpan(position, _ast.sourceSpan))[0];
        }
        if (ast) {
            visitor.visit(ast);
        }
        return new AstPath(path, position);
    }
    function getExpressionCompletions(scope, ast, position, templateInfo) {
        const path = findAstAt(ast, position);
        if (path.empty)
            return undefined;
        const tail = path.tail;
        let result = scope;
        function getType(ast) {
            return new AstType(scope, templateInfo.query, {}, templateInfo.source).getType(ast);
        }
        // If the completion request is in a not in a pipe or property access then the global scope
        // (that is the scope of the implicit receiver) is the right scope as the user is typing the
        // beginning of an expression.
        tail.visit({
            visitUnary(_ast) { },
            visitBinary(_ast) { },
            visitChain(_ast) { },
            visitConditional(_ast) { },
            visitFunctionCall(_ast) { },
            visitImplicitReceiver(_ast) { },
            visitThisReceiver(_ast) { },
            visitInterpolation(_ast) {
                result = undefined;
            },
            visitKeyedRead(_ast) { },
            visitSafeKeyedRead(_ast) { },
            visitKeyedWrite(_ast) { },
            visitLiteralArray(_ast) { },
            visitLiteralMap(_ast) { },
            visitLiteralPrimitive(ast) {
                // The type `LiteralPrimitive` include the `ERROR`, and it's wrapped as `string`.
                // packages/compiler/src/template_parser/binding_parser.ts#L308
                // So exclude the `ERROR` here.
                if (typeof ast.value === 'string' &&
                    ast.value ===
                        templateInfo.source.slice(ast.sourceSpan.start + 1, ast.sourceSpan.end - 1)) {
                    result = undefined;
                }
            },
            visitMethodCall(_ast) { },
            visitPipe(ast) {
                if (position >= ast.exp.span.end &&
                    (!ast.args || !ast.args.length || position < ast.args[0].span.start)) {
                    // We are in a position a pipe name is expected.
                    result = templateInfo.query.getPipes();
                }
            },
            visitPrefixNot(_ast) { },
            visitNonNullAssert(_ast) { },
            visitPropertyRead(ast) {
                const receiverType = getType(ast.receiver);
                result = receiverType ? receiverType.members() : scope;
            },
            visitPropertyWrite(ast) {
                const receiverType = getType(ast.receiver);
                result = receiverType ? receiverType.members() : scope;
            },
            visitQuote(_ast) {
                // For a quote, return the members of any (if there are any).
                result = templateInfo.query.getBuiltinType(BuiltinType$1.Any).members();
            },
            visitSafeMethodCall(ast) {
                const receiverType = getType(ast.receiver);
                result = receiverType ? receiverType.members() : scope;
            },
            visitSafePropertyRead(ast) {
                const receiverType = getType(ast.receiver);
                result = receiverType ? receiverType.members() : scope;
            },
        });
        return result && result.values();
    }
    /**
     * Retrieves the expression symbol at a particular position in a template.
     *
     * @param scope symbols in scope of the template
     * @param ast template AST
     * @param position absolute location in template to retrieve symbol at
     * @param query type symbol query for the template scope
     */
    function getExpressionSymbol(scope, ast, position, templateInfo) {
        const path = findAstAt(ast, position, /* excludeEmpty */ true);
        if (path.empty)
            return undefined;
        const tail = path.tail;
        function getType(ast) {
            return new AstType(scope, templateInfo.query, {}, templateInfo.source).getType(ast);
        }
        function spanFromName(ast) {
            // `nameSpan` is an absolute span, but the span expected by the result of this method is
            // relative to the start of the expression.
            // TODO(ayazhafiz): migrate to only using absolute spans
            const offset = ast.sourceSpan.start - ast.span.start;
            return {
                start: ast.nameSpan.start - offset,
                end: ast.nameSpan.end - offset,
            };
        }
        let symbol = undefined;
        let span = undefined;
        // If the completion request is in a not in a pipe or property access then the global scope
        // (that is the scope of the implicit receiver) is the right scope as the user is typing the
        // beginning of an expression.
        tail.visit({
            visitUnary(_ast) { },
            visitBinary(_ast) { },
            visitChain(_ast) { },
            visitConditional(_ast) { },
            visitFunctionCall(_ast) { },
            visitImplicitReceiver(_ast) { },
            visitThisReceiver(_ast) { },
            visitInterpolation(_ast) { },
            visitKeyedRead(_ast) { },
            visitSafeKeyedRead(_ast) { },
            visitKeyedWrite(_ast) { },
            visitLiteralArray(_ast) { },
            visitLiteralMap(_ast) { },
            visitLiteralPrimitive(_ast) { },
            visitMethodCall(ast) {
                const receiverType = getType(ast.receiver);
                symbol = receiverType && receiverType.members().get(ast.name);
                span = spanFromName(ast);
            },
            visitPipe(ast) {
                if (inSpan(position, ast.nameSpan, /* exclusive */ true)) {
                    // We are in a position a pipe name is expected.
                    const pipes = templateInfo.query.getPipes();
                    symbol = pipes.get(ast.name);
                    span = spanFromName(ast);
                }
            },
            visitPrefixNot(_ast) { },
            visitNonNullAssert(_ast) { },
            visitPropertyRead(ast) {
                const receiverType = getType(ast.receiver);
                symbol = receiverType && receiverType.members().get(ast.name);
                span = spanFromName(ast);
            },
            visitPropertyWrite(ast) {
                const receiverType = getType(ast.receiver);
                symbol = receiverType && receiverType.members().get(ast.name);
                span = spanFromName(ast);
            },
            visitQuote(_ast) { },
            visitSafeMethodCall(ast) {
                const receiverType = getType(ast.receiver);
                symbol = receiverType && receiverType.members().get(ast.name);
                span = spanFromName(ast);
            },
            visitSafePropertyRead(ast) {
                const receiverType = getType(ast.receiver);
                symbol = receiverType && receiverType.members().get(ast.name);
                span = spanFromName(ast);
            },
        });
        if (symbol && span) {
            return { symbol, span };
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const values = [
        'ID',
        'CDATA',
        'NAME',
        ['ltr', 'rtl'],
        ['rect', 'circle', 'poly', 'default'],
        'NUMBER',
        ['nohref'],
        ['ismap'],
        ['declare'],
        ['DATA', 'REF', 'OBJECT'],
        ['GET', 'POST'],
        'IDREF',
        ['TEXT', 'PASSWORD', 'CHECKBOX', 'RADIO', 'SUBMIT', 'RESET', 'FILE', 'HIDDEN', 'IMAGE', 'BUTTON'],
        ['checked'],
        ['disabled'],
        ['readonly'],
        ['multiple'],
        ['selected'],
        ['button', 'submit', 'reset'],
        ['void', 'above', 'below', 'hsides', 'lhs', 'rhs', 'vsides', 'box', 'border'],
        ['none', 'groups', 'rows', 'cols', 'all'],
        ['left', 'center', 'right', 'justify', 'char'],
        ['top', 'middle', 'bottom', 'baseline'],
        'IDREFS',
        ['row', 'col', 'rowgroup', 'colgroup'],
        ['defer']
    ];
    const groups = [
        { id: 0 },
        {
            onclick: 1,
            ondblclick: 1,
            onmousedown: 1,
            onmouseup: 1,
            onmouseover: 1,
            onmousemove: 1,
            onmouseout: 1,
            onkeypress: 1,
            onkeydown: 1,
            onkeyup: 1
        },
        { lang: 2, dir: 3 },
        { onload: 1, onunload: 1 },
        { name: 1 },
        { href: 1 },
        { type: 1 },
        { alt: 1 },
        { tabindex: 5 },
        { media: 1 },
        { nohref: 6 },
        { usemap: 1 },
        { src: 1 },
        { onfocus: 1, onblur: 1 },
        { charset: 1 },
        { declare: 8, classid: 1, codebase: 1, data: 1, codetype: 1, archive: 1, standby: 1 },
        { title: 1 },
        { value: 1 },
        { cite: 1 },
        { datetime: 1 },
        { accept: 1 },
        { shape: 4, coords: 1 },
        { for: 11
        },
        { action: 1, method: 10, enctype: 1, onsubmit: 1, onreset: 1, 'accept-charset': 1 },
        { valuetype: 9 },
        { longdesc: 1 },
        { width: 1 },
        { disabled: 14 },
        { readonly: 15, onselect: 1 },
        { accesskey: 1 },
        { size: 5, multiple: 16 },
        { onchange: 1 },
        { label: 1 },
        { selected: 17 },
        { type: 12, checked: 13, size: 1, maxlength: 5 },
        { rows: 5, cols: 5 },
        { type: 18 },
        { height: 1 },
        { summary: 1, border: 1, frame: 19, rules: 20, cellspacing: 1, cellpadding: 1, datapagesize: 1 },
        { align: 21, char: 1, charoff: 1, valign: 22 },
        { span: 5 },
        { abbr: 1, axis: 1, headers: 23, scope: 24, rowspan: 5, colspan: 5 },
        { profile: 1 },
        { 'http-equiv': 2, name: 2, content: 1, scheme: 1 },
        { class: 1, style: 1 },
        { hreflang: 2, rel: 1, rev: 1 },
        { ismap: 7 },
        {
            defer: 25, event: 1, for: 1
        }
    ];
    const elements = {
        TT: [0, 1, 2, 16, 44],
        I: [0, 1, 2, 16, 44],
        B: [0, 1, 2, 16, 44],
        BIG: [0, 1, 2, 16, 44],
        SMALL: [0, 1, 2, 16, 44],
        EM: [0, 1, 2, 16, 44],
        STRONG: [0, 1, 2, 16, 44],
        DFN: [0, 1, 2, 16, 44],
        CODE: [0, 1, 2, 16, 44],
        SAMP: [0, 1, 2, 16, 44],
        KBD: [0, 1, 2, 16, 44],
        VAR: [0, 1, 2, 16, 44],
        CITE: [0, 1, 2, 16, 44],
        ABBR: [0, 1, 2, 16, 44],
        ACRONYM: [0, 1, 2, 16, 44],
        SUB: [0, 1, 2, 16, 44],
        SUP: [0, 1, 2, 16, 44],
        SPAN: [0, 1, 2, 16, 44],
        BDO: [0, 2, 16, 44],
        BR: [0, 16, 44],
        BODY: [0, 1, 2, 3, 16, 44],
        ADDRESS: [0, 1, 2, 16, 44],
        DIV: [0, 1, 2, 16, 44],
        A: [0, 1, 2, 4, 5, 6, 8, 13, 14, 16, 21, 29, 44, 45],
        MAP: [0, 1, 2, 4, 16, 44],
        AREA: [0, 1, 2, 5, 7, 8, 10, 13, 16, 21, 29, 44],
        LINK: [0, 1, 2, 5, 6, 9, 14, 16, 44, 45],
        IMG: [0, 1, 2, 4, 7, 11, 12, 16, 25, 26, 37, 44, 46],
        OBJECT: [0, 1, 2, 4, 6, 8, 11, 15, 16, 26, 37, 44],
        PARAM: [0, 4, 6, 17, 24],
        HR: [0, 1, 2, 16, 44],
        P: [0, 1, 2, 16, 44],
        H1: [0, 1, 2, 16, 44],
        H2: [0, 1, 2, 16, 44],
        H3: [0, 1, 2, 16, 44],
        H4: [0, 1, 2, 16, 44],
        H5: [0, 1, 2, 16, 44],
        H6: [0, 1, 2, 16, 44],
        PRE: [0, 1, 2, 16, 44],
        Q: [0, 1, 2, 16, 18, 44],
        BLOCKQUOTE: [0, 1, 2, 16, 18, 44],
        INS: [0, 1, 2, 16, 18, 19, 44],
        DEL: [0, 1, 2, 16, 18, 19, 44],
        DL: [0, 1, 2, 16, 44],
        DT: [0, 1, 2, 16, 44],
        DD: [0, 1, 2, 16, 44],
        OL: [0, 1, 2, 16, 44],
        UL: [0, 1, 2, 16, 44],
        LI: [0, 1, 2, 16, 44],
        FORM: [0, 1, 2, 4, 16, 20, 23, 44],
        LABEL: [0, 1, 2, 13, 16, 22, 29, 44],
        INPUT: [0, 1, 2, 4, 7, 8, 11, 12, 13, 16, 17, 20, 27, 28, 29, 31, 34, 44, 46],
        SELECT: [0, 1, 2, 4, 8, 13, 16, 27, 30, 31, 44],
        OPTGROUP: [0, 1, 2, 16, 27, 32, 44],
        OPTION: [0, 1, 2, 16, 17, 27, 32, 33, 44],
        TEXTAREA: [0, 1, 2, 4, 8, 13, 16, 27, 28, 29, 31, 35, 44],
        FIELDSET: [0, 1, 2, 16, 44],
        LEGEND: [0, 1, 2, 16, 29, 44],
        BUTTON: [0, 1, 2, 4, 8, 13, 16, 17, 27, 29, 36, 44],
        TABLE: [0, 1, 2, 16, 26, 38, 44],
        CAPTION: [0, 1, 2, 16, 44],
        COLGROUP: [0, 1, 2, 16, 26, 39, 40, 44],
        COL: [0, 1, 2, 16, 26, 39, 40, 44],
        THEAD: [0, 1, 2, 16, 39, 44],
        TBODY: [0, 1, 2, 16, 39, 44],
        TFOOT: [0, 1, 2, 16, 39, 44],
        TR: [0, 1, 2, 16, 39, 44],
        TH: [0, 1, 2, 16, 39, 41, 44],
        TD: [0, 1, 2, 16, 39, 41, 44],
        HEAD: [2, 42],
        TITLE: [2],
        BASE: [5],
        META: [2, 43],
        STYLE: [2, 6, 9, 16],
        SCRIPT: [6, 12, 14, 47],
        NOSCRIPT: [0, 1, 2, 16, 44],
        HTML: [2]
    };
    const defaultAttributes = [0, 1, 2, 4];
    function elementNames() {
        return Object.keys(elements).sort().map(v => v.toLowerCase());
    }
    function compose(indexes) {
        const result = {};
        if (indexes) {
            for (let index of indexes) {
                const group = groups[index];
                for (let name in group)
                    if (group.hasOwnProperty(name))
                        result[name] = values[group[name]];
            }
        }
        return result;
    }
    function attributeNames(element) {
        return Object.keys(compose(elements[element.toUpperCase()] || defaultAttributes)).sort();
    }
    // This section is describes the DOM property surface of a DOM element and is derivgulp formated
    // from
    // from the SCHEMA strings from the security context information. SCHEMA is copied here because
    // it would be an unnecessary risk to allow this array to be imported from the security context
    // schema registry.
    const SCHEMA$1 = [
        '[Element]|textContent,%classList,className,id,innerHTML,*beforecopy,*beforecut,*beforepaste,*copy,*cut,*paste,*search,*selectstart,*webkitfullscreenchange,*webkitfullscreenerror,*wheel,outerHTML,#scrollLeft,#scrollTop,slot' +
            /* added manually to avoid breaking changes */
            ',*message,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored',
        '[HTMLElement]^[Element]|accessKey,contentEditable,dir,!draggable,!hidden,innerText,lang,*abort,*auxclick,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,outerText,!spellcheck,%style,#tabIndex,title,!translate',
        'abbr,address,article,aside,b,bdi,bdo,cite,code,dd,dfn,dt,em,figcaption,figure,footer,header,i,kbd,main,mark,nav,noscript,rb,rp,rt,rtc,ruby,s,samp,section,small,strong,sub,sup,u,var,wbr^[HTMLElement]|accessKey,contentEditable,dir,!draggable,!hidden,innerText,lang,*abort,*auxclick,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,outerText,!spellcheck,%style,#tabIndex,title,!translate',
        'media^[HTMLElement]|!autoplay,!controls,%controlsList,%crossOrigin,#currentTime,!defaultMuted,#defaultPlaybackRate,!disableRemotePlayback,!loop,!muted,*encrypted,*waitingforkey,#playbackRate,preload,src,%srcObject,#volume',
        ':svg:^[HTMLElement]|*abort,*auxclick,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,%style,#tabIndex',
        ':svg:graphics^:svg:|',
        ':svg:animation^:svg:|*begin,*end,*repeat',
        ':svg:geometry^:svg:|',
        ':svg:componentTransferFunction^:svg:|',
        ':svg:gradient^:svg:|',
        ':svg:textContent^:svg:graphics|',
        ':svg:textPositioning^:svg:textContent|',
        'a^[HTMLElement]|charset,coords,download,hash,host,hostname,href,hreflang,name,password,pathname,ping,port,protocol,referrerPolicy,rel,rev,search,shape,target,text,type,username',
        'area^[HTMLElement]|alt,coords,download,hash,host,hostname,href,!noHref,password,pathname,ping,port,protocol,referrerPolicy,rel,search,shape,target,username',
        'audio^media|',
        'br^[HTMLElement]|clear',
        'base^[HTMLElement]|href,target',
        'body^[HTMLElement]|aLink,background,bgColor,link,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,text,vLink',
        'button^[HTMLElement]|!autofocus,!disabled,formAction,formEnctype,formMethod,!formNoValidate,formTarget,name,type,value',
        'canvas^[HTMLElement]|#height,#width',
        'content^[HTMLElement]|select',
        'dl^[HTMLElement]|!compact',
        'datalist^[HTMLElement]|',
        'details^[HTMLElement]|!open',
        'dialog^[HTMLElement]|!open,returnValue',
        'dir^[HTMLElement]|!compact',
        'div^[HTMLElement]|align',
        'embed^[HTMLElement]|align,height,name,src,type,width',
        'fieldset^[HTMLElement]|!disabled,name',
        'font^[HTMLElement]|color,face,size',
        'form^[HTMLElement]|acceptCharset,action,autocomplete,encoding,enctype,method,name,!noValidate,target',
        'frame^[HTMLElement]|frameBorder,longDesc,marginHeight,marginWidth,name,!noResize,scrolling,src',
        'frameset^[HTMLElement]|cols,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,rows',
        'hr^[HTMLElement]|align,color,!noShade,size,width',
        'head^[HTMLElement]|',
        'h1,h2,h3,h4,h5,h6^[HTMLElement]|align',
        'html^[HTMLElement]|version',
        'iframe^[HTMLElement]|align,!allowFullscreen,frameBorder,height,longDesc,marginHeight,marginWidth,name,referrerPolicy,%sandbox,scrolling,src,srcdoc,width',
        'img^[HTMLElement]|align,alt,border,%crossOrigin,#height,#hspace,!isMap,longDesc,lowsrc,name,referrerPolicy,sizes,src,srcset,useMap,#vspace,#width',
        'input^[HTMLElement]|accept,align,alt,autocapitalize,autocomplete,!autofocus,!checked,!defaultChecked,defaultValue,dirName,!disabled,%files,formAction,formEnctype,formMethod,!formNoValidate,formTarget,#height,!incremental,!indeterminate,max,#maxLength,min,#minLength,!multiple,name,pattern,placeholder,!readOnly,!required,selectionDirection,#selectionEnd,#selectionStart,#size,src,step,type,useMap,value,%valueAsDate,#valueAsNumber,#width',
        'li^[HTMLElement]|type,#value',
        'label^[HTMLElement]|htmlFor',
        'legend^[HTMLElement]|align',
        'link^[HTMLElement]|as,charset,%crossOrigin,!disabled,href,hreflang,integrity,media,referrerPolicy,rel,%relList,rev,%sizes,target,type',
        'map^[HTMLElement]|name',
        'marquee^[HTMLElement]|behavior,bgColor,direction,height,#hspace,#loop,#scrollAmount,#scrollDelay,!trueSpeed,#vspace,width',
        'menu^[HTMLElement]|!compact',
        'meta^[HTMLElement]|content,httpEquiv,name,scheme',
        'meter^[HTMLElement]|#high,#low,#max,#min,#optimum,#value',
        'ins,del^[HTMLElement]|cite,dateTime',
        'ol^[HTMLElement]|!compact,!reversed,#start,type',
        'object^[HTMLElement]|align,archive,border,code,codeBase,codeType,data,!declare,height,#hspace,name,standby,type,useMap,#vspace,width',
        'optgroup^[HTMLElement]|!disabled,label',
        'option^[HTMLElement]|!defaultSelected,!disabled,label,!selected,text,value',
        'output^[HTMLElement]|defaultValue,%htmlFor,name,value',
        'p^[HTMLElement]|align',
        'param^[HTMLElement]|name,type,value,valueType',
        'picture^[HTMLElement]|',
        'pre^[HTMLElement]|#width',
        'progress^[HTMLElement]|#max,#value',
        'q,blockquote,cite^[HTMLElement]|',
        'script^[HTMLElement]|!async,charset,%crossOrigin,!defer,event,htmlFor,integrity,src,text,type',
        'select^[HTMLElement]|autocomplete,!autofocus,!disabled,#length,!multiple,name,!required,#selectedIndex,#size,value',
        'shadow^[HTMLElement]|',
        'slot^[HTMLElement]|name',
        'source^[HTMLElement]|media,sizes,src,srcset,type',
        'span^[HTMLElement]|',
        'style^[HTMLElement]|!disabled,media,type',
        'caption^[HTMLElement]|align',
        'th,td^[HTMLElement]|abbr,align,axis,bgColor,ch,chOff,#colSpan,headers,height,!noWrap,#rowSpan,scope,vAlign,width',
        'col,colgroup^[HTMLElement]|align,ch,chOff,#span,vAlign,width',
        'table^[HTMLElement]|align,bgColor,border,%caption,cellPadding,cellSpacing,frame,rules,summary,%tFoot,%tHead,width',
        'tr^[HTMLElement]|align,bgColor,ch,chOff,vAlign',
        'tfoot,thead,tbody^[HTMLElement]|align,ch,chOff,vAlign',
        'template^[HTMLElement]|',
        'textarea^[HTMLElement]|autocapitalize,autocomplete,!autofocus,#cols,defaultValue,dirName,!disabled,#maxLength,#minLength,name,placeholder,!readOnly,!required,#rows,selectionDirection,#selectionEnd,#selectionStart,value,wrap',
        'title^[HTMLElement]|text',
        'track^[HTMLElement]|!default,kind,label,src,srclang',
        'ul^[HTMLElement]|!compact,type',
        'unknown^[HTMLElement]|',
        'video^media|#height,poster,#width',
        ':svg:a^:svg:graphics|',
        ':svg:animate^:svg:animation|',
        ':svg:animateMotion^:svg:animation|',
        ':svg:animateTransform^:svg:animation|',
        ':svg:circle^:svg:geometry|',
        ':svg:clipPath^:svg:graphics|',
        ':svg:defs^:svg:graphics|',
        ':svg:desc^:svg:|',
        ':svg:discard^:svg:|',
        ':svg:ellipse^:svg:geometry|',
        ':svg:feBlend^:svg:|',
        ':svg:feColorMatrix^:svg:|',
        ':svg:feComponentTransfer^:svg:|',
        ':svg:feComposite^:svg:|',
        ':svg:feConvolveMatrix^:svg:|',
        ':svg:feDiffuseLighting^:svg:|',
        ':svg:feDisplacementMap^:svg:|',
        ':svg:feDistantLight^:svg:|',
        ':svg:feDropShadow^:svg:|',
        ':svg:feFlood^:svg:|',
        ':svg:feFuncA^:svg:componentTransferFunction|',
        ':svg:feFuncB^:svg:componentTransferFunction|',
        ':svg:feFuncG^:svg:componentTransferFunction|',
        ':svg:feFuncR^:svg:componentTransferFunction|',
        ':svg:feGaussianBlur^:svg:|',
        ':svg:feImage^:svg:|',
        ':svg:feMerge^:svg:|',
        ':svg:feMergeNode^:svg:|',
        ':svg:feMorphology^:svg:|',
        ':svg:feOffset^:svg:|',
        ':svg:fePointLight^:svg:|',
        ':svg:feSpecularLighting^:svg:|',
        ':svg:feSpotLight^:svg:|',
        ':svg:feTile^:svg:|',
        ':svg:feTurbulence^:svg:|',
        ':svg:filter^:svg:|',
        ':svg:foreignObject^:svg:graphics|',
        ':svg:g^:svg:graphics|',
        ':svg:image^:svg:graphics|',
        ':svg:line^:svg:geometry|',
        ':svg:linearGradient^:svg:gradient|',
        ':svg:mpath^:svg:|',
        ':svg:marker^:svg:|',
        ':svg:mask^:svg:|',
        ':svg:metadata^:svg:|',
        ':svg:path^:svg:geometry|',
        ':svg:pattern^:svg:|',
        ':svg:polygon^:svg:geometry|',
        ':svg:polyline^:svg:geometry|',
        ':svg:radialGradient^:svg:gradient|',
        ':svg:rect^:svg:geometry|',
        ':svg:svg^:svg:graphics|#currentScale,#zoomAndPan',
        ':svg:script^:svg:|type',
        ':svg:set^:svg:animation|',
        ':svg:stop^:svg:|',
        ':svg:style^:svg:|!disabled,media,title,type',
        ':svg:switch^:svg:graphics|',
        ':svg:symbol^:svg:|',
        ':svg:tspan^:svg:textPositioning|',
        ':svg:text^:svg:textPositioning|',
        ':svg:textPath^:svg:textContent|',
        ':svg:title^:svg:|',
        ':svg:use^:svg:graphics|',
        ':svg:view^:svg:|#zoomAndPan',
        'data^[HTMLElement]|value',
        'keygen^[HTMLElement]|!autofocus,challenge,!disabled,form,keytype,name',
        'menuitem^[HTMLElement]|type,label,icon,!disabled,!checked,radiogroup,!default',
        'summary^[HTMLElement]|',
        'time^[HTMLElement]|dateTime',
        ':svg:cursor^:svg:|',
    ];
    const EVENT = 'event';
    const BOOLEAN$1 = 'boolean';
    const NUMBER$1 = 'number';
    const STRING$1 = 'string';
    const OBJECT$1 = 'object';
    class SchemaInformation {
        constructor() {
            this.schema = {};
            SCHEMA$1.forEach(encodedType => {
                const parts = encodedType.split('|');
                const properties = parts[1].split(',');
                const typeParts = (parts[0] + '^').split('^');
                const typeName = typeParts[0];
                const type = {};
                typeName.split(',').forEach(tag => this.schema[tag.toLowerCase()] = type);
                const superName = typeParts[1];
                const superType = superName && this.schema[superName.toLowerCase()];
                if (superType) {
                    for (const key in superType) {
                        type[key] = superType[key];
                    }
                }
                properties.forEach((property) => {
                    if (property === '') ;
                    else if (property.startsWith('*')) {
                        type[property.substring(1)] = EVENT;
                    }
                    else if (property.startsWith('!')) {
                        type[property.substring(1)] = BOOLEAN$1;
                    }
                    else if (property.startsWith('#')) {
                        type[property.substring(1)] = NUMBER$1;
                    }
                    else if (property.startsWith('%')) {
                        type[property.substring(1)] = OBJECT$1;
                    }
                    else {
                        type[property] = STRING$1;
                    }
                });
            });
        }
        allKnownElements() {
            return Object.keys(this.schema);
        }
        eventsOf(elementName) {
            const elementType = this.schema[elementName.toLowerCase()] || {};
            return Object.keys(elementType).filter(property => elementType[property] === EVENT);
        }
        propertiesOf(elementName) {
            const elementType = this.schema[elementName.toLowerCase()] || {};
            return Object.keys(elementType).filter(property => elementType[property] !== EVENT);
        }
        typeOf(elementName, property) {
            return (this.schema[elementName.toLowerCase()] || {})[property];
        }
        static get instance() {
            let result = SchemaInformation._instance;
            if (!result) {
                result = SchemaInformation._instance = new SchemaInformation();
            }
            return result;
        }
    }
    function eventNames(elementName) {
        return SchemaInformation.instance.eventsOf(elementName);
    }
    function propertyNames(elementName) {
        return SchemaInformation.instance.propertiesOf(elementName);
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const EMPTY_SYMBOL_TABLE = {
        size: 0,
        get: () => undefined,
        has: () => false,
        values: () => [],
    };
    /**
     * A factory function that returns a symbol table that contains all global symbols
     * available in an interpolation scope in a template.
     * This function creates the table the first time it is called, and return a cached
     * value for all subsequent calls.
     */
    const createGlobalSymbolTable = (function () {
        let GLOBAL_SYMBOL_TABLE;
        return function (query) {
            if (GLOBAL_SYMBOL_TABLE) {
                return GLOBAL_SYMBOL_TABLE;
            }
            GLOBAL_SYMBOL_TABLE = query.createSymbolTable([
                // The `$any()` method casts the type of an expression to `any`.
                // https://angular.io/guide/template-syntax#the-any-type-cast-function
                {
                    name: '$any',
                    kind: 'method',
                    type: {
                        name: '$any',
                        kind: 'method',
                        type: undefined,
                        language: 'typescript',
                        container: undefined,
                        public: true,
                        callable: true,
                        definition: undefined,
                        nullable: false,
                        documentation: [{
                                kind: 'text',
                                text: 'function to cast an expression to the `any` type',
                            }],
                        members: () => EMPTY_SYMBOL_TABLE,
                        signatures: () => [],
                        selectSignature(args) {
                            if (args.length !== 1) {
                                return;
                            }
                            return {
                                arguments: EMPTY_SYMBOL_TABLE,
                                result: query.getBuiltinType(BuiltinType$1.Any),
                            };
                        },
                        indexed: () => undefined,
                        typeArguments: () => undefined,
                    },
                },
            ]);
            return GLOBAL_SYMBOL_TABLE;
        };
    })();

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    // In TypeScript 2.1 these flags moved
    // These helpers work for both 2.0 and 2.1.
    const isPrivate = ts.ModifierFlags ?
        ((node) => !!(ts.getCombinedModifierFlags(node) & ts.ModifierFlags.Private)) :
        ((node) => !!(node.flags & ts.NodeFlags.Private));
    const isReferenceType = ts.ObjectFlags ?
        ((type) => !!(type.flags & ts.TypeFlags.Object &&
            type.objectFlags & ts.ObjectFlags.Reference)) :
        ((type) => !!(type.flags & ts.TypeFlags.Reference));
    function getSymbolQuery(program, checker, source, fetchPipes) {
        return new TypeScriptSymbolQuery(program, checker, source, fetchPipes);
    }
    function getClassMembersFromDeclaration(program, checker, source, declaration) {
        const type = checker.getTypeAtLocation(declaration);
        return new TypeWrapper(type, { node: source, program, checker }).members();
    }
    function getPipesTable(source, program, checker, pipes) {
        return new PipesTable(pipes, { program, checker, node: source });
    }
    class TypeScriptSymbolQuery {
        constructor(program, checker, source, fetchPipes) {
            this.program = program;
            this.checker = checker;
            this.source = source;
            this.fetchPipes = fetchPipes;
            this.typeCache = new Map();
        }
        getTypeKind(symbol) {
            const type = symbol instanceof TypeWrapper ? symbol.tsType : undefined;
            return typeKindOf(type);
        }
        getBuiltinType(kind) {
            let result = this.typeCache.get(kind);
            if (!result) {
                const type = getTsTypeFromBuiltinType(kind, {
                    checker: this.checker,
                    node: this.source,
                    program: this.program,
                });
                result =
                    new TypeWrapper(type, { program: this.program, checker: this.checker, node: this.source });
                this.typeCache.set(kind, result);
            }
            return result;
        }
        getTypeUnion(...types) {
            // No API exists so return any if the types are not all the same type.
            let result = undefined;
            if (types.length) {
                result = types[0];
                for (let i = 1; i < types.length; i++) {
                    if (types[i] != result) {
                        result = undefined;
                        break;
                    }
                }
            }
            return result || this.getBuiltinType(BuiltinType$1.Any);
        }
        getArrayType(_type) {
            return this.getBuiltinType(BuiltinType$1.Any);
        }
        getElementType(type) {
            if (type instanceof TypeWrapper) {
                const ty = type.tsType;
                const tyArgs = type.typeArguments();
                // TODO(ayazhafiz): Track https://github.com/microsoft/TypeScript/issues/37711 to expose
                // `isArrayLikeType` as a public method.
                if (!this.checker.isArrayLikeType(ty) || (tyArgs === null || tyArgs === void 0 ? void 0 : tyArgs.length) !== 1)
                    return;
                return tyArgs[0];
            }
        }
        getNonNullableType(symbol) {
            if (symbol instanceof TypeWrapper && (typeof this.checker.getNonNullableType == 'function')) {
                const tsType = symbol.tsType;
                const nonNullableType = this.checker.getNonNullableType(tsType);
                if (nonNullableType != tsType) {
                    return new TypeWrapper(nonNullableType, symbol.context);
                }
                else if (nonNullableType == tsType) {
                    return symbol;
                }
            }
            return this.getBuiltinType(BuiltinType$1.Any);
        }
        getPipes() {
            let result = this.pipesCache;
            if (!result) {
                result = this.pipesCache = this.fetchPipes();
            }
            return result;
        }
        getTemplateContext(type) {
            const context = { node: this.source, program: this.program, checker: this.checker };
            const typeSymbol = findClassSymbolInContext(type, context);
            if (typeSymbol) {
                const contextType = this.getTemplateRefContextType(typeSymbol, context);
                if (contextType)
                    return contextType.members();
            }
        }
        getTypeSymbol(type) {
            const context = { node: this.source, program: this.program, checker: this.checker };
            const typeSymbol = findClassSymbolInContext(type, context);
            return typeSymbol && new SymbolWrapper(typeSymbol, context);
        }
        createSymbolTable(symbols) {
            const result = new MapSymbolTable();
            result.addAll(symbols.map(s => new DeclaredSymbol(s)));
            return result;
        }
        mergeSymbolTable(symbolTables) {
            const result = new MapSymbolTable();
            for (const symbolTable of symbolTables) {
                result.addAll(symbolTable.values());
            }
            return result;
        }
        getSpanAt(line, column) {
            return spanAt(this.source, line, column);
        }
        getTemplateRefContextType(typeSymbol, context) {
            const type = this.checker.getTypeOfSymbolAtLocation(typeSymbol, this.source);
            const constructor = type.symbol && type.symbol.members &&
                getFromSymbolTable(type.symbol.members, '__constructor');
            if (constructor) {
                const constructorDeclaration = constructor.declarations[0];
                for (const parameter of constructorDeclaration.parameters) {
                    const type = this.checker.getTypeAtLocation(parameter.type);
                    if (type.symbol.name == 'TemplateRef' && isReferenceType(type)) {
                        const typeWrapper = new TypeWrapper(type, context);
                        const typeArguments = typeWrapper.typeArguments();
                        if (typeArguments && typeArguments.length === 1) {
                            return typeArguments[0];
                        }
                    }
                }
            }
        }
    }
    function typeCallable(type) {
        const signatures = type.getCallSignatures();
        return signatures && signatures.length != 0;
    }
    function signaturesOf(type, context) {
        return type.getCallSignatures().map(s => new SignatureWrapper(s, context));
    }
    function selectSignature(type, context, types) {
        // TODO: Do a better job of selecting the right signature. TypeScript does not currently support a
        // Type Relationship API (see https://github.com/angular/vscode-ng-language-service/issues/143).
        // Consider creating a TypeCheckBlock host in the language service that may also act as a
        // scratchpad for type comparisons.
        const signatures = type.getCallSignatures();
        const passedInTypes = types.map(type => {
            if (type instanceof TypeWrapper) {
                return type.tsType;
            }
        });
        // Try to select a matching signature in which all parameter types match.
        // Note that this is just a best-effort approach, because we're checking for
        // strict type equality rather than compatibility.
        // For example, if the signature contains a ReadonlyArray<number> and the
        // passed parameter type is an Array<number>, this will fail.
        function allParameterTypesMatch(signature) {
            const tc = context.checker;
            return signature.getParameters().every((parameter, i) => {
                if (parameter.valueDeclaration === undefined) {
                    return false;
                }
                const type = tc.getTypeOfSymbolAtLocation(parameter, parameter.valueDeclaration);
                return type === passedInTypes[i];
            });
        }
        const exactMatch = signatures.find(allParameterTypesMatch);
        if (exactMatch) {
            return new SignatureWrapper(exactMatch, context);
        }
        // If not, fallback to a naive selection
        return signatures.length ? new SignatureWrapper(signatures[0], context) : undefined;
    }
    class TypeWrapper {
        constructor(tsType, context) {
            this.tsType = tsType;
            this.context = context;
            this.kind = 'type';
            this.language = 'typescript';
            this.type = undefined;
            this.container = undefined;
            this.public = true;
            if (!tsType) {
                throw Error('Internal: null type');
            }
        }
        get name() {
            return this.context.checker.typeToString(this.tsType);
        }
        get callable() {
            return typeCallable(this.tsType);
        }
        get nullable() {
            return this.context.checker.getNonNullableType(this.tsType) != this.tsType;
        }
        get documentation() {
            const symbol = this.tsType.getSymbol();
            if (!symbol) {
                return [];
            }
            return symbol.getDocumentationComment(this.context.checker);
        }
        get definition() {
            const symbol = this.tsType.getSymbol();
            return symbol ? definitionFromTsSymbol(symbol) : undefined;
        }
        members() {
            // Should call getApparentProperties() instead of getProperties() because
            // the former includes properties on the base class whereas the latter does
            // not. This provides properties like .bind(), .call(), .apply(), etc for
            // functions.
            return new SymbolTableWrapper(this.tsType.getApparentProperties(), this.context, this.tsType);
        }
        signatures() {
            return signaturesOf(this.tsType, this.context);
        }
        selectSignature(types) {
            return selectSignature(this.tsType, this.context, types);
        }
        indexed(type, value) {
            if (!(type instanceof TypeWrapper))
                return;
            const typeKind = typeKindOf(type.tsType);
            switch (typeKind) {
                case BuiltinType$1.Number:
                    const nType = this.tsType.getNumberIndexType();
                    if (nType) {
                        // get the right tuple type by value, like 'var t: [number, string];'
                        if (nType.isUnion()) {
                            // return undefined if array index out of bound.
                            return nType.types[value] && new TypeWrapper(nType.types[value], this.context);
                        }
                        return new TypeWrapper(nType, this.context);
                    }
                    return undefined;
                case BuiltinType$1.String:
                    const sType = this.tsType.getStringIndexType();
                    return sType && new TypeWrapper(sType, this.context);
            }
        }
        typeArguments() {
            if (!isReferenceType(this.tsType))
                return;
            const typeReference = this.tsType;
            let typeArguments;
            typeArguments = this.context.checker.getTypeArguments(typeReference);
            if (!typeArguments)
                return undefined;
            return typeArguments.map(ta => new TypeWrapper(ta, this.context));
        }
    }
    // If stringIndexType a primitive type(e.g. 'string'), the Symbol is undefined;
    // and in AstType.resolvePropertyRead method, the Symbol.type should get the right type.
    class StringIndexTypeWrapper extends TypeWrapper {
        constructor() {
            super(...arguments);
            this.type = new TypeWrapper(this.tsType, this.context);
        }
    }
    class SymbolWrapper {
        constructor(symbol, 
        /** TypeScript type context of the symbol. */
        context, 
        /**
         * Type of the TypeScript symbol, if known. If not provided, the type of the symbol
         * will be determined dynamically; see `SymbolWrapper#tsType`.
         */
        _tsType) {
            this.context = context;
            this._tsType = _tsType;
            this.nullable = false;
            this.language = 'typescript';
            this.symbol = symbol && context && (symbol.flags & ts.SymbolFlags.Alias) ?
                context.checker.getAliasedSymbol(symbol) :
                symbol;
        }
        get name() {
            return this.symbol.name;
        }
        get kind() {
            return this.callable ? 'method' : 'property';
        }
        get type() {
            return new TypeWrapper(this.tsType, this.context);
        }
        get container() {
            return getContainerOf(this.symbol, this.context);
        }
        get public() {
            // Symbols that are not explicitly made private are public.
            return !isSymbolPrivate(this.symbol);
        }
        get callable() {
            return typeCallable(this.tsType);
        }
        get definition() {
            return definitionFromTsSymbol(this.symbol);
        }
        get documentation() {
            return this.symbol.getDocumentationComment(this.context.checker);
        }
        members() {
            if (!this._members) {
                if ((this.symbol.flags & (ts.SymbolFlags.Class | ts.SymbolFlags.Interface)) != 0) {
                    const declaredType = this.context.checker.getDeclaredTypeOfSymbol(this.symbol);
                    const typeWrapper = new TypeWrapper(declaredType, this.context);
                    this._members = typeWrapper.members();
                }
                else {
                    this._members = new SymbolTableWrapper(this.symbol.members, this.context, this.tsType);
                }
            }
            return this._members;
        }
        signatures() {
            return signaturesOf(this.tsType, this.context);
        }
        selectSignature(types) {
            return selectSignature(this.tsType, this.context, types);
        }
        indexed(_argument) {
            return undefined;
        }
        typeArguments() {
            return this.type.typeArguments();
        }
        get tsType() {
            let type = this._tsType;
            if (!type) {
                type = this._tsType =
                    this.context.checker.getTypeOfSymbolAtLocation(this.symbol, this.context.node);
            }
            return type;
        }
    }
    class DeclaredSymbol {
        constructor(declaration) {
            this.declaration = declaration;
            this.language = 'ng-template';
            this.nullable = false;
            this.public = true;
        }
        get name() {
            return this.declaration.name;
        }
        get kind() {
            return this.declaration.kind;
        }
        get container() {
            return undefined;
        }
        get type() {
            return this.declaration.type;
        }
        get callable() {
            return this.type.callable;
        }
        get definition() {
            return this.declaration.definition;
        }
        get documentation() {
            return this.declaration.type.documentation;
        }
        members() {
            return this.type.members();
        }
        signatures() {
            return this.type.signatures();
        }
        selectSignature(types) {
            return this.type.selectSignature(types);
        }
        typeArguments() {
            return this.type.typeArguments();
        }
        indexed(_argument) {
            return undefined;
        }
    }
    class SignatureWrapper {
        constructor(signature, context) {
            this.signature = signature;
            this.context = context;
        }
        get arguments() {
            return new SymbolTableWrapper(this.signature.getParameters(), this.context);
        }
        get result() {
            return new TypeWrapper(this.signature.getReturnType(), this.context);
        }
    }
    class SignatureResultOverride {
        constructor(signature, resultType) {
            this.signature = signature;
            this.resultType = resultType;
        }
        get arguments() {
            return this.signature.arguments;
        }
        get result() {
            return this.resultType;
        }
    }
    function toSymbolTableFactory(symbols) {
        // â Typescript version >= 2.2, `SymbolTable` is implemented as an ES6 `Map`
        const result = new Map();
        for (const symbol of symbols) {
            result.set(symbol.name, symbol);
        }
        return result;
    }
    function toSymbols(symbolTable) {
        if (!symbolTable)
            return [];
        const table = symbolTable;
        if (typeof table.values === 'function') {
            return Array.from(table.values());
        }
        const result = [];
        const own = typeof table.hasOwnProperty === 'function' ?
            (name) => table.hasOwnProperty(name) :
            (name) => !!table[name];
        for (const name in table) {
            if (own(name)) {
                result.push(table[name]);
            }
        }
        return result;
    }
    class SymbolTableWrapper {
        /**
         * Creates a queryable table of symbols belonging to a TypeScript entity.
         * @param symbols symbols to query belonging to the entity
         * @param context program context
         * @param type original TypeScript type of entity owning the symbols, if known
         */
        constructor(symbols, context, type) {
            this.context = context;
            symbols = symbols || [];
            if (Array.isArray(symbols)) {
                this.symbols = symbols;
                this.symbolTable = toSymbolTableFactory(symbols);
            }
            else {
                this.symbols = toSymbols(symbols);
                this.symbolTable = symbols;
            }
            if (type) {
                this.stringIndexType = type.getStringIndexType();
            }
        }
        get size() {
            return this.symbols.length;
        }
        get(key) {
            const symbol = getFromSymbolTable(this.symbolTable, key);
            if (symbol) {
                return new SymbolWrapper(symbol, this.context);
            }
            if (this.stringIndexType) {
                // If the key does not exist as an explicit symbol on the type, it may be accessing a string
                // index signature using dot notation:
                //
                //   const obj<T>: { [key: string]: T };
                //   obj.stringIndex // equivalent to obj['stringIndex'];
                //
                // In this case, return the type indexed by an arbitrary string key.
                return new StringIndexTypeWrapper(this.stringIndexType, this.context);
            }
            return undefined;
        }
        has(key) {
            const table = this.symbolTable;
            return ((typeof table.has === 'function') ? table.has(key) : table[key] != null) ||
                this.stringIndexType !== undefined;
        }
        values() {
            return this.symbols.map(s => new SymbolWrapper(s, this.context));
        }
    }
    class MapSymbolTable {
        constructor() {
            this.map = new Map();
            this._values = [];
        }
        get size() {
            return this.map.size;
        }
        get(key) {
            return this.map.get(key);
        }
        add(symbol) {
            if (this.map.has(symbol.name)) {
                const previous = this.map.get(symbol.name);
                this._values[this._values.indexOf(previous)] = symbol;
            }
            this.map.set(symbol.name, symbol);
            this._values.push(symbol);
        }
        addAll(symbols) {
            for (const symbol of symbols) {
                this.add(symbol);
            }
        }
        has(key) {
            return this.map.has(key);
        }
        values() {
            // Switch to this.map.values once iterables are supported by the target language.
            return this._values;
        }
    }
    class PipesTable {
        constructor(pipes, context) {
            this.pipes = pipes;
            this.context = context;
        }
        get size() {
            return this.pipes.length;
        }
        get(key) {
            const pipe = this.pipes.find(pipe => pipe.name == key);
            if (pipe) {
                return new PipeSymbol(pipe, this.context);
            }
        }
        has(key) {
            return this.pipes.find(pipe => pipe.name == key) != null;
        }
        values() {
            return this.pipes.map(pipe => new PipeSymbol(pipe, this.context));
        }
    }
    // This matches .d.ts files that look like ".../<package-name>/<package-name>.d.ts",
    const INDEX_PATTERN = /[\\/]([^\\/]+)[\\/]\1\.d\.ts$/;
    class PipeSymbol {
        constructor(pipe, context) {
            this.pipe = pipe;
            this.context = context;
            this.kind = 'pipe';
            this.language = 'typescript';
            this.container = undefined;
            this.callable = true;
            this.nullable = false;
            this.public = true;
        }
        get name() {
            return this.pipe.name;
        }
        get type() {
            return new TypeWrapper(this.tsType, this.context);
        }
        get definition() {
            const symbol = this.tsType.getSymbol();
            return symbol ? definitionFromTsSymbol(symbol) : undefined;
        }
        get documentation() {
            const symbol = this.tsType.getSymbol();
            if (!symbol) {
                return [];
            }
            return symbol.getDocumentationComment(this.context.checker);
        }
        members() {
            return EmptyTable.instance;
        }
        signatures() {
            return signaturesOf(this.tsType, this.context);
        }
        selectSignature(types) {
            let signature = selectSignature(this.tsType, this.context, types);
            if (types.length > 0) {
                const parameterType = types[0];
                let resultType = undefined;
                switch (this.name) {
                    case 'async':
                        // Get type argument of 'Observable', 'Promise', or 'EventEmitter'.
                        const tArgs = parameterType.typeArguments();
                        if (tArgs && tArgs.length === 1) {
                            resultType = tArgs[0];
                        }
                        break;
                    case 'slice':
                        resultType = parameterType;
                        break;
                }
                if (resultType) {
                    signature = new SignatureResultOverride(signature, resultType);
                }
            }
            return signature;
        }
        indexed(_argument) {
            return undefined;
        }
        typeArguments() {
            return this.type.typeArguments();
        }
        get tsType() {
            let type = this._tsType;
            if (!type) {
                const classSymbol = this.findClassSymbol(this.pipe.type.reference);
                if (classSymbol) {
                    type = this._tsType = this.findTransformMethodType(classSymbol);
                }
                if (!type) {
                    type = this._tsType = getTsTypeFromBuiltinType(BuiltinType$1.Any, this.context);
                }
            }
            return type;
        }
        findClassSymbol(type) {
            return findClassSymbolInContext(type, this.context);
        }
        findTransformMethodType(classSymbol) {
            const classType = this.context.checker.getDeclaredTypeOfSymbol(classSymbol);
            if (classType) {
                const transform = classType.getProperty('transform');
                if (transform) {
                    return this.context.checker.getTypeOfSymbolAtLocation(transform, this.context.node);
                }
            }
        }
    }
    function findClassSymbolInContext(type, context) {
        let sourceFile = context.program.getSourceFile(type.filePath);
        if (!sourceFile) {
            // This handles a case where an <packageName>/index.d.ts and a <packageName>/<packageName>.d.ts
            // are in the same directory. If we are looking for <packageName>/<packageName> and didn't
            // find it, look for <packageName>/index.d.ts as the program might have found that instead.
            const p = type.filePath;
            const m = p.match(INDEX_PATTERN);
            if (m) {
                const indexVersion = path.join(path.dirname(p), 'index.d.ts');
                sourceFile = context.program.getSourceFile(indexVersion);
            }
        }
        if (sourceFile) {
            const moduleSymbol = sourceFile.module || sourceFile.symbol;
            const exports = context.checker.getExportsOfModule(moduleSymbol);
            return (exports || []).find(symbol => symbol.name == type.name);
        }
    }
    class EmptyTable {
        constructor() {
            this.size = 0;
        }
        get(_key) {
            return undefined;
        }
        has(_key) {
            return false;
        }
        values() {
            return [];
        }
    }
    EmptyTable.instance = new EmptyTable();
    function isSymbolPrivate(s) {
        return !!s.valueDeclaration && isPrivate(s.valueDeclaration);
    }
    function getTsTypeFromBuiltinType(builtinType, ctx) {
        let syntaxKind;
        switch (builtinType) {
            case BuiltinType$1.Any:
                syntaxKind = ts.SyntaxKind.AnyKeyword;
                break;
            case BuiltinType$1.Boolean:
                syntaxKind = ts.SyntaxKind.BooleanKeyword;
                break;
            case BuiltinType$1.Null:
                syntaxKind = ts.SyntaxKind.NullKeyword;
                break;
            case BuiltinType$1.Number:
                syntaxKind = ts.SyntaxKind.NumberKeyword;
                break;
            case BuiltinType$1.String:
                syntaxKind = ts.SyntaxKind.StringKeyword;
                break;
            case BuiltinType$1.Undefined:
                syntaxKind = ts.SyntaxKind.UndefinedKeyword;
                break;
            default:
                throw new Error(`Internal error, unhandled literal kind ${builtinType}:${BuiltinType$1[builtinType]}`);
        }
        const node = ts.createNode(syntaxKind);
        node.parent = ts.createEmptyStatement();
        return ctx.checker.getTypeAtLocation(node);
    }
    function spanAt(sourceFile, line, column) {
        if (line != null && column != null) {
            const position = ts.getPositionOfLineAndCharacter(sourceFile, line, column);
            const findChild = function findChild(node) {
                if (node.kind > ts.SyntaxKind.LastToken && node.pos <= position && node.end > position) {
                    const betterNode = ts.forEachChild(node, findChild);
                    return betterNode || node;
                }
            };
            const node = ts.forEachChild(sourceFile, findChild);
            if (node) {
                return { start: node.getStart(), end: node.getEnd() };
            }
        }
    }
    function definitionFromTsSymbol(symbol) {
        const declarations = symbol.declarations;
        if (declarations) {
            return declarations.map(declaration => {
                const sourceFile = declaration.getSourceFile();
                return {
                    fileName: sourceFile.fileName,
                    span: { start: declaration.getStart(), end: declaration.getEnd() }
                };
            });
        }
    }
    function parentDeclarationOf(node) {
        while (node) {
            switch (node.kind) {
                case ts.SyntaxKind.ClassDeclaration:
                case ts.SyntaxKind.InterfaceDeclaration:
                    return node;
                case ts.SyntaxKind.SourceFile:
                    return undefined;
            }
            node = node.parent;
        }
    }
    function getContainerOf(symbol, context) {
        if (symbol.getFlags() & ts.SymbolFlags.ClassMember && symbol.declarations) {
            for (const declaration of symbol.declarations) {
                const parent = parentDeclarationOf(declaration);
                if (parent) {
                    const type = context.checker.getTypeAtLocation(parent);
                    if (type) {
                        return new TypeWrapper(type, context);
                    }
                }
            }
        }
    }
    function typeKindOf(type) {
        if (type) {
            if (type.flags & ts.TypeFlags.Any) {
                return BuiltinType$1.Any;
            }
            else if (type.flags & (ts.TypeFlags.String | ts.TypeFlags.StringLike | ts.TypeFlags.StringLiteral)) {
                return BuiltinType$1.String;
            }
            else if (type.flags & (ts.TypeFlags.Number | ts.TypeFlags.NumberLike)) {
                return BuiltinType$1.Number;
            }
            else if (type.flags & ts.TypeFlags.Object) {
                return BuiltinType$1.Object;
            }
            else if (type.flags & (ts.TypeFlags.Undefined)) {
                return BuiltinType$1.Undefined;
            }
            else if (type.flags & (ts.TypeFlags.Null)) {
                return BuiltinType$1.Null;
            }
            else if (type.flags & ts.TypeFlags.Union) {
                const unionType = type;
                if (unionType.types.length === 0)
                    return BuiltinType$1.Other;
                let ty = 0;
                for (const subType of unionType.types) {
                    ty |= typeKindOf(subType);
                }
                return ty;
            }
            else if (type.flags & ts.TypeFlags.TypeParameter) {
                return BuiltinType$1.Unbound;
            }
        }
        return BuiltinType$1.Other;
    }
    function getFromSymbolTable(symbolTable, key) {
        const table = symbolTable;
        let symbol;
        if (typeof table.get === 'function') {
            // TS 2.2 uses a Map
            symbol = table.get(key);
        }
        else {
            // TS pre-2.2 uses an object
            symbol = table[key];
        }
        return symbol;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A base class to represent a template and which component class it is
     * associated with. A template source could answer basic questions about
     * top-level declarations of its class through the members() and query()
     * methods.
     */
    class BaseTemplate {
        constructor(host, classDeclNode, classSymbol) {
            this.host = host;
            this.classDeclNode = classDeclNode;
            this.classSymbol = classSymbol;
            this.program = host.program;
        }
        /**
         * Return the Angular StaticSymbol for the class that contains this template.
         */
        get type() {
            return this.classSymbol;
        }
        /**
         * Return a Map-like data structure that allows users to retrieve some or all
         * top-level declarations in the associated component class.
         */
        get members() {
            if (!this.membersTable) {
                const typeChecker = this.program.getTypeChecker();
                const sourceFile = this.classDeclNode.getSourceFile();
                this.membersTable = this.query.mergeSymbolTable([
                    createGlobalSymbolTable(this.query),
                    getClassMembersFromDeclaration(this.program, typeChecker, sourceFile, this.classDeclNode),
                ]);
            }
            return this.membersTable;
        }
        /**
         * Return an engine that provides more information about symbols in the
         * template.
         */
        get query() {
            if (!this.queryCache) {
                const program = this.program;
                const typeChecker = program.getTypeChecker();
                const sourceFile = this.classDeclNode.getSourceFile();
                this.queryCache = getSymbolQuery(program, typeChecker, sourceFile, () => {
                    // Computing the ast is relatively expensive. Do it only when absolutely
                    // necessary.
                    // TODO: There is circular dependency here between TemplateSource and
                    // TypeScriptHost. Consider refactoring the code to break this cycle.
                    const ast = this.host.getTemplateAst(this);
                    const pipes = (ast && ast.pipes) || [];
                    return getPipesTable(sourceFile, program, typeChecker, pipes);
                });
            }
            return this.queryCache;
        }
    }
    /**
     * An InlineTemplate represents template defined in a TS file through the
     * `template` attribute in the decorator.
     */
    class InlineTemplate extends BaseTemplate {
        constructor(templateNode, classDeclNode, classSymbol, host) {
            super(host, classDeclNode, classSymbol);
            const sourceFile = templateNode.getSourceFile();
            if (sourceFile !== classDeclNode.getSourceFile()) {
                throw new Error(`Inline template and component class should belong to the same source file`);
            }
            this.fileName = sourceFile.fileName;
            // node.text returns the TS internal representation of the normalized text,
            // and all CR characters are stripped. node.getText() returns the raw text.
            this.source = templateNode.getText().slice(1, -1); // strip leading and trailing quotes
            this.span = {
                // TS string literal includes surrounding quotes in the start/end offsets.
                start: templateNode.getStart() + 1,
                end: templateNode.getEnd() - 1,
            };
        }
    }
    /**
     * An ExternalTemplate represents template defined in an external (most likely
     * HTML, but not necessarily) file through the `templateUrl` attribute in the
     * decorator.
     * Note that there is no ts.Node associated with the template because it's not
     * a TS file.
     */
    class ExternalTemplate extends BaseTemplate {
        constructor(source, fileName, classDeclNode, classSymbol, host) {
            super(host, classDeclNode, classSymbol);
            this.source = source;
            this.fileName = fileName;
            this.span = {
                start: 0,
                end: source.length,
            };
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const HIDDEN_HTML_ELEMENTS = new Set(['html', 'script', 'noscript', 'base', 'body', 'title', 'head', 'link']);
    const HTML_ELEMENTS = elementNames().filter(name => !HIDDEN_HTML_ELEMENTS.has(name)).map(name => {
        return {
            name,
            kind: CompletionKind.HTML_ELEMENT,
            sortText: name,
        };
    });
    const ANGULAR_ELEMENTS = [
        {
            name: 'ng-container',
            kind: CompletionKind.ANGULAR_ELEMENT,
            sortText: 'ng-container',
        },
        {
            name: 'ng-content',
            kind: CompletionKind.ANGULAR_ELEMENT,
            sortText: 'ng-content',
        },
        {
            name: 'ng-template',
            kind: CompletionKind.ANGULAR_ELEMENT,
            sortText: 'ng-template',
        },
    ];
    function isIdentifierPart$1(code) {
        // Identifiers consist of alphanumeric characters, '_', or '$'.
        return isAsciiLetter(code) || isDigit(code) || code == $$ || code == $_;
    }
    /**
     * Gets the span of word in a template that surrounds `position`. If there is no word around
     * `position`, nothing is returned.
     */
    function getBoundedWordSpan(templateInfo, position, ast) {
        const { template } = templateInfo;
        const templateSrc = template.source;
        if (!templateSrc)
            return;
        if (ast instanceof Element$1) {
            // The HTML tag may include `-` (e.g. `app-root`),
            // so use the HtmlAst to get the span before ayazhafiz refactor the code.
            return {
                start: templateInfo.template.span.start + ast.startSourceSpan.start.offset + 1,
                length: ast.name.length
            };
        }
        // TODO(ayazhafiz): A solution based on word expansion will always be expensive compared to one
        // based on ASTs. Whatever penalty we incur is probably manageable for small-length (i.e. the
        // majority of) identifiers, but the current solution involes a number of branchings and we can't
        // control potentially very long identifiers. Consider moving to an AST-based solution once
        // existing difficulties with AST spans are more clearly resolved (see #31898 for discussion of
        // known problems, and #33091 for how they affect text replacement).
        //
        // `templatePosition` represents the right-bound location of a cursor in the template.
        //    key.ent|ry
        //           ^---- cursor, at position `r` is at.
        // A cursor is not itself a character in the template; it has a left (lower) and right (upper)
        // index bound that hugs the cursor itself.
        let templatePosition = position - template.span.start;
        // To perform word expansion, we want to determine the left and right indices that hug the cursor.
        // There are three cases here.
        let left, right;
        if (templatePosition === 0) {
            // 1. Case like
            //      |rest of template
            //    the cursor is at the start of the template, hugged only by the right side (0-index).
            left = right = 0;
        }
        else if (templatePosition === templateSrc.length) {
            // 2. Case like
            //      rest of template|
            //    the cursor is at the end of the template, hugged only by the left side (last-index).
            left = right = templateSrc.length - 1;
        }
        else {
            // 3. Case like
            //      wo|rd
            //    there is a clear left and right index.
            left = templatePosition - 1;
            right = templatePosition;
        }
        if (!isIdentifierPart$1(templateSrc.charCodeAt(left)) &&
            !isIdentifierPart$1(templateSrc.charCodeAt(right))) {
            // Case like
            //         .|.
            // left ---^ ^--- right
            // There is no word here.
            return;
        }
        // Expand on the left and right side until a word boundary is hit. Back up one expansion on both
        // side to stay inside the word.
        while (left >= 0 && isIdentifierPart$1(templateSrc.charCodeAt(left)))
            --left;
        ++left;
        while (right < templateSrc.length && isIdentifierPart$1(templateSrc.charCodeAt(right)))
            ++right;
        --right;
        const absoluteStartPosition = position - (templatePosition - left);
        const length = right - left + 1;
        return { start: absoluteStartPosition, length };
    }
    function getTemplateCompletions(templateInfo, position) {
        const { htmlAst, template } = templateInfo;
        // Calculate the position relative to the start of the template. This is needed
        // because spans in HTML AST are relative. Inline template has non-zero start position.
        const templatePosition = position - template.span.start;
        const htmlPath = getPathToNodeAtPosition(htmlAst, templatePosition);
        const mostSpecific = htmlPath.tail;
        const visitor = new HtmlVisitor(templateInfo, htmlPath);
        const results = mostSpecific ?
            mostSpecific.visit(visitor, null /* context */) :
            elementCompletions(templateInfo);
        const replacementSpan = getBoundedWordSpan(templateInfo, position, mostSpecific);
        return results.map(entry => {
            return Object.assign(Object.assign({}, entry), { replacementSpan });
        });
    }
    class HtmlVisitor {
        constructor(templateInfo, htmlPath) {
            this.templateInfo = templateInfo;
            this.htmlPath = htmlPath;
            this.relativePosition = htmlPath.position;
        }
        // Note that every visitor method must explicitly specify return type because
        // Visitor returns `any` for all methods.
        visitElement(ast) {
            const startTagSpan = spanOf(ast.sourceSpan);
            const tagLen = ast.name.length;
            // + 1 for the opening angle bracket
            if (this.relativePosition <= startTagSpan.start + tagLen + 1) {
                // If we are in the tag then return the element completions.
                return elementCompletions(this.templateInfo);
            }
            if (this.relativePosition < startTagSpan.end) {
                // We are in the attribute section of the element (but not in an attribute).
                // Return the attribute completions.
                return attributeCompletionsForElement(this.templateInfo, ast.name);
            }
            return [];
        }
        visitAttribute(ast) {
            // An attribute consists of two parts, LHS="RHS".
            // Determine if completions are requested for LHS or RHS
            if (ast.valueSpan && inSpan(this.relativePosition, spanOf(ast.valueSpan))) {
                // RHS completion
                return attributeValueCompletions(this.templateInfo, this.htmlPath);
            }
            // LHS completion
            return attributeCompletions(this.templateInfo, this.htmlPath);
        }
        visitText() {
            var _a;
            const templatePath = findTemplateAstAt(this.templateInfo.templateAst, this.relativePosition);
            if (templatePath.tail instanceof BoundTextAst) {
                // If we know that this is an interpolation then do not try other scenarios.
                const visitor = new ExpressionVisitor(this.templateInfo, this.relativePosition, () => getExpressionScope(diagnosticInfoFromTemplateInfo(this.templateInfo), templatePath));
                (_a = templatePath.tail) === null || _a === void 0 ? void 0 : _a.visit(visitor, null);
                return visitor.results;
            }
            // TODO(kyliau): Not sure if this check is really needed since we don't have
            // any test cases for it.
            const element = this.htmlPath.first(Element$1);
            if (element &&
                getHtmlTagDefinition(element.name).getContentType() !== TagContentType.PARSABLE_DATA) {
                return [];
            }
            // This is to account for cases like <h1> <a> text | </h1> where the
            // closest element has no closing tag and thus is considered plain text.
            const results = voidElementAttributeCompletions(this.templateInfo, this.htmlPath);
            if (results.length) {
                return results;
            }
            return elementCompletions(this.templateInfo);
        }
        visitComment() {
            return [];
        }
        visitExpansion() {
            return [];
        }
        visitExpansionCase() {
            return [];
        }
    }
    function attributeCompletions(info, path) {
        const attr = path.tail;
        const elem = path.parentOf(attr);
        if (!(attr instanceof Attribute) || !(elem instanceof Element$1)) {
            return [];
        }
        // TODO: Consider parsing the attrinute name to a proper AST instead of
        // matching using regex. This is because the regexp would incorrectly identify
        // bind parts for cases like [()|]
        //                              ^ cursor is here
        const binding = getBindingDescriptor(attr.name);
        if (!binding) {
            // This is a normal HTML attribute, not an Angular attribute.
            return attributeCompletionsForElement(info, elem.name);
        }
        const results = [];
        const ngAttrs = angularAttributes(info, elem.name);
        switch (binding.kind) {
            case ATTR.KW_MICROSYNTAX:
                // template reference attribute: *attrName
                results.push(...ngAttrs.templateRefs);
                break;
            case ATTR.KW_BIND:
            case ATTR.IDENT_PROPERTY:
                // property binding via bind- or []
                results.push(...propertyNames(elem.name), ...ngAttrs.inputs);
                break;
            case ATTR.KW_ON:
            case ATTR.IDENT_EVENT:
                // event binding via on- or ()
                results.push(...eventNames(elem.name), ...ngAttrs.outputs);
                break;
            case ATTR.KW_BINDON:
            case ATTR.IDENT_BANANA_BOX:
                // banana-in-a-box binding via bindon- or [()]
                results.push(...ngAttrs.bananas);
                break;
        }
        return results.map(name => {
            return {
                name,
                kind: CompletionKind.ATTRIBUTE,
                sortText: name,
            };
        });
    }
    function attributeCompletionsForElement(info, elementName) {
        const results = [];
        if (info.template instanceof InlineTemplate) {
            // Provide HTML attributes completion only for inline templates
            for (const name of attributeNames(elementName)) {
                results.push({
                    name,
                    kind: CompletionKind.HTML_ATTRIBUTE,
                    sortText: name,
                });
            }
        }
        // Add Angular attributes
        const ngAttrs = angularAttributes(info, elementName);
        for (const name of ngAttrs.others) {
            results.push({
                name,
                kind: CompletionKind.ATTRIBUTE,
                sortText: name,
            });
        }
        return results;
    }
    /**
     * Provide completions to the RHS of an attribute, which is of the form
     * LHS="RHS". The template path is computed from the specified `info` whereas
     * the context is determined from the specified `htmlPath`.
     * @param info Object that contains the template AST
     * @param htmlPath Path to the HTML node
     */
    function attributeValueCompletions(info, htmlPath) {
        // Find the corresponding Template AST path.
        const templatePath = findTemplateAstAt(info.templateAst, htmlPath.position);
        const visitor = new ExpressionVisitor(info, htmlPath.position, () => {
            const dinfo = diagnosticInfoFromTemplateInfo(info);
            return getExpressionScope(dinfo, templatePath);
        });
        if (templatePath.tail instanceof AttrAst ||
            templatePath.tail instanceof BoundElementPropertyAst ||
            templatePath.tail instanceof BoundEventAst) {
            templatePath.tail.visit(visitor, null);
            return visitor.results;
        }
        // In order to provide accurate attribute value completion, we need to know
        // what the LHS is, and construct the proper AST if it is missing.
        const htmlAttr = htmlPath.tail;
        const binding = getBindingDescriptor(htmlAttr.name);
        if (binding && binding.kind === ATTR.KW_REF) {
            let refAst;
            let elemAst;
            if (templatePath.tail instanceof ReferenceAst) {
                refAst = templatePath.tail;
                const parent = templatePath.parentOf(refAst);
                if (parent instanceof ElementAst) {
                    elemAst = parent;
                }
            }
            else if (templatePath.tail instanceof ElementAst) {
                refAst = new ReferenceAst(htmlAttr.name, null, htmlAttr.value, htmlAttr.valueSpan);
                elemAst = templatePath.tail;
            }
            if (refAst && elemAst) {
                refAst.visit(visitor, elemAst);
            }
        }
        else {
            // HtmlAst contains the `Attribute` node, however the corresponding `AttrAst`
            // node is missing from the TemplateAst.
            const attrAst = new AttrAst(htmlAttr.name, htmlAttr.value, htmlAttr.valueSpan);
            attrAst.visit(visitor, null);
        }
        return visitor.results;
    }
    function elementCompletions(info) {
        const results = [...ANGULAR_ELEMENTS];
        if (info.template instanceof InlineTemplate) {
            // Provide HTML elements completion only for inline templates
            results.push(...HTML_ELEMENTS);
        }
        // Collect the elements referenced by the selectors
        const components = new Set();
        for (const selector of getSelectors(info).selectors) {
            const name = selector.element;
            if (name && !components.has(name)) {
                components.add(name);
                results.push({
                    name,
                    kind: CompletionKind.COMPONENT,
                    sortText: name,
                });
            }
        }
        return results;
    }
    // There is a special case of HTML where text that contains a unclosed tag is treated as
    // text. For exaple '<h1> Some <a text </h1>' produces a text nodes inside of the H1
    // element "Some <a text". We, however, want to treat this as if the user was requesting
    // the attributes of an "a" element, not requesting completion in the a text element. This
    // code checks for this case and returns element completions if it is detected or undefined
    // if it is not.
    function voidElementAttributeCompletions(info, path) {
        const tail = path.tail;
        if (tail instanceof Text$2) {
            const match = tail.value.match(/<(\w(\w|\d|-)*:)?(\w(\w|\d|-)*)\s/);
            // The position must be after the match, otherwise we are still in a place where elements
            // are expected (such as `<|a` or `<a|`; we only want attributes for `<a |` or after).
            if (match &&
                path.position >= (match.index || 0) + match[0].length + tail.sourceSpan.start.offset) {
                return attributeCompletionsForElement(info, match[3]);
            }
        }
        return [];
    }
    class ExpressionVisitor extends NullTemplateVisitor {
        constructor(info, position, getExpressionScope) {
            super();
            this.info = info;
            this.position = position;
            this.getExpressionScope = getExpressionScope;
            this.completions = new Map();
        }
        get results() {
            return Array.from(this.completions.values());
        }
        visitDirectiveProperty(ast) {
            this.processExpressionCompletions(ast.value);
        }
        visitElementProperty(ast) {
            this.processExpressionCompletions(ast.value);
        }
        visitEvent(ast) {
            this.processExpressionCompletions(ast.handler);
        }
        visitElement() {
            // no-op for now
        }
        visitAttr(ast) {
            const binding = getBindingDescriptor(ast.name);
            if (binding && binding.kind === ATTR.KW_MICROSYNTAX) {
                // This a template binding given by micro syntax expression.
                // First, verify the attribute consists of some binding we can give completions for.
                // The sourceSpan of AttrAst points to the RHS of the attribute
                const templateKey = binding.name;
                const templateValue = ast.sourceSpan.toString();
                const templateUrl = ast.sourceSpan.start.file.url;
                // TODO(kyliau): We are unable to determine the absolute offset of the key
                // but it is okay here, because we are only looking at the RHS of the attr
                const absKeyOffset = 0;
                const absValueOffset = ast.sourceSpan.start.offset;
                const { templateBindings } = this.info.expressionParser.parseTemplateBindings(templateKey, templateValue, templateUrl, absKeyOffset, absValueOffset);
                // Find the nearest template binding to the position.
                const lastBindingEnd = templateBindings.length > 0 &&
                    templateBindings[templateBindings.length - 1].sourceSpan.end;
                const normalizedPositionToBinding = lastBindingEnd && this.position > lastBindingEnd ? lastBindingEnd : this.position;
                const templateBinding = templateBindings.find(b => inSpan(normalizedPositionToBinding, b.sourceSpan));
                if (!templateBinding) {
                    return;
                }
                this.microSyntaxInAttributeValue(ast, templateBinding);
            }
            else {
                const expressionAst = this.info.expressionParser.parseBinding(ast.value, ast.sourceSpan.toString(), ast.sourceSpan.start.offset);
                this.processExpressionCompletions(expressionAst);
            }
        }
        visitReference(_ast, context) {
            context.directives.forEach(dir => {
                const { exportAs } = dir.directive;
                if (exportAs) {
                    this.completions.set(exportAs, { name: exportAs, kind: CompletionKind.REFERENCE, sortText: exportAs });
                }
            });
        }
        visitBoundText(ast) {
            if (inSpan(this.position, ast.value.sourceSpan)) {
                const completions = getExpressionCompletions(this.getExpressionScope(), ast.value, this.position, this.info.template);
                if (completions) {
                    this.addSymbolsToCompletions(completions);
                }
            }
        }
        processExpressionCompletions(value) {
            const symbols = getExpressionCompletions(this.getExpressionScope(), value, this.position, this.info.template);
            if (symbols) {
                this.addSymbolsToCompletions(symbols);
            }
        }
        addSymbolsToCompletions(symbols) {
            for (const s of symbols) {
                if (s.name.startsWith('__') || !s.public || this.completions.has(s.name)) {
                    continue;
                }
                // The pipe method should not include parentheses.
                // e.g. {{ value_expression | slice : start [ : end ] }}
                const shouldInsertParentheses = s.callable && s.kind !== CompletionKind.PIPE;
                this.completions.set(s.name, {
                    name: s.name,
                    kind: s.kind,
                    sortText: s.name,
                    insertText: shouldInsertParentheses ? `${s.name}()` : s.name,
                });
            }
        }
        /**
         * This method handles the completions of attribute values for directives that
         * support the microsyntax format. Examples are *ngFor and *ngIf.
         * These directives allows declaration of "let" variables, adds context-specific
         * symbols like $implicit, index, count, among other behaviors.
         * For a complete description of such format, see
         * https://angular.io/guide/structural-directives#asterisk
         *
         * @param attr descriptor for attribute name and value pair
         * @param binding template binding for the expression in the attribute
         */
        microSyntaxInAttributeValue(attr, binding) {
            var _a;
            const key = attr.name.substring(1); // remove leading asterisk
            // Find the selector - eg ngFor, ngIf, etc
            const selectorInfo = getSelectors(this.info);
            const selector = selectorInfo.selectors.find(s => {
                // attributes are listed in (attribute, value) pairs
                for (let i = 0; i < s.attrs.length; i += 2) {
                    if (s.attrs[i] === key) {
                        return true;
                    }
                }
            });
            if (!selector) {
                return;
            }
            const valueRelativePosition = this.position - attr.sourceSpan.start.offset;
            if (binding instanceof VariableBinding) {
                // TODO(kyliau): With expression sourceSpan we shouldn't have to search
                // the attribute value string anymore. Just check if position is in the
                // expression source span.
                const equalLocation = attr.value.indexOf('=');
                if (equalLocation > 0 && valueRelativePosition > equalLocation) {
                    // We are after the '=' in a let clause. The valid values here are the members of the
                    // template reference's type parameter.
                    const directiveMetadata = selectorInfo.map.get(selector);
                    if (directiveMetadata) {
                        const contextTable = this.info.template.query.getTemplateContext(directiveMetadata.type.reference);
                        if (contextTable) {
                            // This adds symbols like $implicit, index, count, etc.
                            this.addSymbolsToCompletions(contextTable.values());
                            return;
                        }
                    }
                }
            }
            else if (binding instanceof ExpressionBinding) {
                if (inSpan(this.position, (_a = binding.value) === null || _a === void 0 ? void 0 : _a.ast.sourceSpan)) {
                    this.processExpressionCompletions(binding.value.ast);
                    return;
                }
                else if (!binding.value && this.position > binding.key.span.end) {
                    // No expression is defined for the value of the key expression binding, but the cursor is
                    // in a location where the expression would be defined. This can happen in a case like
                    //   let i of |
                    //            ^-- cursor
                    // In this case, backfill the value to be an empty expression and retrieve completions.
                    this.processExpressionCompletions(new EmptyExpr(new ParseSpan(valueRelativePosition, valueRelativePosition), new AbsoluteSourceSpan(this.position, this.position)));
                    return;
                }
            }
        }
    }
    /**
     * Return all Angular-specific attributes for the element with `elementName`.
     * @param info
     * @param elementName
     */
    function angularAttributes(info, elementName) {
        const { selectors, map: selectorMap } = getSelectors(info);
        const templateRefs = new Set();
        const inputs = new Set();
        const outputs = new Set();
        const bananas = new Set();
        const others = new Set();
        for (const selector of selectors) {
            if (selector.element && selector.element !== elementName) {
                continue;
            }
            const summary = selectorMap.get(selector);
            const hasTemplateRef = isStructuralDirective(summary.type);
            // attributes are listed in (attribute, value) pairs
            for (let i = 0; i < selector.attrs.length; i += 2) {
                const attr = selector.attrs[i];
                if (hasTemplateRef) {
                    templateRefs.add(attr);
                }
                else {
                    others.add(attr);
                }
            }
            for (const input of Object.values(summary.inputs)) {
                inputs.add(input);
            }
            for (const output of Object.values(summary.outputs)) {
                outputs.add(output);
            }
        }
        for (const name of inputs) {
            // Add banana-in-a-box syntax
            // https://angular.io/guide/template-syntax#two-way-binding-
            if (outputs.has(`${name}Change`)) {
                bananas.add(name);
            }
        }
        return { templateRefs, inputs, outputs, bananas, others };
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Traverses a template AST and locates symbol(s) at a specified position.
     * @param info template AST information set
     * @param position location to locate symbols at
     */
    function locateSymbols(info, position) {
        const templatePosition = position - info.template.span.start;
        // TODO: update `findTemplateAstAt` to use absolute positions.
        const path = findTemplateAstAt(info.templateAst, templatePosition);
        const attribute = findAttribute(info, position);
        if (!path.tail)
            return [];
        const narrowest = spanOf(path.tail);
        const toVisit = [];
        for (let node = path.tail; node && isNarrower(spanOf(node.sourceSpan), narrowest); node = path.parentOf(node)) {
            toVisit.push(node);
        }
        // For the structural directive, only care about the last template AST.
        if (attribute === null || attribute === void 0 ? void 0 : attribute.name.startsWith('*')) {
            toVisit.splice(0, toVisit.length - 1);
        }
        return toVisit.map(ast => locateSymbol(ast, path, info))
            .filter((sym) => sym !== undefined);
    }
    /**
     * Visits a template node and locates the symbol in that node at a path position.
     * @param ast template AST node to visit
     * @param path non-empty set of narrowing AST nodes at a position
     * @param info template AST information set
     */
    function locateSymbol(ast, path, info) {
        const templatePosition = path.position;
        const position = templatePosition + info.template.span.start;
        let symbol;
        let span;
        let staticSymbol;
        const attributeValueSymbol = (ast) => {
            const attribute = findAttribute(info, position);
            if (attribute) {
                if (inSpan(templatePosition, spanOf(attribute.valueSpan))) {
                    let result;
                    if (attribute.name.startsWith('*')) {
                        result = getSymbolInMicrosyntax(info, path, attribute);
                    }
                    else {
                        const dinfo = diagnosticInfoFromTemplateInfo(info);
                        const scope = getExpressionScope(dinfo, path);
                        result = getExpressionSymbol(scope, ast, templatePosition, info.template);
                    }
                    if (result) {
                        symbol = result.symbol;
                        span = offsetSpan(result.span, attribute.valueSpan.start.offset);
                    }
                    return true;
                }
            }
            return false;
        };
        ast.visit({
            visitNgContent(_ast) { },
            visitEmbeddedTemplate(_ast) { },
            visitElement(ast) {
                const component = ast.directives.find(d => d.directive.isComponent);
                if (component) {
                    // Need to cast because 'reference' is typed as any
                    staticSymbol = component.directive.type.reference;
                    symbol = info.template.query.getTypeSymbol(staticSymbol);
                    symbol = symbol && new OverrideKindSymbol(symbol, DirectiveKind.COMPONENT);
                    span = spanOf(ast);
                }
                else {
                    // Find a directive that matches the element name
                    const directive = ast.directives.find(d => d.directive.selector != null && d.directive.selector.indexOf(ast.name) >= 0);
                    if (directive) {
                        // Need to cast because 'reference' is typed as any
                        staticSymbol = directive.directive.type.reference;
                        symbol = info.template.query.getTypeSymbol(staticSymbol);
                        symbol = symbol && new OverrideKindSymbol(symbol, DirectiveKind.DIRECTIVE);
                        span = spanOf(ast);
                    }
                }
            },
            visitReference(ast) {
                symbol = ast.value && info.template.query.getTypeSymbol(tokenReference(ast.value));
                span = spanOf(ast);
            },
            visitVariable(_ast) { },
            visitEvent(ast) {
                if (!attributeValueSymbol(ast.handler)) {
                    symbol = findOutputBinding(ast, path, info.template.query);
                    symbol = symbol && new OverrideKindSymbol(symbol, DirectiveKind.EVENT);
                    span = spanOf(ast);
                }
            },
            visitElementProperty(ast) {
                attributeValueSymbol(ast.value);
            },
            visitAttr(ast) {
                const element = path.first(ElementAst);
                if (!element)
                    return;
                // Create a mapping of all directives applied to the element from their selectors.
                const matcher = new SelectorMatcher();
                for (const dir of element.directives) {
                    if (!dir.directive.selector)
                        continue;
                    matcher.addSelectables(CssSelector.parse(dir.directive.selector), dir);
                }
                // See if this attribute matches the selector of any directive on the element.
                const attributeSelector = `[${ast.name}=${ast.value}]`;
                const parsedAttribute = CssSelector.parse(attributeSelector);
                if (!parsedAttribute.length)
                    return;
                matcher.match(parsedAttribute[0], (_, { directive }) => {
                    // Need to cast because 'reference' is typed as any
                    staticSymbol = directive.type.reference;
                    symbol = info.template.query.getTypeSymbol(staticSymbol);
                    symbol = symbol && new OverrideKindSymbol(symbol, DirectiveKind.DIRECTIVE);
                    span = spanOf(ast);
                });
            },
            visitBoundText(ast) {
                const expressionPosition = templatePosition - ast.sourceSpan.start.offset;
                if (inSpan(expressionPosition, ast.value.span)) {
                    const dinfo = diagnosticInfoFromTemplateInfo(info);
                    const scope = getExpressionScope(dinfo, path);
                    const result = getExpressionSymbol(scope, ast.value, templatePosition, info.template);
                    if (result) {
                        symbol = result.symbol;
                        span = offsetSpan(result.span, ast.sourceSpan.start.offset);
                    }
                }
            },
            visitText(_ast) { },
            visitDirective(ast) {
                // Need to cast because 'reference' is typed as any
                staticSymbol = ast.directive.type.reference;
                symbol = info.template.query.getTypeSymbol(staticSymbol);
                span = spanOf(ast);
            },
            visitDirectiveProperty(ast) {
                if (!attributeValueSymbol(ast.value)) {
                    const directive = findParentOfBinding(info.templateAst, ast, templatePosition);
                    const attribute = findAttribute(info, position);
                    if (directive && attribute) {
                        if (attribute.name.startsWith('*')) {
                            const compileTypeSummary = directive.directive;
                            symbol = info.template.query.getTypeSymbol(compileTypeSummary.type.reference);
                            symbol = symbol && new OverrideKindSymbol(symbol, DirectiveKind.DIRECTIVE);
                            // Use 'attribute.sourceSpan' instead of the directive's,
                            // because the span of the directive is the whole opening tag of an element.
                            span = spanOf(attribute.sourceSpan);
                        }
                        else {
                            symbol = findInputBinding(info, ast.templateName, directive);
                            span = spanOf(ast);
                        }
                    }
                }
            }
        }, null);
        if (symbol && span) {
            const { start, end } = offsetSpan(span, info.template.span.start);
            return {
                symbol,
                span: tss.createTextSpanFromBounds(start, end),
                staticSymbol,
            };
        }
    }
    // Get the symbol in microsyntax at template position.
    function getSymbolInMicrosyntax(info, path, attribute) {
        var _a;
        if (!attribute.valueSpan) {
            return;
        }
        const absValueOffset = attribute.valueSpan.start.offset;
        let result;
        const { templateBindings } = info.expressionParser.parseTemplateBindings(attribute.name, attribute.value, attribute.sourceSpan.toString(), attribute.sourceSpan.start.offset, attribute.valueSpan.start.offset);
        // Find the symbol that contains the position.
        for (const tb of templateBindings) {
            if (tb instanceof VariableBinding) {
                // TODO(kyliau): if binding is variable we should still look for the value
                // of the key. For example, "let i=index" => "index" should point to
                // NgForOfContext.index
                continue;
            }
            if (inSpan(path.position, (_a = tb.value) === null || _a === void 0 ? void 0 : _a.ast.sourceSpan)) {
                const dinfo = diagnosticInfoFromTemplateInfo(info);
                const scope = getExpressionScope(dinfo, path);
                result = getExpressionSymbol(scope, tb.value, path.position, info.template);
            }
            else if (inSpan(path.position, tb.sourceSpan)) {
                const template = path.first(EmbeddedTemplateAst);
                if (template) {
                    // One element can only have one template binding.
                    const directiveAst = template.directives[0];
                    if (directiveAst) {
                        const symbol = findInputBinding(info, tb.key.source.substring(1), directiveAst);
                        if (symbol) {
                            result = {
                                symbol,
                                // the span here has to be relative to the start of the template
                                // value so deduct the absolute offset.
                                // TODO(kyliau): Use absolute source span throughout completions.
                                span: offsetSpan(tb.key.span, -absValueOffset),
                            };
                        }
                    }
                }
            }
        }
        return result;
    }
    function findAttribute(info, position) {
        const templatePosition = position - info.template.span.start;
        const path = getPathToNodeAtPosition(info.htmlAst, templatePosition);
        return path.first(Attribute);
    }
    // TODO: remove this function after the path includes 'DirectiveAst'.
    // Find the directive that corresponds to the specified 'binding'
    // at the specified 'position' in the 'ast'.
    function findParentOfBinding(ast, binding, position) {
        let res;
        const visitor = new class extends RecursiveTemplateAstVisitor {
            visit(ast) {
                const span = spanOf(ast);
                if (!inSpan(position, span)) {
                    // Returning a value here will result in the children being skipped.
                    return true;
                }
            }
            visitEmbeddedTemplate(ast, context) {
                return this.visitChildren(context, visit => {
                    visit(ast.directives);
                    visit(ast.children);
                });
            }
            visitElement(ast, context) {
                return this.visitChildren(context, visit => {
                    visit(ast.directives);
                    visit(ast.children);
                });
            }
            visitDirective(ast) {
                const result = this.visitChildren(ast, visit => {
                    visit(ast.inputs);
                });
                return result;
            }
            visitDirectiveProperty(ast, context) {
                if (ast === binding) {
                    res = context;
                }
            }
        };
        templateVisitAll(visitor, ast);
        return res;
    }
    // Find the symbol of input binding in 'directiveAst' by 'name'.
    function findInputBinding(info, name, directiveAst) {
        const invertedInput = invertMap(directiveAst.directive.inputs);
        const fieldName = invertedInput[name];
        if (fieldName) {
            const classSymbol = info.template.query.getTypeSymbol(directiveAst.directive.type.reference);
            if (classSymbol) {
                return classSymbol.members().get(fieldName);
            }
        }
    }
    /**
     * Wrap a symbol and change its kind to component.
     */
    class OverrideKindSymbol {
        constructor(sym, kindOverride) {
            this.sym = sym;
            this.kind = kindOverride;
        }
        get name() {
            return this.sym.name;
        }
        get language() {
            return this.sym.language;
        }
        get type() {
            return this.sym.type;
        }
        get container() {
            return this.sym.container;
        }
        get public() {
            return this.sym.public;
        }
        get callable() {
            return this.sym.callable;
        }
        get nullable() {
            return this.sym.nullable;
        }
        get definition() {
            return this.sym.definition;
        }
        get documentation() {
            return this.sym.documentation;
        }
        members() {
            return this.sym.members();
        }
        signatures() {
            return this.sym.signatures();
        }
        selectSignature(types) {
            return this.sym.selectSignature(types);
        }
        indexed(argument) {
            return this.sym.indexed(argument);
        }
        typeArguments() {
            return this.sym.typeArguments();
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Return metadata about `node` if it looks like an Angular directive class.
     * In this case, potential matches are `@NgModule`, `@Component`, `@Directive`,
     * `@Pipe`, etc.
     * These class declarations all share some common attributes, namely their
     * decorator takes exactly one parameter and the parameter must be an object
     * literal.
     *
     * For example,
     *     v---------- `decoratorId`
     * @NgModule({           <
     *   declarations: [],   < classDecln-al
     * })                    <
     * class AppModule {}    <
     *          ^----- `classId`
     *
     * @param node Potential node that represents an Angular directive.
     */
    function getDirectiveClassLike(node) {
        if (!tss.isClassDeclaration(node) || !node.name || !node.decorators) {
            return;
        }
        for (const d of node.decorators) {
            const expr = d.expression;
            if (!tss.isCallExpression(expr) || expr.arguments.length !== 1 ||
                !tss.isIdentifier(expr.expression)) {
                continue;
            }
            const arg = expr.arguments[0];
            if (tss.isObjectLiteralExpression(arg)) {
                return {
                    decoratorId: expr.expression,
                    classId: node.name,
                };
            }
        }
    }
    /**
     * Finds the value of a property assignment that is nested in a TypeScript node and is of a certain
     * type T.
     *
     * @param startNode node to start searching for nested property assignment from
     * @param propName property assignment name
     * @param predicate function to verify that a node is of type T.
     * @return node property assignment value of type T, or undefined if none is found
     */
    function findPropertyValueOfType(startNode, propName, predicate) {
        if (tss.isPropertyAssignment(startNode) && startNode.name.getText() === propName) {
            const { initializer } = startNode;
            if (predicate(initializer))
                return initializer;
        }
        return startNode.forEachChild(c => findPropertyValueOfType(c, propName, predicate));
    }
    /**
     * Return the node that most tightly encompass the specified `position`.
     * @param node
     * @param position
     */
    function findTightestNode(node, position) {
        if (node.getStart() <= position && position < node.getEnd()) {
            return node.forEachChild(c => findTightestNode(c, position)) || node;
        }
    }
    /**
     * Returns a property assignment from the assignment value if the property name
     * matches the specified `key`, or `undefined` if there is no match.
     */
    function getPropertyAssignmentFromValue(value, key) {
        const propAssignment = value.parent;
        if (!propAssignment || !tss.isPropertyAssignment(propAssignment) ||
            propAssignment.name.getText() !== key) {
            return;
        }
        return propAssignment;
    }
    /**
     * Given a decorator property assignment, return the ClassDeclaration node that corresponds to the
     * directive class the property applies to.
     * If the property assignment is not on a class decorator, no declaration is returned.
     *
     * For example,
     *
     * @Component({
     *   template: '<div></div>'
     *   ^^^^^^^^^^^^^^^^^^^^^^^---- property assignment
     * })
     * class AppComponent {}
     *           ^---- class declaration node
     *
     * @param propAsgnNode property assignment
     */
    function getClassDeclFromDecoratorProp(propAsgnNode) {
        if (!propAsgnNode.parent || !tss.isObjectLiteralExpression(propAsgnNode.parent)) {
            return;
        }
        const objLitExprNode = propAsgnNode.parent;
        if (!objLitExprNode.parent || !tss.isCallExpression(objLitExprNode.parent)) {
            return;
        }
        const callExprNode = objLitExprNode.parent;
        if (!callExprNode.parent || !tss.isDecorator(callExprNode.parent)) {
            return;
        }
        const decorator = callExprNode.parent;
        if (!decorator.parent || !tss.isClassDeclaration(decorator.parent)) {
            return;
        }
        const classDeclNode = decorator.parent;
        return classDeclNode;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Convert Angular Span to TypeScript TextSpan. Angular Span has 'start' and
     * 'end' whereas TS TextSpan has 'start' and 'length'.
     * @param span Angular Span
     */
    function ngSpanToTsTextSpan(span) {
        return {
            start: span.start,
            length: span.end - span.start,
        };
    }
    /**
     * Attempts to get the definition of a file whose URL is specified in a property assignment in a
     * directive decorator.
     * Currently applies to `templateUrl` and `styleUrls` properties.
     */
    function getUrlFromProperty(urlNode, tsLsHost) {
        // Get the property assignment node corresponding to the `templateUrl` or `styleUrls` assignment.
        // These assignments are specified differently; `templateUrl` is a string, and `styleUrls` is
        // an array of strings:
        //   {
        //        templateUrl: './template.ng.html',
        //        styleUrls: ['./style.css', './other-style.css']
        //   }
        // `templateUrl`'s property assignment can be found from the string literal node;
        // `styleUrls`'s property assignment can be found from the array (parent) node.
        //
        // First search for `templateUrl`.
        let asgn = getPropertyAssignmentFromValue(urlNode, 'templateUrl');
        if (!asgn) {
            // `templateUrl` assignment not found; search for `styleUrls` array assignment.
            asgn = getPropertyAssignmentFromValue(urlNode.parent, 'styleUrls');
            if (!asgn) {
                // Nothing found, bail.
                return;
            }
        }
        // If the property assignment is not a property of a class decorator, don't generate definitions
        // for it.
        if (!getClassDeclFromDecoratorProp(asgn)) {
            return;
        }
        // Extract url path specified by the url node, which is relative to the TypeScript source file
        // the url node is defined in.
        const url = extractAbsoluteFilePath(urlNode);
        // If the file does not exist, bail. It is possible that the TypeScript language service host
        // does not have a `fileExists` method, in which case optimistically assume the file exists.
        if (tsLsHost.fileExists && !tsLsHost.fileExists(url))
            return;
        const templateDefinitions = [{
                kind: ts.ScriptElementKind.externalModuleName,
                name: url,
                containerKind: ts.ScriptElementKind.unknown,
                containerName: '',
                // Reading the template is expensive, so don't provide a preview.
                textSpan: { start: 0, length: 0 },
                fileName: url,
            }];
        return {
            definitions: templateDefinitions,
            textSpan: {
                // Exclude opening and closing quotes in the url span.
                start: urlNode.getStart() + 1,
                length: urlNode.getWidth() - 2,
            },
        };
    }
    /**
     * Traverse the template AST and look for the symbol located at `position`, then
     * return its definition and span of bound text.
     * @param info
     * @param position
     */
    function getDefinitionAndBoundSpan(info, position) {
        const symbols = locateSymbols(info, position);
        if (!symbols.length) {
            return;
        }
        const seen = new Set();
        const definitions = [];
        for (const symbolInfo of symbols) {
            const { symbol } = symbolInfo;
            // symbol.definition is really the locations of the symbol. There could be
            // more than one. No meaningful info could be provided without any location.
            const { kind, name, container, definition: locations } = symbol;
            if (!locations || !locations.length) {
                continue;
            }
            const containerKind = container ? container.kind : ts.ScriptElementKind.unknown;
            const containerName = container ? container.name : '';
            for (const { fileName, span } of locations) {
                const textSpan = ngSpanToTsTextSpan(span);
                // In cases like two-way bindings, a request for the definitions of an expression may return
                // two of the same definition:
                //    [(ngModel)]="prop"
                //                 ^^^^  -- one definition for the property binding, one for the event binding
                // To prune duplicate definitions, tag definitions with unique location signatures and ignore
                // definitions whose locations have already been seen.
                const signature = `${textSpan.start}:${textSpan.length}@${fileName}`;
                if (seen.has(signature))
                    continue;
                definitions.push({
                    kind: kind,
                    name,
                    containerKind,
                    containerName,
                    textSpan: ngSpanToTsTextSpan(span),
                    fileName: fileName,
                });
                seen.add(signature);
            }
        }
        return {
            definitions,
            textSpan: symbols[0].span,
        };
    }
    /**
     * Gets an Angular-specific definition in a TypeScript source file.
     */
    function getTsDefinitionAndBoundSpan(sf, position, tsLsHost) {
        const node = findTightestNode(sf, position);
        if (!node)
            return;
        switch (node.kind) {
            case ts.SyntaxKind.StringLiteral:
            case ts.SyntaxKind.NoSubstitutionTemplateLiteral:
                // Attempt to extract definition of a URL in a property assignment.
                return getUrlFromProperty(node, tsLsHost);
            default:
                return undefined;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Return diagnostic information for the parsed AST of the template.
     * @param ast contains HTML and template AST
     */
    function getTemplateDiagnostics(ast) {
        const { parseErrors, templateAst, htmlAst, template } = ast;
        if (parseErrors && parseErrors.length) {
            return parseErrors.map(e => {
                return {
                    kind: ts.DiagnosticCategory.Error,
                    span: offsetSpan(spanOf(e.span), template.span.start),
                    message: e.msg,
                };
            });
        }
        return getTemplateExpressionDiagnostics({
            templateAst: templateAst,
            htmlAst: htmlAst,
            offset: template.span.start,
            query: template.query,
            members: template.members,
            source: ast.template.source,
        });
    }
    /**
     * Performs a variety diagnostics on directive declarations.
     *
     * @param declarations Angular directive declarations
     * @param modules NgModules in the project
     * @param host TypeScript service host used to perform TypeScript queries
     * @return diagnosed errors, if any
     */
    function getDeclarationDiagnostics(declarations, modules, host) {
        const directives = new Set();
        for (const ngModule of modules.ngModules) {
            for (const directive of ngModule.declaredDirectives) {
                directives.add(directive.reference);
            }
        }
        const results = [];
        for (const declaration of declarations) {
            const { errors, metadata, type, declarationSpan } = declaration;
            const sf = host.getSourceFile(type.filePath);
            if (!sf) {
                host.error(`directive ${type.name} exists but has no source file`);
                return [];
            }
            // TypeScript identifier of the directive declaration annotation (e.g. "Component" or
            // "Directive") on a directive class.
            const directiveIdentifier = findTightestNode(sf, declarationSpan.start);
            if (!directiveIdentifier) {
                host.error(`directive ${type.name} exists but has no identifier`);
                return [];
            }
            for (const error of errors) {
                results.push({
                    kind: ts.DiagnosticCategory.Error,
                    message: error.message,
                    span: error.span,
                });
            }
            if (!modules.ngModuleByPipeOrDirective.has(declaration.type)) {
                results.push(createDiagnostic(declarationSpan, Diagnostic.directive_not_in_module, metadata.isComponent ? 'Component' : 'Directive', type.name));
            }
            if (metadata.isComponent) {
                const { template, templateUrl, styleUrls } = metadata.template;
                if (template === null && !templateUrl) {
                    results.push(createDiagnostic(declarationSpan, Diagnostic.missing_template_and_templateurl, type.name));
                }
                else if (templateUrl) {
                    if (template) {
                        results.push(createDiagnostic(declarationSpan, Diagnostic.both_template_and_templateurl, type.name));
                    }
                    // Find templateUrl value from the directive call expression, which is the parent of the
                    // directive identifier.
                    //
                    // TODO: We should create an enum of the various properties a directive can have to use
                    // instead of string literals. We can then perform a mass migration of all literal usages.
                    const templateUrlNode = findPropertyValueOfType(directiveIdentifier.parent, 'templateUrl', ts.isLiteralExpression);
                    if (!templateUrlNode) {
                        host.error(`templateUrl ${templateUrl} exists but its TypeScript node doesn't`);
                        return [];
                    }
                    results.push(...validateUrls([templateUrlNode], host.tsLsHost));
                }
                if (styleUrls.length > 0) {
                    // Find styleUrls value from the directive call expression, which is the parent of the
                    // directive identifier.
                    const styleUrlsNode = findPropertyValueOfType(directiveIdentifier.parent, 'styleUrls', ts.isArrayLiteralExpression);
                    if (!styleUrlsNode) {
                        host.error(`styleUrls property exists but its TypeScript node doesn't'`);
                        return [];
                    }
                    results.push(...validateUrls(styleUrlsNode.elements, host.tsLsHost));
                }
            }
        }
        return results;
    }
    /**
     * Checks that URLs on a directive point to a valid file.
     * Note that this diagnostic check may require a filesystem hit, and thus may be slower than other
     * checks.
     *
     * @param urls urls to check for validity
     * @param tsLsHost TS LS host used for querying filesystem information
     * @return diagnosed url errors, if any
     */
    function validateUrls(urls, tsLsHost) {
        if (!tsLsHost.fileExists) {
            return [];
        }
        const allErrors = [];
        // TODO(ayazhafiz): most of this logic can be unified with the logic in
        // definitions.ts#getUrlFromProperty. Create a utility function to be used by both.
        for (let i = 0; i < urls.length; ++i) {
            const urlNode = urls[i];
            if (!ts.isStringLiteralLike(urlNode)) {
                // If a non-string value is assigned to a URL node (like `templateUrl`), a type error will be
                // picked up by the TS Language Server.
                continue;
            }
            const url = extractAbsoluteFilePath(urlNode);
            if (tsLsHost.fileExists(url))
                continue;
            // Exclude opening and closing quotes in the url span.
            const urlSpan = { start: urlNode.getStart() + 1, end: urlNode.end - 1 };
            allErrors.push(createDiagnostic(urlSpan, Diagnostic.invalid_templateurl));
        }
        return allErrors;
    }
    /**
     * Return a recursive data structure that chains diagnostic messages.
     * @param chain
     */
    function chainDiagnostics(chain) {
        return {
            messageText: chain.message,
            category: ts.DiagnosticCategory.Error,
            code: 0,
            next: chain.next ? chain.next.map(chainDiagnostics) : undefined
        };
    }
    /**
     * Convert ng.Diagnostic to ts.Diagnostic.
     * @param d diagnostic
     * @param file
     */
    function ngDiagnosticToTsDiagnostic(d, file) {
        return {
            file,
            start: d.span.start,
            length: d.span.end - d.span.start,
            messageText: typeof d.message === 'string' ? d.message : chainDiagnostics(d.message),
            category: d.kind,
            code: 0,
            source: 'ng',
        };
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Traverse the template AST and look for the symbol located at `position`, then
     * return the corresponding quick info.
     * @param info template AST
     * @param position location of the symbol
     * @param analyzedModules all NgModules in the program.
     */
    function getTemplateHover(info, position, analyzedModules) {
        var _a, _b;
        const symbolInfo = locateSymbols(info, position)[0];
        if (!symbolInfo) {
            return;
        }
        const { symbol, span, staticSymbol } = symbolInfo;
        // The container is either the symbol's container (for example, 'AppComponent'
        // is the container of the symbol 'title' in its template) or the NgModule
        // that the directive belongs to (the container of AppComponent is AppModule).
        let containerName = (_a = symbol.container) === null || _a === void 0 ? void 0 : _a.name;
        if (!containerName && staticSymbol) {
            // If there is a static symbol then the target is a directive.
            const ngModule = analyzedModules.ngModuleByPipeOrDirective.get(staticSymbol);
            containerName = ngModule === null || ngModule === void 0 ? void 0 : ngModule.type.reference.name;
        }
        return createQuickInfo(symbol.name, symbol.kind, span, containerName, (_b = symbol.type) === null || _b === void 0 ? void 0 : _b.name, symbol.documentation);
    }
    /**
     * Get quick info for Angular semantic entities in TypeScript files, like Directives.
     * @param position location of the symbol in the source file
     * @param declarations All Directive-like declarations in the source file.
     * @param analyzedModules all NgModules in the program.
     */
    function getTsHover(position, declarations, analyzedModules) {
        for (const { declarationSpan, metadata } of declarations) {
            if (inSpan(position, declarationSpan)) {
                const staticSymbol = metadata.type.reference;
                const directiveName = staticSymbol.name;
                const kind = metadata.isComponent ? 'component' : 'directive';
                const textSpan = ts.createTextSpanFromBounds(declarationSpan.start, declarationSpan.end);
                const ngModule = analyzedModules.ngModuleByPipeOrDirective.get(staticSymbol);
                const moduleName = ngModule === null || ngModule === void 0 ? void 0 : ngModule.type.reference.name;
                return createQuickInfo(directiveName, kind, textSpan, moduleName, ts.ScriptElementKind.classElement);
            }
        }
    }
    // Reverse mappings of enum would generate strings
    const ALIAS_NAME = ts.SymbolDisplayPartKind[ts.SymbolDisplayPartKind.aliasName];
    const SYMBOL_INTERFACE = ts.SymbolDisplayPartKind[ts.SymbolDisplayPartKind.interfaceName];
    const SYMBOL_PUNC = ts.SymbolDisplayPartKind[ts.SymbolDisplayPartKind.punctuation];
    const SYMBOL_SPACE = ts.SymbolDisplayPartKind[ts.SymbolDisplayPartKind.space];
    const SYMBOL_TEXT = ts.SymbolDisplayPartKind[ts.SymbolDisplayPartKind.text];
    /**
     * Construct a QuickInfo object taking into account its container and type.
     * @param name Name of the QuickInfo target
     * @param kind component, directive, pipe, etc.
     * @param textSpan span of the target
     * @param containerName either the Symbol's container or the NgModule that contains the directive
     * @param type user-friendly name of the type
     * @param documentation docstring or comment
     */
    function createQuickInfo(name, kind, textSpan, containerName, type, documentation) {
        const containerDisplayParts = containerName ?
            [
                { text: containerName, kind: SYMBOL_INTERFACE },
                { text: '.', kind: SYMBOL_PUNC },
            ] :
            [];
        const typeDisplayParts = type ?
            [
                { text: ':', kind: SYMBOL_PUNC },
                { text: ' ', kind: SYMBOL_SPACE },
                { text: type, kind: SYMBOL_INTERFACE },
            ] :
            [];
        return {
            kind: kind,
            kindModifiers: ts.ScriptElementKindModifier.none,
            textSpan: textSpan,
            displayParts: [
                { text: '(', kind: SYMBOL_PUNC },
                { text: kind, kind: SYMBOL_TEXT },
                { text: ')', kind: SYMBOL_PUNC },
                { text: ' ', kind: SYMBOL_SPACE },
                ...containerDisplayParts,
                { text: name, kind: SYMBOL_INTERFACE },
                ...typeDisplayParts,
            ],
            documentation,
        };
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Create an instance of an Angular `LanguageService`.
     *
     * @publicApi
     */
    function createLanguageService(host) {
        return new LanguageServiceImpl(host);
    }
    class LanguageServiceImpl {
        constructor(host) {
            this.host = host;
        }
        getSemanticDiagnostics(fileName) {
            const analyzedModules = this.host.getAnalyzedModules(); // same role as 'synchronizeHostData'
            const ngDiagnostics = [];
            const templates = this.host.getTemplates(fileName);
            for (const template of templates) {
                const ast = this.host.getTemplateAst(template);
                if (ast) {
                    ngDiagnostics.push(...getTemplateDiagnostics(ast));
                }
            }
            const declarations = this.host.getDeclarations(fileName);
            ngDiagnostics.push(...getDeclarationDiagnostics(declarations, analyzedModules, this.host));
            const sourceFile = fileName.endsWith('.ts') ? this.host.getSourceFile(fileName) : undefined;
            const tsDiagnostics = ngDiagnostics.map(d => ngDiagnosticToTsDiagnostic(d, sourceFile));
            return [...tss.sortAndDeduplicateDiagnostics(tsDiagnostics)];
        }
        getCompletionsAtPosition(fileName, position, _options) {
            this.host.getAnalyzedModules(); // same role as 'synchronizeHostData'
            const ast = this.host.getTemplateAstAtPosition(fileName, position);
            if (!ast) {
                return;
            }
            const results = getTemplateCompletions(ast, position);
            if (!results || !results.length) {
                return;
            }
            return {
                isGlobalCompletion: false,
                isMemberCompletion: false,
                isNewIdentifierLocation: false,
                // Cast CompletionEntry.kind from ng.CompletionKind to ts.ScriptElementKind
                entries: results,
            };
        }
        getDefinitionAndBoundSpan(fileName, position) {
            this.host.getAnalyzedModules(); // same role as 'synchronizeHostData'
            const templateInfo = this.host.getTemplateAstAtPosition(fileName, position);
            if (templateInfo) {
                return getDefinitionAndBoundSpan(templateInfo, position);
            }
            // Attempt to get Angular-specific definitions in a TypeScript file, like templates defined
            // in a `templateUrl` property.
            if (fileName.endsWith('.ts')) {
                const sf = this.host.getSourceFile(fileName);
                if (sf) {
                    return getTsDefinitionAndBoundSpan(sf, position, this.host.tsLsHost);
                }
            }
        }
        getQuickInfoAtPosition(fileName, position) {
            const analyzedModules = this.host.getAnalyzedModules(); // same role as 'synchronizeHostData'
            const templateInfo = this.host.getTemplateAstAtPosition(fileName, position);
            if (templateInfo) {
                return getTemplateHover(templateInfo, position, analyzedModules);
            }
            // Attempt to get Angular-specific hover information in a TypeScript file, the NgModule a
            // directive belongs to.
            const declarations = this.host.getDeclarations(fileName);
            return getTsHover(position, declarations, analyzedModules);
        }
        getReferencesAtPosition(fileName, position) {
            const defAndSpan = this.getDefinitionAndBoundSpan(fileName, position);
            if (!(defAndSpan === null || defAndSpan === void 0 ? void 0 : defAndSpan.definitions)) {
                return;
            }
            const { definitions } = defAndSpan;
            const tsDef = definitions.find(def => def.fileName.endsWith('.ts'));
            if (!tsDef) {
                return;
            }
            return this.host.tsLS.getReferencesAtPosition(tsDef.fileName, tsDef.textSpan.start);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function getClosureSafeProperty(objWithPropertyToExtract) {
        for (let key in objWithPropertyToExtract) {
            if (objWithPropertyToExtract[key] === getClosureSafeProperty) {
                return key;
            }
        }
        throw Error('Could not find renamed property on target object.');
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function stringify$1(token) {
        if (typeof token === 'string') {
            return token;
        }
        if (Array.isArray(token)) {
            return '[' + token.map(stringify$1).join(', ') + ']';
        }
        if (token == null) {
            return '' + token;
        }
        if (token.overriddenName) {
            return `${token.overriddenName}`;
        }
        if (token.name) {
            return `${token.name}`;
        }
        const res = token.toString();
        if (res == null) {
            return '' + res;
        }
        const newLineIndex = res.indexOf('\n');
        return newLineIndex === -1 ? res : res.substring(0, newLineIndex);
    }
    /**
     * Concatenates two strings with separator, allocating new strings only when necessary.
     *
     * @param before before string.
     * @param separator separator string.
     * @param after after string.
     * @returns concatenated string.
     */
    function concatStringsWithSpace(before, after) {
        return (before == null || before === '') ?
            (after === null ? '' : after) :
            ((after == null || after === '') ? before : before + ' ' + after);
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const __forward_ref__ = getClosureSafeProperty({ __forward_ref__: getClosureSafeProperty });
    /**
     * Allows to refer to references which are not yet defined.
     *
     * For instance, `forwardRef` is used when the `token` which we need to refer to for the purposes of
     * DI is declared, but not yet defined. It is also used when the `token` which we use when creating
     * a query is not yet defined.
     *
     * @usageNotes
     * ### Example
     * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='forward_ref'}
     * @publicApi
     */
    function forwardRef(forwardRefFn) {
        forwardRefFn.__forward_ref__ = forwardRef;
        forwardRefFn.toString = function () {
            return stringify$1(this());
        };
        return forwardRefFn;
    }
    /**
     * Lazily retrieves the reference value from a forwardRef.
     *
     * Acts as the identity function when given a non-forward-ref value.
     *
     * @usageNotes
     * ### Example
     *
     * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='resolve_forward_ref'}
     *
     * @see `forwardRef`
     * @publicApi
     */
    function resolveForwardRef$1(type) {
        return isForwardRef(type) ? type() : type;
    }
    /** Checks whether a function is wrapped by a `forwardRef`. */
    function isForwardRef(fn) {
        return typeof fn === 'function' && fn.hasOwnProperty(__forward_ref__) &&
            fn.__forward_ref__ === forwardRef;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    // Base URL for the error details page.
    // Keep this value in sync with a similar const in
    // `packages/compiler-cli/src/ngtsc/diagnostics/src/error_code.ts`.
    const ERROR_DETAILS_PAGE_BASE_URL = 'https://angular.io/errors';
    class RuntimeError extends Error {
        constructor(code, message) {
            super(formatRuntimeError(code, message));
            this.code = code;
        }
    }
    // Contains a set of error messages that have details guides at angular.io.
    // Full list of available error guides can be found at https://angular.io/errors
    /* tslint:disable:no-toplevel-property-access */
    const RUNTIME_ERRORS_WITH_GUIDES = new Set([
        "100" /* EXPRESSION_CHANGED_AFTER_CHECKED */,
        "200" /* CYCLIC_DI_DEPENDENCY */,
        "201" /* PROVIDER_NOT_FOUND */,
        "300" /* MULTIPLE_COMPONENTS_MATCH */,
        "301" /* EXPORT_NOT_FOUND */,
        "302" /* PIPE_NOT_FOUND */,
    ]);
    /* tslint:enable:no-toplevel-property-access */
    /** Called to format a runtime error */
    function formatRuntimeError(code, message) {
        const fullCode = code ? `NG0${code}: ` : '';
        let errorMessage = `${fullCode}${message}`;
        // Some runtime errors are still thrown without `ngDevMode` (for example
        // `throwProviderNotFoundError`), so we add `ngDevMode` check here to avoid pulling
        // `RUNTIME_ERRORS_WITH_GUIDES` symbol into prod bundles.
        // TODO: revisit all instances where `RuntimeError` is thrown and see if `ngDevMode` can be added
        // there instead to tree-shake more devmode-only code (and eventually remove `ngDevMode` check
        // from this code).
        if (ngDevMode && RUNTIME_ERRORS_WITH_GUIDES.has(code)) {
            errorMessage = `${errorMessage}. Find more at ${ERROR_DETAILS_PAGE_BASE_URL}/NG0${code}`;
        }
        return errorMessage;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Used for stringify render output in Ivy.
     * Important! This function is very performance-sensitive and we should
     * be extra careful not to introduce megamorphic reads in it.
     * Check `core/test/render3/perf/render_stringify` for benchmarks and alternate implementations.
     */
    function renderStringify(value) {
        if (typeof value === 'string')
            return value;
        if (value == null)
            return '';
        // Use `String` so that it invokes the `toString` method of the value. Note that this
        // appears to be faster than calling `value.toString` (see `render_stringify` benchmark).
        return String(value);
    }
    /**
     * Used to stringify a value so that it can be displayed in an error message.
     * Important! This function contains a megamorphic read and should only be
     * used for error messages.
     */
    function stringifyForError(value) {
        if (typeof value === 'function')
            return value.name || value.toString();
        if (typeof value === 'object' && value != null && typeof value.type === 'function') {
            return value.type.name || value.type.toString();
        }
        return renderStringify(value);
    }

    /** Called when directives inject each other (creating a circular dependency) */
    function throwCyclicDependencyError(token, path) {
        const depPath = path ? `. Dependency path: ${path.join(' > ')} > ${token}` : '';
        throw new RuntimeError("200" /* CYCLIC_DI_DEPENDENCY */, `Circular dependency in DI detected for ${token}${depPath}`);
    }
    /** Throws an error when a token is not found in DI. */
    function throwProviderNotFoundError(token, injectorName) {
        const injectorDetails = injectorName ? ` in ${injectorName}` : '';
        throw new RuntimeError("201" /* PROVIDER_NOT_FOUND */, `No provider for ${stringifyForError(token)} found${injectorDetails}`);
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function assertNumber(actual, msg) {
        if (!(typeof actual === 'number')) {
            throwError(msg, typeof actual, 'number', '===');
        }
    }
    function assertString(actual, msg) {
        if (!(typeof actual === 'string')) {
            throwError(msg, actual === null ? 'null' : typeof actual, 'string', '===');
        }
    }
    function assertFunction(actual, msg) {
        if (!(typeof actual === 'function')) {
            throwError(msg, actual === null ? 'null' : typeof actual, 'function', '===');
        }
    }
    function assertEqual(actual, expected, msg) {
        if (!(actual == expected)) {
            throwError(msg, actual, expected, '==');
        }
    }
    function assertNotEqual(actual, expected, msg) {
        if (!(actual != expected)) {
            throwError(msg, actual, expected, '!=');
        }
    }
    function assertSame(actual, expected, msg) {
        if (!(actual === expected)) {
            throwError(msg, actual, expected, '===');
        }
    }
    function assertNotSame(actual, expected, msg) {
        if (!(actual !== expected)) {
            throwError(msg, actual, expected, '!==');
        }
    }
    function assertLessThan(actual, expected, msg) {
        if (!(actual < expected)) {
            throwError(msg, actual, expected, '<');
        }
    }
    function assertGreaterThan(actual, expected, msg) {
        if (!(actual > expected)) {
            throwError(msg, actual, expected, '>');
        }
    }
    function assertGreaterThanOrEqual(actual, expected, msg) {
        if (!(actual >= expected)) {
            throwError(msg, actual, expected, '>=');
        }
    }
    function assertDefined(actual, msg) {
        if (actual == null) {
            throwError(msg, actual, null, '!=');
        }
    }
    function throwError(msg, actual, expected, comparison) {
        throw new Error(`ASSERTION ERROR: ${msg}` +
            (comparison == null ? '' : ` [Expected=> ${expected} ${comparison} ${actual} <=Actual]`));
    }
    function assertDomNode(node) {
        // If we're in a worker, `Node` will not be defined.
        if (!(typeof Node !== 'undefined' && node instanceof Node) &&
            !(typeof node === 'object' && node != null &&
                node.constructor.name === 'WebWorkerRenderNode')) {
            throwError(`The provided value must be an instance of a DOM Node but got ${stringify$1(node)}`);
        }
    }
    function assertIndexInRange(arr, index) {
        assertDefined(arr, 'Array must be defined.');
        const maxLen = arr.length;
        if (index < 0 || index >= maxLen) {
            throwError(`Index expected to be less than ${maxLen} but got ${index}`);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Construct an injectable definition which defines how a token will be constructed by the DI
     * system, and in which injectors (if any) it will be available.
     *
     * This should be assigned to a static `Éµprov` field on a type, which will then be an
     * `InjectableType`.
     *
     * Options:
     * * `providedIn` determines which injectors will include the injectable, by either associating it
     *   with an `@NgModule` or other `InjectorType`, or by specifying that this injectable should be
     *   provided in the `'root'` injector, which will be the application-level injector in most apps.
     * * `factory` gives the zero argument function which will create an instance of the injectable.
     *   The factory can call `inject` to access the `Injector` and request injection of dependencies.
     *
     * @codeGenApi
     * @publicApi This instruction has been emitted by ViewEngine for some time and is deployed to npm.
     */
    function ÉµÉµdefineInjectable(opts) {
        return {
            token: opts.token,
            providedIn: opts.providedIn || null,
            factory: opts.factory,
            value: undefined,
        };
    }
    /**
     * Construct an `InjectorDef` which configures an injector.
     *
     * This should be assigned to a static injector def (`Éµinj`) field on a type, which will then be an
     * `InjectorType`.
     *
     * Options:
     *
     * * `providers`: an optional array of providers to add to the injector. Each provider must
     *   either have a factory or point to a type which has a `Éµprov` static property (the
     *   type must be an `InjectableType`).
     * * `imports`: an optional array of imports of other `InjectorType`s or `InjectorTypeWithModule`s
     *   whose providers will also be added to the injector. Locally provided types will override
     *   providers from imports.
     *
     * @codeGenApi
     */
    function ÉµÉµdefineInjector(options) {
        return { providers: options.providers || [], imports: options.imports || [] };
    }
    /**
     * Read the injectable def (`Éµprov`) for `type` in a way which is immune to accidentally reading
     * inherited value.
     *
     * @param type A type which may have its own (non-inherited) `Éµprov`.
     */
    function getInjectableDef(type) {
        return getOwnDefinition(type, NG_PROV_DEF) || getOwnDefinition(type, NG_INJECTABLE_DEF);
    }
    /**
     * Return definition only if it is defined directly on `type` and is not inherited from a base
     * class of `type`.
     */
    function getOwnDefinition(type, field) {
        return type.hasOwnProperty(field) ? type[field] : null;
    }
    const NG_PROV_DEF = getClosureSafeProperty({ Éµprov: getClosureSafeProperty });
    const NG_INJ_DEF = getClosureSafeProperty({ Éµinj: getClosureSafeProperty });
    // We need to keep these around so we can read off old defs if new defs are unavailable
    const NG_INJECTABLE_DEF = getClosureSafeProperty({ ngInjectableDef: getClosureSafeProperty });
    const NG_INJECTOR_DEF = getClosureSafeProperty({ ngInjectorDef: getClosureSafeProperty });

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Injection flags for DI.
     *
     * @publicApi
     */
    var InjectFlags;
    (function (InjectFlags) {
        // TODO(alxhub): make this 'const' (and remove `InternalInjectFlags` enum) when ngc no longer
        // writes exports of it into ngfactory files.
        /** Check self and check parent injector if needed */
        InjectFlags[InjectFlags["Default"] = 0] = "Default";
        /**
         * Specifies that an injector should retrieve a dependency from any injector until reaching the
         * host element of the current component. (Only used with Element Injector)
         */
        InjectFlags[InjectFlags["Host"] = 1] = "Host";
        /** Don't ascend to ancestors of the node requesting injection. */
        InjectFlags[InjectFlags["Self"] = 2] = "Self";
        /** Skip the node that is requesting injection. */
        InjectFlags[InjectFlags["SkipSelf"] = 4] = "SkipSelf";
        /** Inject `defaultValue` instead if token not found. */
        InjectFlags[InjectFlags["Optional"] = 8] = "Optional";
    })(InjectFlags || (InjectFlags = {}));

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Current implementation of inject.
     *
     * By default, it is `injectInjectorOnly`, which makes it `Injector`-only aware. It can be changed
     * to `directiveInject`, which brings in the `NodeInjector` system of ivy. It is designed this
     * way for two reasons:
     *  1. `Injector` should not depend on ivy logic.
     *  2. To maintain tree shake-ability we don't want to bring in unnecessary code.
     */
    let _injectImplementation;
    function getInjectImplementation() {
        return _injectImplementation;
    }
    /**
     * Sets the current inject implementation.
     */
    function setInjectImplementation(impl) {
        const previous = _injectImplementation;
        _injectImplementation = impl;
        return previous;
    }
    /**
     * Injects `root` tokens in limp mode.
     *
     * If no injector exists, we can still inject tree-shakable providers which have `providedIn` set to
     * `"root"`. This is known as the limp mode injection. In such case the value is stored in the
     * injectable definition.
     */
    function injectRootLimpMode(token, notFoundValue, flags) {
        const injectableDef = getInjectableDef(token);
        if (injectableDef && injectableDef.providedIn == 'root') {
            return injectableDef.value === undefined ? injectableDef.value = injectableDef.factory() :
                injectableDef.value;
        }
        if (flags & InjectFlags.Optional)
            return null;
        if (notFoundValue !== undefined)
            return notFoundValue;
        throwProviderNotFoundError(stringify$1(token), 'Injector');
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Convince closure compiler that the wrapped function has no side-effects.
     *
     * Closure compiler always assumes that `toString` has no side-effects. We use this quirk to
     * allow us to execute a function but have closure compiler mark the call as no-side-effects.
     * It is important that the return value for the `noSideEffects` function be assigned
     * to something which is retained otherwise the call to `noSideEffects` will be removed by closure
     * compiler.
     */
    function noSideEffects(fn) {
        return { toString: fn }.toString();
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * The strategy that the default change detector uses to detect changes.
     * When set, takes effect the next time change detection is triggered.
     *
     * @see {@link ChangeDetectorRef#usage-notes Change detection usage}
     *
     * @publicApi
     */
    var ChangeDetectionStrategy$1;
    (function (ChangeDetectionStrategy) {
        /**
         * Use the `CheckOnce` strategy, meaning that automatic change detection is deactivated
         * until reactivated by setting the strategy to `Default` (`CheckAlways`).
         * Change detection can still be explicitly invoked.
         * This strategy applies to all child directives and cannot be overridden.
         */
        ChangeDetectionStrategy[ChangeDetectionStrategy["OnPush"] = 0] = "OnPush";
        /**
         * Use the default `CheckAlways` strategy, in which change detection is automatic until
         * explicitly deactivated.
         */
        ChangeDetectionStrategy[ChangeDetectionStrategy["Default"] = 1] = "Default";
    })(ChangeDetectionStrategy$1 || (ChangeDetectionStrategy$1 = {}));
    /**
     * Defines the possible states of the default change detector.
     * @see `ChangeDetectorRef`
     */
    var ChangeDetectorStatus;
    (function (ChangeDetectorStatus) {
        /**
         * A state in which, after calling `detectChanges()`, the change detector
         * state becomes `Checked`, and must be explicitly invoked or reactivated.
         */
        ChangeDetectorStatus[ChangeDetectorStatus["CheckOnce"] = 0] = "CheckOnce";
        /**
         * A state in which change detection is skipped until the change detector mode
         * becomes `CheckOnce`.
         */
        ChangeDetectorStatus[ChangeDetectorStatus["Checked"] = 1] = "Checked";
        /**
         * A state in which change detection continues automatically until explicitly
         * deactivated.
         */
        ChangeDetectorStatus[ChangeDetectorStatus["CheckAlways"] = 2] = "CheckAlways";
        /**
         * A state in which a change detector sub tree is not a part of the main tree and
         * should be skipped.
         */
        ChangeDetectorStatus[ChangeDetectorStatus["Detached"] = 3] = "Detached";
        /**
         * Indicates that the change detector encountered an error checking a binding
         * or calling a directive lifecycle method and is now in an inconsistent state. Change
         * detectors in this state do not detect changes.
         */
        ChangeDetectorStatus[ChangeDetectorStatus["Errored"] = 4] = "Errored";
        /**
         * Indicates that the change detector has been destroyed.
         */
        ChangeDetectorStatus[ChangeDetectorStatus["Destroyed"] = 5] = "Destroyed";
    })(ChangeDetectorStatus || (ChangeDetectorStatus = {}));

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Defines template and style encapsulation options available for Component's {@link Component}.
     *
     * See {@link Component#encapsulation encapsulation}.
     *
     * @usageNotes
     * ### Example
     *
     * {@example core/ts/metadata/encapsulation.ts region='longform'}
     *
     * @publicApi
     */
    var ViewEncapsulation$1;
    (function (ViewEncapsulation) {
        /**
         * Emulate `Native` scoping of styles by adding an attribute containing surrogate id to the Host
         * Element and pre-processing the style rules provided via {@link Component#styles styles} or
         * {@link Component#styleUrls styleUrls}, and adding the new Host Element attribute to all
         * selectors.
         *
         * This is the default option.
         */
        ViewEncapsulation[ViewEncapsulation["Emulated"] = 0] = "Emulated";
        // Historically the 1 value was for `Native` encapsulation which has been removed as of v11.
        /**
         * Don't provide any template or style encapsulation.
         */
        ViewEncapsulation[ViewEncapsulation["None"] = 2] = "None";
        /**
         * Use Shadow DOM to encapsulate styles.
         *
         * For the DOM this means using modern [Shadow
         * DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM) and
         * creating a ShadowRoot for Component's Host Element.
         */
        ViewEncapsulation[ViewEncapsulation["ShadowDom"] = 3] = "ShadowDom";
    })(ViewEncapsulation$1 || (ViewEncapsulation$1 = {}));

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const __globalThis = typeof globalThis !== 'undefined' && globalThis;
    const __window$1 = typeof window !== 'undefined' && window;
    const __self$1 = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&
        self instanceof WorkerGlobalScope && self;
    const __global$1 = typeof global !== 'undefined' && global;
    // Always use __globalThis if available, which is the spec-defined global variable across all
    // environments, then fallback to __global first, because in Node tests both __global and
    // __window may be defined and _global should be __global in that case.
    const _global$1 = __globalThis || __global$1 || __window$1 || __self$1;

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function ngDevModeResetPerfCounters() {
        const locationString = typeof location !== 'undefined' ? location.toString() : '';
        const newCounters = {
            namedConstructors: locationString.indexOf('ngDevMode=namedConstructors') != -1,
            firstCreatePass: 0,
            tNode: 0,
            tView: 0,
            rendererCreateTextNode: 0,
            rendererSetText: 0,
            rendererCreateElement: 0,
            rendererAddEventListener: 0,
            rendererSetAttribute: 0,
            rendererRemoveAttribute: 0,
            rendererSetProperty: 0,
            rendererSetClassName: 0,
            rendererAddClass: 0,
            rendererRemoveClass: 0,
            rendererSetStyle: 0,
            rendererRemoveStyle: 0,
            rendererDestroy: 0,
            rendererDestroyNode: 0,
            rendererMoveNode: 0,
            rendererRemoveNode: 0,
            rendererAppendChild: 0,
            rendererInsertBefore: 0,
            rendererCreateComment: 0,
        };
        // Make sure to refer to ngDevMode as ['ngDevMode'] for closure.
        const allowNgDevModeTrue = locationString.indexOf('ngDevMode=false') === -1;
        _global$1['ngDevMode'] = allowNgDevModeTrue && newCounters;
        return newCounters;
    }
    /**
     * This function checks to see if the `ngDevMode` has been set. If yes,
     * then we honor it, otherwise we default to dev mode with additional checks.
     *
     * The idea is that unless we are doing production build where we explicitly
     * set `ngDevMode == false` we should be helping the developer by providing
     * as much early warning and errors as possible.
     *
     * `ÉµÉµdefineComponent` is guaranteed to have been called before any component template functions
     * (and thus Ivy instructions), so a single initialization there is sufficient to ensure ngDevMode
     * is defined for the entire instruction set.
     *
     * When checking `ngDevMode` on toplevel, always init it before referencing it
     * (e.g. `((typeof ngDevMode === 'undefined' || ngDevMode) && initNgDevMode())`), otherwise you can
     *  get a `ReferenceError` like in https://github.com/angular/angular/issues/31595.
     *
     * Details on possible values for `ngDevMode` can be found on its docstring.
     *
     * NOTE:
     * - changes to the `ngDevMode` name must be synced with `compiler-cli/src/tooling.ts`.
     */
    function initNgDevMode() {
        // The below checks are to ensure that calling `initNgDevMode` multiple times does not
        // reset the counters.
        // If the `ngDevMode` is not an object, then it means we have not created the perf counters
        // yet.
        if (typeof ngDevMode === 'undefined' || ngDevMode) {
            if (typeof ngDevMode !== 'object') {
                ngDevModeResetPerfCounters();
            }
            return typeof ngDevMode !== 'undefined' && !!ngDevMode;
        }
        return false;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * This file contains reuseable "empty" symbols that can be used as default return values
     * in different parts of the rendering code. Because the same symbols are returned, this
     * allows for identity checks against these values to be consistently used by the framework
     * code.
     */
    const EMPTY_OBJ = {};
    const EMPTY_ARRAY = [];
    // freezing the values prevents any code from accidentally inserting new values in
    if ((typeof ngDevMode === 'undefined' || ngDevMode) && initNgDevMode()) {
        // These property accesses can be ignored because ngDevMode will be set to false
        // when optimizing code and the whole if statement will be dropped.
        // tslint:disable-next-line:no-toplevel-property-access
        Object.freeze(EMPTY_OBJ);
        // tslint:disable-next-line:no-toplevel-property-access
        Object.freeze(EMPTY_ARRAY);
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const NG_COMP_DEF = getClosureSafeProperty({ Éµcmp: getClosureSafeProperty });
    const NG_DIR_DEF = getClosureSafeProperty({ Éµdir: getClosureSafeProperty });
    const NG_PIPE_DEF = getClosureSafeProperty({ Éµpipe: getClosureSafeProperty });
    const NG_MOD_DEF = getClosureSafeProperty({ Éµmod: getClosureSafeProperty });
    const NG_LOC_ID_DEF = getClosureSafeProperty({ Éµloc: getClosureSafeProperty });
    const NG_FACTORY_DEF = getClosureSafeProperty({ Éµfac: getClosureSafeProperty });
    /**
     * If a directive is diPublic, bloomAdd sets a property on the type with this constant as
     * the key and the directive's unique ID as the value. This allows us to map directives to their
     * bloom filter bit for DI.
     */
    // TODO(misko): This is wrong. The NG_ELEMENT_ID should never be minified.
    const NG_ELEMENT_ID = getClosureSafeProperty({ __NG_ELEMENT_ID__: getClosureSafeProperty });

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * The following getter methods retrieve the definition from the type. Currently the retrieval
     * honors inheritance, but in the future we may change the rule to require that definitions are
     * explicit. This would require some sort of migration strategy.
     */
    function getComponentDef(type) {
        return type[NG_COMP_DEF] || null;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    // Below are constants for LView indices to help us look up LView members
    // without having to remember the specific indices.
    // Uglify will inline these when minifying so there shouldn't be a cost.
    const HOST = 0;
    const TVIEW = 1;
    const FLAGS = 2;
    const PARENT = 3;
    const NEXT = 4;
    const TRANSPLANTED_VIEWS_TO_REFRESH = 5;
    const T_HOST = 6;
    const CLEANUP = 7;
    const CONTEXT = 8;
    const INJECTOR = 9;
    const RENDERER_FACTORY = 10;
    const RENDERER = 11;
    const SANITIZER = 12;
    const CHILD_HEAD = 13;
    const CHILD_TAIL = 14;
    // FIXME(misko): Investigate if the three declarations aren't all same thing.
    const DECLARATION_VIEW = 15;
    const DECLARATION_COMPONENT_VIEW = 16;
    const DECLARATION_LCONTAINER = 17;
    const PREORDER_HOOK_FLAGS = 18;
    const QUERIES = 19;
    /**
     * Size of LView's header. Necessary to adjust for it when setting slots.
     *
     * IMPORTANT: `HEADER_OFFSET` should only be referred to the in the `ÉµÉµ*` instructions to translate
     * instruction index into `LView` index. All other indexes should be in the `LView` index space and
     * there should be no need to refer to `HEADER_OFFSET` anywhere else.
     */
    const HEADER_OFFSET = 20;
    /**
     * Converts `TViewType` into human readable text.
     * Make sure this matches with `TViewType`
     */
    const TViewTypeAsString = [
        'Root',
        'Component',
        'Embedded', // 2
    ];

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Special location which allows easy identification of type. If we have an array which was
     * retrieved from the `LView` and that array has `true` at `TYPE` location, we know it is
     * `LContainer`.
     */
    const TYPE = 1;
    /**
     * Below are constants for LContainer indices to help us look up LContainer members
     * without having to remember the specific indices.
     * Uglify will inline these when minifying so there shouldn't be a cost.
     */
    /**
     * Flag to signify that this `LContainer` may have transplanted views which need to be change
     * detected. (see: `LView[DECLARATION_COMPONENT_VIEW])`.
     *
     * This flag, once set, is never unset for the `LContainer`. This means that when unset we can skip
     * a lot of work in `refreshEmbeddedViews`. But when set we still need to verify
     * that the `MOVED_VIEWS` are transplanted and on-push.
     */
    const HAS_TRANSPLANTED_VIEWS = 2;
    // PARENT, NEXT, TRANSPLANTED_VIEWS_TO_REFRESH are indices 3, 4, and 5
    // As we already have these constants in LView, we don't need to re-create them.
    // T_HOST is index 6
    // We already have this constants in LView, we don't need to re-create it.
    const NATIVE = 7;
    const VIEW_REFS = 8;
    const MOVED_VIEWS = 9;
    /**
     * Size of LContainer's header. Represents the index after which all views in the
     * container will be inserted. We need to keep a record of current views so we know
     * which views are already in the DOM (and don't need to be re-added) and so we can
     * remove views from the DOM when they are no longer required.
     */
    const CONTAINER_HEADER_OFFSET = 10;

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * True if `value` is `LView`.
     * @param value wrapped value of `RNode`, `LView`, `LContainer`
     */
    function isLView(value) {
        return Array.isArray(value) && typeof value[TYPE] === 'object';
    }
    /**
     * True if `value` is `LContainer`.
     * @param value wrapped value of `RNode`, `LView`, `LContainer`
     */
    function isLContainer(value) {
        return Array.isArray(value) && value[TYPE] === true;
    }
    function isComponentHost(tNode) {
        return (tNode.flags & 2 /* isComponentHost */) === 2 /* isComponentHost */;
    }
    function isComponentDef(def) {
        return def.template !== null;
    }
    function isRootView(target) {
        return (target[FLAGS] & 512 /* IsRoot */) !== 0;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    // [Assert functions do not constraint type when they are guarded by a truthy
    // expression.](https://github.com/microsoft/TypeScript/issues/37295)
    function assertTNodeForLView(tNode, lView) {
        assertTNodeForTView(tNode, lView[TVIEW]);
    }
    function assertTNodeForTView(tNode, tView) {
        assertTNode(tNode);
        tNode.hasOwnProperty('tView_') &&
            assertEqual(tNode.tView_, tView, 'This TNode does not belong to this TView.');
    }
    function assertTNode(tNode) {
        assertDefined(tNode, 'TNode must be defined');
        if (!(tNode && typeof tNode === 'object' && tNode.hasOwnProperty('directiveStylingLast'))) {
            throwError('Not of type TNode, got: ' + tNode);
        }
    }
    function assertComponentType(actual, msg = 'Type passed in is not ComponentType, it does not have \'Éµcmp\' property.') {
        if (!getComponentDef(actual)) {
            throwError(msg);
        }
    }
    function assertLContainer(value) {
        assertDefined(value, 'LContainer must be defined');
        assertEqual(isLContainer(value), true, 'Expecting LContainer');
    }
    function assertLViewOrUndefined(value) {
        value && assertEqual(isLView(value), true, 'Expecting LView or undefined or null');
    }
    function assertLView(value) {
        assertDefined(value, 'LView must be defined');
        assertEqual(isLView(value), true, 'Expecting LView');
    }
    function assertFirstCreatePass(tView, errMessage) {
        assertEqual(tView.firstCreatePass, true, errMessage || 'Should only be called in first create pass.');
    }
    function assertFirstUpdatePass(tView, errMessage) {
        assertEqual(tView.firstUpdatePass, true, errMessage || 'Should only be called in first update pass.');
    }
    /**
     * This is a basic sanity check that an object is probably a directive def. DirectiveDef is
     * an interface, so we can't do a direct instanceof check.
     */
    function assertDirectiveDef(obj) {
        if (obj.type === undefined || obj.selectors == undefined || obj.inputs === undefined) {
            throwError(`Expected a DirectiveDef/ComponentDef and this object does not seem to have the expected shape.`);
        }
    }
    function assertIndexInDeclRange(lView, index) {
        const tView = lView[1];
        assertBetween(HEADER_OFFSET, tView.bindingStartIndex, index);
    }
    function assertIndexInExpandoRange(lView, index) {
        const tView = lView[1];
        assertBetween(tView.expandoStartIndex, lView.length, index);
    }
    function assertBetween(lower, upper, index) {
        if (!(lower <= index && index < upper)) {
            throwError(`Index out of range (expecting ${lower} <= ${index} < ${upper})`);
        }
    }
    function assertProjectionSlots(lView, errMessage) {
        assertDefined(lView[DECLARATION_COMPONENT_VIEW], 'Component views should exist.');
        assertDefined(lView[DECLARATION_COMPONENT_VIEW][T_HOST].projection, errMessage ||
            'Components with projection nodes (<ng-content>) must have projection slots defined.');
    }
    function assertParentView(lView, errMessage) {
        assertDefined(lView, errMessage || 'Component views should always have a parent view (component\'s host view)');
    }
    /**
     * This is a basic sanity check that the `injectorIndex` seems to point to what looks like a
     * NodeInjector data structure.
     *
     * @param lView `LView` which should be checked.
     * @param injectorIndex index into the `LView` where the `NodeInjector` is expected.
     */
    function assertNodeInjector(lView, injectorIndex) {
        assertIndexInExpandoRange(lView, injectorIndex);
        assertIndexInExpandoRange(lView, injectorIndex + 8 /* PARENT */);
        assertNumber(lView[injectorIndex + 0], 'injectorIndex should point to a bloom filter');
        assertNumber(lView[injectorIndex + 1], 'injectorIndex should point to a bloom filter');
        assertNumber(lView[injectorIndex + 2], 'injectorIndex should point to a bloom filter');
        assertNumber(lView[injectorIndex + 3], 'injectorIndex should point to a bloom filter');
        assertNumber(lView[injectorIndex + 4], 'injectorIndex should point to a bloom filter');
        assertNumber(lView[injectorIndex + 5], 'injectorIndex should point to a bloom filter');
        assertNumber(lView[injectorIndex + 6], 'injectorIndex should point to a bloom filter');
        assertNumber(lView[injectorIndex + 7], 'injectorIndex should point to a bloom filter');
        assertNumber(lView[injectorIndex + 8 /* PARENT */], 'injectorIndex should point to parent injector');
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function getFactoryDef(type, throwNotFound) {
        const hasFactoryDef = type.hasOwnProperty(NG_FACTORY_DEF);
        if (!hasFactoryDef && throwNotFound === true && ngDevMode) {
            throw new Error(`Type ${stringify$1(type)} does not have 'Éµfac' property.`);
        }
        return hasFactoryDef ? type[NG_FACTORY_DEF] : null;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Represents a basic change from a previous to a new value for a single
     * property on a directive instance. Passed as a value in a
     * {@link SimpleChanges} object to the `ngOnChanges` hook.
     *
     * @see `OnChanges`
     *
     * @publicApi
     */
    class SimpleChange {
        constructor(previousValue, currentValue, firstChange) {
            this.previousValue = previousValue;
            this.currentValue = currentValue;
            this.firstChange = firstChange;
        }
        /**
         * Check whether the new value is the first value assigned.
         */
        isFirstChange() {
            return this.firstChange;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function NgOnChangesFeatureImpl(definition) {
        if (definition.type.prototype.ngOnChanges) {
            definition.setInput = ngOnChangesSetInput;
        }
        return rememberChangeHistoryAndInvokeOnChangesHook;
    }
    /**
     * This is a synthetic lifecycle hook which gets inserted into `TView.preOrderHooks` to simulate
     * `ngOnChanges`.
     *
     * The hook reads the `NgSimpleChangesStore` data from the component instance and if changes are
     * found it invokes `ngOnChanges` on the component instance.
     *
     * @param this Component instance. Because this function gets inserted into `TView.preOrderHooks`,
     *     it is guaranteed to be called with component instance.
     */
    function rememberChangeHistoryAndInvokeOnChangesHook() {
        const simpleChangesStore = getSimpleChangesStore(this);
        const current = simpleChangesStore === null || simpleChangesStore === void 0 ? void 0 : simpleChangesStore.current;
        if (current) {
            const previous = simpleChangesStore.previous;
            if (previous === EMPTY_OBJ) {
                simpleChangesStore.previous = current;
            }
            else {
                // New changes are copied to the previous store, so that we don't lose history for inputs
                // which were not changed this time
                for (let key in current) {
                    previous[key] = current[key];
                }
            }
            simpleChangesStore.current = null;
            this.ngOnChanges(current);
        }
    }
    function ngOnChangesSetInput(instance, value, publicName, privateName) {
        const simpleChangesStore = getSimpleChangesStore(instance) ||
            setSimpleChangesStore(instance, { previous: EMPTY_OBJ, current: null });
        const current = simpleChangesStore.current || (simpleChangesStore.current = {});
        const previous = simpleChangesStore.previous;
        const declaredName = this.declaredInputs[publicName];
        const previousChange = previous[declaredName];
        current[declaredName] = new SimpleChange(previousChange && previousChange.currentValue, value, previous === EMPTY_OBJ);
        instance[privateName] = value;
    }
    const SIMPLE_CHANGES_STORE = '__ngSimpleChanges__';
    function getSimpleChangesStore(instance) {
        return instance[SIMPLE_CHANGES_STORE] || null;
    }
    function setSimpleChangesStore(instance, store) {
        return instance[SIMPLE_CHANGES_STORE] = store;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Profiler function which wraps user code executed by the runtime.
     *
     * @param event ProfilerEvent corresponding to the execution context
     * @param instance component instance
     * @param hookOrListener lifecycle hook function or output listener. The value depends on the
     *  execution context
     * @returns
     */
    const profiler = function (event, instance, hookOrListener) {
    };

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
    const MATH_ML_NAMESPACE = 'http://www.w3.org/1998/MathML/';

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Access the object that represents the `document` for this platform.
     *
     * Ivy calls this whenever it needs to access the `document` object.
     * For example to create the renderer or to do sanitization.
     */
    function getDocument() {
        if (typeof document !== 'undefined') {
            return document;
        }
        // No "document" can be found. This should only happen if we are running ivy outside Angular and
        // the current platform is not a browser. Since this is not a supported scenario at the moment
        // this should not happen in Angular apps.
        // Once we support running ivy outside of Angular we will need to publish `setDocument()` as a
        // public API. Meanwhile we just return `undefined` and let the application fail.
        return undefined;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    // TODO: cleanup once the code is merged in angular/angular
    var RendererStyleFlags3;
    (function (RendererStyleFlags3) {
        RendererStyleFlags3[RendererStyleFlags3["Important"] = 1] = "Important";
        RendererStyleFlags3[RendererStyleFlags3["DashCase"] = 2] = "DashCase";
    })(RendererStyleFlags3 || (RendererStyleFlags3 = {}));
    /** Returns whether the `renderer` is a `ProceduralRenderer3` */
    function isProceduralRenderer(renderer) {
        return !!(renderer.listen);
    }
    const Éµ0 = (hostElement, rendererType) => {
        return getDocument();
    };
    const domRendererFactory3 = {
        createRenderer: Éµ0
    };

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * For efficiency reasons we often put several different data types (`RNode`, `LView`, `LContainer`)
     * in same location in `LView`. This is because we don't want to pre-allocate space for it
     * because the storage is sparse. This file contains utilities for dealing with such data types.
     *
     * How do we know what is stored at a given location in `LView`.
     * - `Array.isArray(value) === false` => `RNode` (The normal storage value)
     * - `Array.isArray(value) === true` => then the `value[0]` represents the wrapped value.
     *   - `typeof value[TYPE] === 'object'` => `LView`
     *      - This happens when we have a component at a given location
     *   - `typeof value[TYPE] === true` => `LContainer`
     *      - This happens when we have `LContainer` binding at a given location.
     *
     *
     * NOTE: it is assumed that `Array.isArray` and `typeof` operations are very efficient.
     */
    /**
     * Returns `RNode`.
     * @param value wrapped value of `RNode`, `LView`, `LContainer`
     */
    function unwrapRNode(value) {
        while (Array.isArray(value)) {
            value = value[HOST];
        }
        return value;
    }
    /**
     * Retrieve an `RNode` for a given `TNode` and `LView`.
     *
     * This function guarantees in dev mode to retrieve a non-null `RNode`.
     *
     * @param tNode
     * @param lView
     */
    function getNativeByTNode(tNode, lView) {
        ngDevMode && assertTNodeForLView(tNode, lView);
        ngDevMode && assertIndexInRange(lView, tNode.index);
        const node = unwrapRNode(lView[tNode.index]);
        ngDevMode && !isProceduralRenderer(lView[RENDERER]) && assertDomNode(node);
        return node;
    }
    // fixme(misko): The return Type should be `TNode|null`
    function getTNode(tView, index) {
        ngDevMode && assertGreaterThan(index, -1, 'wrong index for TNode');
        ngDevMode && assertLessThan(index, tView.data.length, 'wrong index for TNode');
        const tNode = tView.data[index];
        ngDevMode && tNode !== null && assertTNode(tNode);
        return tNode;
    }
    function getComponentLViewByIndex(nodeIndex, hostView) {
        // Could be an LView or an LContainer. If LContainer, unwrap to find LView.
        ngDevMode && assertIndexInRange(hostView, nodeIndex);
        const slotValue = hostView[nodeIndex];
        const lView = isLView(slotValue) ? slotValue : slotValue[HOST];
        return lView;
    }
    /** Checks whether a given view is in creation mode */
    function isCreationMode(view) {
        return (view[FLAGS] & 4 /* CreationMode */) === 4 /* CreationMode */;
    }
    /**
     * Returns a boolean for whether the view is attached to the change detection tree.
     *
     * Note: This determines whether a view should be checked, not whether it's inserted
     * into a container. For that, you'll want `viewAttachedToContainer` below.
     */
    function viewAttachedToChangeDetector(view) {
        return (view[FLAGS] & 128 /* Attached */) === 128 /* Attached */;
    }
    /**
     * Resets the pre-order hook flags of the view.
     * @param lView the LView on which the flags are reset
     */
    function resetPreOrderHookFlags(lView) {
        lView[PREORDER_HOOK_FLAGS] = 0;
    }
    /**
     * Updates the `TRANSPLANTED_VIEWS_TO_REFRESH` counter on the `LContainer` as well as the parents
     * whose
     *  1. counter goes from 0 to 1, indicating that there is a new child that has a view to refresh
     *  or
     *  2. counter goes from 1 to 0, indicating there are no more descendant views to refresh
     */
    function updateTransplantedViewCount(lContainer, amount) {
        lContainer[TRANSPLANTED_VIEWS_TO_REFRESH] += amount;
        let viewOrContainer = lContainer;
        let parent = lContainer[PARENT];
        while (parent !== null &&
            ((amount === 1 && viewOrContainer[TRANSPLANTED_VIEWS_TO_REFRESH] === 1) ||
                (amount === -1 && viewOrContainer[TRANSPLANTED_VIEWS_TO_REFRESH] === 0))) {
            parent[TRANSPLANTED_VIEWS_TO_REFRESH] += amount;
            viewOrContainer = parent;
            parent = parent[PARENT];
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const instructionState = {
        lFrame: createLFrame(null),
        bindingsEnabled: true,
        isInCheckNoChangesMode: false,
    };
    /**
     * Return the current `LView`.
     */
    function getLView() {
        return instructionState.lFrame.lView;
    }
    /**
     * Return the current `TView`.
     */
    function getTView() {
        return instructionState.lFrame.tView;
    }
    function getCurrentTNode() {
        let currentTNode = getCurrentTNodePlaceholderOk();
        while (currentTNode !== null && currentTNode.type === 64 /* Placeholder */) {
            currentTNode = currentTNode.parent;
        }
        return currentTNode;
    }
    function getCurrentTNodePlaceholderOk() {
        return instructionState.lFrame.currentTNode;
    }
    function getCurrentParentTNode() {
        const lFrame = instructionState.lFrame;
        const currentTNode = lFrame.currentTNode;
        return lFrame.isParent ? currentTNode : currentTNode.parent;
    }
    function setCurrentTNode(tNode, isParent) {
        ngDevMode && tNode && assertTNodeForTView(tNode, instructionState.lFrame.tView);
        const lFrame = instructionState.lFrame;
        lFrame.currentTNode = tNode;
        lFrame.isParent = isParent;
    }
    function isCurrentTNodeParent() {
        return instructionState.lFrame.isParent;
    }
    function isInCheckNoChangesMode() {
        // TODO(misko): remove this from the LView since it is ngDevMode=true mode only.
        return instructionState.isInCheckNoChangesMode;
    }
    function setIsInCheckNoChangesMode(mode) {
        instructionState.isInCheckNoChangesMode = mode;
    }
    function setBindingIndex(value) {
        return instructionState.lFrame.bindingIndex = value;
    }
    function isInI18nBlock() {
        return instructionState.lFrame.inI18n;
    }
    /**
     * Set a new binding root index so that host template functions can execute.
     *
     * Bindings inside the host template are 0 index. But because we don't know ahead of time
     * how many host bindings we have we can't pre-compute them. For this reason they are all
     * 0 index and we just shift the root so that they match next available location in the LView.
     *
     * @param bindingRootIndex Root index for `hostBindings`
     * @param currentDirectiveIndex `TData[currentDirectiveIndex]` will point to the current directive
     *        whose `hostBindings` are being processed.
     */
    function setBindingRootForHostBindings(bindingRootIndex, currentDirectiveIndex) {
        const lFrame = instructionState.lFrame;
        lFrame.bindingIndex = lFrame.bindingRootIndex = bindingRootIndex;
        setCurrentDirectiveIndex(currentDirectiveIndex);
    }
    /**
     * Sets an index of a directive whose `hostBindings` are being processed.
     *
     * @param currentDirectiveIndex `TData` index where current directive instance can be found.
     */
    function setCurrentDirectiveIndex(currentDirectiveIndex) {
        instructionState.lFrame.currentDirectiveIndex = currentDirectiveIndex;
    }
    function setCurrentQueryIndex(value) {
        instructionState.lFrame.currentQueryIndex = value;
    }
    /**
     * Returns a `TNode` of the location where the current `LView` is declared at.
     *
     * @param lView an `LView` that we want to find parent `TNode` for.
     */
    function getDeclarationTNode(lView) {
        const tView = lView[TVIEW];
        // Return the declaration parent for embedded views
        if (tView.type === 2 /* Embedded */) {
            ngDevMode && assertDefined(tView.declTNode, 'Embedded TNodes should have declaration parents.');
            return tView.declTNode;
        }
        // Components don't have `TView.declTNode` because each instance of component could be
        // inserted in different location, hence `TView.declTNode` is meaningless.
        // Falling back to `T_HOST` in case we cross component boundary.
        if (tView.type === 1 /* Component */) {
            return lView[T_HOST];
        }
        // Remaining TNode type is `TViewType.Root` which doesn't have a parent TNode.
        return null;
    }
    /**
     * This is a light weight version of the `enterView` which is needed by the DI system.
     *
     * @param lView `LView` location of the DI context.
     * @param tNode `TNode` for DI context
     * @param flags DI context flags. if `SkipSelf` flag is set than we walk up the declaration
     *     tree from `tNode`  until we find parent declared `TElementNode`.
     * @returns `true` if we have successfully entered DI associated with `tNode` (or with declared
     *     `TNode` if `flags` has  `SkipSelf`). Failing to enter DI implies that no associated
     *     `NodeInjector` can be found and we should instead use `ModuleInjector`.
     *     - If `true` than this call must be fallowed by `leaveDI`
     *     - If `false` than this call failed and we should NOT call `leaveDI`
     */
    function enterDI(lView, tNode, flags) {
        ngDevMode && assertLViewOrUndefined(lView);
        if (flags & InjectFlags.SkipSelf) {
            ngDevMode && assertTNodeForTView(tNode, lView[TVIEW]);
            let parentTNode = tNode;
            let parentLView = lView;
            while (true) {
                ngDevMode && assertDefined(parentTNode, 'Parent TNode should be defined');
                parentTNode = parentTNode.parent;
                if (parentTNode === null && !(flags & InjectFlags.Host)) {
                    parentTNode = getDeclarationTNode(parentLView);
                    if (parentTNode === null)
                        break;
                    // In this case, a parent exists and is definitely an element. So it will definitely
                    // have an existing lView as the declaration view, which is why we can assume it's defined.
                    ngDevMode && assertDefined(parentLView, 'Parent LView should be defined');
                    parentLView = parentLView[DECLARATION_VIEW];
                    // In Ivy there are Comment nodes that correspond to ngIf and NgFor embedded directives
                    // We want to skip those and look only at Elements and ElementContainers to ensure
                    // we're looking at true parent nodes, and not content or other types.
                    if (parentTNode.type & (2 /* Element */ | 8 /* ElementContainer */)) {
                        break;
                    }
                }
                else {
                    break;
                }
            }
            if (parentTNode === null) {
                // If we failed to find a parent TNode this means that we should use module injector.
                return false;
            }
            else {
                tNode = parentTNode;
                lView = parentLView;
            }
        }
        ngDevMode && assertTNodeForLView(tNode, lView);
        const lFrame = instructionState.lFrame = allocLFrame();
        lFrame.currentTNode = tNode;
        lFrame.lView = lView;
        return true;
    }
    /**
     * Swap the current lView with a new lView.
     *
     * For performance reasons we store the lView in the top level of the module.
     * This way we minimize the number of properties to read. Whenever a new view
     * is entered we have to store the lView for later, and when the view is
     * exited the state has to be restored
     *
     * @param newView New lView to become active
     * @returns the previously active lView;
     */
    function enterView(newView) {
        ngDevMode && assertNotEqual(newView[0], newView[1], '????');
        ngDevMode && assertLViewOrUndefined(newView);
        const newLFrame = allocLFrame();
        if (ngDevMode) {
            assertEqual(newLFrame.isParent, true, 'Expected clean LFrame');
            assertEqual(newLFrame.lView, null, 'Expected clean LFrame');
            assertEqual(newLFrame.tView, null, 'Expected clean LFrame');
            assertEqual(newLFrame.selectedIndex, -1, 'Expected clean LFrame');
            assertEqual(newLFrame.elementDepthCount, 0, 'Expected clean LFrame');
            assertEqual(newLFrame.currentDirectiveIndex, -1, 'Expected clean LFrame');
            assertEqual(newLFrame.currentNamespace, null, 'Expected clean LFrame');
            assertEqual(newLFrame.bindingRootIndex, -1, 'Expected clean LFrame');
            assertEqual(newLFrame.currentQueryIndex, 0, 'Expected clean LFrame');
        }
        const tView = newView[TVIEW];
        instructionState.lFrame = newLFrame;
        ngDevMode && tView.firstChild && assertTNodeForTView(tView.firstChild, tView);
        newLFrame.currentTNode = tView.firstChild;
        newLFrame.lView = newView;
        newLFrame.tView = tView;
        newLFrame.contextLView = newView;
        newLFrame.bindingIndex = tView.bindingStartIndex;
        newLFrame.inI18n = false;
    }
    /**
     * Allocates next free LFrame. This function tries to reuse the `LFrame`s to lower memory pressure.
     */
    function allocLFrame() {
        const currentLFrame = instructionState.lFrame;
        const childLFrame = currentLFrame === null ? null : currentLFrame.child;
        const newLFrame = childLFrame === null ? createLFrame(currentLFrame) : childLFrame;
        return newLFrame;
    }
    function createLFrame(parent) {
        const lFrame = {
            currentTNode: null,
            isParent: true,
            lView: null,
            tView: null,
            selectedIndex: -1,
            contextLView: null,
            elementDepthCount: 0,
            currentNamespace: null,
            currentDirectiveIndex: -1,
            bindingRootIndex: -1,
            bindingIndex: -1,
            currentQueryIndex: 0,
            parent: parent,
            child: null,
            inI18n: false,
        };
        parent !== null && (parent.child = lFrame); // link the new LFrame for reuse.
        return lFrame;
    }
    /**
     * A lightweight version of leave which is used with DI.
     *
     * This function only resets `currentTNode` and `LView` as those are the only properties
     * used with DI (`enterDI()`).
     *
     * NOTE: This function is reexported as `leaveDI`. However `leaveDI` has return type of `void` where
     * as `leaveViewLight` has `LFrame`. This is so that `leaveViewLight` can be used in `leaveView`.
     */
    function leaveViewLight() {
        const oldLFrame = instructionState.lFrame;
        instructionState.lFrame = oldLFrame.parent;
        oldLFrame.currentTNode = null;
        oldLFrame.lView = null;
        return oldLFrame;
    }
    /**
     * This is a lightweight version of the `leaveView` which is needed by the DI system.
     *
     * NOTE: this function is an alias so that we can change the type of the function to have `void`
     * return type.
     */
    const leaveDI = leaveViewLight;
    /**
     * Leave the current `LView`
     *
     * This pops the `LFrame` with the associated `LView` from the stack.
     *
     * IMPORTANT: We must zero out the `LFrame` values here otherwise they will be retained. This is
     * because for performance reasons we don't release `LFrame` but rather keep it for next use.
     */
    function leaveView() {
        const oldLFrame = leaveViewLight();
        oldLFrame.isParent = true;
        oldLFrame.tView = null;
        oldLFrame.selectedIndex = -1;
        oldLFrame.contextLView = null;
        oldLFrame.elementDepthCount = 0;
        oldLFrame.currentDirectiveIndex = -1;
        oldLFrame.currentNamespace = null;
        oldLFrame.bindingRootIndex = -1;
        oldLFrame.bindingIndex = -1;
        oldLFrame.currentQueryIndex = 0;
    }
    /**
     * Gets the currently selected element index.
     *
     * Used with {@link property} instruction (and more in the future) to identify the index in the
     * current `LView` to act on.
     */
    function getSelectedIndex() {
        return instructionState.lFrame.selectedIndex;
    }
    /**
     * Sets the most recent index passed to {@link select}
     *
     * Used with {@link property} instruction (and more in the future) to identify the index in the
     * current `LView` to act on.
     *
     * (Note that if an "exit function" was set earlier (via `setElementExitFn()`) then that will be
     * run if and when the provided `index` value is different from the current selected index value.)
     */
    function setSelectedIndex(index) {
        ngDevMode && index !== -1 &&
            assertGreaterThanOrEqual(index, HEADER_OFFSET, 'Index must be past HEADER_OFFSET (or -1).');
        ngDevMode &&
            assertLessThan(index, instructionState.lFrame.lView.length, 'Can\'t set index passed end of LView');
        instructionState.lFrame.selectedIndex = index;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Adds all directive lifecycle hooks from the given `DirectiveDef` to the given `TView`.
     *
     * Must be run *only* on the first template pass.
     *
     * Sets up the pre-order hooks on the provided `tView`,
     * see {@link HookData} for details about the data structure.
     *
     * @param directiveIndex The index of the directive in LView
     * @param directiveDef The definition containing the hooks to setup in tView
     * @param tView The current TView
     */
    function registerPreOrderHooks(directiveIndex, directiveDef, tView) {
        ngDevMode && assertFirstCreatePass(tView);
        const { ngOnChanges, ngOnInit, ngDoCheck } = directiveDef.type.prototype;
        if (ngOnChanges) {
            const wrappedOnChanges = NgOnChangesFeatureImpl(directiveDef);
            (tView.preOrderHooks || (tView.preOrderHooks = [])).push(directiveIndex, wrappedOnChanges);
            (tView.preOrderCheckHooks || (tView.preOrderCheckHooks = []))
                .push(directiveIndex, wrappedOnChanges);
        }
        if (ngOnInit) {
            (tView.preOrderHooks || (tView.preOrderHooks = [])).push(0 - directiveIndex, ngOnInit);
        }
        if (ngDoCheck) {
            (tView.preOrderHooks || (tView.preOrderHooks = [])).push(directiveIndex, ngDoCheck);
            (tView.preOrderCheckHooks || (tView.preOrderCheckHooks = [])).push(directiveIndex, ngDoCheck);
        }
    }
    /**
     *
     * Loops through the directives on the provided `tNode` and queues hooks to be
     * run that are not initialization hooks.
     *
     * Should be executed during `elementEnd()` and similar to
     * preserve hook execution order. Content, view, and destroy hooks for projected
     * components and directives must be called *before* their hosts.
     *
     * Sets up the content, view, and destroy hooks on the provided `tView`,
     * see {@link HookData} for details about the data structure.
     *
     * NOTE: This does not set up `onChanges`, `onInit` or `doCheck`, those are set up
     * separately at `elementStart`.
     *
     * @param tView The current TView
     * @param tNode The TNode whose directives are to be searched for hooks to queue
     */
    function registerPostOrderHooks(tView, tNode) {
        ngDevMode && assertFirstCreatePass(tView);
        // It's necessary to loop through the directives at elementEnd() (rather than processing in
        // directiveCreate) so we can preserve the current hook order. Content, view, and destroy
        // hooks for projected components and directives must be called *before* their hosts.
        for (let i = tNode.directiveStart, end = tNode.directiveEnd; i < end; i++) {
            const directiveDef = tView.data[i];
            ngDevMode && assertDefined(directiveDef, 'Expecting DirectiveDef');
            const lifecycleHooks = directiveDef.type.prototype;
            const { ngAfterContentInit, ngAfterContentChecked, ngAfterViewInit, ngAfterViewChecked, ngOnDestroy } = lifecycleHooks;
            if (ngAfterContentInit) {
                (tView.contentHooks || (tView.contentHooks = [])).push(-i, ngAfterContentInit);
            }
            if (ngAfterContentChecked) {
                (tView.contentHooks || (tView.contentHooks = [])).push(i, ngAfterContentChecked);
                (tView.contentCheckHooks || (tView.contentCheckHooks = [])).push(i, ngAfterContentChecked);
            }
            if (ngAfterViewInit) {
                (tView.viewHooks || (tView.viewHooks = [])).push(-i, ngAfterViewInit);
            }
            if (ngAfterViewChecked) {
                (tView.viewHooks || (tView.viewHooks = [])).push(i, ngAfterViewChecked);
                (tView.viewCheckHooks || (tView.viewCheckHooks = [])).push(i, ngAfterViewChecked);
            }
            if (ngOnDestroy != null) {
                (tView.destroyHooks || (tView.destroyHooks = [])).push(i, ngOnDestroy);
            }
        }
    }
    /**
     * Executing hooks requires complex logic as we need to deal with 2 constraints.
     *
     * 1. Init hooks (ngOnInit, ngAfterContentInit, ngAfterViewInit) must all be executed once and only
     * once, across many change detection cycles. This must be true even if some hooks throw, or if
     * some recursively trigger a change detection cycle.
     * To solve that, it is required to track the state of the execution of these init hooks.
     * This is done by storing and maintaining flags in the view: the {@link InitPhaseState},
     * and the index within that phase. They can be seen as a cursor in the following structure:
     * [[onInit1, onInit2], [afterContentInit1], [afterViewInit1, afterViewInit2, afterViewInit3]]
     * They are are stored as flags in LView[FLAGS].
     *
     * 2. Pre-order hooks can be executed in batches, because of the select instruction.
     * To be able to pause and resume their execution, we also need some state about the hook's array
     * that is being processed:
     * - the index of the next hook to be executed
     * - the number of init hooks already found in the processed part of the  array
     * They are are stored as flags in LView[PREORDER_HOOK_FLAGS].
     */
    /**
     * Executes pre-order check hooks ( OnChanges, DoChanges) given a view where all the init hooks were
     * executed once. This is a light version of executeInitAndCheckPreOrderHooks where we can skip read
     * / write of the init-hooks related flags.
     * @param lView The LView where hooks are defined
     * @param hooks Hooks to be run
     * @param nodeIndex 3 cases depending on the value:
     * - undefined: all hooks from the array should be executed (post-order case)
     * - null: execute hooks only from the saved index until the end of the array (pre-order case, when
     * flushing the remaining hooks)
     * - number: execute hooks only from the saved index until that node index exclusive (pre-order
     * case, when executing select(number))
     */
    function executeCheckHooks(lView, hooks, nodeIndex) {
        callHooks(lView, hooks, 3 /* InitPhaseCompleted */, nodeIndex);
    }
    /**
     * Executes post-order init and check hooks (one of AfterContentInit, AfterContentChecked,
     * AfterViewInit, AfterViewChecked) given a view where there are pending init hooks to be executed.
     * @param lView The LView where hooks are defined
     * @param hooks Hooks to be run
     * @param initPhase A phase for which hooks should be run
     * @param nodeIndex 3 cases depending on the value:
     * - undefined: all hooks from the array should be executed (post-order case)
     * - null: execute hooks only from the saved index until the end of the array (pre-order case, when
     * flushing the remaining hooks)
     * - number: execute hooks only from the saved index until that node index exclusive (pre-order
     * case, when executing select(number))
     */
    function executeInitAndCheckHooks(lView, hooks, initPhase, nodeIndex) {
        ngDevMode &&
            assertNotEqual(initPhase, 3 /* InitPhaseCompleted */, 'Init pre-order hooks should not be called more than once');
        if ((lView[FLAGS] & 3 /* InitPhaseStateMask */) === initPhase) {
            callHooks(lView, hooks, initPhase, nodeIndex);
        }
    }
    function incrementInitPhaseFlags(lView, initPhase) {
        ngDevMode &&
            assertNotEqual(initPhase, 3 /* InitPhaseCompleted */, 'Init hooks phase should not be incremented after all init hooks have been run.');
        let flags = lView[FLAGS];
        if ((flags & 3 /* InitPhaseStateMask */) === initPhase) {
            flags &= 2047 /* IndexWithinInitPhaseReset */;
            flags += 1 /* InitPhaseStateIncrementer */;
            lView[FLAGS] = flags;
        }
    }
    /**
     * Calls lifecycle hooks with their contexts, skipping init hooks if it's not
     * the first LView pass
     *
     * @param currentView The current view
     * @param arr The array in which the hooks are found
     * @param initPhaseState the current state of the init phase
     * @param currentNodeIndex 3 cases depending on the value:
     * - undefined: all hooks from the array should be executed (post-order case)
     * - null: execute hooks only from the saved index until the end of the array (pre-order case, when
     * flushing the remaining hooks)
     * - number: execute hooks only from the saved index until that node index exclusive (pre-order
     * case, when executing select(number))
     */
    function callHooks(currentView, arr, initPhase, currentNodeIndex) {
        ngDevMode &&
            assertEqual(isInCheckNoChangesMode(), false, 'Hooks should never be run when in check no changes mode.');
        const startIndex = currentNodeIndex !== undefined ?
            (currentView[PREORDER_HOOK_FLAGS] & 65535 /* IndexOfTheNextPreOrderHookMaskMask */) :
            0;
        const nodeIndexLimit = currentNodeIndex != null ? currentNodeIndex : -1;
        const max = arr.length - 1; // Stop the loop at length - 1, because we look for the hook at i + 1
        let lastNodeIndexFound = 0;
        for (let i = startIndex; i < max; i++) {
            const hook = arr[i + 1];
            if (typeof hook === 'number') {
                lastNodeIndexFound = arr[i];
                if (currentNodeIndex != null && lastNodeIndexFound >= currentNodeIndex) {
                    break;
                }
            }
            else {
                const isInitHook = arr[i] < 0;
                if (isInitHook)
                    currentView[PREORDER_HOOK_FLAGS] += 65536 /* NumberOfInitHooksCalledIncrementer */;
                if (lastNodeIndexFound < nodeIndexLimit || nodeIndexLimit == -1) {
                    callHook(currentView, initPhase, arr, i);
                    currentView[PREORDER_HOOK_FLAGS] =
                        (currentView[PREORDER_HOOK_FLAGS] & 4294901760 /* NumberOfInitHooksCalledMask */) + i +
                            2;
                }
                i++;
            }
        }
    }
    /**
     * Execute one hook against the current `LView`.
     *
     * @param currentView The current view
     * @param initPhaseState the current state of the init phase
     * @param arr The array in which the hooks are found
     * @param i The current index within the hook data array
     */
    function callHook(currentView, initPhase, arr, i) {
        const isInitHook = arr[i] < 0;
        const hook = arr[i + 1];
        const directiveIndex = isInitHook ? -arr[i] : arr[i];
        const directive = currentView[directiveIndex];
        if (isInitHook) {
            const indexWithintInitPhase = currentView[FLAGS] >> 11 /* IndexWithinInitPhaseShift */;
            // The init phase state must be always checked here as it may have been recursively updated.
            if (indexWithintInitPhase <
                (currentView[PREORDER_HOOK_FLAGS] >> 16 /* NumberOfInitHooksCalledShift */) &&
                (currentView[FLAGS] & 3 /* InitPhaseStateMask */) === initPhase) {
                currentView[FLAGS] += 2048 /* IndexWithinInitPhaseIncrementer */;
                try {
                    hook.call(directive);
                }
                finally {
                }
            }
        }
        else {
            try {
                hook.call(directive);
            }
            finally {
            }
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const NO_PARENT_INJECTOR = -1;
    /**
     * Each injector is saved in 9 contiguous slots in `LView` and 9 contiguous slots in
     * `TView.data`. This allows us to store information about the current node's tokens (which
     * can be shared in `TView`) as well as the tokens of its ancestor nodes (which cannot be
     * shared, so they live in `LView`).
     *
     * Each of these slots (aside from the last slot) contains a bloom filter. This bloom filter
     * determines whether a directive is available on the associated node or not. This prevents us
     * from searching the directives array at this level unless it's probable the directive is in it.
     *
     * See: https://en.wikipedia.org/wiki/Bloom_filter for more about bloom filters.
     *
     * Because all injectors have been flattened into `LView` and `TViewData`, they cannot typed
     * using interfaces as they were previously. The start index of each `LInjector` and `TInjector`
     * will differ based on where it is flattened into the main array, so it's not possible to know
     * the indices ahead of time and save their types here. The interfaces are still included here
     * for documentation purposes.
     *
     * export interface LInjector extends Array<any> {
     *
     *    // Cumulative bloom for directive IDs 0-31  (IDs are % BLOOM_SIZE)
     *    [0]: number;
     *
     *    // Cumulative bloom for directive IDs 32-63
     *    [1]: number;
     *
     *    // Cumulative bloom for directive IDs 64-95
     *    [2]: number;
     *
     *    // Cumulative bloom for directive IDs 96-127
     *    [3]: number;
     *
     *    // Cumulative bloom for directive IDs 128-159
     *    [4]: number;
     *
     *    // Cumulative bloom for directive IDs 160 - 191
     *    [5]: number;
     *
     *    // Cumulative bloom for directive IDs 192 - 223
     *    [6]: number;
     *
     *    // Cumulative bloom for directive IDs 224 - 255
     *    [7]: number;
     *
     *    // We need to store a reference to the injector's parent so DI can keep looking up
     *    // the injector tree until it finds the dependency it's looking for.
     *    [PARENT_INJECTOR]: number;
     * }
     *
     * export interface TInjector extends Array<any> {
     *
     *    // Shared node bloom for directive IDs 0-31  (IDs are % BLOOM_SIZE)
     *    [0]: number;
     *
     *    // Shared node bloom for directive IDs 32-63
     *    [1]: number;
     *
     *    // Shared node bloom for directive IDs 64-95
     *    [2]: number;
     *
     *    // Shared node bloom for directive IDs 96-127
     *    [3]: number;
     *
     *    // Shared node bloom for directive IDs 128-159
     *    [4]: number;
     *
     *    // Shared node bloom for directive IDs 160 - 191
     *    [5]: number;
     *
     *    // Shared node bloom for directive IDs 192 - 223
     *    [6]: number;
     *
     *    // Shared node bloom for directive IDs 224 - 255
     *    [7]: number;
     *
     *    // Necessary to find directive indices for a particular node.
     *    [TNODE]: TElementNode|TElementContainerNode|TContainerNode;
     *  }
     */
    /**
     * Factory for creating instances of injectors in the NodeInjector.
     *
     * This factory is complicated by the fact that it can resolve `multi` factories as well.
     *
     * NOTE: Some of the fields are optional which means that this class has two hidden classes.
     * - One without `multi` support (most common)
     * - One with `multi` values, (rare).
     *
     * Since VMs can cache up to 4 inline hidden classes this is OK.
     *
     * - Single factory: Only `resolving` and `factory` is defined.
     * - `providers` factory: `componentProviders` is a number and `index = -1`.
     * - `viewProviders` factory: `componentProviders` is a number and `index` points to `providers`.
     */
    class NodeInjectorFactory {
        constructor(
        /**
         * Factory to invoke in order to create a new instance.
         */
        factory, 
        /**
         * Set to `true` if the token is declared in `viewProviders` (or if it is component).
         */
        isViewProvider, injectImplementation) {
            this.factory = factory;
            /**
             * Marker set to true during factory invocation to see if we get into recursive loop.
             * Recursive loop causes an error to be displayed.
             */
            this.resolving = false;
            ngDevMode && assertDefined(factory, 'Factory not specified');
            ngDevMode && assertEqual(typeof factory, 'function', 'Expected factory function.');
            this.canSeeViewProviders = isViewProvider;
            this.injectImpl = injectImplementation;
        }
    }
    function isFactory(obj) {
        return obj instanceof NodeInjectorFactory;
    }

    /**
     * Converts `TNodeType` into human readable text.
     * Make sure this matches with `TNodeType`
     */
    function toTNodeTypeAsString(tNodeType) {
        let text = '';
        (tNodeType & 1 /* Text */) && (text += '|Text');
        (tNodeType & 2 /* Element */) && (text += '|Element');
        (tNodeType & 4 /* Container */) && (text += '|Container');
        (tNodeType & 8 /* ElementContainer */) && (text += '|ElementContainer');
        (tNodeType & 16 /* Projection */) && (text += '|Projection');
        (tNodeType & 32 /* Icu */) && (text += '|IcuContainer');
        (tNodeType & 64 /* Placeholder */) && (text += '|Placeholder');
        return text.length > 0 ? text.substring(1) : text;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function assertTNodeType(tNode, expectedTypes, message) {
        assertDefined(tNode, 'should be called with a TNode');
        if ((tNode.type & expectedTypes) === 0) {
            throwError(message ||
                `Expected [${toTNodeTypeAsString(expectedTypes)}] but got ${toTNodeTypeAsString(tNode.type)}.`);
        }
    }
    function assertPureTNodeType(type) {
        if (!(type === 2 /* Element */ || //
            type === 1 /* Text */ || //
            type === 4 /* Container */ || //
            type === 8 /* ElementContainer */ || //
            type === 32 /* Icu */ || //
            type === 16 /* Projection */ || //
            type === 64 /* Placeholder */)) {
            throwError(`Expected TNodeType to have only a single type selected, but got ${toTNodeTypeAsString(type)}.`);
        }
    }

    /**
     * Assigns all attribute values to the provided element via the inferred renderer.
     *
     * This function accepts two forms of attribute entries:
     *
     * default: (key, value):
     *  attrs = [key1, value1, key2, value2]
     *
     * namespaced: (NAMESPACE_MARKER, uri, name, value)
     *  attrs = [NAMESPACE_MARKER, uri, name, value, NAMESPACE_MARKER, uri, name, value]
     *
     * The `attrs` array can contain a mix of both the default and namespaced entries.
     * The "default" values are set without a marker, but if the function comes across
     * a marker value then it will attempt to set a namespaced value. If the marker is
     * not of a namespaced value then the function will quit and return the index value
     * where it stopped during the iteration of the attrs array.
     *
     * See [AttributeMarker] to understand what the namespace marker value is.
     *
     * Note that this instruction does not support assigning style and class values to
     * an element. See `elementStart` and `elementHostAttrs` to learn how styling values
     * are applied to an element.
     * @param renderer The renderer to be used
     * @param native The element that the attributes will be assigned to
     * @param attrs The attribute array of values that will be assigned to the element
     * @returns the index value that was last accessed in the attributes array
     */
    function setUpAttributes(renderer, native, attrs) {
        const isProc = isProceduralRenderer(renderer);
        let i = 0;
        while (i < attrs.length) {
            const value = attrs[i];
            if (typeof value === 'number') {
                // only namespaces are supported. Other value types (such as style/class
                // entries) are not supported in this function.
                if (value !== 0 /* NamespaceURI */) {
                    break;
                }
                // we just landed on the marker value ... therefore
                // we should skip to the next entry
                i++;
                const namespaceURI = attrs[i++];
                const attrName = attrs[i++];
                const attrVal = attrs[i++];
                ngDevMode && ngDevMode.rendererSetAttribute++;
                isProc ?
                    renderer.setAttribute(native, attrName, attrVal, namespaceURI) :
                    native.setAttributeNS(namespaceURI, attrName, attrVal);
            }
            else {
                // attrName is string;
                const attrName = value;
                const attrVal = attrs[++i];
                // Standard attributes
                ngDevMode && ngDevMode.rendererSetAttribute++;
                if (isAnimationProp(attrName)) {
                    if (isProc) {
                        renderer.setProperty(native, attrName, attrVal);
                    }
                }
                else {
                    isProc ?
                        renderer.setAttribute(native, attrName, attrVal) :
                        native.setAttribute(attrName, attrVal);
                }
                i++;
            }
        }
        // another piece of code may iterate over the same attributes array. Therefore
        // it may be helpful to return the exact spot where the attributes array exited
        // whether by running into an unsupported marker or if all the static values were
        // iterated over.
        return i;
    }
    function isAnimationProp(name) {
        // Perf note: accessing charCodeAt to check for the first character of a string is faster as
        // compared to accessing a character at index 0 (ex. name[0]). The main reason for this is that
        // charCodeAt doesn't allocate memory to return a substring.
        return name.charCodeAt(0) === 64 /* AT_SIGN */;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /// Parent Injector Utils ///////////////////////////////////////////////////////////////
    function hasParentInjector(parentLocation) {
        return parentLocation !== NO_PARENT_INJECTOR;
    }
    function getParentInjectorIndex(parentLocation) {
        ngDevMode && assertNumber(parentLocation, 'Number expected');
        ngDevMode && assertNotEqual(parentLocation, -1, 'Not a valid state.');
        const parentInjectorIndex = parentLocation & 32767 /* InjectorIndexMask */;
        ngDevMode &&
            assertGreaterThan(parentInjectorIndex, HEADER_OFFSET, 'Parent injector must be pointing past HEADER_OFFSET.');
        return parentLocation & 32767 /* InjectorIndexMask */;
    }
    function getParentInjectorViewOffset(parentLocation) {
        return parentLocation >> 16 /* ViewOffsetShift */;
    }
    /**
     * Unwraps a parent injector location number to find the view offset from the current injector,
     * then walks up the declaration view tree until the view is found that contains the parent
     * injector.
     *
     * @param location The location of the parent injector, which contains the view offset
     * @param startView The LView instance from which to start walking up the view tree
     * @returns The LView instance that contains the parent injector
     */
    function getParentInjectorView(location, startView) {
        let viewOffset = getParentInjectorViewOffset(location);
        let parentView = startView;
        // For most cases, the parent injector can be found on the host node (e.g. for component
        // or container), but we must keep the loop here to support the rarer case of deeply nested
        // <ng-template> tags or inline views, where the parent injector might live many views
        // above the child injector.
        while (viewOffset > 0) {
            parentView = parentView[DECLARATION_VIEW];
            viewOffset--;
        }
        return parentView;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Defines if the call to `inject` should include `viewProviders` in its resolution.
     *
     * This is set to true when we try to instantiate a component. This value is reset in
     * `getNodeInjectable` to a value which matches the declaration location of the token about to be
     * instantiated. This is done so that if we are injecting a token which was declared outside of
     * `viewProviders` we don't accidentally pull `viewProviders` in.
     *
     * Example:
     *
     * ```
     * @Injectable()
     * class MyService {
     *   constructor(public value: String) {}
     * }
     *
     * @Component({
     *   providers: [
     *     MyService,
     *     {provide: String, value: 'providers' }
     *   ]
     *   viewProviders: [
     *     {provide: String, value: 'viewProviders'}
     *   ]
     * })
     * class MyComponent {
     *   constructor(myService: MyService, value: String) {
     *     // We expect that Component can see into `viewProviders`.
     *     expect(value).toEqual('viewProviders');
     *     // `MyService` was not declared in `viewProviders` hence it can't see it.
     *     expect(myService.value).toEqual('providers');
     *   }
     * }
     *
     * ```
     */
    let includeViewProviders = true;
    function setIncludeViewProviders(v) {
        const oldValue = includeViewProviders;
        includeViewProviders = v;
        return oldValue;
    }
    /**
     * The number of slots in each bloom filter (used by DI). The larger this number, the fewer
     * directives that will share slots, and thus, the fewer false positives when checking for
     * the existence of a directive.
     */
    const BLOOM_SIZE = 256;
    const BLOOM_MASK = BLOOM_SIZE - 1;
    /**
     * The number of bits that is represented by a single bloom bucket. JS bit operations are 32 bits,
     * so each bucket represents 32 distinct tokens which accounts for log2(32) = 5 bits of a bloom hash
     * number.
     */
    const BLOOM_BUCKET_BITS = 5;
    /** Counter used to generate unique IDs for directives. */
    let nextNgElementId = 0;
    /**
     * Registers this directive as present in its node's injector by flipping the directive's
     * corresponding bit in the injector's bloom filter.
     *
     * @param injectorIndex The index of the node injector where this token should be registered
     * @param tView The TView for the injector's bloom filters
     * @param type The directive token to register
     */
    function bloomAdd(injectorIndex, tView, type) {
        ngDevMode && assertEqual(tView.firstCreatePass, true, 'expected firstCreatePass to be true');
        let id;
        if (typeof type === 'string') {
            id = type.charCodeAt(0) || 0;
        }
        else if (type.hasOwnProperty(NG_ELEMENT_ID)) {
            id = type[NG_ELEMENT_ID];
        }
        // Set a unique ID on the directive type, so if something tries to inject the directive,
        // we can easily retrieve the ID and hash it into the bloom bit that should be checked.
        if (id == null) {
            id = type[NG_ELEMENT_ID] = nextNgElementId++;
        }
        // We only have BLOOM_SIZE (256) slots in our bloom filter (8 buckets * 32 bits each),
        // so all unique IDs must be modulo-ed into a number from 0 - 255 to fit into the filter.
        const bloomHash = id & BLOOM_MASK;
        // Create a mask that targets the specific bit associated with the directive.
        // JS bit operations are 32 bits, so this will be a number between 2^0 and 2^31, corresponding
        // to bit positions 0 - 31 in a 32 bit integer.
        const mask = 1 << bloomHash;
        // Each bloom bucket in `tData` represents `BLOOM_BUCKET_BITS` number of bits of `bloomHash`.
        // Any bits in `bloomHash` beyond `BLOOM_BUCKET_BITS` indicate the bucket offset that the mask
        // should be written to.
        tView.data[injectorIndex + (bloomHash >> BLOOM_BUCKET_BITS)] |= mask;
    }
    /**
     * Creates (or gets an existing) injector for a given element or container.
     *
     * @param tNode for which an injector should be retrieved / created.
     * @param lView View where the node is stored
     * @returns Node injector
     */
    function getOrCreateNodeInjectorForNode(tNode, lView) {
        const existingInjectorIndex = getInjectorIndex(tNode, lView);
        if (existingInjectorIndex !== -1) {
            return existingInjectorIndex;
        }
        const tView = lView[TVIEW];
        if (tView.firstCreatePass) {
            tNode.injectorIndex = lView.length;
            insertBloom(tView.data, tNode); // foundation for node bloom
            insertBloom(lView, null); // foundation for cumulative bloom
            insertBloom(tView.blueprint, null);
        }
        const parentLoc = getParentInjectorLocation(tNode, lView);
        const injectorIndex = tNode.injectorIndex;
        // If a parent injector can't be found, its location is set to -1.
        // In that case, we don't need to set up a cumulative bloom
        if (hasParentInjector(parentLoc)) {
            const parentIndex = getParentInjectorIndex(parentLoc);
            const parentLView = getParentInjectorView(parentLoc, lView);
            const parentData = parentLView[TVIEW].data;
            // Creates a cumulative bloom filter that merges the parent's bloom filter
            // and its own cumulative bloom (which contains tokens for all ancestors)
            for (let i = 0; i < 8 /* BLOOM_SIZE */; i++) {
                lView[injectorIndex + i] = parentLView[parentIndex + i] | parentData[parentIndex + i];
            }
        }
        lView[injectorIndex + 8 /* PARENT */] = parentLoc;
        return injectorIndex;
    }
    function insertBloom(arr, footer) {
        arr.push(0, 0, 0, 0, 0, 0, 0, 0, footer);
    }
    function getInjectorIndex(tNode, lView) {
        if (tNode.injectorIndex === -1 ||
            // If the injector index is the same as its parent's injector index, then the index has been
            // copied down from the parent node. No injector has been created yet on this node.
            (tNode.parent && tNode.parent.injectorIndex === tNode.injectorIndex) ||
            // After the first template pass, the injector index might exist but the parent values
            // might not have been calculated yet for this instance
            lView[tNode.injectorIndex + 8 /* PARENT */] === null) {
            return -1;
        }
        else {
            ngDevMode && assertIndexInRange(lView, tNode.injectorIndex);
            return tNode.injectorIndex;
        }
    }
    /**
     * Finds the index of the parent injector, with a view offset if applicable. Used to set the
     * parent injector initially.
     *
     * @returns Returns a number that is the combination of the number of LViews that we have to go up
     * to find the LView containing the parent inject AND the index of the injector within that LView.
     */
    function getParentInjectorLocation(tNode, lView) {
        if (tNode.parent && tNode.parent.injectorIndex !== -1) {
            // If we have a parent `TNode` and there is an injector associated with it we are done, because
            // the parent injector is within the current `LView`.
            return tNode.parent.injectorIndex; // ViewOffset is 0
        }
        // When parent injector location is computed it may be outside of the current view. (ie it could
        // be pointing to a declared parent location). This variable stores number of declaration parents
        // we need to walk up in order to find the parent injector location.
        let declarationViewOffset = 0;
        let parentTNode = null;
        let lViewCursor = lView;
        // The parent injector is not in the current `LView`. We will have to walk the declared parent
        // `LView` hierarchy and look for it. If we walk of the top, that means that there is no parent
        // `NodeInjector`.
        while (lViewCursor !== null) {
            // First determine the `parentTNode` location. The parent pointer differs based on `TView.type`.
            const tView = lViewCursor[TVIEW];
            const tViewType = tView.type;
            if (tViewType === 2 /* Embedded */) {
                ngDevMode &&
                    assertDefined(tView.declTNode, 'Embedded TNodes should have declaration parents.');
                parentTNode = tView.declTNode;
            }
            else if (tViewType === 1 /* Component */) {
                // Components don't have `TView.declTNode` because each instance of component could be
                // inserted in different location, hence `TView.declTNode` is meaningless.
                parentTNode = lViewCursor[T_HOST];
            }
            else {
                ngDevMode && assertEqual(tView.type, 0 /* Root */, 'Root type expected');
                parentTNode = null;
            }
            if (parentTNode === null) {
                // If we have no parent, than we are done.
                return NO_PARENT_INJECTOR;
            }
            ngDevMode && parentTNode && assertTNodeForLView(parentTNode, lViewCursor[DECLARATION_VIEW]);
            // Every iteration of the loop requires that we go to the declared parent.
            declarationViewOffset++;
            lViewCursor = lViewCursor[DECLARATION_VIEW];
            if (parentTNode.injectorIndex !== -1) {
                // We found a NodeInjector which points to something.
                return (parentTNode.injectorIndex |
                    (declarationViewOffset << 16 /* ViewOffsetShift */));
            }
        }
        return NO_PARENT_INJECTOR;
    }
    /**
     * Makes a type or an injection token public to the DI system by adding it to an
     * injector's bloom filter.
     *
     * @param di The node injector in which a directive will be added
     * @param token The type or the injection token to be made public
     */
    function diPublicInInjector(injectorIndex, tView, token) {
        bloomAdd(injectorIndex, tView, token);
    }
    function notFoundValueOrThrow(notFoundValue, token, flags) {
        if (flags & InjectFlags.Optional) {
            return notFoundValue;
        }
        else {
            throwProviderNotFoundError(token, 'NodeInjector');
        }
    }
    /**
     * Returns the value associated to the given token from the ModuleInjector or throws exception
     *
     * @param lView The `LView` that contains the `tNode`
     * @param token The token to look for
     * @param flags Injection flags
     * @param notFoundValue The value to return when the injection flags is `InjectFlags.Optional`
     * @returns the value from the injector or throws an exception
     */
    function lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue) {
        if (flags & InjectFlags.Optional && notFoundValue === undefined) {
            // This must be set or the NullInjector will throw for optional deps
            notFoundValue = null;
        }
        if ((flags & (InjectFlags.Self | InjectFlags.Host)) === 0) {
            const moduleInjector = lView[INJECTOR];
            // switch to `injectInjectorOnly` implementation for module injector, since module injector
            // should not have access to Component/Directive DI scope (that may happen through
            // `directiveInject` implementation)
            const previousInjectImplementation = setInjectImplementation(undefined);
            try {
                if (moduleInjector) {
                    return moduleInjector.get(token, notFoundValue, flags & InjectFlags.Optional);
                }
                else {
                    return injectRootLimpMode(token, notFoundValue, flags & InjectFlags.Optional);
                }
            }
            finally {
                setInjectImplementation(previousInjectImplementation);
            }
        }
        return notFoundValueOrThrow(notFoundValue, token, flags);
    }
    /**
     * Returns the value associated to the given token from the NodeInjectors => ModuleInjector.
     *
     * Look for the injector providing the token by walking up the node injector tree and then
     * the module injector tree.
     *
     * This function patches `token` with `__NG_ELEMENT_ID__` which contains the id for the bloom
     * filter. `-1` is reserved for injecting `Injector` (implemented by `NodeInjector`)
     *
     * @param tNode The Node where the search for the injector should start
     * @param lView The `LView` that contains the `tNode`
     * @param token The token to look for
     * @param flags Injection flags
     * @param notFoundValue The value to return when the injection flags is `InjectFlags.Optional`
     * @returns the value from the injector, `null` when not found, or `notFoundValue` if provided
     */
    function getOrCreateInjectable(tNode, lView, token, flags = InjectFlags.Default, notFoundValue) {
        if (tNode !== null) {
            const bloomHash = bloomHashBitOrFactory(token);
            // If the ID stored here is a function, this is a special object like ElementRef or TemplateRef
            // so just call the factory function to create it.
            if (typeof bloomHash === 'function') {
                if (!enterDI(lView, tNode, flags)) {
                    // Failed to enter DI, try module injector instead. If a token is injected with the @Host
                    // flag, the module injector is not searched for that token in Ivy.
                    return (flags & InjectFlags.Host) ?
                        notFoundValueOrThrow(notFoundValue, token, flags) :
                        lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue);
                }
                try {
                    const value = bloomHash(flags);
                    if (value == null && !(flags & InjectFlags.Optional)) {
                        throwProviderNotFoundError(token);
                    }
                    else {
                        return value;
                    }
                }
                finally {
                    leaveDI();
                }
            }
            else if (typeof bloomHash === 'number') {
                // A reference to the previous injector TView that was found while climbing the element
                // injector tree. This is used to know if viewProviders can be accessed on the current
                // injector.
                let previousTView = null;
                let injectorIndex = getInjectorIndex(tNode, lView);
                let parentLocation = NO_PARENT_INJECTOR;
                let hostTElementNode = flags & InjectFlags.Host ? lView[DECLARATION_COMPONENT_VIEW][T_HOST] : null;
                // If we should skip this injector, or if there is no injector on this node, start by
                // searching the parent injector.
                if (injectorIndex === -1 || flags & InjectFlags.SkipSelf) {
                    parentLocation = injectorIndex === -1 ? getParentInjectorLocation(tNode, lView) :
                        lView[injectorIndex + 8 /* PARENT */];
                    if (parentLocation === NO_PARENT_INJECTOR || !shouldSearchParent(flags, false)) {
                        injectorIndex = -1;
                    }
                    else {
                        previousTView = lView[TVIEW];
                        injectorIndex = getParentInjectorIndex(parentLocation);
                        lView = getParentInjectorView(parentLocation, lView);
                    }
                }
                // Traverse up the injector tree until we find a potential match or until we know there
                // *isn't* a match.
                while (injectorIndex !== -1) {
                    ngDevMode && assertNodeInjector(lView, injectorIndex);
                    // Check the current injector. If it matches, see if it contains token.
                    const tView = lView[TVIEW];
                    ngDevMode &&
                        assertTNodeForLView(tView.data[injectorIndex + 8 /* TNODE */], lView);
                    if (bloomHasToken(bloomHash, injectorIndex, tView.data)) {
                        // At this point, we have an injector which *may* contain the token, so we step through
                        // the providers and directives associated with the injector's corresponding node to get
                        // the instance.
                        const instance = searchTokensOnInjector(injectorIndex, lView, token, previousTView, flags, hostTElementNode);
                        if (instance !== NOT_FOUND) {
                            return instance;
                        }
                    }
                    parentLocation = lView[injectorIndex + 8 /* PARENT */];
                    if (parentLocation !== NO_PARENT_INJECTOR &&
                        shouldSearchParent(flags, lView[TVIEW].data[injectorIndex + 8 /* TNODE */] === hostTElementNode) &&
                        bloomHasToken(bloomHash, injectorIndex, lView)) {
                        // The def wasn't found anywhere on this node, so it was a false positive.
                        // Traverse up the tree and continue searching.
                        previousTView = tView;
                        injectorIndex = getParentInjectorIndex(parentLocation);
                        lView = getParentInjectorView(parentLocation, lView);
                    }
                    else {
                        // If we should not search parent OR If the ancestor bloom filter value does not have the
                        // bit corresponding to the directive we can give up on traversing up to find the specific
                        // injector.
                        injectorIndex = -1;
                    }
                }
            }
        }
        return lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue);
    }
    const NOT_FOUND = {};
    function createNodeInjector() {
        return new NodeInjector(getCurrentTNode(), getLView());
    }
    function searchTokensOnInjector(injectorIndex, lView, token, previousTView, flags, hostTElementNode) {
        const currentTView = lView[TVIEW];
        const tNode = currentTView.data[injectorIndex + 8 /* TNODE */];
        // First, we need to determine if view providers can be accessed by the starting element.
        // There are two possibilities
        const canAccessViewProviders = previousTView == null ?
            // 1) This is the first invocation `previousTView == null` which means that we are at the
            // `TNode` of where injector is starting to look. In such a case the only time we are allowed
            // to look into the ViewProviders is if:
            // - we are on a component
            // - AND the injector set `includeViewProviders` to true (implying that the token can see
            // ViewProviders because it is the Component or a Service which itself was declared in
            // ViewProviders)
            (isComponentHost(tNode) && includeViewProviders) :
            // 2) `previousTView != null` which means that we are now walking across the parent nodes.
            // In such a case we are only allowed to look into the ViewProviders if:
            // - We just crossed from child View to Parent View `previousTView != currentTView`
            // - AND the parent TNode is an Element.
            // This means that we just came from the Component's View and therefore are allowed to see
            // into the ViewProviders.
            (previousTView != currentTView && ((tNode.type & 3 /* AnyRNode */) !== 0));
        // This special case happens when there is a @host on the inject and when we are searching
        // on the host element node.
        const isHostSpecialCase = (flags & InjectFlags.Host) && hostTElementNode === tNode;
        const injectableIdx = locateDirectiveOrProvider(tNode, currentTView, token, canAccessViewProviders, isHostSpecialCase);
        if (injectableIdx !== null) {
            return getNodeInjectable(lView, currentTView, injectableIdx, tNode);
        }
        else {
            return NOT_FOUND;
        }
    }
    /**
     * Searches for the given token among the node's directives and providers.
     *
     * @param tNode TNode on which directives are present.
     * @param tView The tView we are currently processing
     * @param token Provider token or type of a directive to look for.
     * @param canAccessViewProviders Whether view providers should be considered.
     * @param isHostSpecialCase Whether the host special case applies.
     * @returns Index of a found directive or provider, or null when none found.
     */
    function locateDirectiveOrProvider(tNode, tView, token, canAccessViewProviders, isHostSpecialCase) {
        const nodeProviderIndexes = tNode.providerIndexes;
        const tInjectables = tView.data;
        const injectablesStart = nodeProviderIndexes & 1048575 /* ProvidersStartIndexMask */;
        const directivesStart = tNode.directiveStart;
        const directiveEnd = tNode.directiveEnd;
        const cptViewProvidersCount = nodeProviderIndexes >> 20 /* CptViewProvidersCountShift */;
        const startingIndex = canAccessViewProviders ? injectablesStart : injectablesStart + cptViewProvidersCount;
        // When the host special case applies, only the viewProviders and the component are visible
        const endIndex = isHostSpecialCase ? injectablesStart + cptViewProvidersCount : directiveEnd;
        for (let i = startingIndex; i < endIndex; i++) {
            const providerTokenOrDef = tInjectables[i];
            if (i < directivesStart && token === providerTokenOrDef ||
                i >= directivesStart && providerTokenOrDef.type === token) {
                return i;
            }
        }
        if (isHostSpecialCase) {
            const dirDef = tInjectables[directivesStart];
            if (dirDef && isComponentDef(dirDef) && dirDef.type === token) {
                return directivesStart;
            }
        }
        return null;
    }
    /**
     * Retrieve or instantiate the injectable from the `LView` at particular `index`.
     *
     * This function checks to see if the value has already been instantiated and if so returns the
     * cached `injectable`. Otherwise if it detects that the value is still a factory it
     * instantiates the `injectable` and caches the value.
     */
    function getNodeInjectable(lView, tView, index, tNode) {
        let value = lView[index];
        const tData = tView.data;
        if (isFactory(value)) {
            const factory = value;
            if (factory.resolving) {
                throwCyclicDependencyError(stringifyForError(tData[index]));
            }
            const previousIncludeViewProviders = setIncludeViewProviders(factory.canSeeViewProviders);
            factory.resolving = true;
            const previousInjectImplementation = factory.injectImpl ? setInjectImplementation(factory.injectImpl) : null;
            const success = enterDI(lView, tNode, InjectFlags.Default);
            ngDevMode &&
                assertEqual(success, true, 'Because flags do not contain \`SkipSelf\' we expect this to always succeed.');
            try {
                value = lView[index] = factory.factory(undefined, tData, lView, tNode);
                // This code path is hit for both directives and providers.
                // For perf reasons, we want to avoid searching for hooks on providers.
                // It does no harm to try (the hooks just won't exist), but the extra
                // checks are unnecessary and this is a hot path. So we check to see
                // if the index of the dependency is in the directive range for this
                // tNode. If it's not, we know it's a provider and skip hook registration.
                if (tView.firstCreatePass && index >= tNode.directiveStart) {
                    ngDevMode && assertDirectiveDef(tData[index]);
                    registerPreOrderHooks(index, tData[index], tView);
                }
            }
            finally {
                previousInjectImplementation !== null &&
                    setInjectImplementation(previousInjectImplementation);
                setIncludeViewProviders(previousIncludeViewProviders);
                factory.resolving = false;
                leaveDI();
            }
        }
        return value;
    }
    /**
     * Returns the bit in an injector's bloom filter that should be used to determine whether or not
     * the directive might be provided by the injector.
     *
     * When a directive is public, it is added to the bloom filter and given a unique ID that can be
     * retrieved on the Type. When the directive isn't public or the token is not a directive `null`
     * is returned as the node injector can not possibly provide that token.
     *
     * @param token the injection token
     * @returns the matching bit to check in the bloom filter or `null` if the token is not known.
     *   When the returned value is negative then it represents special values such as `Injector`.
     */
    function bloomHashBitOrFactory(token) {
        ngDevMode && assertDefined(token, 'token must be defined');
        if (typeof token === 'string') {
            return token.charCodeAt(0) || 0;
        }
        const tokenId = 
        // First check with `hasOwnProperty` so we don't get an inherited ID.
        token.hasOwnProperty(NG_ELEMENT_ID) ? token[NG_ELEMENT_ID] : undefined;
        // Negative token IDs are used for special objects such as `Injector`
        if (typeof tokenId === 'number') {
            if (tokenId >= 0) {
                return tokenId & BLOOM_MASK;
            }
            else {
                ngDevMode &&
                    assertEqual(tokenId, -1 /* Injector */, 'Expecting to get Special Injector Id');
                return createNodeInjector;
            }
        }
        else {
            return tokenId;
        }
    }
    function bloomHasToken(bloomHash, injectorIndex, injectorView) {
        // Create a mask that targets the specific bit associated with the directive we're looking for.
        // JS bit operations are 32 bits, so this will be a number between 2^0 and 2^31, corresponding
        // to bit positions 0 - 31 in a 32 bit integer.
        const mask = 1 << bloomHash;
        // Each bloom bucket in `injectorView` represents `BLOOM_BUCKET_BITS` number of bits of
        // `bloomHash`. Any bits in `bloomHash` beyond `BLOOM_BUCKET_BITS` indicate the bucket offset
        // that should be used.
        const value = injectorView[injectorIndex + (bloomHash >> BLOOM_BUCKET_BITS)];
        // If the bloom filter value has the bit corresponding to the directive's bloomBit flipped on,
        // this injector is a potential match.
        return !!(value & mask);
    }
    /** Returns true if flags prevent parent injector from being searched for tokens */
    function shouldSearchParent(flags, isFirstHostTNode) {
        return !(flags & InjectFlags.Self) && !(flags & InjectFlags.Host && isFirstHostTNode);
    }
    class NodeInjector {
        constructor(_tNode, _lView) {
            this._tNode = _tNode;
            this._lView = _lView;
        }
        get(token, notFoundValue) {
            return getOrCreateInjectable(this._tNode, this._lView, token, undefined, notFoundValue);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const ANNOTATIONS = '__annotations__';
    const PARAMETERS = '__parameters__';
    const PROP_METADATA = '__prop__metadata__';
    /**
     * @suppress {globalThis}
     */
    function makeDecorator(name, props, parentClass, additionalProcessing, typeFn) {
        return noSideEffects(() => {
            const metaCtor = makeMetadataCtor(props);
            function DecoratorFactory(...args) {
                if (this instanceof DecoratorFactory) {
                    metaCtor.call(this, ...args);
                    return this;
                }
                const annotationInstance = new DecoratorFactory(...args);
                return function TypeDecorator(cls) {
                    if (typeFn)
                        typeFn(cls, ...args);
                    // Use of Object.defineProperty is important since it creates non-enumerable property which
                    // prevents the property is copied during subclassing.
                    const annotations = cls.hasOwnProperty(ANNOTATIONS) ?
                        cls[ANNOTATIONS] :
                        Object.defineProperty(cls, ANNOTATIONS, { value: [] })[ANNOTATIONS];
                    annotations.push(annotationInstance);
                    if (additionalProcessing)
                        additionalProcessing(cls);
                    return cls;
                };
            }
            if (parentClass) {
                DecoratorFactory.prototype = Object.create(parentClass.prototype);
            }
            DecoratorFactory.prototype.ngMetadataName = name;
            DecoratorFactory.annotationCls = DecoratorFactory;
            return DecoratorFactory;
        });
    }
    function makeMetadataCtor(props) {
        return function ctor(...args) {
            if (props) {
                const values = props(...args);
                for (const propName in values) {
                    this[propName] = values[propName];
                }
            }
        };
    }
    function makeParamDecorator(name, props, parentClass) {
        return noSideEffects(() => {
            const metaCtor = makeMetadataCtor(props);
            function ParamDecoratorFactory(...args) {
                if (this instanceof ParamDecoratorFactory) {
                    metaCtor.apply(this, args);
                    return this;
                }
                const annotationInstance = new ParamDecoratorFactory(...args);
                ParamDecorator.annotation = annotationInstance;
                return ParamDecorator;
                function ParamDecorator(cls, unusedKey, index) {
                    // Use of Object.defineProperty is important since it creates non-enumerable property which
                    // prevents the property is copied during subclassing.
                    const parameters = cls.hasOwnProperty(PARAMETERS) ?
                        cls[PARAMETERS] :
                        Object.defineProperty(cls, PARAMETERS, { value: [] })[PARAMETERS];
                    // there might be gaps if some in between parameters do not have annotations.
                    // we pad with nulls.
                    while (parameters.length <= index) {
                        parameters.push(null);
                    }
                    (parameters[index] = parameters[index] || []).push(annotationInstance);
                    return cls;
                }
            }
            if (parentClass) {
                ParamDecoratorFactory.prototype = Object.create(parentClass.prototype);
            }
            ParamDecoratorFactory.prototype.ngMetadataName = name;
            ParamDecoratorFactory.annotationCls = ParamDecoratorFactory;
            return ParamDecoratorFactory;
        });
    }
    function makePropDecorator(name, props, parentClass, additionalProcessing) {
        return noSideEffects(() => {
            const metaCtor = makeMetadataCtor(props);
            function PropDecoratorFactory(...args) {
                if (this instanceof PropDecoratorFactory) {
                    metaCtor.apply(this, args);
                    return this;
                }
                const decoratorInstance = new PropDecoratorFactory(...args);
                function PropDecorator(target, name) {
                    const constructor = target.constructor;
                    // Use of Object.defineProperty is important because it creates a non-enumerable property
                    // which prevents the property from being copied during subclassing.
                    const meta = constructor.hasOwnProperty(PROP_METADATA) ?
                        constructor[PROP_METADATA] :
                        Object.defineProperty(constructor, PROP_METADATA, { value: {} })[PROP_METADATA];
                    meta[name] = meta.hasOwnProperty(name) && meta[name] || [];
                    meta[name].unshift(decoratorInstance);
                    if (additionalProcessing)
                        additionalProcessing(target, name, ...args);
                }
                return PropDecorator;
            }
            if (parentClass) {
                PropDecoratorFactory.prototype = Object.create(parentClass.prototype);
            }
            PropDecoratorFactory.prototype.ngMetadataName = name;
            PropDecoratorFactory.annotationCls = PropDecoratorFactory;
            return PropDecoratorFactory;
        });
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function CREATE_ATTRIBUTE_DECORATOR__PRE_R3__() {
        return makeParamDecorator('Attribute', (attributeName) => ({ attributeName }));
    }
    const CREATE_ATTRIBUTE_DECORATOR_IMPL = CREATE_ATTRIBUTE_DECORATOR__PRE_R3__;
    /**
     * Attribute decorator and metadata.
     *
     * @Annotation
     * @publicApi
     */
    const Attribute$1 = CREATE_ATTRIBUTE_DECORATOR_IMPL();

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Creates a token that can be used in a DI Provider.
     *
     * Use an `InjectionToken` whenever the type you are injecting is not reified (does not have a
     * runtime representation) such as when injecting an interface, callable type, array or
     * parameterized type.
     *
     * `InjectionToken` is parameterized on `T` which is the type of object which will be returned by
     * the `Injector`. This provides an additional level of type safety.
     *
     * ```
     * interface MyInterface {...}
     * const myInterface = injector.get(new InjectionToken<MyInterface>('SomeToken'));
     * // myInterface is inferred to be MyInterface.
     * ```
     *
     * When creating an `InjectionToken`, you can optionally specify a factory function which returns
     * (possibly by creating) a default value of the parameterized type `T`. This sets up the
     * `InjectionToken` using this factory as a provider as if it was defined explicitly in the
     * application's root injector. If the factory function, which takes zero arguments, needs to inject
     * dependencies, it can do so using the `inject` function.
     * As you can see in the Tree-shakable InjectionToken example below.
     *
     * Additionally, if a `factory` is specified you can also specify the `providedIn` option, which
     * overrides the above behavior and marks the token as belonging to a particular `@NgModule`. As
     * mentioned above, `'root'` is the default value for `providedIn`.
     *
     * @usageNotes
     * ### Basic Examples
     *
     * ### Plain InjectionToken
     *
     * {@example core/di/ts/injector_spec.ts region='InjectionToken'}
     *
     * ### Tree-shakable InjectionToken
     *
     * {@example core/di/ts/injector_spec.ts region='ShakableInjectionToken'}
     *
     *
     * @publicApi
     */
    class InjectionToken {
        /**
         * @param _desc   Description for the token,
         *                used only for debugging purposes,
         *                it should but does not need to be unique
         * @param options Options for the token's usage, as described above
         */
        constructor(_desc, options) {
            this._desc = _desc;
            /** @internal */
            this.ngMetadataName = 'InjectionToken';
            this.Éµprov = undefined;
            if (typeof options == 'number') {
                (typeof ngDevMode === 'undefined' || ngDevMode) &&
                    assertLessThan(options, 0, 'Only negative numbers are supported here');
                // This is a special hack to assign __NG_ELEMENT_ID__ to this instance.
                // See `InjectorMarkers`
                this.__NG_ELEMENT_ID__ = options;
            }
            else if (options !== undefined) {
                this.Éµprov = ÉµÉµdefineInjectable({
                    token: this,
                    providedIn: options.providedIn || 'root',
                    factory: options.factory,
                });
            }
        }
        toString() {
            return `InjectionToken ${this._desc}`;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A DI token that you can use to create a virtual [provider](guide/glossary#provider)
     * that will populate the `entryComponents` field of components and NgModules
     * based on its `useValue` property value.
     * All components that are referenced in the `useValue` value (either directly
     * or in a nested array or map) are added to the `entryComponents` property.
     *
     * @usageNotes
     *
     * The following example shows how the router can populate the `entryComponents`
     * field of an NgModule based on a router configuration that refers
     * to components.
     *
     * ```typescript
     * // helper function inside the router
     * function provideRoutes(routes) {
     *   return [
     *     {provide: ROUTES, useValue: routes},
     *     {provide: ANALYZE_FOR_ENTRY_COMPONENTS, useValue: routes, multi: true}
     *   ];
     * }
     *
     * // user code
     * let routes = [
     *   {path: '/root', component: RootComp},
     *   {path: '/teams', component: TeamsComp}
     * ];
     *
     * @NgModule({
     *   providers: [provideRoutes(routes)]
     * })
     * class ModuleWithRoutes {}
     * ```
     *
     * @publicApi
     * @deprecated Since 9.0.0. With Ivy, this property is no longer necessary.
     */
    const ANALYZE_FOR_ENTRY_COMPONENTS = new InjectionToken('AnalyzeForEntryComponents');
    // Stores the default value of `emitDistinctChangesOnly` when the `emitDistinctChangesOnly` is not
    // explicitly set.
    const emitDistinctChangesOnlyDefaultValue$1 = true;
    /**
     * Base class for query metadata.
     *
     * @see `ContentChildren`.
     * @see `ContentChild`.
     * @see `ViewChildren`.
     * @see `ViewChild`.
     *
     * @publicApi
     */
    class Query {
    }
    const Éµ0$1 = (selector, data = {}) => (Object.assign({ selector, first: false, isViewQuery: false, descendants: false, emitDistinctChangesOnly: emitDistinctChangesOnlyDefaultValue$1 }, data));
    /**
     * ContentChildren decorator and metadata.
     *
     *
     * @Annotation
     * @publicApi
     */
    const ContentChildren = makePropDecorator('ContentChildren', Éµ0$1, Query);
    const Éµ1 = (selector, data = {}) => (Object.assign({ selector, first: true, isViewQuery: false, descendants: true }, data));
    /**
     * ContentChild decorator and metadata.
     *
     *
     * @Annotation
     *
     * @publicApi
     */
    const ContentChild = makePropDecorator('ContentChild', Éµ1, Query);
    const Éµ2 = (selector, data = {}) => (Object.assign({ selector, first: false, isViewQuery: true, descendants: true, emitDistinctChangesOnly: emitDistinctChangesOnlyDefaultValue$1 }, data));
    /**
     * ViewChildren decorator and metadata.
     *
     * @Annotation
     * @publicApi
     */
    const ViewChildren = makePropDecorator('ViewChildren', Éµ2, Query);
    const Éµ3 = (selector, data) => (Object.assign({ selector, first: true, isViewQuery: true, descendants: true }, data));
    /**
     * ViewChild decorator and metadata.
     *
     * @Annotation
     * @publicApi
     */
    const ViewChild = makePropDecorator('ViewChild', Éµ3, Query);

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var FactoryTarget$2;
    (function (FactoryTarget) {
        FactoryTarget[FactoryTarget["Directive"] = 0] = "Directive";
        FactoryTarget[FactoryTarget["Component"] = 1] = "Component";
        FactoryTarget[FactoryTarget["Injectable"] = 2] = "Injectable";
        FactoryTarget[FactoryTarget["Pipe"] = 3] = "Pipe";
        FactoryTarget[FactoryTarget["NgModule"] = 4] = "NgModule";
    })(FactoryTarget$2 || (FactoryTarget$2 = {}));
    var ViewEncapsulation$2;
    (function (ViewEncapsulation) {
        ViewEncapsulation[ViewEncapsulation["Emulated"] = 0] = "Emulated";
        // Historically the 1 value was for `Native` encapsulation which has been removed as of v11.
        ViewEncapsulation[ViewEncapsulation["None"] = 2] = "None";
        ViewEncapsulation[ViewEncapsulation["ShadowDom"] = 3] = "ShadowDom";
    })(ViewEncapsulation$2 || (ViewEncapsulation$2 = {}));

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * @description
     *
     * Represents a type that a Component or other object is instances of.
     *
     * An example of a `Type` is `MyCustomComponent` class, which in JavaScript is represented by
     * the `MyCustomComponent` constructor function.
     *
     * @publicApi
     */
    const Type$2 = Function;
    function isType(v) {
        return typeof v === 'function';
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function removeFromArray(arr, index) {
        // perf: array.pop is faster than array.splice!
        if (index >= arr.length - 1) {
            return arr.pop();
        }
        else {
            return arr.splice(index, 1)[0];
        }
    }
    function newArray$1(size, value) {
        const list = [];
        for (let i = 0; i < size; i++) {
            list.push(value);
        }
        return list;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /*
     * #########################
     * Attention: These Regular expressions have to hold even if the code is minified!
     * ##########################
     */
    /**
     * Regular expression that detects pass-through constructors for ES5 output. This Regex
     * intends to capture the common delegation pattern emitted by TypeScript and Babel. Also
     * it intends to capture the pattern where existing constructors have been downleveled from
     * ES2015 to ES5 using TypeScript w/ downlevel iteration. e.g.
     *
     * ```
     *   function MyClass() {
     *     var _this = _super.apply(this, arguments) || this;
     * ```
     *
     * downleveled to ES5 with `downlevelIteration` for TypeScript < 4.2:
     * ```
     *   function MyClass() {
     *     var _this = _super.apply(this, __spread(arguments)) || this;
     * ```
     *
     * or downleveled to ES5 with `downlevelIteration` for TypeScript >= 4.2:
     * ```
     *   function MyClass() {
     *     var _this = _super.apply(this, __spreadArray([], __read(arguments))) || this;
     * ```
     *
     * More details can be found in: https://github.com/angular/angular/issues/38453.
     */
    const ES5_DELEGATE_CTOR = /^function\s+\S+\(\)\s*{[\s\S]+\.apply\(this,\s*(arguments|(?:[^()]+\(\[\],)?[^()]+\(arguments\))\)/;
    /** Regular expression that detects ES2015 classes which extend from other classes. */
    const ES2015_INHERITED_CLASS = /^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{/;
    /**
     * Regular expression that detects ES2015 classes which extend from other classes and
     * have an explicit constructor defined.
     */
    const ES2015_INHERITED_CLASS_WITH_CTOR = /^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{[\s\S]*constructor\s*\(/;
    /**
     * Regular expression that detects ES2015 classes which extend from other classes
     * and inherit a constructor.
     */
    const ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR = /^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{[\s\S]*constructor\s*\(\)\s*{\s*super\(\.\.\.arguments\)/;
    /**
     * Determine whether a stringified type is a class which delegates its constructor
     * to its parent.
     *
     * This is not trivial since compiled code can actually contain a constructor function
     * even if the original source code did not. For instance, when the child class contains
     * an initialized instance property.
     */
    function isDelegateCtor(typeStr) {
        return ES5_DELEGATE_CTOR.test(typeStr) ||
            ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR.test(typeStr) ||
            (ES2015_INHERITED_CLASS.test(typeStr) && !ES2015_INHERITED_CLASS_WITH_CTOR.test(typeStr));
    }
    class ReflectionCapabilities {
        constructor(reflect) {
            this._reflect = reflect || _global$1['Reflect'];
        }
        isReflectionEnabled() {
            return true;
        }
        factory(t) {
            return (...args) => new t(...args);
        }
        /** @internal */
        _zipTypesAndAnnotations(paramTypes, paramAnnotations) {
            let result;
            if (typeof paramTypes === 'undefined') {
                result = newArray$1(paramAnnotations.length);
            }
            else {
                result = newArray$1(paramTypes.length);
            }
            for (let i = 0; i < result.length; i++) {
                // TS outputs Object for parameters without types, while Traceur omits
                // the annotations. For now we preserve the Traceur behavior to aid
                // migration, but this can be revisited.
                if (typeof paramTypes === 'undefined') {
                    result[i] = [];
                }
                else if (paramTypes[i] && paramTypes[i] != Object) {
                    result[i] = [paramTypes[i]];
                }
                else {
                    result[i] = [];
                }
                if (paramAnnotations && paramAnnotations[i] != null) {
                    result[i] = result[i].concat(paramAnnotations[i]);
                }
            }
            return result;
        }
        _ownParameters(type, parentCtor) {
            const typeStr = type.toString();
            // If we have no decorators, we only have function.length as metadata.
            // In that case, to detect whether a child class declared an own constructor or not,
            // we need to look inside of that constructor to check whether it is
            // just calling the parent.
            // This also helps to work around for https://github.com/Microsoft/TypeScript/issues/12439
            // that sets 'design:paramtypes' to []
            // if a class inherits from another class but has no ctor declared itself.
            if (isDelegateCtor(typeStr)) {
                return null;
            }
            // Prefer the direct API.
            if (type.parameters && type.parameters !== parentCtor.parameters) {
                return type.parameters;
            }
            // API of tsickle for lowering decorators to properties on the class.
            const tsickleCtorParams = type.ctorParameters;
            if (tsickleCtorParams && tsickleCtorParams !== parentCtor.ctorParameters) {
                // Newer tsickle uses a function closure
                // Retain the non-function case for compatibility with older tsickle
                const ctorParameters = typeof tsickleCtorParams === 'function' ? tsickleCtorParams() : tsickleCtorParams;
                const paramTypes = ctorParameters.map((ctorParam) => ctorParam && ctorParam.type);
                const paramAnnotations = ctorParameters.map((ctorParam) => ctorParam && convertTsickleDecoratorIntoMetadata(ctorParam.decorators));
                return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);
            }
            // API for metadata created by invoking the decorators.
            const paramAnnotations = type.hasOwnProperty(PARAMETERS) && type[PARAMETERS];
            const paramTypes = this._reflect && this._reflect.getOwnMetadata &&
                this._reflect.getOwnMetadata('design:paramtypes', type);
            if (paramTypes || paramAnnotations) {
                return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);
            }
            // If a class has no decorators, at least create metadata
            // based on function.length.
            // Note: We know that this is a real constructor as we checked
            // the content of the constructor above.
            return newArray$1(type.length);
        }
        parameters(type) {
            // Note: only report metadata if we have at least one class decorator
            // to stay in sync with the static reflector.
            if (!isType(type)) {
                return [];
            }
            const parentCtor = getParentCtor(type);
            let parameters = this._ownParameters(type, parentCtor);
            if (!parameters && parentCtor !== Object) {
                parameters = this.parameters(parentCtor);
            }
            return parameters || [];
        }
        _ownAnnotations(typeOrFunc, parentCtor) {
            // Prefer the direct API.
            if (typeOrFunc.annotations && typeOrFunc.annotations !== parentCtor.annotations) {
                let annotations = typeOrFunc.annotations;
                if (typeof annotations === 'function' && annotations.annotations) {
                    annotations = annotations.annotations;
                }
                return annotations;
            }
            // API of tsickle for lowering decorators to properties on the class.
            if (typeOrFunc.decorators && typeOrFunc.decorators !== parentCtor.decorators) {
                return convertTsickleDecoratorIntoMetadata(typeOrFunc.decorators);
            }
            // API for metadata created by invoking the decorators.
            if (typeOrFunc.hasOwnProperty(ANNOTATIONS)) {
                return typeOrFunc[ANNOTATIONS];
            }
            return null;
        }
        annotations(typeOrFunc) {
            if (!isType(typeOrFunc)) {
                return [];
            }
            const parentCtor = getParentCtor(typeOrFunc);
            const ownAnnotations = this._ownAnnotations(typeOrFunc, parentCtor) || [];
            const parentAnnotations = parentCtor !== Object ? this.annotations(parentCtor) : [];
            return parentAnnotations.concat(ownAnnotations);
        }
        _ownPropMetadata(typeOrFunc, parentCtor) {
            // Prefer the direct API.
            if (typeOrFunc.propMetadata &&
                typeOrFunc.propMetadata !== parentCtor.propMetadata) {
                let propMetadata = typeOrFunc.propMetadata;
                if (typeof propMetadata === 'function' && propMetadata.propMetadata) {
                    propMetadata = propMetadata.propMetadata;
                }
                return propMetadata;
            }
            // API of tsickle for lowering decorators to properties on the class.
            if (typeOrFunc.propDecorators &&
                typeOrFunc.propDecorators !== parentCtor.propDecorators) {
                const propDecorators = typeOrFunc.propDecorators;
                const propMetadata = {};
                Object.keys(propDecorators).forEach(prop => {
                    propMetadata[prop] = convertTsickleDecoratorIntoMetadata(propDecorators[prop]);
                });
                return propMetadata;
            }
            // API for metadata created by invoking the decorators.
            if (typeOrFunc.hasOwnProperty(PROP_METADATA)) {
                return typeOrFunc[PROP_METADATA];
            }
            return null;
        }
        propMetadata(typeOrFunc) {
            if (!isType(typeOrFunc)) {
                return {};
            }
            const parentCtor = getParentCtor(typeOrFunc);
            const propMetadata = {};
            if (parentCtor !== Object) {
                const parentPropMetadata = this.propMetadata(parentCtor);
                Object.keys(parentPropMetadata).forEach((propName) => {
                    propMetadata[propName] = parentPropMetadata[propName];
                });
            }
            const ownPropMetadata = this._ownPropMetadata(typeOrFunc, parentCtor);
            if (ownPropMetadata) {
                Object.keys(ownPropMetadata).forEach((propName) => {
                    const decorators = [];
                    if (propMetadata.hasOwnProperty(propName)) {
                        decorators.push(...propMetadata[propName]);
                    }
                    decorators.push(...ownPropMetadata[propName]);
                    propMetadata[propName] = decorators;
                });
            }
            return propMetadata;
        }
        ownPropMetadata(typeOrFunc) {
            if (!isType(typeOrFunc)) {
                return {};
            }
            return this._ownPropMetadata(typeOrFunc, getParentCtor(typeOrFunc)) || {};
        }
        hasLifecycleHook(type, lcProperty) {
            return type instanceof Type$2 && lcProperty in type.prototype;
        }
        guards(type) {
            return {};
        }
        getter(name) {
            return new Function('o', 'return o.' + name + ';');
        }
        setter(name) {
            return new Function('o', 'v', 'return o.' + name + ' = v;');
        }
        method(name) {
            const functionBody = `if (!o.${name}) throw new Error('"${name}" is undefined');
        return o.${name}.apply(o, args);`;
            return new Function('o', 'args', functionBody);
        }
        // There is not a concept of import uri in Js, but this is useful in developing Dart applications.
        importUri(type) {
            // StaticSymbol
            if (typeof type === 'object' && type['filePath']) {
                return type['filePath'];
            }
            // Runtime type
            return `./${stringify$1(type)}`;
        }
        resourceUri(type) {
            return `./${stringify$1(type)}`;
        }
        resolveIdentifier(name, moduleUrl, members, runtime) {
            return runtime;
        }
        resolveEnum(enumIdentifier, name) {
            return enumIdentifier[name];
        }
    }
    function convertTsickleDecoratorIntoMetadata(decoratorInvocations) {
        if (!decoratorInvocations) {
            return [];
        }
        return decoratorInvocations.map(decoratorInvocation => {
            const decoratorType = decoratorInvocation.type;
            const annotationCls = decoratorType.annotationCls;
            const annotationArgs = decoratorInvocation.args ? decoratorInvocation.args : [];
            return new annotationCls(...annotationArgs);
        });
    }
    function getParentCtor(ctor) {
        const parentProto = ctor.prototype ? Object.getPrototypeOf(ctor.prototype) : null;
        const parentCtor = parentProto ? parentProto.constructor : null;
        // Note: We always use `Object` as the null value
        // to simplify checking later on.
        return parentCtor || Object;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const _THROW_IF_NOT_FOUND = {};
    const THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;
    /*
     * Name of a property (that we patch onto DI decorator), which is used as an annotation of which
     * InjectFlag this decorator represents. This allows to avoid direct references to the DI decorators
     * in the code, thus making them tree-shakable.
     */
    const DI_DECORATOR_FLAG = '__NG_DI_FLAG__';
    const NG_TEMP_TOKEN_PATH = 'ngTempTokenPath';
    const NG_TOKEN_PATH = 'ngTokenPath';
    const NEW_LINE = /\n/gm;
    const NO_NEW_LINE = 'Éµ';
    const SOURCE = '__source';
    const Éµ0$2 = getClosureSafeProperty;
    const USE_VALUE$2 = getClosureSafeProperty({ provide: String, useValue: Éµ0$2 });
    /**
     * Current injector value used by `inject`.
     * - `undefined`: it is an error to call `inject`
     * - `null`: `inject` can be called but there is no injector (limp-mode).
     * - Injector instance: Use the injector for resolution.
     */
    let _currentInjector = undefined;
    function setCurrentInjector(injector) {
        const former = _currentInjector;
        _currentInjector = injector;
        return former;
    }
    function injectInjectorOnly(token, flags = InjectFlags.Default) {
        if (_currentInjector === undefined) {
            throw new Error(`inject() must be called from an injection context`);
        }
        else if (_currentInjector === null) {
            return injectRootLimpMode(token, undefined, flags);
        }
        else {
            return _currentInjector.get(token, flags & InjectFlags.Optional ? null : undefined, flags);
        }
    }
    function ÉµÉµinject(token, flags = InjectFlags.Default) {
        return (getInjectImplementation() || injectInjectorOnly)(resolveForwardRef$1(token), flags);
    }
    function injectArgs(types) {
        const args = [];
        for (let i = 0; i < types.length; i++) {
            const arg = resolveForwardRef$1(types[i]);
            if (Array.isArray(arg)) {
                if (arg.length === 0) {
                    throw new Error('Arguments array must have arguments.');
                }
                let type = undefined;
                let flags = InjectFlags.Default;
                for (let j = 0; j < arg.length; j++) {
                    const meta = arg[j];
                    const flag = getInjectFlag(meta);
                    if (typeof flag === 'number') {
                        // Special case when we handle @Inject decorator.
                        if (flag === -1 /* Inject */) {
                            type = meta.token;
                        }
                        else {
                            flags |= flag;
                        }
                    }
                    else {
                        type = meta;
                    }
                }
                args.push(ÉµÉµinject(type, flags));
            }
            else {
                args.push(ÉµÉµinject(arg));
            }
        }
        return args;
    }
    /**
     * Attaches a given InjectFlag to a given decorator using monkey-patching.
     * Since DI decorators can be used in providers `deps` array (when provider is configured using
     * `useFactory`) without initialization (e.g. `Host`) and as an instance (e.g. `new Host()`), we
     * attach the flag to make it available both as a static property and as a field on decorator
     * instance.
     *
     * @param decorator Provided DI decorator.
     * @param flag InjectFlag that should be applied.
     */
    function attachInjectFlag(decorator, flag) {
        decorator[DI_DECORATOR_FLAG] = flag;
        decorator.prototype[DI_DECORATOR_FLAG] = flag;
        return decorator;
    }
    /**
     * Reads monkey-patched property that contains InjectFlag attached to a decorator.
     *
     * @param token Token that may contain monkey-patched DI flags property.
     */
    function getInjectFlag(token) {
        return token[DI_DECORATOR_FLAG];
    }
    function catchInjectorError(e, token, injectorErrorName, source) {
        const tokenPath = e[NG_TEMP_TOKEN_PATH];
        if (token[SOURCE]) {
            tokenPath.unshift(token[SOURCE]);
        }
        e.message = formatError('\n' + e.message, tokenPath, injectorErrorName, source);
        e[NG_TOKEN_PATH] = tokenPath;
        e[NG_TEMP_TOKEN_PATH] = null;
        throw e;
    }
    function formatError(text, obj, injectorErrorName, source = null) {
        text = text && text.charAt(0) === '\n' && text.charAt(1) == NO_NEW_LINE ? text.substr(2) : text;
        let context = stringify$1(obj);
        if (Array.isArray(obj)) {
            context = obj.map(stringify$1).join(' -> ');
        }
        else if (typeof obj === 'object') {
            let parts = [];
            for (let key in obj) {
                if (obj.hasOwnProperty(key)) {
                    let value = obj[key];
                    parts.push(key + ':' + (typeof value === 'string' ? JSON.stringify(value) : stringify$1(value)));
                }
            }
            context = `{${parts.join(', ')}}`;
        }
        return `${injectorErrorName}${source ? '(' + source + ')' : ''}[${context}]: ${text.replace(NEW_LINE, '\n  ')}`;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const Éµ0$3 = (token) => ({ token });
    /**
     * Inject decorator and metadata.
     *
     * @Annotation
     * @publicApi
     */
    const Inject = attachInjectFlag(
    // Disable tslint because `DecoratorFlags` is a const enum which gets inlined.
    // tslint:disable-next-line: no-toplevel-property-access
    makeParamDecorator('Inject', Éµ0$3), -1 /* Inject */);
    /**
     * Optional decorator and metadata.
     *
     * @Annotation
     * @publicApi
     */
    const Optional = 
    // Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.
    // tslint:disable-next-line: no-toplevel-property-access
    attachInjectFlag(makeParamDecorator('Optional'), 8 /* Optional */);
    /**
     * Self decorator and metadata.
     *
     * @Annotation
     * @publicApi
     */
    const Self = 
    // Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.
    // tslint:disable-next-line: no-toplevel-property-access
    attachInjectFlag(makeParamDecorator('Self'), 2 /* Self */);
    /**
     * `SkipSelf` decorator and metadata.
     *
     * @Annotation
     * @publicApi
     */
    const SkipSelf = 
    // Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.
    // tslint:disable-next-line: no-toplevel-property-access
    attachInjectFlag(makeParamDecorator('SkipSelf'), 4 /* SkipSelf */);
    /**
     * Host decorator and metadata.
     *
     * @Annotation
     * @publicApi
     */
    const Host = 
    // Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.
    // tslint:disable-next-line: no-toplevel-property-access
    attachInjectFlag(makeParamDecorator('Host'), 1 /* Host */);

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * The Trusted Types policy, or null if Trusted Types are not
     * enabled/supported, or undefined if the policy has not been created yet.
     */
    let policy$1;
    /**
     * Returns the Trusted Types policy, or null if Trusted Types are not
     * enabled/supported. The first call to this function will create the policy.
     */
    function getPolicy$1() {
        if (policy$1 === undefined) {
            policy$1 = null;
            if (_global$1.trustedTypes) {
                try {
                    policy$1 = _global$1.trustedTypes.createPolicy('angular', {
                        createHTML: (s) => s,
                        createScript: (s) => s,
                        createScriptURL: (s) => s,
                    });
                }
                catch (_a) {
                    // trustedTypes.createPolicy throws if called with a name that is
                    // already registered, even in report-only mode. Until the API changes,
                    // catch the error not to break the applications functionally. In such
                    // cases, the code will fall back to using strings.
                }
            }
        }
        return policy$1;
    }
    /**
     * Unsafely promote a string to a TrustedScript, falling back to strings when
     * Trusted Types are not available.
     * @security In particular, it must be assured that the provided string will
     * never cause an XSS vulnerability if used in a context that will be
     * interpreted and executed as a script by a browser, e.g. when calling eval.
     */
    function trustedScriptFromString$1(script) {
        var _a;
        return ((_a = getPolicy$1()) === null || _a === void 0 ? void 0 : _a.createScript(script)) || script;
    }
    /**
     * Unsafely call the Function constructor with the given string arguments. It
     * is only available in development mode, and should be stripped out of
     * production code.
     * @security This is a security-sensitive function; any use of this function
     * must go through security review. In particular, it must be assured that it
     * is only called from development code, as use in production code can lead to
     * XSS vulnerabilities.
     */
    function newTrustedFunctionForDev(...args) {
        if (typeof ngDevMode === 'undefined') {
            throw new Error('newTrustedFunctionForDev should never be called in production');
        }
        if (!_global$1.trustedTypes) {
            // In environments that don't support Trusted Types, fall back to the most
            // straightforward implementation:
            return new Function(...args);
        }
        // Chrome currently does not support passing TrustedScript to the Function
        // constructor. The following implements the workaround proposed on the page
        // below, where the Chromium bug is also referenced:
        // https://github.com/w3c/webappsec-trusted-types/wiki/Trusted-Types-for-function-constructor
        const fnArgs = args.slice(0, -1).join(',');
        const fnBody = args[args.length - 1];
        const body = `(function anonymous(${fnArgs}
) { ${fnBody}
})`;
        // Using eval directly confuses the compiler and prevents this module from
        // being stripped out of JS binaries even if not used. The global['eval']
        // indirection fixes that.
        const fn = _global$1['eval'](trustedScriptFromString$1(body));
        if (fn.bind === undefined) {
            // Workaround for a browser bug that only exists in Chrome 83, where passing
            // a TrustedScript to eval just returns the TrustedScript back without
            // evaluating it. In that case, fall back to the most straightforward
            // implementation:
            return new Function(...args);
        }
        // To completely mimic the behavior of calling "new Function", two more
        // things need to happen:
        // 1. Stringifying the resulting function should return its source code
        fn.toString = () => body;
        // 2. When calling the resulting function, `this` should refer to `global`
        return fn.bind(_global$1);
        // When Trusted Types support in Function constructors is widely available,
        // the implementation of this function can be simplified to:
        // return new Function(...args.map(a => trustedScriptFromString(a)));
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function tagSet(tags) {
        const res = {};
        for (const t of tags.split(','))
            res[t] = true;
        return res;
    }
    function merge(...sets) {
        const res = {};
        for (const s of sets) {
            for (const v in s) {
                if (s.hasOwnProperty(v))
                    res[v] = true;
            }
        }
        return res;
    }
    // Good source of info about elements and attributes
    // https://html.spec.whatwg.org/#semantics
    // https://simon.html5.org/html-elements
    // Safe Void Elements - HTML5
    // https://html.spec.whatwg.org/#void-elements
    const VOID_ELEMENTS = tagSet('area,br,col,hr,img,wbr');
    // Elements that you can, intentionally, leave open (and which close themselves)
    // https://html.spec.whatwg.org/#optional-tags
    const OPTIONAL_END_TAG_BLOCK_ELEMENTS = tagSet('colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr');
    const OPTIONAL_END_TAG_INLINE_ELEMENTS = tagSet('rp,rt');
    const OPTIONAL_END_TAG_ELEMENTS = merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, OPTIONAL_END_TAG_BLOCK_ELEMENTS);
    // Safe Block Elements - HTML5
    const BLOCK_ELEMENTS = merge(OPTIONAL_END_TAG_BLOCK_ELEMENTS, tagSet('address,article,' +
        'aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,' +
        'h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul'));
    // Inline Elements - HTML5
    const INLINE_ELEMENTS = merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, tagSet('a,abbr,acronym,audio,b,' +
        'bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,' +
        'samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video'));
    const VALID_ELEMENTS = merge(VOID_ELEMENTS, BLOCK_ELEMENTS, INLINE_ELEMENTS, OPTIONAL_END_TAG_ELEMENTS);
    // Attributes that have href and hence need to be sanitized
    const URI_ATTRS = tagSet('background,cite,href,itemtype,longdesc,poster,src,xlink:href');
    // Attributes that have special href set hence need to be sanitized
    const SRCSET_ATTRS = tagSet('srcset');
    const HTML_ATTRS = tagSet('abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,' +
        'compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,' +
        'ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,' +
        'scope,scrolling,shape,size,sizes,span,srclang,start,summary,tabindex,target,title,translate,type,usemap,' +
        'valign,value,vspace,width');
    // Accessibility attributes as per WAI-ARIA 1.1 (W3C Working Draft 14 December 2018)
    const ARIA_ATTRS = tagSet('aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,' +
        'aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,' +
        'aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,' +
        'aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,' +
        'aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,' +
        'aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,' +
        'aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext');
    // NB: This currently consciously doesn't support SVG. SVG sanitization has had several security
    // issues in the past, so it seems safer to leave it out if possible. If support for binding SVG via
    // innerHTML is required, SVG attributes should be added here.
    // NB: Sanitization does not allow <form> elements or other active elements (<button> etc). Those
    // can be sanitized, but they increase security surface area without a legitimate use case, so they
    // are left out here.
    const VALID_ATTRS = merge(URI_ATTRS, SRCSET_ATTRS, HTML_ATTRS, ARIA_ATTRS);
    // Elements whose content should not be traversed/preserved, if the elements themselves are invalid.
    //
    // Typically, `<invalid>Some content</invalid>` would traverse (and in this case preserve)
    // `Some content`, but strip `invalid-element` opening/closing tags. For some elements, though, we
    // don't want to preserve the content, if the elements themselves are going to be removed.
    const SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS = tagSet('script,style,template');

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A SecurityContext marks a location that has dangerous security implications, e.g. a DOM property
     * like `innerHTML` that could cause Cross Site Scripting (XSS) security bugs when improperly
     * handled.
     *
     * See DomSanitizer for more details on security in Angular applications.
     *
     * @publicApi
     */
    var SecurityContext$1;
    (function (SecurityContext) {
        SecurityContext[SecurityContext["NONE"] = 0] = "NONE";
        SecurityContext[SecurityContext["HTML"] = 1] = "HTML";
        SecurityContext[SecurityContext["STYLE"] = 2] = "STYLE";
        SecurityContext[SecurityContext["SCRIPT"] = 3] = "SCRIPT";
        SecurityContext[SecurityContext["URL"] = 4] = "URL";
        SecurityContext[SecurityContext["RESOURCE_URL"] = 5] = "RESOURCE_URL";
    })(SecurityContext$1 || (SecurityContext$1 = {}));

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * This property will be monkey-patched on elements, components and directives.
     */
    const MONKEY_PATCH_KEY_NAME = '__ngContext__';
    /**
     * Assigns the given data to the given target (which could be a component,
     * directive or DOM node instance) using monkey-patching.
     */
    function attachPatchData(target, data) {
        ngDevMode && assertDefined(target, 'Target expected');
        target[MONKEY_PATCH_KEY_NAME] = data;
    }
    /**
     * Returns the monkey-patch value data present on the target (which could be
     * a component, directive or a DOM node).
     */
    function readPatchedData(target) {
        ngDevMode && assertDefined(target, 'Target expected');
        return target[MONKEY_PATCH_KEY_NAME] || null;
    }
    function readPatchedLView(target) {
        const value = readPatchedData(target);
        if (value) {
            return Array.isArray(value) ? value : value.lView;
        }
        return null;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const ERROR_DEBUG_CONTEXT = 'ngDebugContext';
    const ERROR_ORIGINAL_ERROR = 'ngOriginalError';
    const ERROR_LOGGER = 'ngErrorLogger';

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function getDebugContext(error) {
        return error[ERROR_DEBUG_CONTEXT];
    }
    function getOriginalError(error) {
        return error[ERROR_ORIGINAL_ERROR];
    }
    function getErrorLogger(error) {
        return error && error[ERROR_LOGGER] || defaultErrorLogger;
    }
    function defaultErrorLogger(console, ...values) {
        console.error(...values);
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Provides a hook for centralized exception handling.
     *
     * The default implementation of `ErrorHandler` prints error messages to the `console`. To
     * intercept error handling, write a custom exception handler that replaces this default as
     * appropriate for your app.
     *
     * @usageNotes
     * ### Example
     *
     * ```
     * class MyErrorHandler implements ErrorHandler {
     *   handleError(error) {
     *     // do something with the exception
     *   }
     * }
     *
     * @NgModule({
     *   providers: [{provide: ErrorHandler, useClass: MyErrorHandler}]
     * })
     * class MyModule {}
     * ```
     *
     * @publicApi
     */
    class ErrorHandler {
        constructor() {
            /**
             * @internal
             */
            this._console = console;
        }
        handleError(error) {
            const originalError = this._findOriginalError(error);
            const context = this._findContext(error);
            // Note: Browser consoles show the place from where console.error was called.
            // We can use this to give users additional information about the error.
            const errorLogger = getErrorLogger(error);
            errorLogger(this._console, `ERROR`, error);
            if (originalError) {
                errorLogger(this._console, `ORIGINAL ERROR`, originalError);
            }
            if (context) {
                errorLogger(this._console, 'ERROR CONTEXT', context);
            }
        }
        /** @internal */
        _findContext(error) {
            return error ? (getDebugContext(error) || this._findContext(getOriginalError(error))) : null;
        }
        /** @internal */
        _findOriginalError(error) {
            let e = error && getOriginalError(error);
            while (e && getOriginalError(e)) {
                e = getOriginalError(e);
            }
            return e || null;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * THIS FILE CONTAINS CODE WHICH SHOULD BE TREE SHAKEN AND NEVER CALLED FROM PRODUCTION CODE!!!
     */
    /**
     * Creates an `Array` construction with a given name. This is useful when
     * looking for memory consumption to see what time of array it is.
     *
     *
     * @param name Name to give to the constructor
     * @returns A subclass of `Array` if possible. This can only be done in
     *          environments which support `class` construct.
     */
    function createNamedArrayType(name) {
        // This should never be called in prod mode, so let's verify that is the case.
        if (ngDevMode) {
            try {
                // If this function were compromised the following could lead to arbitrary
                // script execution. We bless it with Trusted Types anyway since this
                // function is stripped out of production binaries.
                return (newTrustedFunctionForDev('Array', `return class ${name} extends Array{}`))(Array);
            }
            catch (e) {
                // If it does not work just give up and fall back to regular Array.
                return Array;
            }
        }
        else {
            throw new Error('Looks like we are in \'prod mode\', but we are creating a named Array type, which is wrong! Check your code');
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const Éµ0$4 = () => (typeof requestAnimationFrame !== 'undefined' &&
        requestAnimationFrame || // browser only
        setTimeout // everything else
    )
        .bind(_global$1);
    const defaultScheduler = (Éµ0$4)();

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Flags for renderer-specific style modifiers.
     * @publicApi
     */
    var RendererStyleFlags2;
    (function (RendererStyleFlags2) {
        // TODO(misko): This needs to be refactored into a separate file so that it can be imported from
        // `node_manipulation.ts` Currently doing the import cause resolution order to change and fails
        // the tests. The work around is to have hard coded value in `node_manipulation.ts` for now.
        /**
         * Marks a style as important.
         */
        RendererStyleFlags2[RendererStyleFlags2["Important"] = 1] = "Important";
        /**
         * Marks a style as using dash case naming (this-is-dash-case).
         */
        RendererStyleFlags2[RendererStyleFlags2["DashCase"] = 2] = "DashCase";
    })(RendererStyleFlags2 || (RendererStyleFlags2 = {}));

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    let _icuContainerIterate;
    /**
     * Iterator which provides ability to visit all of the `TIcuContainerNode` root `RNode`s.
     */
    function icuContainerIterate(tIcuContainerNode, lView) {
        return _icuContainerIterate();
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Gets the parent LView of the passed LView, if the PARENT is an LContainer, will get the parent of
     * that LContainer, which is an LView
     * @param lView the lView whose parent to get
     */
    function getLViewParent(lView) {
        ngDevMode && assertLView(lView);
        const parent = lView[PARENT];
        return isLContainer(parent) ? parent[PARENT] : parent;
    }
    /**
     * Gets the first `LContainer` in the LView or `null` if none exists.
     */
    function getFirstLContainer(lView) {
        return getNearestLContainer(lView[CHILD_HEAD]);
    }
    /**
     * Gets the next `LContainer` that is a sibling of the given container.
     */
    function getNextLContainer(container) {
        return getNearestLContainer(container[NEXT]);
    }
    function getNearestLContainer(viewOrContainer) {
        while (viewOrContainer !== null && !isLContainer(viewOrContainer)) {
            viewOrContainer = viewOrContainer[NEXT];
        }
        return viewOrContainer;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * NOTE: for performance reasons, the possible actions are inlined within the function instead of
     * being passed as an argument.
     */
    function applyToElementOrContainer(action, renderer, parent, lNodeToHandle, beforeNode) {
        // If this slot was allocated for a text node dynamically created by i18n, the text node itself
        // won't be created until i18nApply() in the update block, so this node should be skipped.
        // For more info, see "ICU expressions should work inside an ngTemplateOutlet inside an ngFor"
        // in `i18n_spec.ts`.
        if (lNodeToHandle != null) {
            let lContainer;
            let isComponent = false;
            // We are expecting an RNode, but in the case of a component or LContainer the `RNode` is
            // wrapped in an array which needs to be unwrapped. We need to know if it is a component and if
            // it has LContainer so that we can process all of those cases appropriately.
            if (isLContainer(lNodeToHandle)) {
                lContainer = lNodeToHandle;
            }
            else if (isLView(lNodeToHandle)) {
                isComponent = true;
                ngDevMode && assertDefined(lNodeToHandle[HOST], 'HOST must be defined for a component LView');
                lNodeToHandle = lNodeToHandle[HOST];
            }
            const rNode = unwrapRNode(lNodeToHandle);
            ngDevMode && !isProceduralRenderer(renderer) && assertDomNode(rNode);
            if (action === 0 /* Create */ && parent !== null) {
                if (beforeNode == null) {
                    nativeAppendChild(renderer, parent, rNode);
                }
                else {
                    nativeInsertBefore(renderer, parent, rNode, beforeNode || null, true);
                }
            }
            else if (action === 1 /* Insert */ && parent !== null) {
                nativeInsertBefore(renderer, parent, rNode, beforeNode || null, true);
            }
            else if (action === 2 /* Detach */) {
                nativeRemoveNode(renderer, rNode, isComponent);
            }
            else if (action === 3 /* Destroy */) {
                ngDevMode && ngDevMode.rendererDestroyNode++;
                renderer.destroyNode(rNode);
            }
            if (lContainer != null) {
                applyContainer(renderer, action, lContainer, parent, beforeNode);
            }
        }
    }
    /**
     * Creates a native element from a tag name, using a renderer.
     * @param renderer A renderer to use
     * @param name the tag name
     * @param namespace Optional namespace for element.
     * @returns the element created
     */
    function createElementNode(renderer, name, namespace) {
        ngDevMode && ngDevMode.rendererCreateElement++;
        if (isProceduralRenderer(renderer)) {
            return renderer.createElement(name, namespace);
        }
        else {
            return namespace === null ? renderer.createElement(name) :
                renderer.createElementNS(namespace, name);
        }
    }
    /**
     * Removes all DOM elements associated with a view.
     *
     * Because some root nodes of the view may be containers, we sometimes need
     * to propagate deeply into the nested containers to remove all elements in the
     * views beneath it.
     *
     * @param tView The `TView' of the `LView` from which elements should be added or removed
     * @param lView The view from which elements should be added or removed
     */
    function removeViewFromContainer(tView, lView) {
        const renderer = lView[RENDERER];
        applyView(tView, lView, renderer, 2 /* Detach */, null, null);
        lView[HOST] = null;
        lView[T_HOST] = null;
    }
    /**
     * Detach a `LView` from the DOM by detaching its nodes.
     *
     * @param tView The `TView' of the `LView` to be detached
     * @param lView the `LView` to be detached.
     */
    function renderDetachView(tView, lView) {
        applyView(tView, lView, lView[RENDERER], 2 /* Detach */, null, null);
    }
    /**
     * Traverses down and up the tree of views and containers to remove listeners and
     * call onDestroy callbacks.
     *
     * Notes:
     *  - Because it's used for onDestroy calls, it needs to be bottom-up.
     *  - Must process containers instead of their views to avoid splicing
     *  when views are destroyed and re-added.
     *  - Using a while loop because it's faster than recursion
     *  - Destroy only called on movement to sibling or movement to parent (laterally or up)
     *
     *  @param rootView The view to destroy
     */
    function destroyViewTree(rootView) {
        // If the view has no children, we can clean it up and return early.
        let lViewOrLContainer = rootView[CHILD_HEAD];
        if (!lViewOrLContainer) {
            return cleanUpView(rootView[TVIEW], rootView);
        }
        while (lViewOrLContainer) {
            let next = null;
            if (isLView(lViewOrLContainer)) {
                // If LView, traverse down to child.
                next = lViewOrLContainer[CHILD_HEAD];
            }
            else {
                ngDevMode && assertLContainer(lViewOrLContainer);
                // If container, traverse down to its first LView.
                const firstView = lViewOrLContainer[CONTAINER_HEADER_OFFSET];
                if (firstView)
                    next = firstView;
            }
            if (!next) {
                // Only clean up view when moving to the side or up, as destroy hooks
                // should be called in order from the bottom up.
                while (lViewOrLContainer && !lViewOrLContainer[NEXT] && lViewOrLContainer !== rootView) {
                    if (isLView(lViewOrLContainer)) {
                        cleanUpView(lViewOrLContainer[TVIEW], lViewOrLContainer);
                    }
                    lViewOrLContainer = lViewOrLContainer[PARENT];
                }
                if (lViewOrLContainer === null)
                    lViewOrLContainer = rootView;
                if (isLView(lViewOrLContainer)) {
                    cleanUpView(lViewOrLContainer[TVIEW], lViewOrLContainer);
                }
                next = lViewOrLContainer && lViewOrLContainer[NEXT];
            }
            lViewOrLContainer = next;
        }
    }
    function detachMovedView(declarationContainer, lView) {
        ngDevMode && assertLContainer(declarationContainer);
        ngDevMode &&
            assertDefined(declarationContainer[MOVED_VIEWS], 'A projected view should belong to a non-empty projected views collection');
        const movedViews = declarationContainer[MOVED_VIEWS];
        const declarationViewIndex = movedViews.indexOf(lView);
        const insertionLContainer = lView[PARENT];
        ngDevMode && assertLContainer(insertionLContainer);
        // If the view was marked for refresh but then detached before it was checked (where the flag
        // would be cleared and the counter decremented), we need to decrement the view counter here
        // instead.
        if (lView[FLAGS] & 1024 /* RefreshTransplantedView */) {
            lView[FLAGS] &= ~1024 /* RefreshTransplantedView */;
            updateTransplantedViewCount(insertionLContainer, -1);
        }
        movedViews.splice(declarationViewIndex, 1);
    }
    /**
     * Detaches a view from a container.
     *
     * This method removes the view from the container's array of active views. It also
     * removes the view's elements from the DOM.
     *
     * @param lContainer The container from which to detach a view
     * @param removeIndex The index of the view to detach
     * @returns Detached LView instance.
     */
    function detachView(lContainer, removeIndex) {
        if (lContainer.length <= CONTAINER_HEADER_OFFSET)
            return;
        const indexInContainer = CONTAINER_HEADER_OFFSET + removeIndex;
        const viewToDetach = lContainer[indexInContainer];
        if (viewToDetach) {
            const declarationLContainer = viewToDetach[DECLARATION_LCONTAINER];
            if (declarationLContainer !== null && declarationLContainer !== lContainer) {
                detachMovedView(declarationLContainer, viewToDetach);
            }
            if (removeIndex > 0) {
                lContainer[indexInContainer - 1][NEXT] = viewToDetach[NEXT];
            }
            const removedLView = removeFromArray(lContainer, CONTAINER_HEADER_OFFSET + removeIndex);
            removeViewFromContainer(viewToDetach[TVIEW], viewToDetach);
            // notify query that a view has been removed
            const lQueries = removedLView[QUERIES];
            if (lQueries !== null) {
                lQueries.detachView(removedLView[TVIEW]);
            }
            viewToDetach[PARENT] = null;
            viewToDetach[NEXT] = null;
            // Unsets the attached flag
            viewToDetach[FLAGS] &= ~128 /* Attached */;
        }
        return viewToDetach;
    }
    /**
     * A standalone function which destroys an LView,
     * conducting clean up (e.g. removing listeners, calling onDestroys).
     *
     * @param tView The `TView' of the `LView` to be destroyed
     * @param lView The view to be destroyed.
     */
    function destroyLView(tView, lView) {
        if (!(lView[FLAGS] & 256 /* Destroyed */)) {
            const renderer = lView[RENDERER];
            if (isProceduralRenderer(renderer) && renderer.destroyNode) {
                applyView(tView, lView, renderer, 3 /* Destroy */, null, null);
            }
            destroyViewTree(lView);
        }
    }
    /**
     * Calls onDestroys hooks for all directives and pipes in a given view and then removes all
     * listeners. Listeners are removed as the last step so events delivered in the onDestroys hooks
     * can be propagated to @Output listeners.
     *
     * @param tView `TView` for the `LView` to clean up.
     * @param lView The LView to clean up
     */
    function cleanUpView(tView, lView) {
        if (!(lView[FLAGS] & 256 /* Destroyed */)) {
            // Usually the Attached flag is removed when the view is detached from its parent, however
            // if it's a root view, the flag won't be unset hence why we're also removing on destroy.
            lView[FLAGS] &= ~128 /* Attached */;
            // Mark the LView as destroyed *before* executing the onDestroy hooks. An onDestroy hook
            // runs arbitrary user code, which could include its own `viewRef.destroy()` (or similar). If
            // We don't flag the view as destroyed before the hooks, this could lead to an infinite loop.
            // This also aligns with the ViewEngine behavior. It also means that the onDestroy hook is
            // really more of an "afterDestroy" hook if you think about it.
            lView[FLAGS] |= 256 /* Destroyed */;
            executeOnDestroys(tView, lView);
            processCleanups(tView, lView);
            // For component views only, the local renderer is destroyed at clean up time.
            if (lView[TVIEW].type === 1 /* Component */ && isProceduralRenderer(lView[RENDERER])) {
                ngDevMode && ngDevMode.rendererDestroy++;
                lView[RENDERER].destroy();
            }
            const declarationContainer = lView[DECLARATION_LCONTAINER];
            // we are dealing with an embedded view that is still inserted into a container
            if (declarationContainer !== null && isLContainer(lView[PARENT])) {
                // and this is a projected view
                if (declarationContainer !== lView[PARENT]) {
                    detachMovedView(declarationContainer, lView);
                }
                // For embedded views still attached to a container: remove query result from this view.
                const lQueries = lView[QUERIES];
                if (lQueries !== null) {
                    lQueries.detachView(tView);
                }
            }
        }
    }
    /** Removes listeners and unsubscribes from output subscriptions */
    function processCleanups(tView, lView) {
        const tCleanup = tView.cleanup;
        const lCleanup = lView[CLEANUP];
        // `LCleanup` contains both share information with `TCleanup` as well as instance specific
        // information appended at the end. We need to know where the end of the `TCleanup` information
        // is, and we track this with `lastLCleanupIndex`.
        let lastLCleanupIndex = -1;
        if (tCleanup !== null) {
            for (let i = 0; i < tCleanup.length - 1; i += 2) {
                if (typeof tCleanup[i] === 'string') {
                    // This is a native DOM listener
                    const idxOrTargetGetter = tCleanup[i + 1];
                    const target = typeof idxOrTargetGetter === 'function' ?
                        idxOrTargetGetter(lView) :
                        unwrapRNode(lView[idxOrTargetGetter]);
                    const listener = lCleanup[lastLCleanupIndex = tCleanup[i + 2]];
                    const useCaptureOrSubIdx = tCleanup[i + 3];
                    if (typeof useCaptureOrSubIdx === 'boolean') {
                        // native DOM listener registered with Renderer3
                        target.removeEventListener(tCleanup[i], listener, useCaptureOrSubIdx);
                    }
                    else {
                        if (useCaptureOrSubIdx >= 0) {
                            // unregister
                            lCleanup[lastLCleanupIndex = useCaptureOrSubIdx]();
                        }
                        else {
                            // Subscription
                            lCleanup[lastLCleanupIndex = -useCaptureOrSubIdx].unsubscribe();
                        }
                    }
                    i += 2;
                }
                else {
                    // This is a cleanup function that is grouped with the index of its context
                    const context = lCleanup[lastLCleanupIndex = tCleanup[i + 1]];
                    tCleanup[i].call(context);
                }
            }
        }
        if (lCleanup !== null) {
            for (let i = lastLCleanupIndex + 1; i < lCleanup.length; i++) {
                const instanceCleanupFn = lCleanup[i];
                ngDevMode && assertFunction(instanceCleanupFn, 'Expecting instance cleanup function.');
                instanceCleanupFn();
            }
            lView[CLEANUP] = null;
        }
    }
    /** Calls onDestroy hooks for this view */
    function executeOnDestroys(tView, lView) {
        let destroyHooks;
        if (tView != null && (destroyHooks = tView.destroyHooks) != null) {
            for (let i = 0; i < destroyHooks.length; i += 2) {
                const context = lView[destroyHooks[i]];
                // Only call the destroy hook if the context has been requested.
                if (!(context instanceof NodeInjectorFactory)) {
                    const toCall = destroyHooks[i + 1];
                    if (Array.isArray(toCall)) {
                        for (let j = 0; j < toCall.length; j += 2) {
                            const callContext = context[toCall[j]];
                            const hook = toCall[j + 1];
                            try {
                                hook.call(callContext);
                            }
                            finally {
                            }
                        }
                    }
                    else {
                        try {
                            toCall.call(context);
                        }
                        finally {
                        }
                    }
                }
            }
        }
    }
    /**
     * Inserts a native node before another native node for a given parent using {@link Renderer3}.
     * This is a utility function that can be used when native nodes were determined - it abstracts an
     * actual renderer being used.
     */
    function nativeInsertBefore(renderer, parent, child, beforeNode, isMove) {
        ngDevMode && ngDevMode.rendererInsertBefore++;
        if (isProceduralRenderer(renderer)) {
            renderer.insertBefore(parent, child, beforeNode, isMove);
        }
        else {
            parent.insertBefore(child, beforeNode, isMove);
        }
    }
    function nativeAppendChild(renderer, parent, child) {
        ngDevMode && ngDevMode.rendererAppendChild++;
        ngDevMode && assertDefined(parent, 'parent node must be defined');
        if (isProceduralRenderer(renderer)) {
            renderer.appendChild(parent, child);
        }
        else {
            parent.appendChild(child);
        }
    }
    /** Removes a node from the DOM given its native parent. */
    function nativeRemoveChild(renderer, parent, child, isHostElement) {
        if (isProceduralRenderer(renderer)) {
            renderer.removeChild(parent, child, isHostElement);
        }
        else {
            parent.removeChild(child);
        }
    }
    /**
     * Returns a native parent of a given native node.
     */
    function nativeParentNode(renderer, node) {
        return (isProceduralRenderer(renderer) ? renderer.parentNode(node) : node.parentNode);
    }
    function getProjectionNodes(lView, tNode) {
        if (tNode !== null) {
            const componentView = lView[DECLARATION_COMPONENT_VIEW];
            const componentHost = componentView[T_HOST];
            const slotIdx = tNode.projection;
            ngDevMode && assertProjectionSlots(lView);
            return componentHost.projection[slotIdx];
        }
        return null;
    }
    /**
     * Removes a native node itself using a given renderer. To remove the node we are looking up its
     * parent from the native tree as not all platforms / browsers support the equivalent of
     * node.remove().
     *
     * @param renderer A renderer to be used
     * @param rNode The native node that should be removed
     * @param isHostElement A flag indicating if a node to be removed is a host of a component.
     */
    function nativeRemoveNode(renderer, rNode, isHostElement) {
        ngDevMode && ngDevMode.rendererRemoveNode++;
        const nativeParent = nativeParentNode(renderer, rNode);
        if (nativeParent) {
            nativeRemoveChild(renderer, nativeParent, rNode, isHostElement);
        }
    }
    /**
     * Performs the operation of `action` on the node. Typically this involves inserting or removing
     * nodes on the LView or projection boundary.
     */
    function applyNodes(renderer, action, tNode, lView, parentRElement, beforeNode, isProjection) {
        while (tNode != null) {
            ngDevMode && assertTNodeForLView(tNode, lView);
            ngDevMode &&
                assertTNodeType(tNode, 3 /* AnyRNode */ | 12 /* AnyContainer */ | 16 /* Projection */ | 32 /* Icu */);
            const rawSlotValue = lView[tNode.index];
            const tNodeType = tNode.type;
            if (isProjection) {
                if (action === 0 /* Create */) {
                    rawSlotValue && attachPatchData(unwrapRNode(rawSlotValue), lView);
                    tNode.flags |= 4 /* isProjected */;
                }
            }
            if ((tNode.flags & 64 /* isDetached */) !== 64 /* isDetached */) {
                if (tNodeType & 8 /* ElementContainer */) {
                    applyNodes(renderer, action, tNode.child, lView, parentRElement, beforeNode, false);
                    applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);
                }
                else if (tNodeType & 32 /* Icu */) {
                    const nextRNode = icuContainerIterate();
                    let rNode;
                    while (rNode = nextRNode()) {
                        applyToElementOrContainer(action, renderer, parentRElement, rNode, beforeNode);
                    }
                    applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);
                }
                else if (tNodeType & 16 /* Projection */) {
                    applyProjectionRecursive(renderer, action, lView, tNode, parentRElement, beforeNode);
                }
                else {
                    ngDevMode && assertTNodeType(tNode, 3 /* AnyRNode */ | 4 /* Container */);
                    applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);
                }
            }
            tNode = isProjection ? tNode.projectionNext : tNode.next;
        }
    }
    function applyView(tView, lView, renderer, action, parentRElement, beforeNode) {
        applyNodes(renderer, action, tView.firstChild, lView, parentRElement, beforeNode, false);
    }
    /**
     * `applyProjectionRecursive` performs operation on the projection specified by `action` (insert,
     * detach, destroy)
     *
     * Inserting a projection requires us to locate the projected nodes from the parent component. The
     * complication is that those nodes themselves could be re-projected from their parent component.
     *
     * @param renderer Render to use
     * @param action action to perform (insert, detach, destroy)
     * @param lView The LView which needs to be inserted, detached, destroyed.
     * @param tProjectionNode node to project
     * @param parentRElement parent DOM element for insertion/removal.
     * @param beforeNode Before which node the insertions should happen.
     */
    function applyProjectionRecursive(renderer, action, lView, tProjectionNode, parentRElement, beforeNode) {
        const componentLView = lView[DECLARATION_COMPONENT_VIEW];
        const componentNode = componentLView[T_HOST];
        ngDevMode &&
            assertEqual(typeof tProjectionNode.projection, 'number', 'expecting projection index');
        const nodeToProjectOrRNodes = componentNode.projection[tProjectionNode.projection];
        if (Array.isArray(nodeToProjectOrRNodes)) {
            // This should not exist, it is a bit of a hack. When we bootstrap a top level node and we
            // need to support passing projectable nodes, so we cheat and put them in the TNode
            // of the Host TView. (Yes we put instance info at the T Level). We can get away with it
            // because we know that that TView is not shared and therefore it will not be a problem.
            // This should be refactored and cleaned up.
            for (let i = 0; i < nodeToProjectOrRNodes.length; i++) {
                const rNode = nodeToProjectOrRNodes[i];
                applyToElementOrContainer(action, renderer, parentRElement, rNode, beforeNode);
            }
        }
        else {
            let nodeToProject = nodeToProjectOrRNodes;
            const projectedComponentLView = componentLView[PARENT];
            applyNodes(renderer, action, nodeToProject, projectedComponentLView, parentRElement, beforeNode, true);
        }
    }
    /**
     * `applyContainer` performs an operation on the container and its views as specified by
     * `action` (insert, detach, destroy)
     *
     * Inserting a Container is complicated by the fact that the container may have Views which
     * themselves have containers or projections.
     *
     * @param renderer Renderer to use
     * @param action action to perform (insert, detach, destroy)
     * @param lContainer The LContainer which needs to be inserted, detached, destroyed.
     * @param parentRElement parent DOM element for insertion/removal.
     * @param beforeNode Before which node the insertions should happen.
     */
    function applyContainer(renderer, action, lContainer, parentRElement, beforeNode) {
        ngDevMode && assertLContainer(lContainer);
        const anchor = lContainer[NATIVE]; // LContainer has its own before node.
        const native = unwrapRNode(lContainer);
        // An LContainer can be created dynamically on any node by injecting ViewContainerRef.
        // Asking for a ViewContainerRef on an element will result in a creation of a separate anchor
        // node (comment in the DOM) that will be different from the LContainer's host node. In this
        // particular case we need to execute action on 2 nodes:
        // - container's host node (this is done in the executeActionOnElementOrContainer)
        // - container's host node (this is done here)
        if (anchor !== native) {
            // This is very strange to me (Misko). I would expect that the native is same as anchor. I
            // don't see a reason why they should be different, but they are.
            //
            // If they are we need to process the second anchor as well.
            applyToElementOrContainer(action, renderer, parentRElement, anchor, beforeNode);
        }
        for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {
            const lView = lContainer[i];
            applyView(lView[TVIEW], lView, renderer, action, parentRElement, anchor);
        }
    }
    /**
     * Write `cssText` to `RElement`.
     *
     * This function does direct write without any reconciliation. Used for writing initial values, so
     * that static styling values do not pull in the style parser.
     *
     * @param renderer Renderer to use
     * @param element The element which needs to be updated.
     * @param newValue The new class list to write.
     */
    function writeDirectStyle(renderer, element, newValue) {
        ngDevMode && assertString(newValue, '\'newValue\' should be a string');
        if (isProceduralRenderer(renderer)) {
            renderer.setAttribute(element, 'style', newValue);
        }
        else {
            element.style.cssText = newValue;
        }
        ngDevMode && ngDevMode.rendererSetStyle++;
    }
    /**
     * Write `className` to `RElement`.
     *
     * This function does direct write without any reconciliation. Used for writing initial values, so
     * that static styling values do not pull in the style parser.
     *
     * @param renderer Renderer to use
     * @param element The element which needs to be updated.
     * @param newValue The new class list to write.
     */
    function writeDirectClass(renderer, element, newValue) {
        ngDevMode && assertString(newValue, '\'newValue\' should be a string');
        if (isProceduralRenderer(renderer)) {
            if (newValue === '') {
                // There are tests in `google3` which expect `element.getAttribute('class')` to be `null`.
                renderer.removeAttribute(element, 'class');
            }
            else {
                renderer.setAttribute(element, 'class', newValue);
            }
        }
        else {
            element.className = newValue;
        }
        ngDevMode && ngDevMode.rendererSetClassName++;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function isPositive(mode) {
        return (mode & 1 /* NOT */) === 0;
    }
    function maybeWrapInNotSelector(isNegativeMode, chunk) {
        return isNegativeMode ? ':not(' + chunk.trim() + ')' : chunk;
    }
    function stringifyCSSSelector(selector) {
        let result = selector[0];
        let i = 1;
        let mode = 2 /* ATTRIBUTE */;
        let currentChunk = '';
        let isNegativeMode = false;
        while (i < selector.length) {
            let valueOrMarker = selector[i];
            if (typeof valueOrMarker === 'string') {
                if (mode & 2 /* ATTRIBUTE */) {
                    const attrValue = selector[++i];
                    currentChunk +=
                        '[' + valueOrMarker + (attrValue.length > 0 ? '="' + attrValue + '"' : '') + ']';
                }
                else if (mode & 8 /* CLASS */) {
                    currentChunk += '.' + valueOrMarker;
                }
                else if (mode & 4 /* ELEMENT */) {
                    currentChunk += ' ' + valueOrMarker;
                }
            }
            else {
                //
                // Append current chunk to the final result in case we come across SelectorFlag, which
                // indicates that the previous section of a selector is over. We need to accumulate content
                // between flags to make sure we wrap the chunk later in :not() selector if needed, e.g.
                // ```
                //  ['', Flags.CLASS, '.classA', Flags.CLASS | Flags.NOT, '.classB', '.classC']
                // ```
                // should be transformed to `.classA :not(.classB .classC)`.
                //
                // Note: for negative selector part, we accumulate content between flags until we find the
                // next negative flag. This is needed to support a case where `:not()` rule contains more than
                // one chunk, e.g. the following selector:
                // ```
                //  ['', Flags.ELEMENT | Flags.NOT, 'p', Flags.CLASS, 'foo', Flags.CLASS | Flags.NOT, 'bar']
                // ```
                // should be stringified to `:not(p.foo) :not(.bar)`
                //
                if (currentChunk !== '' && !isPositive(valueOrMarker)) {
                    result += maybeWrapInNotSelector(isNegativeMode, currentChunk);
                    currentChunk = '';
                }
                mode = valueOrMarker;
                // According to CssSelector spec, once we come across `SelectorFlags.NOT` flag, the negative
                // mode is maintained for remaining chunks of a selector.
                isNegativeMode = isNegativeMode || !isPositive(mode);
            }
            i++;
        }
        if (currentChunk !== '') {
            result += maybeWrapInNotSelector(isNegativeMode, currentChunk);
        }
        return result;
    }
    /**
     * Generates string representation of CSS selector in parsed form.
     *
     * ComponentDef and DirectiveDef are generated with the selector in parsed form to avoid doing
     * additional parsing at runtime (for example, for directive matching). However in some cases (for
     * example, while bootstrapping a component), a string version of the selector is required to query
     * for the host element on the page. This function takes the parsed form of a selector and returns
     * its string representation.
     *
     * @param selectorList selector in parsed form
     * @returns string representation of a given selector
     */
    function stringifyCSSSelectorList(selectorList) {
        return selectorList.map(stringifyCSSSelector).join(',');
    }
    /**
     * Extracts attributes and classes information from a given CSS selector.
     *
     * This function is used while creating a component dynamically. In this case, the host element
     * (that is created dynamically) should contain attributes and classes specified in component's CSS
     * selector.
     *
     * @param selector CSS selector in parsed form (in a form of array)
     * @returns object with `attrs` and `classes` fields that contain extracted information
     */
    function extractAttrsAndClassesFromSelector(selector) {
        const attrs = [];
        const classes = [];
        let i = 1;
        let mode = 2 /* ATTRIBUTE */;
        while (i < selector.length) {
            let valueOrMarker = selector[i];
            if (typeof valueOrMarker === 'string') {
                if (mode === 2 /* ATTRIBUTE */) {
                    if (valueOrMarker !== '') {
                        attrs.push(valueOrMarker, selector[++i]);
                    }
                }
                else if (mode === 8 /* CLASS */) {
                    classes.push(valueOrMarker);
                }
            }
            else {
                // According to CssSelector spec, once we come across `SelectorFlags.NOT` flag, the negative
                // mode is maintained for remaining chunks of a selector. Since attributes and classes are
                // extracted only for "positive" part of the selector, we can stop here.
                if (!isPositive(mode))
                    break;
                mode = valueOrMarker;
            }
            i++;
        }
        return { attrs, classes };
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /** A special value which designates that a value has not changed. */
    const NO_CHANGE = (typeof ngDevMode === 'undefined' || ngDevMode) ? { __brand__: 'NO_CHANGE' } : {};

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function selectIndexInternal(tView, lView, index, checkNoChangesMode) {
        ngDevMode && assertIndexInDeclRange(lView, index);
        // Flush the initial hooks for elements in the view that have been added up to this point.
        // PERF WARNING: do NOT extract this to a separate function without running benchmarks
        if (!checkNoChangesMode) {
            const hooksInitPhaseCompleted = (lView[FLAGS] & 3 /* InitPhaseStateMask */) === 3 /* InitPhaseCompleted */;
            if (hooksInitPhaseCompleted) {
                const preOrderCheckHooks = tView.preOrderCheckHooks;
                if (preOrderCheckHooks !== null) {
                    executeCheckHooks(lView, preOrderCheckHooks, index);
                }
            }
            else {
                const preOrderHooks = tView.preOrderHooks;
                if (preOrderHooks !== null) {
                    executeInitAndCheckHooks(lView, preOrderHooks, 0 /* OnInitHooksToBeRun */, index);
                }
            }
        }
        // We must set the selected index *after* running the hooks, because hooks may have side-effects
        // that cause other template functions to run, thus updating the selected index, which is global
        // state. If we run `setSelectedIndex` *before* we run the hooks, in some cases the selected index
        // will be altered by the time we leave the `ÉµÉµadvance` instruction.
        setSelectedIndex(index);
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function getTStylingRangePrev(tStylingRange) {
        ngDevMode && assertNumber(tStylingRange, 'expected number');
        return (tStylingRange >> 17 /* PREV_SHIFT */) & 32767 /* UNSIGNED_MASK */;
    }
    function getTStylingRangePrevDuplicate(tStylingRange) {
        ngDevMode && assertNumber(tStylingRange, 'expected number');
        return (tStylingRange & 2 /* PREV_DUPLICATE */) ==
            2 /* PREV_DUPLICATE */;
    }
    function getTStylingRangeNext(tStylingRange) {
        ngDevMode && assertNumber(tStylingRange, 'expected number');
        return (tStylingRange & 131068 /* NEXT_MASK */) >> 2 /* NEXT_SHIFT */;
    }
    function getTStylingRangeNextDuplicate(tStylingRange) {
        ngDevMode && assertNumber(tStylingRange, 'expected number');
        return (tStylingRange & 1 /* NEXT_DUPLICATE */) ===
            1 /* NEXT_DUPLICATE */;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Patch a `debug` property on top of the existing object.
     *
     * NOTE: always call this method with `ngDevMode && attachDebugObject(...)`
     *
     * @param obj Object to patch
     * @param debug Value to patch
     */
    function attachDebugObject(obj, debug) {
        if (ngDevMode) {
            Object.defineProperty(obj, 'debug', { value: debug, enumerable: false });
        }
        else {
            throw new Error('This method should be guarded with `ngDevMode` so that it can be tree shaken in production!');
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const NG_DEV_MODE = ((typeof ngDevMode === 'undefined' || !!ngDevMode) && initNgDevMode());
    /*
     * This file contains conditionally attached classes which provide human readable (debug) level
     * information for `LView`, `LContainer` and other internal data structures. These data structures
     * are stored internally as array which makes it very difficult during debugging to reason about the
     * current state of the system.
     *
     * Patching the array with extra property does change the array's hidden class' but it does not
     * change the cost of access, therefore this patching should not have significant if any impact in
     * `ngDevMode` mode. (see: https://jsperf.com/array-vs-monkey-patch-array)
     *
     * So instead of seeing:
     * ```
     * Array(30) [Object, 659, null, â¦]
     * ```
     *
     * You get to see:
     * ```
     * LViewDebug {
     *   views: [...],
     *   flags: {attached: true, ...}
     *   nodes: [
     *     {html: '<div id="123">', ..., nodes: [
     *       {html: '<span>', ..., nodes: null}
     *     ]}
     *   ]
     * }
     * ```
     */
    let LVIEW_COMPONENT_CACHE;
    let LVIEW_EMBEDDED_CACHE;
    let LVIEW_ROOT;
    /**
     * This function clones a blueprint and creates LView.
     *
     * Simple slice will keep the same type, and we need it to be LView
     */
    function cloneToLViewFromTViewBlueprint(tView) {
        const debugTView = tView;
        const lView = getLViewToClone(debugTView.type, tView.template && tView.template.name);
        return lView.concat(tView.blueprint);
    }
    function getLViewToClone(type, name) {
        switch (type) {
            case 0 /* Root */:
                if (LVIEW_ROOT === undefined)
                    LVIEW_ROOT = new (createNamedArrayType('LRootView'))();
                return LVIEW_ROOT;
            case 1 /* Component */:
                if (LVIEW_COMPONENT_CACHE === undefined)
                    LVIEW_COMPONENT_CACHE = new Map();
                let componentArray = LVIEW_COMPONENT_CACHE.get(name);
                if (componentArray === undefined) {
                    componentArray = new (createNamedArrayType('LComponentView' + nameSuffix(name)))();
                    LVIEW_COMPONENT_CACHE.set(name, componentArray);
                }
                return componentArray;
            case 2 /* Embedded */:
                if (LVIEW_EMBEDDED_CACHE === undefined)
                    LVIEW_EMBEDDED_CACHE = new Map();
                let embeddedArray = LVIEW_EMBEDDED_CACHE.get(name);
                if (embeddedArray === undefined) {
                    embeddedArray = new (createNamedArrayType('LEmbeddedView' + nameSuffix(name)))();
                    LVIEW_EMBEDDED_CACHE.set(name, embeddedArray);
                }
                return embeddedArray;
        }
    }
    function nameSuffix(text) {
        if (text == null)
            return '';
        const index = text.lastIndexOf('_Template');
        return '_' + (index === -1 ? text : text.substr(0, index));
    }
    /**
     * This class is a debug version of Object literal so that we can have constructor name show up
     * in
     * debug tools in ngDevMode.
     */
    const TViewConstructor = class TView {
        constructor(type, blueprint, template, queries, viewQuery, declTNode, data, bindingStartIndex, expandoStartIndex, hostBindingOpCodes, firstCreatePass, firstUpdatePass, staticViewQueries, staticContentQueries, preOrderHooks, preOrderCheckHooks, contentHooks, contentCheckHooks, viewHooks, viewCheckHooks, destroyHooks, cleanup, contentQueries, components, directiveRegistry, pipeRegistry, firstChild, schemas, consts, incompleteFirstPass, _decls, _vars) {
            this.type = type;
            this.blueprint = blueprint;
            this.template = template;
            this.queries = queries;
            this.viewQuery = viewQuery;
            this.declTNode = declTNode;
            this.data = data;
            this.bindingStartIndex = bindingStartIndex;
            this.expandoStartIndex = expandoStartIndex;
            this.hostBindingOpCodes = hostBindingOpCodes;
            this.firstCreatePass = firstCreatePass;
            this.firstUpdatePass = firstUpdatePass;
            this.staticViewQueries = staticViewQueries;
            this.staticContentQueries = staticContentQueries;
            this.preOrderHooks = preOrderHooks;
            this.preOrderCheckHooks = preOrderCheckHooks;
            this.contentHooks = contentHooks;
            this.contentCheckHooks = contentCheckHooks;
            this.viewHooks = viewHooks;
            this.viewCheckHooks = viewCheckHooks;
            this.destroyHooks = destroyHooks;
            this.cleanup = cleanup;
            this.contentQueries = contentQueries;
            this.components = components;
            this.directiveRegistry = directiveRegistry;
            this.pipeRegistry = pipeRegistry;
            this.firstChild = firstChild;
            this.schemas = schemas;
            this.consts = consts;
            this.incompleteFirstPass = incompleteFirstPass;
            this._decls = _decls;
            this._vars = _vars;
        }
        get template_() {
            const buf = [];
            processTNodeChildren(this.firstChild, buf);
            return buf.join('');
        }
        get type_() {
            return TViewTypeAsString[this.type] || `TViewType.?${this.type}?`;
        }
    };
    class TNode {
        constructor(tView_, //
        type, //
        index, //
        insertBeforeIndex, //
        injectorIndex, //
        directiveStart, //
        directiveEnd, //
        directiveStylingLast, //
        propertyBindings, //
        flags, //
        providerIndexes, //
        value, //
        attrs, //
        mergedAttrs, //
        localNames, //
        initialInputs, //
        inputs, //
        outputs, //
        tViews, //
        next, //
        projectionNext, //
        child, //
        parent, //
        projection, //
        styles, //
        stylesWithoutHost, //
        residualStyles, //
        classes, //
        classesWithoutHost, //
        residualClasses, //
        classBindings, //
        styleBindings) {
            this.tView_ = tView_;
            this.type = type;
            this.index = index;
            this.insertBeforeIndex = insertBeforeIndex;
            this.injectorIndex = injectorIndex;
            this.directiveStart = directiveStart;
            this.directiveEnd = directiveEnd;
            this.directiveStylingLast = directiveStylingLast;
            this.propertyBindings = propertyBindings;
            this.flags = flags;
            this.providerIndexes = providerIndexes;
            this.value = value;
            this.attrs = attrs;
            this.mergedAttrs = mergedAttrs;
            this.localNames = localNames;
            this.initialInputs = initialInputs;
            this.inputs = inputs;
            this.outputs = outputs;
            this.tViews = tViews;
            this.next = next;
            this.projectionNext = projectionNext;
            this.child = child;
            this.parent = parent;
            this.projection = projection;
            this.styles = styles;
            this.stylesWithoutHost = stylesWithoutHost;
            this.residualStyles = residualStyles;
            this.classes = classes;
            this.classesWithoutHost = classesWithoutHost;
            this.residualClasses = residualClasses;
            this.classBindings = classBindings;
            this.styleBindings = styleBindings;
        }
        /**
         * Return a human debug version of the set of `NodeInjector`s which will be consulted when
         * resolving tokens from this `TNode`.
         *
         * When debugging applications, it is often difficult to determine which `NodeInjector`s will be
         * consulted. This method shows a list of `DebugNode`s representing the `TNode`s which will be
         * consulted in order when resolving a token starting at this `TNode`.
         *
         * The original data is stored in `LView` and `TView` with a lot of offset indexes, and so it is
         * difficult to reason about.
         *
         * @param lView The `LView` instance for this `TNode`.
         */
        debugNodeInjectorPath(lView) {
            const path = [];
            let injectorIndex = getInjectorIndex(this, lView);
            if (injectorIndex === -1) {
                // Looks like the current `TNode` does not have `NodeInjector` associated with it => look for
                // parent NodeInjector.
                const parentLocation = getParentInjectorLocation(this, lView);
                if (parentLocation !== NO_PARENT_INJECTOR) {
                    // We found a parent, so start searching from the parent location.
                    injectorIndex = getParentInjectorIndex(parentLocation);
                    lView = getParentInjectorView(parentLocation, lView);
                }
            }
            while (injectorIndex !== -1) {
                ngDevMode && assertNodeInjector(lView, injectorIndex);
                const tNode = lView[TVIEW].data[injectorIndex + 8 /* TNODE */];
                path.push(buildDebugNode(tNode, lView));
                const parentLocation = lView[injectorIndex + 8 /* PARENT */];
                if (parentLocation === NO_PARENT_INJECTOR) {
                    injectorIndex = -1;
                }
                else {
                    injectorIndex = getParentInjectorIndex(parentLocation);
                    lView = getParentInjectorView(parentLocation, lView);
                }
            }
            return path;
        }
        get type_() {
            return toTNodeTypeAsString(this.type) || `TNodeType.?${this.type}?`;
        }
        get flags_() {
            const flags = [];
            if (this.flags & 16 /* hasClassInput */)
                flags.push('TNodeFlags.hasClassInput');
            if (this.flags & 8 /* hasContentQuery */)
                flags.push('TNodeFlags.hasContentQuery');
            if (this.flags & 32 /* hasStyleInput */)
                flags.push('TNodeFlags.hasStyleInput');
            if (this.flags & 128 /* hasHostBindings */)
                flags.push('TNodeFlags.hasHostBindings');
            if (this.flags & 2 /* isComponentHost */)
                flags.push('TNodeFlags.isComponentHost');
            if (this.flags & 1 /* isDirectiveHost */)
                flags.push('TNodeFlags.isDirectiveHost');
            if (this.flags & 64 /* isDetached */)
                flags.push('TNodeFlags.isDetached');
            if (this.flags & 4 /* isProjected */)
                flags.push('TNodeFlags.isProjected');
            return flags.join('|');
        }
        get template_() {
            if (this.type & 1 /* Text */)
                return this.value;
            const buf = [];
            const tagName = typeof this.value === 'string' && this.value || this.type_;
            buf.push('<', tagName);
            if (this.flags) {
                buf.push(' ', this.flags_);
            }
            if (this.attrs) {
                for (let i = 0; i < this.attrs.length;) {
                    const attrName = this.attrs[i++];
                    if (typeof attrName == 'number') {
                        break;
                    }
                    const attrValue = this.attrs[i++];
                    buf.push(' ', attrName, '="', attrValue, '"');
                }
            }
            buf.push('>');
            processTNodeChildren(this.child, buf);
            buf.push('</', tagName, '>');
            return buf.join('');
        }
        get styleBindings_() {
            return toDebugStyleBinding(this, false);
        }
        get classBindings_() {
            return toDebugStyleBinding(this, true);
        }
        get providerIndexStart_() {
            return this.providerIndexes & 1048575 /* ProvidersStartIndexMask */;
        }
        get providerIndexEnd_() {
            return this.providerIndexStart_ +
                (this.providerIndexes >>> 20 /* CptViewProvidersCountShift */);
        }
    }
    const TNodeDebug = TNode;
    function toDebugStyleBinding(tNode, isClassBased) {
        const tData = tNode.tView_.data;
        const bindings = [];
        const range = isClassBased ? tNode.classBindings : tNode.styleBindings;
        const prev = getTStylingRangePrev(range);
        const next = getTStylingRangeNext(range);
        let isTemplate = next !== 0;
        let cursor = isTemplate ? next : prev;
        while (cursor !== 0) {
            const itemKey = tData[cursor];
            const itemRange = tData[cursor + 1];
            bindings.unshift({
                key: itemKey,
                index: cursor,
                isTemplate: isTemplate,
                prevDuplicate: getTStylingRangePrevDuplicate(itemRange),
                nextDuplicate: getTStylingRangeNextDuplicate(itemRange),
                nextIndex: getTStylingRangeNext(itemRange),
                prevIndex: getTStylingRangePrev(itemRange),
            });
            if (cursor === prev)
                isTemplate = false;
            cursor = getTStylingRangePrev(itemRange);
        }
        bindings.push((isClassBased ? tNode.residualClasses : tNode.residualStyles) || null);
        return bindings;
    }
    function processTNodeChildren(tNode, buf) {
        while (tNode) {
            buf.push(tNode.template_);
            tNode = tNode.next;
        }
    }
    const TViewData = NG_DEV_MODE && createNamedArrayType('TViewData') || null;
    let TVIEWDATA_EMPTY; // can't initialize here or it will not be tree shaken, because
    // `LView` constructor could have side-effects.
    /**
     * This function clones a blueprint and creates TData.
     *
     * Simple slice will keep the same type, and we need it to be TData
     */
    function cloneToTViewData(list) {
        if (TVIEWDATA_EMPTY === undefined)
            TVIEWDATA_EMPTY = new TViewData();
        return TVIEWDATA_EMPTY.concat(list);
    }
    const LViewBlueprint = NG_DEV_MODE && createNamedArrayType('LViewBlueprint') || null;
    const MatchesArray = NG_DEV_MODE && createNamedArrayType('MatchesArray') || null;
    const TViewComponents = NG_DEV_MODE && createNamedArrayType('TViewComponents') || null;
    const TNodeLocalNames = NG_DEV_MODE && createNamedArrayType('TNodeLocalNames') || null;
    const TNodeInitialInputs = NG_DEV_MODE && createNamedArrayType('TNodeInitialInputs') || null;
    const TNodeInitialData = NG_DEV_MODE && createNamedArrayType('TNodeInitialData') || null;
    const LCleanup = NG_DEV_MODE && createNamedArrayType('LCleanup') || null;
    const TCleanup = NG_DEV_MODE && createNamedArrayType('TCleanup') || null;
    function attachLViewDebug(lView) {
        attachDebugObject(lView, new LViewDebug(lView));
    }
    function toDebug(obj) {
        if (obj) {
            const debug = obj.debug;
            assertDefined(debug, 'Object does not have a debug representation.');
            return debug;
        }
        else {
            return obj;
        }
    }
    /**
     * Use this method to unwrap a native element in `LView` and convert it into HTML for easier
     * reading.
     *
     * @param value possibly wrapped native DOM node.
     * @param includeChildren If `true` then the serialized HTML form will include child elements
     * (same
     * as `outerHTML`). If `false` then the serialized HTML form will only contain the element
     * itself
     * (will not serialize child elements).
     */
    function toHtml(value, includeChildren = false) {
        const node = unwrapRNode(value);
        if (node) {
            switch (node.nodeType) {
                case Node.TEXT_NODE:
                    return node.textContent;
                case Node.COMMENT_NODE:
                    return `<!--${node.textContent}-->`;
                case Node.ELEMENT_NODE:
                    const outerHTML = node.outerHTML;
                    if (includeChildren) {
                        return outerHTML;
                    }
                    else {
                        const innerHTML = '>' + node.innerHTML + '<';
                        return (outerHTML.split(innerHTML)[0]) + '>';
                    }
            }
        }
        return null;
    }
    class LViewDebug {
        constructor(_raw_lView) {
            this._raw_lView = _raw_lView;
        }
        /**
         * Flags associated with the `LView` unpacked into a more readable state.
         */
        get flags() {
            const flags = this._raw_lView[FLAGS];
            return {
                __raw__flags__: flags,
                initPhaseState: flags & 3 /* InitPhaseStateMask */,
                creationMode: !!(flags & 4 /* CreationMode */),
                firstViewPass: !!(flags & 8 /* FirstLViewPass */),
                checkAlways: !!(flags & 16 /* CheckAlways */),
                dirty: !!(flags & 64 /* Dirty */),
                attached: !!(flags & 128 /* Attached */),
                destroyed: !!(flags & 256 /* Destroyed */),
                isRoot: !!(flags & 512 /* IsRoot */),
                indexWithinInitPhase: flags >> 11 /* IndexWithinInitPhaseShift */,
            };
        }
        get parent() {
            return toDebug(this._raw_lView[PARENT]);
        }
        get hostHTML() {
            return toHtml(this._raw_lView[HOST], true);
        }
        get html() {
            return (this.nodes || []).map(mapToHTML).join('');
        }
        get context() {
            return this._raw_lView[CONTEXT];
        }
        /**
         * The tree of nodes associated with the current `LView`. The nodes have been normalized into
         * a tree structure with relevant details pulled out for readability.
         */
        get nodes() {
            const lView = this._raw_lView;
            const tNode = lView[TVIEW].firstChild;
            return toDebugNodes(tNode, lView);
        }
        get template() {
            return this.tView.template_;
        }
        get tView() {
            return this._raw_lView[TVIEW];
        }
        get cleanup() {
            return this._raw_lView[CLEANUP];
        }
        get injector() {
            return this._raw_lView[INJECTOR];
        }
        get rendererFactory() {
            return this._raw_lView[RENDERER_FACTORY];
        }
        get renderer() {
            return this._raw_lView[RENDERER];
        }
        get sanitizer() {
            return this._raw_lView[SANITIZER];
        }
        get childHead() {
            return toDebug(this._raw_lView[CHILD_HEAD]);
        }
        get next() {
            return toDebug(this._raw_lView[NEXT]);
        }
        get childTail() {
            return toDebug(this._raw_lView[CHILD_TAIL]);
        }
        get declarationView() {
            return toDebug(this._raw_lView[DECLARATION_VIEW]);
        }
        get queries() {
            return this._raw_lView[QUERIES];
        }
        get tHost() {
            return this._raw_lView[T_HOST];
        }
        get decls() {
            return toLViewRange(this.tView, this._raw_lView, HEADER_OFFSET, this.tView.bindingStartIndex);
        }
        get vars() {
            return toLViewRange(this.tView, this._raw_lView, this.tView.bindingStartIndex, this.tView.expandoStartIndex);
        }
        get expando() {
            return toLViewRange(this.tView, this._raw_lView, this.tView.expandoStartIndex, this._raw_lView.length);
        }
        /**
         * Normalized view of child views (and containers) attached at this location.
         */
        get childViews() {
            const childViews = [];
            let child = this.childHead;
            while (child) {
                childViews.push(child);
                child = child.next;
            }
            return childViews;
        }
    }
    function mapToHTML(node) {
        if (node.type === 'ElementContainer') {
            return (node.children || []).map(mapToHTML).join('');
        }
        else if (node.type === 'IcuContainer') {
            throw new Error('Not implemented');
        }
        else {
            return toHtml(node.native, true) || '';
        }
    }
    function toLViewRange(tView, lView, start, end) {
        let content = [];
        for (let index = start; index < end; index++) {
            content.push({ index: index, t: tView.data[index], l: lView[index] });
        }
        return { start: start, end: end, length: end - start, content: content };
    }
    /**
     * Turns a flat list of nodes into a tree by walking the associated `TNode` tree.
     *
     * @param tNode
     * @param lView
     */
    function toDebugNodes(tNode, lView) {
        if (tNode) {
            const debugNodes = [];
            let tNodeCursor = tNode;
            while (tNodeCursor) {
                debugNodes.push(buildDebugNode(tNodeCursor, lView));
                tNodeCursor = tNodeCursor.next;
            }
            return debugNodes;
        }
        else {
            return [];
        }
    }
    function buildDebugNode(tNode, lView) {
        const rawValue = lView[tNode.index];
        const native = unwrapRNode(rawValue);
        const factories = [];
        const instances = [];
        const tView = lView[TVIEW];
        for (let i = tNode.directiveStart; i < tNode.directiveEnd; i++) {
            const def = tView.data[i];
            factories.push(def.type);
            instances.push(lView[i]);
        }
        return {
            html: toHtml(native),
            type: toTNodeTypeAsString(tNode.type),
            tNode,
            native: native,
            children: toDebugNodes(tNode.child, lView),
            factories,
            instances,
            injector: buildNodeInjectorDebug(tNode, tView, lView),
            get injectorResolutionPath() {
                return tNode.debugNodeInjectorPath(lView);
            },
        };
    }
    function buildNodeInjectorDebug(tNode, tView, lView) {
        const viewProviders = [];
        for (let i = tNode.providerIndexStart_; i < tNode.providerIndexEnd_; i++) {
            viewProviders.push(tView.data[i]);
        }
        const providers = [];
        for (let i = tNode.providerIndexEnd_; i < tNode.directiveEnd; i++) {
            providers.push(tView.data[i]);
        }
        const nodeInjectorDebug = {
            bloom: toBloom(lView, tNode.injectorIndex),
            cumulativeBloom: toBloom(tView.data, tNode.injectorIndex),
            providers,
            viewProviders,
            parentInjectorIndex: lView[tNode.providerIndexStart_ - 1],
        };
        return nodeInjectorDebug;
    }
    /**
     * Convert a number at `idx` location in `array` into binary representation.
     *
     * @param array
     * @param idx
     */
    function binary(array, idx) {
        const value = array[idx];
        // If not a number we print 8 `?` to retain alignment but let user know that it was called on
        // wrong type.
        if (typeof value !== 'number')
            return '????????';
        // We prefix 0s so that we have constant length number
        const text = '00000000' + value.toString(2);
        return text.substring(text.length - 8);
    }
    /**
     * Convert a bloom filter at location `idx` in `array` into binary representation.
     *
     * @param array
     * @param idx
     */
    function toBloom(array, idx) {
        if (idx < 0) {
            return 'NO_NODE_INJECTOR';
        }
        return `${binary(array, idx + 7)}_${binary(array, idx + 6)}_${binary(array, idx + 5)}_${binary(array, idx + 4)}_${binary(array, idx + 3)}_${binary(array, idx + 2)}_${binary(array, idx + 1)}_${binary(array, idx + 0)}`;
    }

    const Éµ0$5 = () => Promise.resolve(null);
    /**
     * A permanent marker promise which signifies that the current CD tree is
     * clean.
     */
    const _CLEAN_PROMISE = (Éµ0$5)();
    /**
     * Invoke `HostBindingsFunction`s for view.
     *
     * This methods executes `TView.hostBindingOpCodes`. It is used to execute the
     * `HostBindingsFunction`s associated with the current `LView`.
     *
     * @param tView Current `TView`.
     * @param lView Current `LView`.
     */
    function processHostBindingOpCodes(tView, lView) {
        const hostBindingOpCodes = tView.hostBindingOpCodes;
        if (hostBindingOpCodes === null)
            return;
        try {
            for (let i = 0; i < hostBindingOpCodes.length; i++) {
                const opCode = hostBindingOpCodes[i];
                if (opCode < 0) {
                    // Negative numbers are element indexes.
                    setSelectedIndex(~opCode);
                }
                else {
                    // Positive numbers are NumberTuple which store bindingRootIndex and directiveIndex.
                    const directiveIdx = opCode;
                    const bindingRootIndx = hostBindingOpCodes[++i];
                    const hostBindingFn = hostBindingOpCodes[++i];
                    setBindingRootForHostBindings(bindingRootIndx, directiveIdx);
                    const context = lView[directiveIdx];
                    hostBindingFn(2 /* Update */, context);
                }
            }
        }
        finally {
            setSelectedIndex(-1);
        }
    }
    /** Refreshes all content queries declared by directives in a given view */
    function refreshContentQueries(tView, lView) {
        const contentQueries = tView.contentQueries;
        if (contentQueries !== null) {
            for (let i = 0; i < contentQueries.length; i += 2) {
                const queryStartIdx = contentQueries[i];
                const directiveDefIdx = contentQueries[i + 1];
                if (directiveDefIdx !== -1) {
                    const directiveDef = tView.data[directiveDefIdx];
                    ngDevMode && assertDefined(directiveDef, 'DirectiveDef not found.');
                    ngDevMode &&
                        assertDefined(directiveDef.contentQueries, 'contentQueries function should be defined');
                    setCurrentQueryIndex(queryStartIdx);
                    directiveDef.contentQueries(2 /* Update */, lView[directiveDefIdx], directiveDefIdx);
                }
            }
        }
    }
    /** Refreshes child components in the current view (update mode). */
    function refreshChildComponents(hostLView, components) {
        for (let i = 0; i < components.length; i++) {
            refreshComponent(hostLView, components[i]);
        }
    }
    /** Renders child components in the current view (creation mode). */
    function renderChildComponents(hostLView, components) {
        for (let i = 0; i < components.length; i++) {
            renderComponent(hostLView, components[i]);
        }
    }
    function createLView(parentLView, tView, context, flags, host, tHostNode, rendererFactory, renderer, sanitizer, injector) {
        const lView = ngDevMode ? cloneToLViewFromTViewBlueprint(tView) : tView.blueprint.slice();
        lView[HOST] = host;
        lView[FLAGS] = flags | 4 /* CreationMode */ | 128 /* Attached */ | 8 /* FirstLViewPass */;
        resetPreOrderHookFlags(lView);
        ngDevMode && tView.declTNode && parentLView && assertTNodeForLView(tView.declTNode, parentLView);
        lView[PARENT] = lView[DECLARATION_VIEW] = parentLView;
        lView[CONTEXT] = context;
        lView[RENDERER_FACTORY] = (rendererFactory || parentLView && parentLView[RENDERER_FACTORY]);
        ngDevMode && assertDefined(lView[RENDERER_FACTORY], 'RendererFactory is required');
        lView[RENDERER] = (renderer || parentLView && parentLView[RENDERER]);
        ngDevMode && assertDefined(lView[RENDERER], 'Renderer is required');
        lView[SANITIZER] = sanitizer || parentLView && parentLView[SANITIZER] || null;
        lView[INJECTOR] = injector || parentLView && parentLView[INJECTOR] || null;
        lView[T_HOST] = tHostNode;
        ngDevMode &&
            assertEqual(tView.type == 2 /* Embedded */ ? parentLView !== null : true, true, 'Embedded views must have parentLView');
        lView[DECLARATION_COMPONENT_VIEW] =
            tView.type == 2 /* Embedded */ ? parentLView[DECLARATION_COMPONENT_VIEW] : lView;
        ngDevMode && attachLViewDebug(lView);
        return lView;
    }
    function getOrCreateTNode(tView, index, type, name, attrs) {
        ngDevMode && index !== 0 && // 0 are bogus nodes and they are OK. See `createContainerRef` in
            // `view_engine_compatibility` for additional context.
            assertGreaterThanOrEqual(index, HEADER_OFFSET, 'TNodes can\'t be in the LView header.');
        // Keep this function short, so that the VM will inline it.
        ngDevMode && assertPureTNodeType(type);
        let tNode = tView.data[index];
        if (tNode === null) {
            tNode = createTNodeAtIndex(tView, index, type, name, attrs);
            if (isInI18nBlock()) {
                // If we are in i18n block then all elements should be pre declared through `Placeholder`
                // See `TNodeType.Placeholder` and `LFrame.inI18n` for more context.
                // If the `TNode` was not pre-declared than it means it was not mentioned which means it was
                // removed, so we mark it as detached.
                tNode.flags |= 64 /* isDetached */;
            }
        }
        else if (tNode.type & 64 /* Placeholder */) {
            tNode.type = type;
            tNode.value = name;
            tNode.attrs = attrs;
            const parent = getCurrentParentTNode();
            tNode.injectorIndex = parent === null ? -1 : parent.injectorIndex;
            ngDevMode && assertTNodeForTView(tNode, tView);
            ngDevMode && assertEqual(index, tNode.index, 'Expecting same index');
        }
        setCurrentTNode(tNode, true);
        return tNode;
    }
    function createTNodeAtIndex(tView, index, type, name, attrs) {
        const currentTNode = getCurrentTNodePlaceholderOk();
        const isParent = isCurrentTNodeParent();
        const parent = isParent ? currentTNode : currentTNode && currentTNode.parent;
        // Parents cannot cross component boundaries because components will be used in multiple places.
        const tNode = tView.data[index] =
            createTNode(tView, parent, type, index, name, attrs);
        // Assign a pointer to the first child node of a given view. The first node is not always the one
        // at index 0, in case of i18n, index 0 can be the instruction `i18nStart` and the first node has
        // the index 1 or more, so we can't just check node index.
        if (tView.firstChild === null) {
            tView.firstChild = tNode;
        }
        if (currentTNode !== null) {
            if (isParent) {
                // FIXME(misko): This logic looks unnecessarily complicated. Could we simplify?
                if (currentTNode.child == null && tNode.parent !== null) {
                    // We are in the same view, which means we are adding content node to the parent view.
                    currentTNode.child = tNode;
                }
            }
            else {
                if (currentTNode.next === null) {
                    // In the case of i18n the `currentTNode` may already be linked, in which case we don't want
                    // to break the links which i18n created.
                    currentTNode.next = tNode;
                }
            }
        }
        return tNode;
    }
    /**
     * When elements are created dynamically after a view blueprint is created (e.g. through
     * i18nApply()), we need to adjust the blueprint for future
     * template passes.
     *
     * @param tView `TView` associated with `LView`
     * @param lView The `LView` containing the blueprint to adjust
     * @param numSlotsToAlloc The number of slots to alloc in the LView, should be >0
     * @param initialValue Initial value to store in blueprint
     */
    function allocExpando(tView, lView, numSlotsToAlloc, initialValue) {
        if (numSlotsToAlloc === 0)
            return -1;
        if (ngDevMode) {
            assertFirstCreatePass(tView);
            assertSame(tView, lView[TVIEW], '`LView` must be associated with `TView`!');
            assertEqual(tView.data.length, lView.length, 'Expecting LView to be same size as TView');
            assertEqual(tView.data.length, tView.blueprint.length, 'Expecting Blueprint to be same size as TView');
            assertFirstUpdatePass(tView);
        }
        const allocIdx = lView.length;
        for (let i = 0; i < numSlotsToAlloc; i++) {
            lView.push(initialValue);
            tView.blueprint.push(initialValue);
            tView.data.push(null);
        }
        return allocIdx;
    }
    //////////////////////////
    //// Render
    //////////////////////////
    /**
     * Processes a view in the creation mode. This includes a number of steps in a specific order:
     * - creating view query functions (if any);
     * - executing a template function in the creation mode;
     * - updating static queries (if any);
     * - creating child components defined in a given view.
     */
    function renderView(tView, lView, context) {
        ngDevMode && assertEqual(isCreationMode(lView), true, 'Should be run in creation mode');
        enterView(lView);
        try {
            const viewQuery = tView.viewQuery;
            if (viewQuery !== null) {
                executeViewQueryFn(1 /* Create */, viewQuery, context);
            }
            // Execute a template associated with this view, if it exists. A template function might not be
            // defined for the root component views.
            const templateFn = tView.template;
            if (templateFn !== null) {
                executeTemplate(tView, lView, templateFn, 1 /* Create */, context);
            }
            // This needs to be set before children are processed to support recursive components.
            // This must be set to false immediately after the first creation run because in an
            // ngFor loop, all the views will be created together before update mode runs and turns
            // off firstCreatePass. If we don't set it here, instances will perform directive
            // matching, etc again and again.
            if (tView.firstCreatePass) {
                tView.firstCreatePass = false;
            }
            // We resolve content queries specifically marked as `static` in creation mode. Dynamic
            // content queries are resolved during change detection (i.e. update mode), after embedded
            // views are refreshed (see block above).
            if (tView.staticContentQueries) {
                refreshContentQueries(tView, lView);
            }
            // We must materialize query results before child components are processed
            // in case a child component has projected a container. The LContainer needs
            // to exist so the embedded views are properly attached by the container.
            if (tView.staticViewQueries) {
                executeViewQueryFn(2 /* Update */, tView.viewQuery, context);
            }
            // Render child component views.
            const components = tView.components;
            if (components !== null) {
                renderChildComponents(lView, components);
            }
        }
        catch (error) {
            // If we didn't manage to get past the first template pass due to
            // an error, mark the view as corrupted so we can try to recover.
            if (tView.firstCreatePass) {
                tView.incompleteFirstPass = true;
                tView.firstCreatePass = false;
            }
            throw error;
        }
        finally {
            lView[FLAGS] &= ~4 /* CreationMode */;
            leaveView();
        }
    }
    /**
     * Processes a view in update mode. This includes a number of steps in a specific order:
     * - executing a template function in update mode;
     * - executing hooks;
     * - refreshing queries;
     * - setting host bindings;
     * - refreshing child (embedded and component) views.
     */
    function refreshView(tView, lView, templateFn, context) {
        ngDevMode && assertEqual(isCreationMode(lView), false, 'Should be run in update mode');
        const flags = lView[FLAGS];
        if ((flags & 256 /* Destroyed */) === 256 /* Destroyed */)
            return;
        enterView(lView);
        // Check no changes mode is a dev only mode used to verify that bindings have not changed
        // since they were assigned. We do not want to execute lifecycle hooks in that mode.
        const isInCheckNoChangesPass = isInCheckNoChangesMode();
        try {
            resetPreOrderHookFlags(lView);
            setBindingIndex(tView.bindingStartIndex);
            if (templateFn !== null) {
                executeTemplate(tView, lView, templateFn, 2 /* Update */, context);
            }
            const hooksInitPhaseCompleted = (flags & 3 /* InitPhaseStateMask */) === 3 /* InitPhaseCompleted */;
            // execute pre-order hooks (OnInit, OnChanges, DoCheck)
            // PERF WARNING: do NOT extract this to a separate function without running benchmarks
            if (!isInCheckNoChangesPass) {
                if (hooksInitPhaseCompleted) {
                    const preOrderCheckHooks = tView.preOrderCheckHooks;
                    if (preOrderCheckHooks !== null) {
                        executeCheckHooks(lView, preOrderCheckHooks, null);
                    }
                }
                else {
                    const preOrderHooks = tView.preOrderHooks;
                    if (preOrderHooks !== null) {
                        executeInitAndCheckHooks(lView, preOrderHooks, 0 /* OnInitHooksToBeRun */, null);
                    }
                    incrementInitPhaseFlags(lView, 0 /* OnInitHooksToBeRun */);
                }
            }
            // First mark transplanted views that are declared in this lView as needing a refresh at their
            // insertion points. This is needed to avoid the situation where the template is defined in this
            // `LView` but its declaration appears after the insertion component.
            markTransplantedViewsForRefresh(lView);
            refreshEmbeddedViews(lView);
            // Content query results must be refreshed before content hooks are called.
            if (tView.contentQueries !== null) {
                refreshContentQueries(tView, lView);
            }
            // execute content hooks (AfterContentInit, AfterContentChecked)
            // PERF WARNING: do NOT extract this to a separate function without running benchmarks
            if (!isInCheckNoChangesPass) {
                if (hooksInitPhaseCompleted) {
                    const contentCheckHooks = tView.contentCheckHooks;
                    if (contentCheckHooks !== null) {
                        executeCheckHooks(lView, contentCheckHooks);
                    }
                }
                else {
                    const contentHooks = tView.contentHooks;
                    if (contentHooks !== null) {
                        executeInitAndCheckHooks(lView, contentHooks, 1 /* AfterContentInitHooksToBeRun */);
                    }
                    incrementInitPhaseFlags(lView, 1 /* AfterContentInitHooksToBeRun */);
                }
            }
            processHostBindingOpCodes(tView, lView);
            // Refresh child component views.
            const components = tView.components;
            if (components !== null) {
                refreshChildComponents(lView, components);
            }
            // View queries must execute after refreshing child components because a template in this view
            // could be inserted in a child component. If the view query executes before child component
            // refresh, the template might not yet be inserted.
            const viewQuery = tView.viewQuery;
            if (viewQuery !== null) {
                executeViewQueryFn(2 /* Update */, viewQuery, context);
            }
            // execute view hooks (AfterViewInit, AfterViewChecked)
            // PERF WARNING: do NOT extract this to a separate function without running benchmarks
            if (!isInCheckNoChangesPass) {
                if (hooksInitPhaseCompleted) {
                    const viewCheckHooks = tView.viewCheckHooks;
                    if (viewCheckHooks !== null) {
                        executeCheckHooks(lView, viewCheckHooks);
                    }
                }
                else {
                    const viewHooks = tView.viewHooks;
                    if (viewHooks !== null) {
                        executeInitAndCheckHooks(lView, viewHooks, 2 /* AfterViewInitHooksToBeRun */);
                    }
                    incrementInitPhaseFlags(lView, 2 /* AfterViewInitHooksToBeRun */);
                }
            }
            if (tView.firstUpdatePass === true) {
                // We need to make sure that we only flip the flag on successful `refreshView` only
                // Don't do this in `finally` block.
                // If we did this in `finally` block then an exception could block the execution of styling
                // instructions which in turn would be unable to insert themselves into the styling linked
                // list. The result of this would be that if the exception would not be throw on subsequent CD
                // the styling would be unable to process it data and reflect to the DOM.
                tView.firstUpdatePass = false;
            }
            // Do not reset the dirty state when running in check no changes mode. We don't want components
            // to behave differently depending on whether check no changes is enabled or not. For example:
            // Marking an OnPush component as dirty from within the `ngAfterViewInit` hook in order to
            // refresh a `NgClass` binding should work. If we would reset the dirty state in the check
            // no changes cycle, the component would be not be dirty for the next update pass. This would
            // be different in production mode where the component dirty state is not reset.
            if (!isInCheckNoChangesPass) {
                lView[FLAGS] &= ~(64 /* Dirty */ | 8 /* FirstLViewPass */);
            }
            if (lView[FLAGS] & 1024 /* RefreshTransplantedView */) {
                lView[FLAGS] &= ~1024 /* RefreshTransplantedView */;
                updateTransplantedViewCount(lView[PARENT], -1);
            }
        }
        finally {
            leaveView();
        }
    }
    function renderComponentOrTemplate(tView, lView, templateFn, context) {
        const rendererFactory = lView[RENDERER_FACTORY];
        const normalExecutionPath = !isInCheckNoChangesMode();
        const creationModeIsActive = isCreationMode(lView);
        try {
            if (normalExecutionPath && !creationModeIsActive && rendererFactory.begin) {
                rendererFactory.begin();
            }
            if (creationModeIsActive) {
                renderView(tView, lView, context);
            }
            refreshView(tView, lView, templateFn, context);
        }
        finally {
            if (normalExecutionPath && !creationModeIsActive && rendererFactory.end) {
                rendererFactory.end();
            }
        }
    }
    function executeTemplate(tView, lView, templateFn, rf, context) {
        const prevSelectedIndex = getSelectedIndex();
        const isUpdatePhase = rf & 2 /* Update */;
        try {
            setSelectedIndex(-1);
            if (isUpdatePhase && lView.length > HEADER_OFFSET) {
                // When we're updating, inherently select 0 so we don't
                // have to generate that instruction for most update blocks.
                selectIndexInternal(tView, lView, HEADER_OFFSET, isInCheckNoChangesMode());
            }
            const preHookType = isUpdatePhase ? 2 /* TemplateUpdateStart */ : 0 /* TemplateCreateStart */;
            profiler(preHookType, context);
            templateFn(rf, context);
        }
        finally {
            setSelectedIndex(prevSelectedIndex);
        }
    }
    /**
     * Gets TView from a template function or creates a new TView
     * if it doesn't already exist.
     *
     * @param def ComponentDef
     * @returns TView
     */
    function getOrCreateTComponentView(def) {
        const tView = def.tView;
        // Create a TView if there isn't one, or recreate it if the first create pass didn't
        // complete successfully since we can't know for sure whether it's in a usable shape.
        if (tView === null || tView.incompleteFirstPass) {
            // Declaration node here is null since this function is called when we dynamically create a
            // component and hence there is no declaration.
            const declTNode = null;
            return def.tView = createTView(1 /* Component */, declTNode, def.template, def.decls, def.vars, def.directiveDefs, def.pipeDefs, def.viewQuery, def.schemas, def.consts);
        }
        return tView;
    }
    /**
     * Creates a TView instance
     *
     * @param type Type of `TView`.
     * @param declTNode Declaration location of this `TView`.
     * @param templateFn Template function
     * @param decls The number of nodes, local refs, and pipes in this template
     * @param directives Registry of directives for this view
     * @param pipes Registry of pipes for this view
     * @param viewQuery View queries for this view
     * @param schemas Schemas for this view
     * @param consts Constants for this view
     */
    function createTView(type, declTNode, templateFn, decls, vars, directives, pipes, viewQuery, schemas, constsOrFactory) {
        ngDevMode && ngDevMode.tView++;
        const bindingStartIndex = HEADER_OFFSET + decls;
        // This length does not yet contain host bindings from child directives because at this point,
        // we don't know which directives are active on this template. As soon as a directive is matched
        // that has a host binding, we will update the blueprint with that def's hostVars count.
        const initialViewLength = bindingStartIndex + vars;
        const blueprint = createViewBlueprint(bindingStartIndex, initialViewLength);
        const consts = typeof constsOrFactory === 'function' ? constsOrFactory() : constsOrFactory;
        const tView = blueprint[TVIEW] = ngDevMode ?
            new TViewConstructor(type, // type: TViewType,
            blueprint, // blueprint: LView,
            templateFn, // template: ComponentTemplate<{}>|null,
            null, // queries: TQueries|null
            viewQuery, // viewQuery: ViewQueriesFunction<{}>|null,
            declTNode, // declTNode: TNode|null,
            cloneToTViewData(blueprint).fill(null, bindingStartIndex), // data: TData,
            bindingStartIndex, // bindingStartIndex: number,
            initialViewLength, // expandoStartIndex: number,
            null, // hostBindingOpCodes: HostBindingOpCodes,
            true, // firstCreatePass: boolean,
            true, // firstUpdatePass: boolean,
            false, // staticViewQueries: boolean,
            false, // staticContentQueries: boolean,
            null, // preOrderHooks: HookData|null,
            null, // preOrderCheckHooks: HookData|null,
            null, // contentHooks: HookData|null,
            null, // contentCheckHooks: HookData|null,
            null, // viewHooks: HookData|null,
            null, // viewCheckHooks: HookData|null,
            null, // destroyHooks: DestroyHookData|null,
            null, // cleanup: any[]|null,
            null, // contentQueries: number[]|null,
            null, // components: number[]|null,
            typeof directives === 'function' ? //
                directives() : //
                directives, // directiveRegistry: DirectiveDefList|null,
            typeof pipes === 'function' ? pipes() : pipes, // pipeRegistry: PipeDefList|null,
            null, // firstChild: TNode|null,
            schemas, // schemas: SchemaMetadata[]|null,
            consts, // consts: TConstants|null
            false, // incompleteFirstPass: boolean
            decls, // ngDevMode only: decls
            vars) :
            {
                type: type,
                blueprint: blueprint,
                template: templateFn,
                queries: null,
                viewQuery: viewQuery,
                declTNode: declTNode,
                data: blueprint.slice().fill(null, bindingStartIndex),
                bindingStartIndex: bindingStartIndex,
                expandoStartIndex: initialViewLength,
                hostBindingOpCodes: null,
                firstCreatePass: true,
                firstUpdatePass: true,
                staticViewQueries: false,
                staticContentQueries: false,
                preOrderHooks: null,
                preOrderCheckHooks: null,
                contentHooks: null,
                contentCheckHooks: null,
                viewHooks: null,
                viewCheckHooks: null,
                destroyHooks: null,
                cleanup: null,
                contentQueries: null,
                components: null,
                directiveRegistry: typeof directives === 'function' ? directives() : directives,
                pipeRegistry: typeof pipes === 'function' ? pipes() : pipes,
                firstChild: null,
                schemas: schemas,
                consts: consts,
                incompleteFirstPass: false
            };
        if (ngDevMode) {
            // For performance reasons it is important that the tView retains the same shape during runtime.
            // (To make sure that all of the code is monomorphic.) For this reason we seal the object to
            // prevent class transitions.
            Object.seal(tView);
        }
        return tView;
    }
    function createViewBlueprint(bindingStartIndex, initialViewLength) {
        const blueprint = ngDevMode ? new LViewBlueprint() : [];
        for (let i = 0; i < initialViewLength; i++) {
            blueprint.push(i < bindingStartIndex ? null : NO_CHANGE);
        }
        return blueprint;
    }
    function createError(text, token) {
        return new Error(`Renderer: ${text} [${stringifyForError(token)}]`);
    }
    function assertHostNodeExists(rElement, elementOrSelector) {
        if (!rElement) {
            if (typeof elementOrSelector === 'string') {
                throw createError('Host node with selector not found:', elementOrSelector);
            }
            else {
                throw createError('Host node is required:', elementOrSelector);
            }
        }
    }
    /**
     * Locates the host native element, used for bootstrapping existing nodes into rendering pipeline.
     *
     * @param rendererFactory Factory function to create renderer instance.
     * @param elementOrSelector Render element or CSS selector to locate the element.
     * @param encapsulation View Encapsulation defined for component that requests host element.
     */
    function locateHostElement(renderer, elementOrSelector, encapsulation) {
        if (isProceduralRenderer(renderer)) {
            // When using native Shadow DOM, do not clear host element to allow native slot projection
            const preserveContent = encapsulation === ViewEncapsulation$1.ShadowDom;
            return renderer.selectRootElement(elementOrSelector, preserveContent);
        }
        let rElement = typeof elementOrSelector === 'string' ?
            renderer.querySelector(elementOrSelector) :
            elementOrSelector;
        ngDevMode && assertHostNodeExists(rElement, elementOrSelector);
        // Always clear host element's content when Renderer3 is in use. For procedural renderer case we
        // make it depend on whether ShadowDom encapsulation is used (in which case the content should be
        // preserved to allow native slot projection). ShadowDom encapsulation requires procedural
        // renderer, and procedural renderer case is handled above.
        rElement.textContent = '';
        return rElement;
    }
    /**
     * Saves context for this cleanup function in LView.cleanupInstances.
     *
     * On the first template pass, saves in TView:
     * - Cleanup function
     * - Index of context we just saved in LView.cleanupInstances
     *
     * This function can also be used to store instance specific cleanup fns. In that case the `context`
     * is `null` and the function is store in `LView` (rather than it `TView`).
     */
    function storeCleanupWithContext(tView, lView, context, cleanupFn) {
        const lCleanup = getOrCreateLViewCleanup(lView);
        if (context === null) {
            // If context is null that this is instance specific callback. These callbacks can only be
            // inserted after template shared instances. For this reason in ngDevMode we freeze the TView.
            if (ngDevMode) {
                Object.freeze(getOrCreateTViewCleanup(tView));
            }
            lCleanup.push(cleanupFn);
        }
        else {
            lCleanup.push(context);
            if (tView.firstCreatePass) {
                getOrCreateTViewCleanup(tView).push(cleanupFn, lCleanup.length - 1);
            }
        }
    }
    function createTNode(tView, tParent, type, index, value, attrs) {
        ngDevMode && index !== 0 && // 0 are bogus nodes and they are OK. See `createContainerRef` in
            // `view_engine_compatibility` for additional context.
            assertGreaterThanOrEqual(index, HEADER_OFFSET, 'TNodes can\'t be in the LView header.');
        ngDevMode && assertNotSame(attrs, undefined, '\'undefined\' is not valid value for \'attrs\'');
        ngDevMode && ngDevMode.tNode++;
        ngDevMode && tParent && assertTNodeForTView(tParent, tView);
        let injectorIndex = tParent ? tParent.injectorIndex : -1;
        const tNode = ngDevMode ?
            new TNodeDebug(tView, // tView_: TView
            type, // type: TNodeType
            index, // index: number
            null, // insertBeforeIndex: null|-1|number|number[]
            injectorIndex, // injectorIndex: number
            -1, // directiveStart: number
            -1, // directiveEnd: number
            -1, // directiveStylingLast: number
            null, // propertyBindings: number[]|null
            0, // flags: TNodeFlags
            0, // providerIndexes: TNodeProviderIndexes
            value, // value: string|null
            attrs, // attrs: (string|AttributeMarker|(string|SelectorFlags)[])[]|null
            null, // mergedAttrs
            null, // localNames: (string|number)[]|null
            undefined, // initialInputs: (string[]|null)[]|null|undefined
            null, // inputs: PropertyAliases|null
            null, // outputs: PropertyAliases|null
            null, // tViews: ITView|ITView[]|null
            null, // next: ITNode|null
            null, // projectionNext: ITNode|null
            null, // child: ITNode|null
            tParent, // parent: TElementNode|TContainerNode|null
            null, // projection: number|(ITNode|RNode[])[]|null
            null, // styles: string|null
            null, // stylesWithoutHost: string|null
            undefined, // residualStyles: string|null
            null, // classes: string|null
            null, // classesWithoutHost: string|null
            undefined, // residualClasses: string|null
            0, // classBindings: TStylingRange;
            0) :
            {
                type,
                index,
                insertBeforeIndex: null,
                injectorIndex,
                directiveStart: -1,
                directiveEnd: -1,
                directiveStylingLast: -1,
                propertyBindings: null,
                flags: 0,
                providerIndexes: 0,
                value: value,
                attrs: attrs,
                mergedAttrs: null,
                localNames: null,
                initialInputs: undefined,
                inputs: null,
                outputs: null,
                tViews: null,
                next: null,
                projectionNext: null,
                child: null,
                parent: tParent,
                projection: null,
                styles: null,
                stylesWithoutHost: null,
                residualStyles: undefined,
                classes: null,
                classesWithoutHost: null,
                residualClasses: undefined,
                classBindings: 0,
                styleBindings: 0,
            };
        if (ngDevMode) {
            // For performance reasons it is important that the tNode retains the same shape during runtime.
            // (To make sure that all of the code is monomorphic.) For this reason we seal the object to
            // prevent class transitions.
            Object.seal(tNode);
        }
        return tNode;
    }
    /**
     * Instantiate a root component.
     */
    function instantiateRootComponent(tView, lView, def) {
        const rootTNode = getCurrentTNode();
        if (tView.firstCreatePass) {
            if (def.providersResolver)
                def.providersResolver(def);
            const directiveIndex = allocExpando(tView, lView, 1, null);
            ngDevMode &&
                assertEqual(directiveIndex, rootTNode.directiveStart, 'Because this is a root component the allocated expando should match the TNode component.');
            configureViewWithDirective(tView, rootTNode, lView, directiveIndex, def);
        }
        const directive = getNodeInjectable(lView, tView, rootTNode.directiveStart, rootTNode);
        attachPatchData(directive, lView);
        const native = getNativeByTNode(rootTNode, lView);
        if (native) {
            attachPatchData(native, lView);
        }
        return directive;
    }
    /**
     * Add `hostBindings` to the `TView.hostBindingOpCodes`.
     *
     * @param tView `TView` to which the `hostBindings` should be added.
     * @param tNode `TNode` the element which contains the directive
     * @param lView `LView` current `LView`
     * @param directiveIdx Directive index in view.
     * @param directiveVarsIdx Where will the directive's vars be stored
     * @param def `ComponentDef`/`DirectiveDef`, which contains the `hostVars`/`hostBindings` to add.
     */
    function registerHostBindingOpCodes(tView, tNode, lView, directiveIdx, directiveVarsIdx, def) {
        ngDevMode && assertFirstCreatePass(tView);
        const hostBindings = def.hostBindings;
        if (hostBindings) {
            let hostBindingOpCodes = tView.hostBindingOpCodes;
            if (hostBindingOpCodes === null) {
                hostBindingOpCodes = tView.hostBindingOpCodes = [];
            }
            const elementIndx = ~tNode.index;
            if (lastSelectedElementIdx(hostBindingOpCodes) != elementIndx) {
                // Conditionally add select element so that we are more efficient in execution.
                // NOTE: this is strictly not necessary and it trades code size for runtime perf.
                // (We could just always add it.)
                hostBindingOpCodes.push(elementIndx);
            }
            hostBindingOpCodes.push(directiveIdx, directiveVarsIdx, hostBindings);
        }
    }
    /**
     * Returns the last selected element index in the `HostBindingOpCodes`
     *
     * For perf reasons we don't need to update the selected element index in `HostBindingOpCodes` only
     * if it changes. This method returns the last index (or '0' if not found.)
     *
     * Selected element index are only the ones which are negative.
     */
    function lastSelectedElementIdx(hostBindingOpCodes) {
        let i = hostBindingOpCodes.length;
        while (i > 0) {
            const value = hostBindingOpCodes[--i];
            if (typeof value === 'number' && value < 0) {
                return value;
            }
        }
        return 0;
    }
    /**
     * Invoke the host bindings in creation mode.
     *
     * @param def `DirectiveDef` which may contain the `hostBindings` function.
     * @param directive Instance of directive.
     */
    function invokeHostBindingsInCreationMode(def, directive) {
        if (def.hostBindings !== null) {
            def.hostBindings(1 /* Create */, directive);
        }
    }
    /**
     * Marks a given TNode as a component's host. This consists of:
     * - setting appropriate TNode flags;
     * - storing index of component's host element so it will be queued for view refresh during CD.
     */
    function markAsComponentHost(tView, hostTNode) {
        ngDevMode && assertFirstCreatePass(tView);
        hostTNode.flags |= 2 /* isComponentHost */;
        (tView.components || (tView.components = ngDevMode ? new TViewComponents() : []))
            .push(hostTNode.index);
    }
    /**
     * Initializes the flags on the current node, setting all indices to the initial index,
     * the directive count to 0, and adding the isComponent flag.
     * @param index the initial index
     */
    function initTNodeFlags(tNode, index, numberOfDirectives) {
        ngDevMode &&
            assertNotEqual(numberOfDirectives, tNode.directiveEnd - tNode.directiveStart, 'Reached the max number of directives');
        tNode.flags |= 1 /* isDirectiveHost */;
        // When the first directive is created on a node, save the index
        tNode.directiveStart = index;
        tNode.directiveEnd = index + numberOfDirectives;
        tNode.providerIndexes = index;
    }
    /**
     * Setup directive for instantiation.
     *
     * We need to create a `NodeInjectorFactory` which is then inserted in both the `Blueprint` as well
     * as `LView`. `TView` gets the `DirectiveDef`.
     *
     * @param tView `TView`
     * @param tNode `TNode`
     * @param lView `LView`
     * @param directiveIndex Index where the directive will be stored in the Expando.
     * @param def `DirectiveDef`
     */
    function configureViewWithDirective(tView, tNode, lView, directiveIndex, def) {
        ngDevMode &&
            assertGreaterThanOrEqual(directiveIndex, HEADER_OFFSET, 'Must be in Expando section');
        tView.data[directiveIndex] = def;
        const directiveFactory = def.factory || (def.factory = getFactoryDef(def.type, true));
        const nodeInjectorFactory = new NodeInjectorFactory(directiveFactory, isComponentDef(def), null);
        tView.blueprint[directiveIndex] = nodeInjectorFactory;
        lView[directiveIndex] = nodeInjectorFactory;
        registerHostBindingOpCodes(tView, tNode, lView, directiveIndex, allocExpando(tView, lView, def.hostVars, NO_CHANGE), def);
    }
    //////////////////////////
    //// ViewContainer & View
    //////////////////////////
    // Not sure why I need to do `any` here but TS complains later.
    const LContainerArray = ((typeof ngDevMode === 'undefined' || ngDevMode) && initNgDevMode()) &&
        createNamedArrayType('LContainer');
    /**
     * Goes over embedded views (ones created through ViewContainerRef APIs) and refreshes
     * them by executing an associated template function.
     */
    function refreshEmbeddedViews(lView) {
        for (let lContainer = getFirstLContainer(lView); lContainer !== null; lContainer = getNextLContainer(lContainer)) {
            for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {
                const embeddedLView = lContainer[i];
                const embeddedTView = embeddedLView[TVIEW];
                ngDevMode && assertDefined(embeddedTView, 'TView must be allocated');
                if (viewAttachedToChangeDetector(embeddedLView)) {
                    refreshView(embeddedTView, embeddedLView, embeddedTView.template, embeddedLView[CONTEXT]);
                }
            }
        }
    }
    /**
     * Mark transplanted views as needing to be refreshed at their insertion points.
     *
     * @param lView The `LView` that may have transplanted views.
     */
    function markTransplantedViewsForRefresh(lView) {
        for (let lContainer = getFirstLContainer(lView); lContainer !== null; lContainer = getNextLContainer(lContainer)) {
            if (!lContainer[HAS_TRANSPLANTED_VIEWS])
                continue;
            const movedViews = lContainer[MOVED_VIEWS];
            ngDevMode && assertDefined(movedViews, 'Transplanted View flags set but missing MOVED_VIEWS');
            for (let i = 0; i < movedViews.length; i++) {
                const movedLView = movedViews[i];
                const insertionLContainer = movedLView[PARENT];
                ngDevMode && assertLContainer(insertionLContainer);
                // We don't want to increment the counter if the moved LView was already marked for
                // refresh.
                if ((movedLView[FLAGS] & 1024 /* RefreshTransplantedView */) === 0) {
                    updateTransplantedViewCount(insertionLContainer, 1);
                }
                // Note, it is possible that the `movedViews` is tracking views that are transplanted *and*
                // those that aren't (declaration component === insertion component). In the latter case,
                // it's fine to add the flag, as we will clear it immediately in
                // `refreshEmbeddedViews` for the view currently being refreshed.
                movedLView[FLAGS] |= 1024 /* RefreshTransplantedView */;
            }
        }
    }
    /////////////
    /**
     * Refreshes components by entering the component view and processing its bindings, queries, etc.
     *
     * @param componentHostIdx  Element index in LView[] (adjusted for HEADER_OFFSET)
     */
    function refreshComponent(hostLView, componentHostIdx) {
        ngDevMode && assertEqual(isCreationMode(hostLView), false, 'Should be run in update mode');
        const componentView = getComponentLViewByIndex(componentHostIdx, hostLView);
        // Only attached components that are CheckAlways or OnPush and dirty should be refreshed
        if (viewAttachedToChangeDetector(componentView)) {
            const tView = componentView[TVIEW];
            if (componentView[FLAGS] & (16 /* CheckAlways */ | 64 /* Dirty */)) {
                refreshView(tView, componentView, tView.template, componentView[CONTEXT]);
            }
            else if (componentView[TRANSPLANTED_VIEWS_TO_REFRESH] > 0) {
                // Only attached components that are CheckAlways or OnPush and dirty should be refreshed
                refreshContainsDirtyView(componentView);
            }
        }
    }
    /**
     * Refreshes all transplanted views marked with `LViewFlags.RefreshTransplantedView` that are
     * children or descendants of the given lView.
     *
     * @param lView The lView which contains descendant transplanted views that need to be refreshed.
     */
    function refreshContainsDirtyView(lView) {
        for (let lContainer = getFirstLContainer(lView); lContainer !== null; lContainer = getNextLContainer(lContainer)) {
            for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {
                const embeddedLView = lContainer[i];
                if (embeddedLView[FLAGS] & 1024 /* RefreshTransplantedView */) {
                    const embeddedTView = embeddedLView[TVIEW];
                    ngDevMode && assertDefined(embeddedTView, 'TView must be allocated');
                    refreshView(embeddedTView, embeddedLView, embeddedTView.template, embeddedLView[CONTEXT]);
                }
                else if (embeddedLView[TRANSPLANTED_VIEWS_TO_REFRESH] > 0) {
                    refreshContainsDirtyView(embeddedLView);
                }
            }
        }
        const tView = lView[TVIEW];
        // Refresh child component views.
        const components = tView.components;
        if (components !== null) {
            for (let i = 0; i < components.length; i++) {
                const componentView = getComponentLViewByIndex(components[i], lView);
                // Only attached components that are CheckAlways or OnPush and dirty should be refreshed
                if (viewAttachedToChangeDetector(componentView) &&
                    componentView[TRANSPLANTED_VIEWS_TO_REFRESH] > 0) {
                    refreshContainsDirtyView(componentView);
                }
            }
        }
    }
    function renderComponent(hostLView, componentHostIdx) {
        ngDevMode && assertEqual(isCreationMode(hostLView), true, 'Should be run in creation mode');
        const componentView = getComponentLViewByIndex(componentHostIdx, hostLView);
        const componentTView = componentView[TVIEW];
        syncViewWithBlueprint(componentTView, componentView);
        renderView(componentTView, componentView, componentView[CONTEXT]);
    }
    /**
     * Syncs an LView instance with its blueprint if they have gotten out of sync.
     *
     * Typically, blueprints and their view instances should always be in sync, so the loop here
     * will be skipped. However, consider this case of two components side-by-side:
     *
     * App template:
     * ```
     * <comp></comp>
     * <comp></comp>
     * ```
     *
     * The following will happen:
     * 1. App template begins processing.
     * 2. First <comp> is matched as a component and its LView is created.
     * 3. Second <comp> is matched as a component and its LView is created.
     * 4. App template completes processing, so it's time to check child templates.
     * 5. First <comp> template is checked. It has a directive, so its def is pushed to blueprint.
     * 6. Second <comp> template is checked. Its blueprint has been updated by the first
     * <comp> template, but its LView was created before this update, so it is out of sync.
     *
     * Note that embedded views inside ngFor loops will never be out of sync because these views
     * are processed as soon as they are created.
     *
     * @param tView The `TView` that contains the blueprint for syncing
     * @param lView The view to sync
     */
    function syncViewWithBlueprint(tView, lView) {
        for (let i = lView.length; i < tView.blueprint.length; i++) {
            lView.push(tView.blueprint[i]);
        }
    }
    /**
     * Adds LView or LContainer to the end of the current view tree.
     *
     * This structure will be used to traverse through nested views to remove listeners
     * and call onDestroy callbacks.
     *
     * @param lView The view where LView or LContainer should be added
     * @param adjustedHostIndex Index of the view's host node in LView[], adjusted for header
     * @param lViewOrLContainer The LView or LContainer to add to the view tree
     * @returns The state passed in
     */
    function addToViewTree(lView, lViewOrLContainer) {
        // TODO(benlesh/misko): This implementation is incorrect, because it always adds the LContainer
        // to the end of the queue, which means if the developer retrieves the LContainers from RNodes out
        // of order, the change detection will run out of order, as the act of retrieving the the
        // LContainer from the RNode is what adds it to the queue.
        if (lView[CHILD_HEAD]) {
            lView[CHILD_TAIL][NEXT] = lViewOrLContainer;
        }
        else {
            lView[CHILD_HEAD] = lViewOrLContainer;
        }
        lView[CHILD_TAIL] = lViewOrLContainer;
        return lViewOrLContainer;
    }
    ///////////////////////////////
    //// Change detection
    ///////////////////////////////
    /**
     * Marks current view and all ancestors dirty.
     *
     * Returns the root view because it is found as a byproduct of marking the view tree
     * dirty, and can be used by methods that consume markViewDirty() to easily schedule
     * change detection. Otherwise, such methods would need to traverse up the view tree
     * an additional time to get the root view and schedule a tick on it.
     *
     * @param lView The starting LView to mark dirty
     * @returns the root LView
     */
    function markViewDirty(lView) {
        while (lView) {
            lView[FLAGS] |= 64 /* Dirty */;
            const parent = getLViewParent(lView);
            // Stop traversing up as soon as you find a root view that wasn't attached to any container
            if (isRootView(lView) && !parent) {
                return lView;
            }
            // continue otherwise
            lView = parent;
        }
        return null;
    }
    function tickRootContext(rootContext) {
        for (let i = 0; i < rootContext.components.length; i++) {
            const rootComponent = rootContext.components[i];
            const lView = readPatchedLView(rootComponent);
            const tView = lView[TVIEW];
            renderComponentOrTemplate(tView, lView, tView.template, rootComponent);
        }
    }
    function detectChangesInternal(tView, lView, context) {
        const rendererFactory = lView[RENDERER_FACTORY];
        if (rendererFactory.begin)
            rendererFactory.begin();
        try {
            refreshView(tView, lView, tView.template, context);
        }
        catch (error) {
            handleError(lView, error);
            throw error;
        }
        finally {
            if (rendererFactory.end)
                rendererFactory.end();
        }
    }
    /**
     * Synchronously perform change detection on a root view and its components.
     *
     * @param lView The view which the change detection should be performed on.
     */
    function detectChangesInRootView(lView) {
        tickRootContext(lView[CONTEXT]);
    }
    function checkNoChangesInternal(tView, view, context) {
        setIsInCheckNoChangesMode(true);
        try {
            detectChangesInternal(tView, view, context);
        }
        finally {
            setIsInCheckNoChangesMode(false);
        }
    }
    /**
     * Checks the change detector on a root view and its components, and throws if any changes are
     * detected.
     *
     * This is used in development mode to verify that running change detection doesn't
     * introduce other changes.
     *
     * @param lView The view which the change detection should be checked on.
     */
    function checkNoChangesInRootView(lView) {
        setIsInCheckNoChangesMode(true);
        try {
            detectChangesInRootView(lView);
        }
        finally {
            setIsInCheckNoChangesMode(false);
        }
    }
    function executeViewQueryFn(flags, viewQueryFn, component) {
        ngDevMode && assertDefined(viewQueryFn, 'View queries function to execute must be defined.');
        setCurrentQueryIndex(0);
        viewQueryFn(flags, component);
    }
    const CLEAN_PROMISE = _CLEAN_PROMISE;
    function getOrCreateLViewCleanup(view) {
        // top level variables should not be exported for performance reasons (PERF_NOTES.md)
        return view[CLEANUP] || (view[CLEANUP] = ngDevMode ? new LCleanup() : []);
    }
    function getOrCreateTViewCleanup(tView) {
        return tView.cleanup || (tView.cleanup = ngDevMode ? new TCleanup() : []);
    }
    /** Handles an error thrown in an LView. */
    function handleError(lView, error) {
        const injector = lView[INJECTOR];
        const errorHandler = injector ? injector.get(ErrorHandler, null) : null;
        errorHandler && errorHandler.handleError(error);
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Compute the static styling (class/style) from `TAttributes`.
     *
     * This function should be called during `firstCreatePass` only.
     *
     * @param tNode The `TNode` into which the styling information should be loaded.
     * @param attrs `TAttributes` containing the styling information.
     * @param writeToHost Where should the resulting static styles be written?
     *   - `false` Write to `TNode.stylesWithoutHost` / `TNode.classesWithoutHost`
     *   - `true` Write to `TNode.styles` / `TNode.classes`
     */
    function computeStaticStyling(tNode, attrs, writeToHost) {
        ngDevMode &&
            assertFirstCreatePass(getTView(), 'Expecting to be called in first template pass only');
        let styles = writeToHost ? tNode.styles : null;
        let classes = writeToHost ? tNode.classes : null;
        let mode = 0;
        if (attrs !== null) {
            for (let i = 0; i < attrs.length; i++) {
                const value = attrs[i];
                if (typeof value === 'number') {
                    mode = value;
                }
                else if (mode == 1 /* Classes */) {
                    classes = concatStringsWithSpace(classes, value);
                }
                else if (mode == 2 /* Styles */) {
                    const style = value;
                    const styleValue = attrs[++i];
                    styles = concatStringsWithSpace(styles, style + ': ' + styleValue + ';');
                }
            }
        }
        writeToHost ? tNode.styles = styles : tNode.stylesWithoutHost = styles;
        writeToHost ? tNode.classes = classes : tNode.classesWithoutHost = classes;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * An InjectionToken that gets the current `Injector` for `createInjector()`-style injectors.
     *
     * Requesting this token instead of `Injector` allows `StaticInjector` to be tree-shaken from a
     * project.
     *
     * @publicApi
     */
    const INJECTOR$1 = new InjectionToken('INJECTOR', 
    // Dissable tslint because this is const enum which gets inlined not top level prop access.
    // tslint:disable-next-line: no-toplevel-property-access
    -1 /* Injector */);

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class NullInjector {
        get(token, notFoundValue = THROW_IF_NOT_FOUND) {
            if (notFoundValue === THROW_IF_NOT_FOUND) {
                const error = new Error(`NullInjectorError: No provider for ${stringify$1(token)}!`);
                error.name = 'NullInjectorError';
                throw error;
            }
            return notFoundValue;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * An internal token whose presence in an injector indicates that the injector should treat itself
     * as a root scoped injector when processing requests for unknown tokens which may indicate
     * they are provided in the root scope.
     */
    const INJECTOR_SCOPE = new InjectionToken('Set Injector scope.');

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function INJECTOR_IMPL__PRE_R3__(providers, parent, name) {
        return new StaticInjector(providers, parent, name);
    }
    const INJECTOR_IMPL = INJECTOR_IMPL__PRE_R3__;
    /**
     * Concrete injectors implement this interface. Injectors are configured
     * with [providers](guide/glossary#provider) that associate
     * dependencies of various types with [injection tokens](guide/glossary#di-token).
     *
     * @see ["DI Providers"](guide/dependency-injection-providers).
     * @see `StaticProvider`
     *
     * @usageNotes
     *
     *  The following example creates a service injector instance.
     *
     * {@example core/di/ts/provider_spec.ts region='ConstructorProvider'}
     *
     * ### Usage example
     *
     * {@example core/di/ts/injector_spec.ts region='Injector'}
     *
     * `Injector` returns itself when given `Injector` as a token:
     *
     * {@example core/di/ts/injector_spec.ts region='injectInjector'}
     *
     * @publicApi
     */
    class Injector {
        static create(options, parent) {
            if (Array.isArray(options)) {
                return INJECTOR_IMPL(options, parent, '');
            }
            else {
                return INJECTOR_IMPL(options.providers, options.parent, options.name || '');
            }
        }
    }
    Injector.THROW_IF_NOT_FOUND = THROW_IF_NOT_FOUND;
    Injector.NULL = ( /* @__PURE__ */new NullInjector());
    /** @nocollapse */
    Injector.Éµprov = ÉµÉµdefineInjectable({
        token: Injector,
        providedIn: 'any',
        factory: () => ÉµÉµinject(INJECTOR$1),
    });
    /**
     * @internal
     * @nocollapse
     */
    Injector.__NG_ELEMENT_ID__ = -1 /* Injector */;
    const IDENT = function (value) {
        return value;
    };
    const EMPTY = [];
    const CIRCULAR = IDENT;
    const MULTI_PROVIDER_FN = function () {
        return Array.prototype.slice.call(arguments);
    };
    const NO_NEW_LINE$1 = 'Éµ';
    class StaticInjector {
        constructor(providers, parent = Injector.NULL, source = null) {
            this.parent = parent;
            this.source = source;
            const records = this._records = new Map();
            records.set(Injector, { token: Injector, fn: IDENT, deps: EMPTY, value: this, useNew: false });
            records.set(INJECTOR$1, { token: INJECTOR$1, fn: IDENT, deps: EMPTY, value: this, useNew: false });
            this.scope = recursivelyProcessProviders(records, providers);
        }
        get(token, notFoundValue, flags = InjectFlags.Default) {
            const records = this._records;
            let record = records.get(token);
            if (record === undefined) {
                // This means we have never seen this record, see if it is tree shakable provider.
                const injectableDef = getInjectableDef(token);
                if (injectableDef) {
                    const providedIn = injectableDef && resolveForwardRef$1(injectableDef.providedIn);
                    if (providedIn === 'any' || providedIn != null && providedIn === this.scope) {
                        records.set(token, record = resolveProvider({ provide: token, useFactory: injectableDef.factory, deps: EMPTY }));
                    }
                }
                if (record === undefined) {
                    // Set record to null to make sure that we don't go through expensive lookup above again.
                    records.set(token, null);
                }
            }
            let lastInjector = setCurrentInjector(this);
            try {
                return tryResolveToken(token, record, records, this.parent, notFoundValue, flags);
            }
            catch (e) {
                return catchInjectorError(e, token, 'StaticInjectorError', this.source);
            }
            finally {
                setCurrentInjector(lastInjector);
            }
        }
        toString() {
            const tokens = [], records = this._records;
            records.forEach((v, token) => tokens.push(stringify$1(token)));
            return `StaticInjector[${tokens.join(', ')}]`;
        }
    }
    function resolveProvider(provider) {
        const deps = computeDeps(provider);
        let fn = IDENT;
        let value = EMPTY;
        let useNew = false;
        let provide = resolveForwardRef$1(provider.provide);
        if (USE_VALUE$2 in provider) {
            // We need to use USE_VALUE in provider since provider.useValue could be defined as undefined.
            value = provider.useValue;
        }
        else if (provider.useFactory) {
            fn = provider.useFactory;
        }
        else if (provider.useExisting) ;
        else if (provider.useClass) {
            useNew = true;
            fn = resolveForwardRef$1(provider.useClass);
        }
        else if (typeof provide == 'function') {
            useNew = true;
            fn = provide;
        }
        else {
            throw staticError('StaticProvider does not have [useValue|useFactory|useExisting|useClass] or [provide] is not newable', provider);
        }
        return { deps, fn, useNew, value };
    }
    function multiProviderMixError(token) {
        return staticError('Cannot mix multi providers and regular providers', token);
    }
    function recursivelyProcessProviders(records, provider) {
        let scope = null;
        if (provider) {
            provider = resolveForwardRef$1(provider);
            if (Array.isArray(provider)) {
                // if we have an array recurse into the array
                for (let i = 0; i < provider.length; i++) {
                    scope = recursivelyProcessProviders(records, provider[i]) || scope;
                }
            }
            else if (typeof provider === 'function') {
                // Functions were supported in ReflectiveInjector, but are not here. For safety give useful
                // error messages
                throw staticError('Function/Class not supported', provider);
            }
            else if (provider && typeof provider === 'object' && provider.provide) {
                // At this point we have what looks like a provider: {provide: ?, ....}
                let token = resolveForwardRef$1(provider.provide);
                const resolvedProvider = resolveProvider(provider);
                if (provider.multi === true) {
                    // This is a multi provider.
                    let multiProvider = records.get(token);
                    if (multiProvider) {
                        if (multiProvider.fn !== MULTI_PROVIDER_FN) {
                            throw multiProviderMixError(token);
                        }
                    }
                    else {
                        // Create a placeholder factory which will look up the constituents of the multi provider.
                        records.set(token, multiProvider = {
                            token: provider.provide,
                            deps: [],
                            useNew: false,
                            fn: MULTI_PROVIDER_FN,
                            value: EMPTY
                        });
                    }
                    // Treat the provider as the token.
                    token = provider;
                    multiProvider.deps.push({ token, options: 6 /* Default */ });
                }
                const record = records.get(token);
                if (record && record.fn == MULTI_PROVIDER_FN) {
                    throw multiProviderMixError(token);
                }
                if (token === INJECTOR_SCOPE) {
                    scope = resolvedProvider.value;
                }
                records.set(token, resolvedProvider);
            }
            else {
                throw staticError('Unexpected provider', provider);
            }
        }
        return scope;
    }
    function tryResolveToken(token, record, records, parent, notFoundValue, flags) {
        try {
            return resolveToken(token, record, records, parent, notFoundValue, flags);
        }
        catch (e) {
            // ensure that 'e' is of type Error.
            if (!(e instanceof Error)) {
                e = new Error(e);
            }
            const path = e[NG_TEMP_TOKEN_PATH] = e[NG_TEMP_TOKEN_PATH] || [];
            path.unshift(token);
            if (record && record.value == CIRCULAR) {
                // Reset the Circular flag.
                record.value = EMPTY;
            }
            throw e;
        }
    }
    function resolveToken(token, record, records, parent, notFoundValue, flags) {
        let value;
        if (record && !(flags & InjectFlags.SkipSelf)) {
            // If we don't have a record, this implies that we don't own the provider hence don't know how
            // to resolve it.
            value = record.value;
            if (value == CIRCULAR) {
                throw Error(NO_NEW_LINE$1 + 'Circular dependency');
            }
            else if (value === EMPTY) {
                record.value = CIRCULAR;
                let obj = undefined;
                let useNew = record.useNew;
                let fn = record.fn;
                let depRecords = record.deps;
                let deps = EMPTY;
                if (depRecords.length) {
                    deps = [];
                    for (let i = 0; i < depRecords.length; i++) {
                        const depRecord = depRecords[i];
                        const options = depRecord.options;
                        const childRecord = options & 2 /* CheckSelf */ ? records.get(depRecord.token) : undefined;
                        deps.push(tryResolveToken(
                        // Current Token to resolve
                        depRecord.token, 
                        // A record which describes how to resolve the token.
                        // If undefined, this means we don't have such a record
                        childRecord, 
                        // Other records we know about.
                        records, 
                        // If we don't know how to resolve dependency and we should not check parent for it,
                        // than pass in Null injector.
                        !childRecord && !(options & 4 /* CheckParent */) ? Injector.NULL : parent, options & 1 /* Optional */ ? null : Injector.THROW_IF_NOT_FOUND, InjectFlags.Default));
                    }
                }
                record.value = value = useNew ? new fn(...deps) : fn.apply(obj, deps);
            }
        }
        else if (!(flags & InjectFlags.Self)) {
            value = parent.get(token, notFoundValue, InjectFlags.Default);
        }
        else if (!(flags & InjectFlags.Optional)) {
            value = Injector.NULL.get(token, notFoundValue);
        }
        else {
            value = Injector.NULL.get(token, typeof notFoundValue !== 'undefined' ? notFoundValue : null);
        }
        return value;
    }
    function computeDeps(provider) {
        let deps = EMPTY;
        const providerDeps = provider.deps;
        if (providerDeps && providerDeps.length) {
            deps = [];
            for (let i = 0; i < providerDeps.length; i++) {
                let options = 6 /* Default */;
                let token = resolveForwardRef$1(providerDeps[i]);
                if (Array.isArray(token)) {
                    for (let j = 0, annotations = token; j < annotations.length; j++) {
                        const annotation = annotations[j];
                        if (annotation instanceof Optional || annotation == Optional) {
                            options = options | 1 /* Optional */;
                        }
                        else if (annotation instanceof SkipSelf || annotation == SkipSelf) {
                            options = options & ~2 /* CheckSelf */;
                        }
                        else if (annotation instanceof Self || annotation == Self) {
                            options = options & ~4 /* CheckParent */;
                        }
                        else if (annotation instanceof Inject) {
                            token = annotation.token;
                        }
                        else {
                            token = resolveForwardRef$1(annotation);
                        }
                    }
                }
                deps.push({ token, options });
            }
        }
        else if (provider.useExisting) {
            const token = resolveForwardRef$1(provider.useExisting);
            deps = [{ token, options: 6 /* Default */ }];
        }
        else if (!providerDeps && !(USE_VALUE$2 in provider)) {
            // useValue & useExisting are the only ones which are exempt from deps all others need it.
            throw staticError('\'deps\' required', provider);
        }
        return deps;
    }
    function staticError(text, obj) {
        return new Error(formatError(text, obj, 'StaticInjectorError'));
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Creates the root component view and the root component node.
     *
     * @param rNode Render host element.
     * @param def ComponentDef
     * @param rootView The parent view where the host node is stored
     * @param rendererFactory Factory to be used for creating child renderers.
     * @param hostRenderer The current renderer
     * @param sanitizer The sanitizer, if provided
     *
     * @returns Component view created
     */
    function createRootComponentView(rNode, def, rootView, rendererFactory, hostRenderer, sanitizer) {
        const tView = rootView[TVIEW];
        const index = HEADER_OFFSET;
        ngDevMode && assertIndexInRange(rootView, index);
        rootView[index] = rNode;
        // '#host' is added here as we don't know the real host DOM name (we don't want to read it) and at
        // the same time we want to communicate the debug `TNode` that this is a special `TNode`
        // representing a host element.
        const tNode = getOrCreateTNode(tView, index, 2 /* Element */, '#host', null);
        const mergedAttrs = tNode.mergedAttrs = def.hostAttrs;
        if (mergedAttrs !== null) {
            computeStaticStyling(tNode, mergedAttrs, true);
            if (rNode !== null) {
                setUpAttributes(hostRenderer, rNode, mergedAttrs);
                if (tNode.classes !== null) {
                    writeDirectClass(hostRenderer, rNode, tNode.classes);
                }
                if (tNode.styles !== null) {
                    writeDirectStyle(hostRenderer, rNode, tNode.styles);
                }
            }
        }
        const viewRenderer = rendererFactory.createRenderer(rNode, def);
        const componentView = createLView(rootView, getOrCreateTComponentView(def), null, def.onPush ? 64 /* Dirty */ : 16 /* CheckAlways */, rootView[index], tNode, rendererFactory, viewRenderer, sanitizer || null, null);
        if (tView.firstCreatePass) {
            diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, rootView), tView, def.type);
            markAsComponentHost(tView, tNode);
            initTNodeFlags(tNode, rootView.length, 1);
        }
        addToViewTree(rootView, componentView);
        // Store component view at node index, with node as the HOST
        return rootView[index] = componentView;
    }
    /**
     * Creates a root component and sets it up with features and host bindings. Shared by
     * renderComponent() and ViewContainerRef.createComponent().
     */
    function createRootComponent(componentView, componentDef, rootLView, rootContext, hostFeatures) {
        const tView = rootLView[TVIEW];
        // Create directive instance with factory() and store at next index in viewData
        const component = instantiateRootComponent(tView, rootLView, componentDef);
        rootContext.components.push(component);
        componentView[CONTEXT] = component;
        hostFeatures && hostFeatures.forEach((feature) => feature(component, componentDef));
        // We want to generate an empty QueryList for root content queries for backwards
        // compatibility with ViewEngine.
        if (componentDef.contentQueries) {
            const tNode = getCurrentTNode();
            ngDevMode && assertDefined(tNode, 'TNode expected');
            componentDef.contentQueries(1 /* Create */, component, tNode.directiveStart);
        }
        const rootTNode = getCurrentTNode();
        ngDevMode && assertDefined(rootTNode, 'tNode should have been already created');
        if (tView.firstCreatePass &&
            (componentDef.hostBindings !== null || componentDef.hostAttrs !== null)) {
            setSelectedIndex(rootTNode.index);
            const rootTView = rootLView[TVIEW];
            registerHostBindingOpCodes(rootTView, rootTNode, rootLView, rootTNode.directiveStart, rootTNode.directiveEnd, componentDef);
            invokeHostBindingsInCreationMode(componentDef, component);
        }
        return component;
    }
    function createRootContext(scheduler, playerHandler) {
        return {
            components: [],
            scheduler: scheduler || defaultScheduler,
            clean: CLEAN_PROMISE,
            playerHandler: playerHandler || null,
            flags: 0 /* Empty */
        };
    }
    /**
     * Used to enable lifecycle hooks on the root component.
     *
     * Include this feature when calling `renderComponent` if the root component
     * you are rendering has lifecycle hooks defined. Otherwise, the hooks won't
     * be called properly.
     *
     * Example:
     *
     * ```
     * renderComponent(AppComponent, {hostFeatures: [LifecycleHooksFeature]});
     * ```
     */
    function LifecycleHooksFeature(component, def) {
        const lView = readPatchedLView(component);
        ngDevMode && assertDefined(lView, 'LView is required');
        const tView = lView[TVIEW];
        const tNode = getCurrentTNode();
        ngDevMode && assertDefined(tNode, 'TNode is required');
        registerPostOrderHooks(tView, tNode);
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    let _symbolIterator = null;
    function getSymbolIterator() {
        if (!_symbolIterator) {
            const Symbol = _global$1['Symbol'];
            if (Symbol && Symbol.iterator) {
                _symbolIterator = Symbol.iterator;
            }
            else {
                // es6-shim specific logic
                const keys = Object.getOwnPropertyNames(Map.prototype);
                for (let i = 0; i < keys.length; ++i) {
                    const key = keys[i];
                    if (key !== 'entries' && key !== 'size' &&
                        Map.prototype[key] === Map.prototype['entries']) {
                        _symbolIterator = key;
                    }
                }
            }
        }
        return _symbolIterator;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function isListLikeIterable(obj) {
        if (!isJsObject(obj))
            return false;
        return Array.isArray(obj) ||
            (!(obj instanceof Map) && // JS Map are iterables but return entries as [k, v]
                getSymbolIterator() in obj); // JS Iterable have a Symbol.iterator prop
    }
    function iterateListLike(obj, fn) {
        if (Array.isArray(obj)) {
            for (let i = 0; i < obj.length; i++) {
                fn(obj[i]);
            }
        }
        else {
            const iterator = obj[getSymbolIterator()]();
            let item;
            while (!((item = iterator.next()).done)) {
                fn(item.value);
            }
        }
    }
    function isJsObject(o) {
        return o !== null && (typeof o === 'function' || typeof o === 'object');
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const Éµ0$6 = getClosureSafeProperty;
    const USE_VALUE$3 = getClosureSafeProperty({ provide: String, useValue: Éµ0$6 });

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const Éµ0$7 = getClosureSafeProperty;
    const USE_VALUE$4 = getClosureSafeProperty({ provide: String, useValue: Éµ0$7 });
    function convertInjectableProviderToFactory(type, provider) {
        if (!provider) {
            const reflectionCapabilities = new ReflectionCapabilities();
            const deps = reflectionCapabilities.parameters(type);
            // TODO - convert to flags.
            return () => new type(...injectArgs(deps));
        }
        if (USE_VALUE$4 in provider) {
            const valueProvider = provider;
            return () => valueProvider.useValue;
        }
        else if (provider.useExisting) {
            const existingProvider = provider;
            return () => ÉµÉµinject(resolveForwardRef$1(existingProvider.useExisting));
        }
        else if (provider.useFactory) {
            const factoryProvider = provider;
            return () => factoryProvider.useFactory(...injectArgs(factoryProvider.deps || EMPTY_ARRAY));
        }
        else if (provider.useClass) {
            const classProvider = provider;
            let deps = provider.deps;
            if (!deps) {
                const reflectionCapabilities = new ReflectionCapabilities();
                deps = reflectionCapabilities.parameters(type);
            }
            return () => new (resolveForwardRef$1(classProvider.useClass))(...injectArgs(deps));
        }
        else {
            let deps = provider.deps;
            if (!deps) {
                const reflectionCapabilities = new ReflectionCapabilities();
                deps = reflectionCapabilities.parameters(type);
            }
            return () => new type(...injectArgs(deps));
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const Éµ0$8 = (type, meta) => SWITCH_COMPILE_INJECTABLE(type, meta);
    /**
     * Injectable decorator and metadata.
     *
     * @Annotation
     * @publicApi
     */
    const Injectable = makeDecorator('Injectable', undefined, undefined, undefined, Éµ0$8);
    /**
     * Supports @Injectable() in JIT mode for Render2.
     */
    function render2CompileInjectable(injectableType, options) {
        if (options && options.providedIn !== undefined && !getInjectableDef(injectableType)) {
            injectableType.Éµprov = ÉµÉµdefineInjectable({
                token: injectableType,
                providedIn: options.providedIn,
                factory: convertInjectableProviderToFactory(injectableType, options),
            });
        }
    }
    const SWITCH_COMPILE_INJECTABLE__PRE_R3__ = render2CompileInjectable;
    const SWITCH_COMPILE_INJECTABLE = SWITCH_COMPILE_INJECTABLE__PRE_R3__;

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Determine if the argument is shaped like a Promise
     */
    function isPromise$1(obj) {
        // allow any Promise/A+ compliant thenable.
        // It's up to the caller to ensure that obj.then conforms to the spec
        return !!obj && typeof obj.then === 'function';
    }
    /**
     * Determine if the argument is a Subscribable
     */
    function isSubscribable(obj) {
        return !!obj && typeof obj.subscribe === 'function';
    }
    /**
     * Determine if the argument is an Observable
     *
     * Strictly this tests that the `obj` is `Subscribable`, since `Observable`
     * types need additional methods, such as `lift()`. But it is adequate for our
     * needs since within the Angular framework code we only ever need to use the
     * `subscribe()` method, and RxJS has mechanisms to wrap `Subscribable` objects
     * into `Observable` as needed.
     */
    const isObservable = isSubscribable;

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * NOTE: changes to the `ngI18nClosureMode` name must be synced with `compiler-cli/src/tooling.ts`.
     */
    if (typeof ngI18nClosureMode === 'undefined') {
        // These property accesses can be ignored because ngI18nClosureMode will be set to false
        // when optimizing code and the whole if statement will be dropped.
        // Make sure to refer to ngI18nClosureMode as ['ngI18nClosureMode'] for closure.
        // NOTE: we need to have it in IIFE so that the tree-shaker is happy.
        (function () {
            // tslint:disable-next-line:no-toplevel-property-access
            _global$1['ngI18nClosureMode'] =
                // TODO(FW-1250): validate that this actually, you know, works.
                // tslint:disable-next-line:no-toplevel-property-access
                typeof goog !== 'undefined' && typeof goog.getMsg === 'function';
        })();
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Index of each type of locale data from the locale data array
     */
    var LocaleDataIndex;
    (function (LocaleDataIndex) {
        LocaleDataIndex[LocaleDataIndex["LocaleId"] = 0] = "LocaleId";
        LocaleDataIndex[LocaleDataIndex["DayPeriodsFormat"] = 1] = "DayPeriodsFormat";
        LocaleDataIndex[LocaleDataIndex["DayPeriodsStandalone"] = 2] = "DayPeriodsStandalone";
        LocaleDataIndex[LocaleDataIndex["DaysFormat"] = 3] = "DaysFormat";
        LocaleDataIndex[LocaleDataIndex["DaysStandalone"] = 4] = "DaysStandalone";
        LocaleDataIndex[LocaleDataIndex["MonthsFormat"] = 5] = "MonthsFormat";
        LocaleDataIndex[LocaleDataIndex["MonthsStandalone"] = 6] = "MonthsStandalone";
        LocaleDataIndex[LocaleDataIndex["Eras"] = 7] = "Eras";
        LocaleDataIndex[LocaleDataIndex["FirstDayOfWeek"] = 8] = "FirstDayOfWeek";
        LocaleDataIndex[LocaleDataIndex["WeekendRange"] = 9] = "WeekendRange";
        LocaleDataIndex[LocaleDataIndex["DateFormat"] = 10] = "DateFormat";
        LocaleDataIndex[LocaleDataIndex["TimeFormat"] = 11] = "TimeFormat";
        LocaleDataIndex[LocaleDataIndex["DateTimeFormat"] = 12] = "DateTimeFormat";
        LocaleDataIndex[LocaleDataIndex["NumberSymbols"] = 13] = "NumberSymbols";
        LocaleDataIndex[LocaleDataIndex["NumberFormats"] = 14] = "NumberFormats";
        LocaleDataIndex[LocaleDataIndex["CurrencyCode"] = 15] = "CurrencyCode";
        LocaleDataIndex[LocaleDataIndex["CurrencySymbol"] = 16] = "CurrencySymbol";
        LocaleDataIndex[LocaleDataIndex["CurrencyName"] = 17] = "CurrencyName";
        LocaleDataIndex[LocaleDataIndex["Currencies"] = 18] = "Currencies";
        LocaleDataIndex[LocaleDataIndex["Directionality"] = 19] = "Directionality";
        LocaleDataIndex[LocaleDataIndex["PluralCase"] = 20] = "PluralCase";
        LocaleDataIndex[LocaleDataIndex["ExtraData"] = 21] = "ExtraData";
    })(LocaleDataIndex || (LocaleDataIndex = {}));

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * The locale id that the application is using by default (for translations and ICU expressions).
     */
    const DEFAULT_LOCALE_ID = 'en-US';
    /**
     * USD currency code that the application uses by default for CurrencyPipe when no
     * DEFAULT_CURRENCY_CODE is provided.
     */
    const USD_CURRENCY_CODE = 'USD';

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * See `I18nCreateOpCodes`
     */
    var I18nCreateOpCode;
    (function (I18nCreateOpCode) {
        /**
         * Number of bits to shift index so that it can be combined with the `APPEND_EAGERLY` and
         * `COMMENT`.
         */
        I18nCreateOpCode[I18nCreateOpCode["SHIFT"] = 2] = "SHIFT";
        /**
         * Should the node be appended to parent imedditatly after creation.
         */
        I18nCreateOpCode[I18nCreateOpCode["APPEND_EAGERLY"] = 1] = "APPEND_EAGERLY";
        /**
         * If set the node should be comment (rather than a text) node.
         */
        I18nCreateOpCode[I18nCreateOpCode["COMMENT"] = 2] = "COMMENT";
    })(I18nCreateOpCode || (I18nCreateOpCode = {}));

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * The locale id that the application is currently using (for translations and ICU expressions).
     * This is the ivy version of `LOCALE_ID` that was defined as an injection token for the view engine
     * but is now defined as a global value.
     */
    let LOCALE_ID = DEFAULT_LOCALE_ID;
    /**
     * Sets the locale id that will be used for translations and ICU expressions.
     * This is the ivy version of `LOCALE_ID` that was defined as an injection token for the view engine
     * but is now defined as a global value.
     *
     * @param localeId
     */
    function setLocaleId(localeId) {
        assertDefined(localeId, `Expected localeId to be defined`);
        if (typeof localeId === 'string') {
            LOCALE_ID = localeId.toLowerCase().replace(/_/g, '-');
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Represents a component created by a `ComponentFactory`.
     * Provides access to the component instance and related objects,
     * and provides the means of destroying the instance.
     *
     * @publicApi
     */
    class ComponentRef {
    }
    /**
     * Base class for a factory that can create a component dynamically.
     * Instantiate a factory for a given type of component with `resolveComponentFactory()`.
     * Use the resulting `ComponentFactory.create()` method to create a component of that type.
     *
     * @see [Dynamic Components](guide/dynamic-component-loader)
     *
     * @publicApi
     */
    class ComponentFactory {
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function noComponentFactoryError(component) {
        const error = Error(`No component factory found for ${stringify$1(component)}. Did you add it to @NgModule.entryComponents?`);
        error[ERROR_COMPONENT] = component;
        return error;
    }
    const ERROR_COMPONENT = 'ngComponent';
    class _NullComponentFactoryResolver {
        resolveComponentFactory(component) {
            throw noComponentFactoryError(component);
        }
    }
    /**
     * A simple registry that maps `Components` to generated `ComponentFactory` classes
     * that can be used to create instances of components.
     * Use to obtain the factory for a given component type,
     * then use the factory's `create()` method to create a component of that type.
     *
     * @see [Dynamic Components](guide/dynamic-component-loader)
     * @see [Usage Example](guide/dynamic-component-loader#resolving-components)
     * @see <live-example name="dynamic-component-loader" noDownload></live-example>
    of the code in this cookbook
     * @publicApi
     */
    class ComponentFactoryResolver {
    }
    ComponentFactoryResolver.NULL = ( /* @__PURE__ */new _NullComponentFactoryResolver());
    class ComponentFactoryBoundToModule extends ComponentFactory {
        constructor(factory, ngModule) {
            super();
            this.factory = factory;
            this.ngModule = ngModule;
            this.selector = factory.selector;
            this.componentType = factory.componentType;
            this.ngContentSelectors = factory.ngContentSelectors;
            this.inputs = factory.inputs;
            this.outputs = factory.outputs;
        }
        create(injector, projectableNodes, rootSelectorOrNode, ngModule) {
            return this.factory.create(injector, projectableNodes, rootSelectorOrNode, ngModule || this.ngModule);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function noop(...args) {
        // Do nothing.
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Creates an ElementRef given a node.
     *
     * @param tNode The node for which you'd like an ElementRef
     * @param lView The view to which the node belongs
     * @returns The ElementRef instance to use
     */
    function createElementRef(tNode, lView) {
        return new ElementRef(getNativeByTNode(tNode, lView));
    }
    const SWITCH_ELEMENT_REF_FACTORY__PRE_R3__ = noop;
    const SWITCH_ELEMENT_REF_FACTORY = SWITCH_ELEMENT_REF_FACTORY__PRE_R3__;
    /**
     * A wrapper around a native element inside of a View.
     *
     * An `ElementRef` is backed by a render-specific element. In the browser, this is usually a DOM
     * element.
     *
     * @security Permitting direct access to the DOM can make your application more vulnerable to
     * XSS attacks. Carefully review any use of `ElementRef` in your code. For more detail, see the
     * [Security Guide](https://g.co/ng/security).
     *
     * @publicApi
     */
    // Note: We don't expose things like `Injector`, `ViewContainer`, ... here,
    // i.e. users have to ask for what they need. With that, we can build better analysis tools
    // and could do better codegen in the future.
    class ElementRef {
        constructor(nativeElement) {
            this.nativeElement = nativeElement;
        }
    }
    /**
     * @internal
     * @nocollapse
     */
    ElementRef.__NG_ELEMENT_ID__ = SWITCH_ELEMENT_REF_FACTORY;

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const Renderer2Interceptor = new InjectionToken('Renderer2Interceptor');
    /**
     * Creates and initializes a custom renderer that implements the `Renderer2` base class.
     *
     * @publicApi
     */
    class RendererFactory2 {
    }
    /**
     * Extend this base class to implement custom rendering. By default, Angular
     * renders a template into DOM. You can use custom rendering to intercept
     * rendering calls, or to render to something other than DOM.
     *
     * Create your custom renderer using `RendererFactory2`.
     *
     * Use a custom renderer to bypass Angular's templating and
     * make custom UI changes that can't be expressed declaratively.
     * For example if you need to set a property or an attribute whose name is
     * not statically known, use the `setProperty()` or
     * `setAttribute()` method.
     *
     * @publicApi
     */
    class Renderer2 {
    }
    /**
     * @internal
     * @nocollapse
     */
    Renderer2.__NG_ELEMENT_ID__ = () => SWITCH_RENDERER2_FACTORY();
    const SWITCH_RENDERER2_FACTORY__PRE_R3__ = noop;
    const SWITCH_RENDERER2_FACTORY = SWITCH_RENDERER2_FACTORY__PRE_R3__;

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Sanitizer is used by the views to sanitize potentially dangerous values.
     *
     * @publicApi
     */
    class Sanitizer {
    }
    /** @nocollapse */
    Sanitizer.Éµprov = ÉµÉµdefineInjectable({
        token: Sanitizer,
        providedIn: 'root',
        factory: () => null,
    });

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * @description Represents the version of Angular
     *
     * @publicApi
     */
    class Version$1 {
        constructor(full) {
            this.full = full;
            this.major = full.split('.')[0];
            this.minor = full.split('.')[1];
            this.patch = full.split('.').slice(2).join('.');
        }
    }
    /**
     * @publicApi
     */
    const VERSION$2 = new Version$1('12.2.12');

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class DefaultIterableDifferFactory {
        constructor() { }
        supports(obj) {
            return isListLikeIterable(obj);
        }
        create(trackByFn) {
            return new DefaultIterableDiffer(trackByFn);
        }
    }
    const trackByIdentity = (index, item) => item;
    /**
     * @deprecated v4.0.0 - Should not be part of public API.
     * @publicApi
     */
    class DefaultIterableDiffer {
        constructor(trackByFn) {
            this.length = 0;
            // Keeps track of the used records at any point in time (during & across `_check()` calls)
            this._linkedRecords = null;
            // Keeps track of the removed records at any point in time during `_check()` calls.
            this._unlinkedRecords = null;
            this._previousItHead = null;
            this._itHead = null;
            this._itTail = null;
            this._additionsHead = null;
            this._additionsTail = null;
            this._movesHead = null;
            this._movesTail = null;
            this._removalsHead = null;
            this._removalsTail = null;
            // Keeps track of records where custom track by is the same, but item identity has changed
            this._identityChangesHead = null;
            this._identityChangesTail = null;
            this._trackByFn = trackByFn || trackByIdentity;
        }
        forEachItem(fn) {
            let record;
            for (record = this._itHead; record !== null; record = record._next) {
                fn(record);
            }
        }
        forEachOperation(fn) {
            let nextIt = this._itHead;
            let nextRemove = this._removalsHead;
            let addRemoveOffset = 0;
            let moveOffsets = null;
            while (nextIt || nextRemove) {
                // Figure out which is the next record to process
                // Order: remove, add, move
                const record = !nextRemove ||
                    nextIt &&
                        nextIt.currentIndex <
                            getPreviousIndex(nextRemove, addRemoveOffset, moveOffsets) ?
                    nextIt :
                    nextRemove;
                const adjPreviousIndex = getPreviousIndex(record, addRemoveOffset, moveOffsets);
                const currentIndex = record.currentIndex;
                // consume the item, and adjust the addRemoveOffset and update moveDistance if necessary
                if (record === nextRemove) {
                    addRemoveOffset--;
                    nextRemove = nextRemove._nextRemoved;
                }
                else {
                    nextIt = nextIt._next;
                    if (record.previousIndex == null) {
                        addRemoveOffset++;
                    }
                    else {
                        // INVARIANT:  currentIndex < previousIndex
                        if (!moveOffsets)
                            moveOffsets = [];
                        const localMovePreviousIndex = adjPreviousIndex - addRemoveOffset;
                        const localCurrentIndex = currentIndex - addRemoveOffset;
                        if (localMovePreviousIndex != localCurrentIndex) {
                            for (let i = 0; i < localMovePreviousIndex; i++) {
                                const offset = i < moveOffsets.length ? moveOffsets[i] : (moveOffsets[i] = 0);
                                const index = offset + i;
                                if (localCurrentIndex <= index && index < localMovePreviousIndex) {
                                    moveOffsets[i] = offset + 1;
                                }
                            }
                            const previousIndex = record.previousIndex;
                            moveOffsets[previousIndex] = localCurrentIndex - localMovePreviousIndex;
                        }
                    }
                }
                if (adjPreviousIndex !== currentIndex) {
                    fn(record, adjPreviousIndex, currentIndex);
                }
            }
        }
        forEachPreviousItem(fn) {
            let record;
            for (record = this._previousItHead; record !== null; record = record._nextPrevious) {
                fn(record);
            }
        }
        forEachAddedItem(fn) {
            let record;
            for (record = this._additionsHead; record !== null; record = record._nextAdded) {
                fn(record);
            }
        }
        forEachMovedItem(fn) {
            let record;
            for (record = this._movesHead; record !== null; record = record._nextMoved) {
                fn(record);
            }
        }
        forEachRemovedItem(fn) {
            let record;
            for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
                fn(record);
            }
        }
        forEachIdentityChange(fn) {
            let record;
            for (record = this._identityChangesHead; record !== null; record = record._nextIdentityChange) {
                fn(record);
            }
        }
        diff(collection) {
            if (collection == null)
                collection = [];
            if (!isListLikeIterable(collection)) {
                throw new Error(`Error trying to diff '${stringify$1(collection)}'. Only arrays and iterables are allowed`);
            }
            if (this.check(collection)) {
                return this;
            }
            else {
                return null;
            }
        }
        onDestroy() { }
        check(collection) {
            this._reset();
            let record = this._itHead;
            let mayBeDirty = false;
            let index;
            let item;
            let itemTrackBy;
            if (Array.isArray(collection)) {
                this.length = collection.length;
                for (let index = 0; index < this.length; index++) {
                    item = collection[index];
                    itemTrackBy = this._trackByFn(index, item);
                    if (record === null || !Object.is(record.trackById, itemTrackBy)) {
                        record = this._mismatch(record, item, itemTrackBy, index);
                        mayBeDirty = true;
                    }
                    else {
                        if (mayBeDirty) {
                            // TODO(misko): can we limit this to duplicates only?
                            record = this._verifyReinsertion(record, item, itemTrackBy, index);
                        }
                        if (!Object.is(record.item, item))
                            this._addIdentityChange(record, item);
                    }
                    record = record._next;
                }
            }
            else {
                index = 0;
                iterateListLike(collection, (item) => {
                    itemTrackBy = this._trackByFn(index, item);
                    if (record === null || !Object.is(record.trackById, itemTrackBy)) {
                        record = this._mismatch(record, item, itemTrackBy, index);
                        mayBeDirty = true;
                    }
                    else {
                        if (mayBeDirty) {
                            // TODO(misko): can we limit this to duplicates only?
                            record = this._verifyReinsertion(record, item, itemTrackBy, index);
                        }
                        if (!Object.is(record.item, item))
                            this._addIdentityChange(record, item);
                    }
                    record = record._next;
                    index++;
                });
                this.length = index;
            }
            this._truncate(record);
            this.collection = collection;
            return this.isDirty;
        }
        /* CollectionChanges is considered dirty if it has any additions, moves, removals, or identity
         * changes.
         */
        get isDirty() {
            return this._additionsHead !== null || this._movesHead !== null ||
                this._removalsHead !== null || this._identityChangesHead !== null;
        }
        /**
         * Reset the state of the change objects to show no changes. This means set previousKey to
         * currentKey, and clear all of the queues (additions, moves, removals).
         * Set the previousIndexes of moved and added items to their currentIndexes
         * Reset the list of additions, moves and removals
         *
         * @internal
         */
        _reset() {
            if (this.isDirty) {
                let record;
                for (record = this._previousItHead = this._itHead; record !== null; record = record._next) {
                    record._nextPrevious = record._next;
                }
                for (record = this._additionsHead; record !== null; record = record._nextAdded) {
                    record.previousIndex = record.currentIndex;
                }
                this._additionsHead = this._additionsTail = null;
                for (record = this._movesHead; record !== null; record = record._nextMoved) {
                    record.previousIndex = record.currentIndex;
                }
                this._movesHead = this._movesTail = null;
                this._removalsHead = this._removalsTail = null;
                this._identityChangesHead = this._identityChangesTail = null;
                // TODO(vicb): when assert gets supported
                // assert(!this.isDirty);
            }
        }
        /**
         * This is the core function which handles differences between collections.
         *
         * - `record` is the record which we saw at this position last time. If null then it is a new
         *   item.
         * - `item` is the current item in the collection
         * - `index` is the position of the item in the collection
         *
         * @internal
         */
        _mismatch(record, item, itemTrackBy, index) {
            // The previous record after which we will append the current one.
            let previousRecord;
            if (record === null) {
                previousRecord = this._itTail;
            }
            else {
                previousRecord = record._prev;
                // Remove the record from the collection since we know it does not match the item.
                this._remove(record);
            }
            // See if we have evicted the item, which used to be at some anterior position of _itHead list.
            record = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy, null);
            if (record !== null) {
                // It is an item which we have evicted earlier: reinsert it back into the list.
                // But first we need to check if identity changed, so we can update in view if necessary.
                if (!Object.is(record.item, item))
                    this._addIdentityChange(record, item);
                this._reinsertAfter(record, previousRecord, index);
            }
            else {
                // Attempt to see if the item is at some posterior position of _itHead list.
                record = this._linkedRecords === null ? null : this._linkedRecords.get(itemTrackBy, index);
                if (record !== null) {
                    // We have the item in _itHead at/after `index` position. We need to move it forward in the
                    // collection.
                    // But first we need to check if identity changed, so we can update in view if necessary.
                    if (!Object.is(record.item, item))
                        this._addIdentityChange(record, item);
                    this._moveAfter(record, previousRecord, index);
                }
                else {
                    // It is a new item: add it.
                    record =
                        this._addAfter(new IterableChangeRecord_(item, itemTrackBy), previousRecord, index);
                }
            }
            return record;
        }
        /**
         * This check is only needed if an array contains duplicates. (Short circuit of nothing dirty)
         *
         * Use case: `[a, a]` => `[b, a, a]`
         *
         * If we did not have this check then the insertion of `b` would:
         *   1) evict first `a`
         *   2) insert `b` at `0` index.
         *   3) leave `a` at index `1` as is. <-- this is wrong!
         *   3) reinsert `a` at index 2. <-- this is wrong!
         *
         * The correct behavior is:
         *   1) evict first `a`
         *   2) insert `b` at `0` index.
         *   3) reinsert `a` at index 1.
         *   3) move `a` at from `1` to `2`.
         *
         *
         * Double check that we have not evicted a duplicate item. We need to check if the item type may
         * have already been removed:
         * The insertion of b will evict the first 'a'. If we don't reinsert it now it will be reinserted
         * at the end. Which will show up as the two 'a's switching position. This is incorrect, since a
         * better way to think of it is as insert of 'b' rather then switch 'a' with 'b' and then add 'a'
         * at the end.
         *
         * @internal
         */
        _verifyReinsertion(record, item, itemTrackBy, index) {
            let reinsertRecord = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy, null);
            if (reinsertRecord !== null) {
                record = this._reinsertAfter(reinsertRecord, record._prev, index);
            }
            else if (record.currentIndex != index) {
                record.currentIndex = index;
                this._addToMoves(record, index);
            }
            return record;
        }
        /**
         * Get rid of any excess {@link IterableChangeRecord_}s from the previous collection
         *
         * - `record` The first excess {@link IterableChangeRecord_}.
         *
         * @internal
         */
        _truncate(record) {
            // Anything after that needs to be removed;
            while (record !== null) {
                const nextRecord = record._next;
                this._addToRemovals(this._unlink(record));
                record = nextRecord;
            }
            if (this._unlinkedRecords !== null) {
                this._unlinkedRecords.clear();
            }
            if (this._additionsTail !== null) {
                this._additionsTail._nextAdded = null;
            }
            if (this._movesTail !== null) {
                this._movesTail._nextMoved = null;
            }
            if (this._itTail !== null) {
                this._itTail._next = null;
            }
            if (this._removalsTail !== null) {
                this._removalsTail._nextRemoved = null;
            }
            if (this._identityChangesTail !== null) {
                this._identityChangesTail._nextIdentityChange = null;
            }
        }
        /** @internal */
        _reinsertAfter(record, prevRecord, index) {
            if (this._unlinkedRecords !== null) {
                this._unlinkedRecords.remove(record);
            }
            const prev = record._prevRemoved;
            const next = record._nextRemoved;
            if (prev === null) {
                this._removalsHead = next;
            }
            else {
                prev._nextRemoved = next;
            }
            if (next === null) {
                this._removalsTail = prev;
            }
            else {
                next._prevRemoved = prev;
            }
            this._insertAfter(record, prevRecord, index);
            this._addToMoves(record, index);
            return record;
        }
        /** @internal */
        _moveAfter(record, prevRecord, index) {
            this._unlink(record);
            this._insertAfter(record, prevRecord, index);
            this._addToMoves(record, index);
            return record;
        }
        /** @internal */
        _addAfter(record, prevRecord, index) {
            this._insertAfter(record, prevRecord, index);
            if (this._additionsTail === null) {
                // TODO(vicb):
                // assert(this._additionsHead === null);
                this._additionsTail = this._additionsHead = record;
            }
            else {
                // TODO(vicb):
                // assert(_additionsTail._nextAdded === null);
                // assert(record._nextAdded === null);
                this._additionsTail = this._additionsTail._nextAdded = record;
            }
            return record;
        }
        /** @internal */
        _insertAfter(record, prevRecord, index) {
            // TODO(vicb):
            // assert(record != prevRecord);
            // assert(record._next === null);
            // assert(record._prev === null);
            const next = prevRecord === null ? this._itHead : prevRecord._next;
            // TODO(vicb):
            // assert(next != record);
            // assert(prevRecord != record);
            record._next = next;
            record._prev = prevRecord;
            if (next === null) {
                this._itTail = record;
            }
            else {
                next._prev = record;
            }
            if (prevRecord === null) {
                this._itHead = record;
            }
            else {
                prevRecord._next = record;
            }
            if (this._linkedRecords === null) {
                this._linkedRecords = new _DuplicateMap();
            }
            this._linkedRecords.put(record);
            record.currentIndex = index;
            return record;
        }
        /** @internal */
        _remove(record) {
            return this._addToRemovals(this._unlink(record));
        }
        /** @internal */
        _unlink(record) {
            if (this._linkedRecords !== null) {
                this._linkedRecords.remove(record);
            }
            const prev = record._prev;
            const next = record._next;
            // TODO(vicb):
            // assert((record._prev = null) === null);
            // assert((record._next = null) === null);
            if (prev === null) {
                this._itHead = next;
            }
            else {
                prev._next = next;
            }
            if (next === null) {
                this._itTail = prev;
            }
            else {
                next._prev = prev;
            }
            return record;
        }
        /** @internal */
        _addToMoves(record, toIndex) {
            // TODO(vicb):
            // assert(record._nextMoved === null);
            if (record.previousIndex === toIndex) {
                return record;
            }
            if (this._movesTail === null) {
                // TODO(vicb):
                // assert(_movesHead === null);
                this._movesTail = this._movesHead = record;
            }
            else {
                // TODO(vicb):
                // assert(_movesTail._nextMoved === null);
                this._movesTail = this._movesTail._nextMoved = record;
            }
            return record;
        }
        _addToRemovals(record) {
            if (this._unlinkedRecords === null) {
                this._unlinkedRecords = new _DuplicateMap();
            }
            this._unlinkedRecords.put(record);
            record.currentIndex = null;
            record._nextRemoved = null;
            if (this._removalsTail === null) {
                // TODO(vicb):
                // assert(_removalsHead === null);
                this._removalsTail = this._removalsHead = record;
                record._prevRemoved = null;
            }
            else {
                // TODO(vicb):
                // assert(_removalsTail._nextRemoved === null);
                // assert(record._nextRemoved === null);
                record._prevRemoved = this._removalsTail;
                this._removalsTail = this._removalsTail._nextRemoved = record;
            }
            return record;
        }
        /** @internal */
        _addIdentityChange(record, item) {
            record.item = item;
            if (this._identityChangesTail === null) {
                this._identityChangesTail = this._identityChangesHead = record;
            }
            else {
                this._identityChangesTail = this._identityChangesTail._nextIdentityChange = record;
            }
            return record;
        }
    }
    class IterableChangeRecord_ {
        constructor(item, trackById) {
            this.item = item;
            this.trackById = trackById;
            this.currentIndex = null;
            this.previousIndex = null;
            /** @internal */
            this._nextPrevious = null;
            /** @internal */
            this._prev = null;
            /** @internal */
            this._next = null;
            /** @internal */
            this._prevDup = null;
            /** @internal */
            this._nextDup = null;
            /** @internal */
            this._prevRemoved = null;
            /** @internal */
            this._nextRemoved = null;
            /** @internal */
            this._nextAdded = null;
            /** @internal */
            this._nextMoved = null;
            /** @internal */
            this._nextIdentityChange = null;
        }
    }
    // A linked list of IterableChangeRecords with the same IterableChangeRecord_.item
    class _DuplicateItemRecordList {
        constructor() {
            /** @internal */
            this._head = null;
            /** @internal */
            this._tail = null;
        }
        /**
         * Append the record to the list of duplicates.
         *
         * Note: by design all records in the list of duplicates hold the same value in record.item.
         */
        add(record) {
            if (this._head === null) {
                this._head = this._tail = record;
                record._nextDup = null;
                record._prevDup = null;
            }
            else {
                // TODO(vicb):
                // assert(record.item ==  _head.item ||
                //       record.item is num && record.item.isNaN && _head.item is num && _head.item.isNaN);
                this._tail._nextDup = record;
                record._prevDup = this._tail;
                record._nextDup = null;
                this._tail = record;
            }
        }
        // Returns a IterableChangeRecord_ having IterableChangeRecord_.trackById == trackById and
        // IterableChangeRecord_.currentIndex >= atOrAfterIndex
        get(trackById, atOrAfterIndex) {
            let record;
            for (record = this._head; record !== null; record = record._nextDup) {
                if ((atOrAfterIndex === null || atOrAfterIndex <= record.currentIndex) &&
                    Object.is(record.trackById, trackById)) {
                    return record;
                }
            }
            return null;
        }
        /**
         * Remove one {@link IterableChangeRecord_} from the list of duplicates.
         *
         * Returns whether the list of duplicates is empty.
         */
        remove(record) {
            // TODO(vicb):
            // assert(() {
            //  // verify that the record being removed is in the list.
            //  for (IterableChangeRecord_ cursor = _head; cursor != null; cursor = cursor._nextDup) {
            //    if (identical(cursor, record)) return true;
            //  }
            //  return false;
            //});
            const prev = record._prevDup;
            const next = record._nextDup;
            if (prev === null) {
                this._head = next;
            }
            else {
                prev._nextDup = next;
            }
            if (next === null) {
                this._tail = prev;
            }
            else {
                next._prevDup = prev;
            }
            return this._head === null;
        }
    }
    class _DuplicateMap {
        constructor() {
            this.map = new Map();
        }
        put(record) {
            const key = record.trackById;
            let duplicates = this.map.get(key);
            if (!duplicates) {
                duplicates = new _DuplicateItemRecordList();
                this.map.set(key, duplicates);
            }
            duplicates.add(record);
        }
        /**
         * Retrieve the `value` using key. Because the IterableChangeRecord_ value may be one which we
         * have already iterated over, we use the `atOrAfterIndex` to pretend it is not there.
         *
         * Use case: `[a, b, c, a, a]` if we are at index `3` which is the second `a` then asking if we
         * have any more `a`s needs to return the second `a`.
         */
        get(trackById, atOrAfterIndex) {
            const key = trackById;
            const recordList = this.map.get(key);
            return recordList ? recordList.get(trackById, atOrAfterIndex) : null;
        }
        /**
         * Removes a {@link IterableChangeRecord_} from the list of duplicates.
         *
         * The list of duplicates also is removed from the map if it gets empty.
         */
        remove(record) {
            const key = record.trackById;
            const recordList = this.map.get(key);
            // Remove the list of duplicates when it gets empty
            if (recordList.remove(record)) {
                this.map.delete(key);
            }
            return record;
        }
        get isEmpty() {
            return this.map.size === 0;
        }
        clear() {
            this.map.clear();
        }
    }
    function getPreviousIndex(item, addRemoveOffset, moveOffsets) {
        const previousIndex = item.previousIndex;
        if (previousIndex === null)
            return previousIndex;
        let moveOffset = 0;
        if (moveOffsets && previousIndex < moveOffsets.length) {
            moveOffset = moveOffsets[previousIndex];
        }
        return previousIndex + addRemoveOffset + moveOffset;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class DefaultKeyValueDifferFactory {
        constructor() { }
        supports(obj) {
            return obj instanceof Map || isJsObject(obj);
        }
        create() {
            return new DefaultKeyValueDiffer();
        }
    }
    class DefaultKeyValueDiffer {
        constructor() {
            this._records = new Map();
            this._mapHead = null;
            // _appendAfter is used in the check loop
            this._appendAfter = null;
            this._previousMapHead = null;
            this._changesHead = null;
            this._changesTail = null;
            this._additionsHead = null;
            this._additionsTail = null;
            this._removalsHead = null;
            this._removalsTail = null;
        }
        get isDirty() {
            return this._additionsHead !== null || this._changesHead !== null ||
                this._removalsHead !== null;
        }
        forEachItem(fn) {
            let record;
            for (record = this._mapHead; record !== null; record = record._next) {
                fn(record);
            }
        }
        forEachPreviousItem(fn) {
            let record;
            for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {
                fn(record);
            }
        }
        forEachChangedItem(fn) {
            let record;
            for (record = this._changesHead; record !== null; record = record._nextChanged) {
                fn(record);
            }
        }
        forEachAddedItem(fn) {
            let record;
            for (record = this._additionsHead; record !== null; record = record._nextAdded) {
                fn(record);
            }
        }
        forEachRemovedItem(fn) {
            let record;
            for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
                fn(record);
            }
        }
        diff(map) {
            if (!map) {
                map = new Map();
            }
            else if (!(map instanceof Map || isJsObject(map))) {
                throw new Error(`Error trying to diff '${stringify$1(map)}'. Only maps and objects are allowed`);
            }
            return this.check(map) ? this : null;
        }
        onDestroy() { }
        /**
         * Check the current state of the map vs the previous.
         * The algorithm is optimised for when the keys do no change.
         */
        check(map) {
            this._reset();
            let insertBefore = this._mapHead;
            this._appendAfter = null;
            this._forEach(map, (value, key) => {
                if (insertBefore && insertBefore.key === key) {
                    this._maybeAddToChanges(insertBefore, value);
                    this._appendAfter = insertBefore;
                    insertBefore = insertBefore._next;
                }
                else {
                    const record = this._getOrCreateRecordForKey(key, value);
                    insertBefore = this._insertBeforeOrAppend(insertBefore, record);
                }
            });
            // Items remaining at the end of the list have been deleted
            if (insertBefore) {
                if (insertBefore._prev) {
                    insertBefore._prev._next = null;
                }
                this._removalsHead = insertBefore;
                for (let record = insertBefore; record !== null; record = record._nextRemoved) {
                    if (record === this._mapHead) {
                        this._mapHead = null;
                    }
                    this._records.delete(record.key);
                    record._nextRemoved = record._next;
                    record.previousValue = record.currentValue;
                    record.currentValue = null;
                    record._prev = null;
                    record._next = null;
                }
            }
            // Make sure tails have no next records from previous runs
            if (this._changesTail)
                this._changesTail._nextChanged = null;
            if (this._additionsTail)
                this._additionsTail._nextAdded = null;
            return this.isDirty;
        }
        /**
         * Inserts a record before `before` or append at the end of the list when `before` is null.
         *
         * Notes:
         * - This method appends at `this._appendAfter`,
         * - This method updates `this._appendAfter`,
         * - The return value is the new value for the insertion pointer.
         */
        _insertBeforeOrAppend(before, record) {
            if (before) {
                const prev = before._prev;
                record._next = before;
                record._prev = prev;
                before._prev = record;
                if (prev) {
                    prev._next = record;
                }
                if (before === this._mapHead) {
                    this._mapHead = record;
                }
                this._appendAfter = before;
                return before;
            }
            if (this._appendAfter) {
                this._appendAfter._next = record;
                record._prev = this._appendAfter;
            }
            else {
                this._mapHead = record;
            }
            this._appendAfter = record;
            return null;
        }
        _getOrCreateRecordForKey(key, value) {
            if (this._records.has(key)) {
                const record = this._records.get(key);
                this._maybeAddToChanges(record, value);
                const prev = record._prev;
                const next = record._next;
                if (prev) {
                    prev._next = next;
                }
                if (next) {
                    next._prev = prev;
                }
                record._next = null;
                record._prev = null;
                return record;
            }
            const record = new KeyValueChangeRecord_(key);
            this._records.set(key, record);
            record.currentValue = value;
            this._addToAdditions(record);
            return record;
        }
        /** @internal */
        _reset() {
            if (this.isDirty) {
                let record;
                // let `_previousMapHead` contain the state of the map before the changes
                this._previousMapHead = this._mapHead;
                for (record = this._previousMapHead; record !== null; record = record._next) {
                    record._nextPrevious = record._next;
                }
                // Update `record.previousValue` with the value of the item before the changes
                // We need to update all changed items (that's those which have been added and changed)
                for (record = this._changesHead; record !== null; record = record._nextChanged) {
                    record.previousValue = record.currentValue;
                }
                for (record = this._additionsHead; record != null; record = record._nextAdded) {
                    record.previousValue = record.currentValue;
                }
                this._changesHead = this._changesTail = null;
                this._additionsHead = this._additionsTail = null;
                this._removalsHead = null;
            }
        }
        // Add the record or a given key to the list of changes only when the value has actually changed
        _maybeAddToChanges(record, newValue) {
            if (!Object.is(newValue, record.currentValue)) {
                record.previousValue = record.currentValue;
                record.currentValue = newValue;
                this._addToChanges(record);
            }
        }
        _addToAdditions(record) {
            if (this._additionsHead === null) {
                this._additionsHead = this._additionsTail = record;
            }
            else {
                this._additionsTail._nextAdded = record;
                this._additionsTail = record;
            }
        }
        _addToChanges(record) {
            if (this._changesHead === null) {
                this._changesHead = this._changesTail = record;
            }
            else {
                this._changesTail._nextChanged = record;
                this._changesTail = record;
            }
        }
        /** @internal */
        _forEach(obj, fn) {
            if (obj instanceof Map) {
                obj.forEach(fn);
            }
            else {
                Object.keys(obj).forEach(k => fn(obj[k], k));
            }
        }
    }
    class KeyValueChangeRecord_ {
        constructor(key) {
            this.key = key;
            this.previousValue = null;
            this.currentValue = null;
            /** @internal */
            this._nextPrevious = null;
            /** @internal */
            this._next = null;
            /** @internal */
            this._prev = null;
            /** @internal */
            this._nextAdded = null;
            /** @internal */
            this._nextRemoved = null;
            /** @internal */
            this._nextChanged = null;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function defaultIterableDiffersFactory() {
        return new IterableDiffers([new DefaultIterableDifferFactory()]);
    }
    /**
     * A repository of different iterable diffing strategies used by NgFor, NgClass, and others.
     *
     * @publicApi
     */
    class IterableDiffers {
        constructor(factories) {
            this.factories = factories;
        }
        static create(factories, parent) {
            if (parent != null) {
                const copied = parent.factories.slice();
                factories = factories.concat(copied);
            }
            return new IterableDiffers(factories);
        }
        /**
         * Takes an array of {@link IterableDifferFactory} and returns a provider used to extend the
         * inherited {@link IterableDiffers} instance with the provided factories and return a new
         * {@link IterableDiffers} instance.
         *
         * @usageNotes
         * ### Example
         *
         * The following example shows how to extend an existing list of factories,
         * which will only be applied to the injector for this component and its children.
         * This step is all that's required to make a new {@link IterableDiffer} available.
         *
         * ```
         * @Component({
         *   viewProviders: [
         *     IterableDiffers.extend([new ImmutableListDiffer()])
         *   ]
         * })
         * ```
         */
        static extend(factories) {
            return {
                provide: IterableDiffers,
                useFactory: (parent) => {
                    // if parent is null, it means that we are in the root injector and we have just overridden
                    // the default injection mechanism for IterableDiffers, in such a case just assume
                    // `defaultIterableDiffersFactory`.
                    return IterableDiffers.create(factories, parent || defaultIterableDiffersFactory());
                },
                // Dependency technically isn't optional, but we can provide a better error message this way.
                deps: [[IterableDiffers, new SkipSelf(), new Optional()]]
            };
        }
        find(iterable) {
            const factory = this.factories.find(f => f.supports(iterable));
            if (factory != null) {
                return factory;
            }
            else {
                throw new Error(`Cannot find a differ supporting object '${iterable}' of type '${getTypeNameForDebugging(iterable)}'`);
            }
        }
    }
    /** @nocollapse */
    IterableDiffers.Éµprov = ÉµÉµdefineInjectable({ token: IterableDiffers, providedIn: 'root', factory: defaultIterableDiffersFactory });
    function getTypeNameForDebugging(type) {
        return type['name'] || typeof type;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function defaultKeyValueDiffersFactory() {
        return new KeyValueDiffers([new DefaultKeyValueDifferFactory()]);
    }
    /**
     * A repository of different Map diffing strategies used by NgClass, NgStyle, and others.
     *
     * @publicApi
     */
    class KeyValueDiffers {
        constructor(factories) {
            this.factories = factories;
        }
        static create(factories, parent) {
            if (parent) {
                const copied = parent.factories.slice();
                factories = factories.concat(copied);
            }
            return new KeyValueDiffers(factories);
        }
        /**
         * Takes an array of {@link KeyValueDifferFactory} and returns a provider used to extend the
         * inherited {@link KeyValueDiffers} instance with the provided factories and return a new
         * {@link KeyValueDiffers} instance.
         *
         * @usageNotes
         * ### Example
         *
         * The following example shows how to extend an existing list of factories,
         * which will only be applied to the injector for this component and its children.
         * This step is all that's required to make a new {@link KeyValueDiffer} available.
         *
         * ```
         * @Component({
         *   viewProviders: [
         *     KeyValueDiffers.extend([new ImmutableMapDiffer()])
         *   ]
         * })
         * ```
         */
        static extend(factories) {
            return {
                provide: KeyValueDiffers,
                useFactory: (parent) => {
                    // if parent is null, it means that we are in the root injector and we have just overridden
                    // the default injection mechanism for KeyValueDiffers, in such a case just assume
                    // `defaultKeyValueDiffersFactory`.
                    return KeyValueDiffers.create(factories, parent || defaultKeyValueDiffersFactory());
                },
                // Dependency technically isn't optional, but we can provide a better error message this way.
                deps: [[KeyValueDiffers, new SkipSelf(), new Optional()]]
            };
        }
        find(kv) {
            const factory = this.factories.find(f => f.supports(kv));
            if (factory) {
                return factory;
            }
            throw new Error(`Cannot find a differ supporting object '${kv}'`);
        }
    }
    /** @nocollapse */
    KeyValueDiffers.Éµprov = ÉµÉµdefineInjectable({ token: KeyValueDiffers, providedIn: 'root', factory: defaultKeyValueDiffersFactory });

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function collectNativeNodes(tView, lView, tNode, result, isProjection = false) {
        while (tNode !== null) {
            ngDevMode &&
                assertTNodeType(tNode, 3 /* AnyRNode */ | 12 /* AnyContainer */ | 16 /* Projection */ | 32 /* Icu */);
            const lNode = lView[tNode.index];
            if (lNode !== null) {
                result.push(unwrapRNode(lNode));
            }
            // A given lNode can represent either a native node or a LContainer (when it is a host of a
            // ViewContainerRef). When we find a LContainer we need to descend into it to collect root nodes
            // from the views in this container.
            if (isLContainer(lNode)) {
                for (let i = CONTAINER_HEADER_OFFSET; i < lNode.length; i++) {
                    const lViewInAContainer = lNode[i];
                    const lViewFirstChildTNode = lViewInAContainer[TVIEW].firstChild;
                    if (lViewFirstChildTNode !== null) {
                        collectNativeNodes(lViewInAContainer[TVIEW], lViewInAContainer, lViewFirstChildTNode, result);
                    }
                }
            }
            const tNodeType = tNode.type;
            if (tNodeType & 8 /* ElementContainer */) {
                collectNativeNodes(tView, lView, tNode.child, result);
            }
            else if (tNodeType & 32 /* Icu */) {
                const nextRNode = icuContainerIterate();
                let rNode;
                while (rNode = nextRNode()) {
                    result.push(rNode);
                }
            }
            else if (tNodeType & 16 /* Projection */) {
                const nodesInSlot = getProjectionNodes(lView, tNode);
                if (Array.isArray(nodesInSlot)) {
                    result.push(...nodesInSlot);
                }
                else {
                    const parentView = getLViewParent(lView[DECLARATION_COMPONENT_VIEW]);
                    ngDevMode && assertParentView(parentView);
                    collectNativeNodes(parentView[TVIEW], parentView, nodesInSlot, result, true);
                }
            }
            tNode = isProjection ? tNode.projectionNext : tNode.next;
        }
        return result;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class ViewRef {
        constructor(
        /**
         * This represents `LView` associated with the component when ViewRef is a ChangeDetectorRef.
         *
         * When ViewRef is created for a dynamic component, this also represents the `LView` for the
         * component.
         *
         * For a "regular" ViewRef created for an embedded view, this is the `LView` for the embedded
         * view.
         *
         * @internal
         */
        _lView, 
        /**
         * This represents the `LView` associated with the point where `ChangeDetectorRef` was
         * requested.
         *
         * This may be different from `_lView` if the `_cdRefInjectingView` is an embedded view.
         */
        _cdRefInjectingView) {
            this._lView = _lView;
            this._cdRefInjectingView = _cdRefInjectingView;
            this._appRef = null;
            this._attachedToViewContainer = false;
        }
        get rootNodes() {
            const lView = this._lView;
            const tView = lView[TVIEW];
            return collectNativeNodes(tView, lView, tView.firstChild, []);
        }
        get context() {
            return this._lView[CONTEXT];
        }
        set context(value) {
            this._lView[CONTEXT] = value;
        }
        get destroyed() {
            return (this._lView[FLAGS] & 256 /* Destroyed */) === 256 /* Destroyed */;
        }
        destroy() {
            if (this._appRef) {
                this._appRef.detachView(this);
            }
            else if (this._attachedToViewContainer) {
                const parent = this._lView[PARENT];
                if (isLContainer(parent)) {
                    const viewRefs = parent[VIEW_REFS];
                    const index = viewRefs ? viewRefs.indexOf(this) : -1;
                    if (index > -1) {
                        ngDevMode &&
                            assertEqual(index, parent.indexOf(this._lView) - CONTAINER_HEADER_OFFSET, 'An attached view should be in the same position within its container as its ViewRef in the VIEW_REFS array.');
                        detachView(parent, index);
                        removeFromArray(viewRefs, index);
                    }
                }
                this._attachedToViewContainer = false;
            }
            destroyLView(this._lView[TVIEW], this._lView);
        }
        onDestroy(callback) {
            storeCleanupWithContext(this._lView[TVIEW], this._lView, null, callback);
        }
        /**
         * Marks a view and all of its ancestors dirty.
         *
         * This can be used to ensure an {@link ChangeDetectionStrategy#OnPush OnPush} component is
         * checked when it needs to be re-rendered but the two normal triggers haven't marked it
         * dirty (i.e. inputs haven't changed and events haven't fired in the view).
         *
         * <!-- TODO: Add a link to a chapter on OnPush components -->
         *
         * @usageNotes
         * ### Example
         *
         * ```typescript
         * @Component({
         *   selector: 'app-root',
         *   template: `Number of ticks: {{numberOfTicks}}`
         *   changeDetection: ChangeDetectionStrategy.OnPush,
         * })
         * class AppComponent {
         *   numberOfTicks = 0;
         *
         *   constructor(private ref: ChangeDetectorRef) {
         *     setInterval(() => {
         *       this.numberOfTicks++;
         *       // the following is required, otherwise the view will not be updated
         *       this.ref.markForCheck();
         *     }, 1000);
         *   }
         * }
         * ```
         */
        markForCheck() {
            markViewDirty(this._cdRefInjectingView || this._lView);
        }
        /**
         * Detaches the view from the change detection tree.
         *
         * Detached views will not be checked during change detection runs until they are
         * re-attached, even if they are dirty. `detach` can be used in combination with
         * {@link ChangeDetectorRef#detectChanges detectChanges} to implement local change
         * detection checks.
         *
         * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
         * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->
         *
         * @usageNotes
         * ### Example
         *
         * The following example defines a component with a large list of readonly data.
         * Imagine the data changes constantly, many times per second. For performance reasons,
         * we want to check and update the list every five seconds. We can do that by detaching
         * the component's change detector and doing a local check every five seconds.
         *
         * ```typescript
         * class DataProvider {
         *   // in a real application the returned data will be different every time
         *   get data() {
         *     return [1,2,3,4,5];
         *   }
         * }
         *
         * @Component({
         *   selector: 'giant-list',
         *   template: `
         *     <li *ngFor="let d of dataProvider.data">Data {{d}}</li>
         *   `,
         * })
         * class GiantList {
         *   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {
         *     ref.detach();
         *     setInterval(() => {
         *       this.ref.detectChanges();
         *     }, 5000);
         *   }
         * }
         *
         * @Component({
         *   selector: 'app',
         *   providers: [DataProvider],
         *   template: `
         *     <giant-list><giant-list>
         *   `,
         * })
         * class App {
         * }
         * ```
         */
        detach() {
            this._lView[FLAGS] &= ~128 /* Attached */;
        }
        /**
         * Re-attaches a view to the change detection tree.
         *
         * This can be used to re-attach views that were previously detached from the tree
         * using {@link ChangeDetectorRef#detach detach}. Views are attached to the tree by default.
         *
         * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
         *
         * @usageNotes
         * ### Example
         *
         * The following example creates a component displaying `live` data. The component will detach
         * its change detector from the main change detector tree when the component's live property
         * is set to false.
         *
         * ```typescript
         * class DataProvider {
         *   data = 1;
         *
         *   constructor() {
         *     setInterval(() => {
         *       this.data = this.data * 2;
         *     }, 500);
         *   }
         * }
         *
         * @Component({
         *   selector: 'live-data',
         *   inputs: ['live'],
         *   template: 'Data: {{dataProvider.data}}'
         * })
         * class LiveData {
         *   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {}
         *
         *   set live(value) {
         *     if (value) {
         *       this.ref.reattach();
         *     } else {
         *       this.ref.detach();
         *     }
         *   }
         * }
         *
         * @Component({
         *   selector: 'app-root',
         *   providers: [DataProvider],
         *   template: `
         *     Live Update: <input type="checkbox" [(ngModel)]="live">
         *     <live-data [live]="live"><live-data>
         *   `,
         * })
         * class AppComponent {
         *   live = true;
         * }
         * ```
         */
        reattach() {
            this._lView[FLAGS] |= 128 /* Attached */;
        }
        /**
         * Checks the view and its children.
         *
         * This can also be used in combination with {@link ChangeDetectorRef#detach detach} to implement
         * local change detection checks.
         *
         * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
         * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->
         *
         * @usageNotes
         * ### Example
         *
         * The following example defines a component with a large list of readonly data.
         * Imagine, the data changes constantly, many times per second. For performance reasons,
         * we want to check and update the list every five seconds.
         *
         * We can do that by detaching the component's change detector and doing a local change detection
         * check every five seconds.
         *
         * See {@link ChangeDetectorRef#detach detach} for more information.
         */
        detectChanges() {
            detectChangesInternal(this._lView[TVIEW], this._lView, this.context);
        }
        /**
         * Checks the change detector and its children, and throws if any changes are detected.
         *
         * This is used in development mode to verify that running change detection doesn't
         * introduce other changes.
         */
        checkNoChanges() {
            checkNoChangesInternal(this._lView[TVIEW], this._lView, this.context);
        }
        attachToViewContainerRef() {
            if (this._appRef) {
                throw new Error('This view is already attached directly to the ApplicationRef!');
            }
            this._attachedToViewContainer = true;
        }
        detachFromAppRef() {
            this._appRef = null;
            renderDetachView(this._lView[TVIEW], this._lView);
        }
        attachToAppRef(appRef) {
            if (this._attachedToViewContainer) {
                throw new Error('This view is already attached to a ViewContainer!');
            }
            this._appRef = appRef;
        }
    }
    /** @internal */
    class RootViewRef extends ViewRef {
        constructor(_view) {
            super(_view);
            this._view = _view;
        }
        detectChanges() {
            detectChangesInRootView(this._view);
        }
        checkNoChanges() {
            checkNoChangesInRootView(this._view);
        }
        get context() {
            return null;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const SWITCH_CHANGE_DETECTOR_REF_FACTORY__PRE_R3__ = noop;
    const SWITCH_CHANGE_DETECTOR_REF_FACTORY = SWITCH_CHANGE_DETECTOR_REF_FACTORY__PRE_R3__;
    /**
     * Base class that provides change detection functionality.
     * A change-detection tree collects all views that are to be checked for changes.
     * Use the methods to add and remove views from the tree, initiate change-detection,
     * and explicitly mark views as _dirty_, meaning that they have changed and need to be re-rendered.
     *
     * @see [Using change detection hooks](guide/lifecycle-hooks#using-change-detection-hooks)
     * @see [Defining custom change detection](guide/lifecycle-hooks#defining-custom-change-detection)
     *
     * @usageNotes
     *
     * The following examples demonstrate how to modify default change-detection behavior
     * to perform explicit detection when needed.
     *
     * ### Use `markForCheck()` with `CheckOnce` strategy
     *
     * The following example sets the `OnPush` change-detection strategy for a component
     * (`CheckOnce`, rather than the default `CheckAlways`), then forces a second check
     * after an interval. See [live demo](https://plnkr.co/edit/GC512b?p=preview).
     *
     * <code-example path="core/ts/change_detect/change-detection.ts"
     * region="mark-for-check"></code-example>
     *
     * ### Detach change detector to limit how often check occurs
     *
     * The following example defines a component with a large list of read-only data
     * that is expected to change constantly, many times per second.
     * To improve performance, we want to check and update the list
     * less often than the changes actually occur. To do that, we detach
     * the component's change detector and perform an explicit local check every five seconds.
     *
     * <code-example path="core/ts/change_detect/change-detection.ts" region="detach"></code-example>
     *
     *
     * ### Reattaching a detached component
     *
     * The following example creates a component displaying live data.
     * The component detaches its change detector from the main change detector tree
     * when the `live` property is set to false, and reattaches it when the property
     * becomes true.
     *
     * <code-example path="core/ts/change_detect/change-detection.ts" region="reattach"></code-example>
     *
     * @publicApi
     */
    class ChangeDetectorRef {
    }
    /**
     * @internal
     * @nocollapse
     */
    ChangeDetectorRef.__NG_ELEMENT_ID__ = SWITCH_CHANGE_DETECTOR_REF_FACTORY;

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Structural diffing for `Object`s and `Map`s.
     */
    const keyValDiff = [new DefaultKeyValueDifferFactory()];
    /**
     * Structural diffing for `Iterable` types such as `Array`s.
     */
    const iterableDiff = [new DefaultIterableDifferFactory()];
    const defaultIterableDiffers = new IterableDiffers(iterableDiff);
    const defaultKeyValueDiffers = new KeyValueDiffers(keyValDiff);

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const SWITCH_TEMPLATE_REF_FACTORY__PRE_R3__ = noop;
    const SWITCH_TEMPLATE_REF_FACTORY = SWITCH_TEMPLATE_REF_FACTORY__PRE_R3__;
    /**
     * Represents an embedded template that can be used to instantiate embedded views.
     * To instantiate embedded views based on a template, use the `ViewContainerRef`
     * method `createEmbeddedView()`.
     *
     * Access a `TemplateRef` instance by placing a directive on an `<ng-template>`
     * element (or directive prefixed with `*`). The `TemplateRef` for the embedded view
     * is injected into the constructor of the directive,
     * using the `TemplateRef` token.
     *
     * You can also use a `Query` to find a `TemplateRef` associated with
     * a component or a directive.
     *
     * @see `ViewContainerRef`
     * @see [Navigate the Component Tree with DI](guide/dependency-injection-navtree)
     *
     * @publicApi
     */
    class TemplateRef {
    }
    /**
     * @internal
     * @nocollapse
     */
    TemplateRef.__NG_ELEMENT_ID__ = SWITCH_TEMPLATE_REF_FACTORY;

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Represents an instance of an `NgModule` created by an `NgModuleFactory`.
     * Provides access to the `NgModule` instance and related objects.
     *
     * @publicApi
     */
    class NgModuleRef {
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const SWITCH_VIEW_CONTAINER_REF_FACTORY__PRE_R3__ = noop;
    const SWITCH_VIEW_CONTAINER_REF_FACTORY = SWITCH_VIEW_CONTAINER_REF_FACTORY__PRE_R3__;
    /**
     * Represents a container where one or more views can be attached to a component.
     *
     * Can contain *host views* (created by instantiating a
     * component with the `createComponent()` method), and *embedded views*
     * (created by instantiating a `TemplateRef` with the `createEmbeddedView()` method).
     *
     * A view container instance can contain other view containers,
     * creating a [view hierarchy](guide/glossary#view-tree).
     *
     * @see `ComponentRef`
     * @see `EmbeddedViewRef`
     *
     * @publicApi
     */
    class ViewContainerRef {
    }
    /**
     * @internal
     * @nocollapse
     */
    ViewContainerRef.__NG_ELEMENT_ID__ = SWITCH_VIEW_CONTAINER_REF_FACTORY;

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const _tokenKeyCache = new Map();
    function tokenKey(token) {
        let key = _tokenKeyCache.get(token);
        if (!key) {
            key = stringify$1(token) + '_' + _tokenKeyCache.size;
            _tokenKeyCache.set(token, key);
        }
        return key;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const InjectorRefTokenKey = tokenKey(Injector);
    const INJECTORRefTokenKey = tokenKey(INJECTOR$1);
    const NgModuleRefTokenKey = tokenKey(NgModuleRef);

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const Renderer2TokenKey = tokenKey(Renderer2);
    const ElementRefTokenKey = tokenKey(ElementRef);
    const ViewContainerRefTokenKey = tokenKey(ViewContainerRef);
    const TemplateRefTokenKey = tokenKey(TemplateRef);
    const ChangeDetectorRefTokenKey = tokenKey(ChangeDetectorRef);
    const InjectorRefTokenKey$1 = tokenKey(Injector);
    const INJECTORRefTokenKey$1 = tokenKey(INJECTOR$1);
    // This default value is when checking the hierarchy for a token.
    //
    // It means both:
    // - the token is not provided by the current injector,
    // - only the element injectors should be checked (ie do not check module injectors
    //
    //          mod1
    //         /
    //       el1   mod2
    //         \  /
    //         el2
    //
    // When requesting el2.injector.get(token), we should check in the following order and return the
    // first found value:
    // - el2.injector.get(token, default)
    // - el1.injector.get(token, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR) -> do not check the module
    // - mod2.injector.get(token, default)
    const NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR = {};

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class ComponentFactoryResolver$1 extends ComponentFactoryResolver {
        /**
         * @param ngModule The NgModuleRef to which all resolved factories are bound.
         */
        constructor(ngModule) {
            super();
            this.ngModule = ngModule;
        }
        resolveComponentFactory(component) {
            ngDevMode && assertComponentType(component);
            const componentDef = getComponentDef(component);
            return new ComponentFactory$1(componentDef, this.ngModule);
        }
    }
    function toRefArray(map) {
        const array = [];
        for (let nonMinified in map) {
            if (map.hasOwnProperty(nonMinified)) {
                const minified = map[nonMinified];
                array.push({ propName: minified, templateName: nonMinified });
            }
        }
        return array;
    }
    function getNamespace(elementName) {
        const name = elementName.toLowerCase();
        return name === 'svg' ? SVG_NAMESPACE : (name === 'math' ? MATH_ML_NAMESPACE : null);
    }
    /**
     * A change detection scheduler token for {@link RootContext}. This token is the default value used
     * for the default `RootContext` found in the {@link ROOT_CONTEXT} token.
     */
    const SCHEDULER = new InjectionToken('SCHEDULER_TOKEN', {
        providedIn: 'root',
        factory: () => defaultScheduler,
    });
    function createChainedInjector(rootViewInjector, moduleInjector) {
        return {
            get: (token, notFoundValue, flags) => {
                const value = rootViewInjector.get(token, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR, flags);
                if (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR ||
                    notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR) {
                    // Return the value from the root element injector when
                    // - it provides it
                    //   (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR)
                    // - the module injector should not be checked
                    //   (notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR)
                    return value;
                }
                return moduleInjector.get(token, notFoundValue, flags);
            }
        };
    }
    /**
     * Render3 implementation of {@link viewEngine_ComponentFactory}.
     */
    class ComponentFactory$1 extends ComponentFactory {
        /**
         * @param componentDef The component definition.
         * @param ngModule The NgModuleRef to which the factory is bound.
         */
        constructor(componentDef, ngModule) {
            super();
            this.componentDef = componentDef;
            this.ngModule = ngModule;
            this.componentType = componentDef.type;
            this.selector = stringifyCSSSelectorList(componentDef.selectors);
            this.ngContentSelectors =
                componentDef.ngContentSelectors ? componentDef.ngContentSelectors : [];
            this.isBoundToModule = !!ngModule;
        }
        get inputs() {
            return toRefArray(this.componentDef.inputs);
        }
        get outputs() {
            return toRefArray(this.componentDef.outputs);
        }
        create(injector, projectableNodes, rootSelectorOrNode, ngModule) {
            ngModule = ngModule || this.ngModule;
            const rootViewInjector = ngModule ? createChainedInjector(injector, ngModule.injector) : injector;
            const rendererFactory = rootViewInjector.get(RendererFactory2, domRendererFactory3);
            const sanitizer = rootViewInjector.get(Sanitizer, null);
            const hostRenderer = rendererFactory.createRenderer(null, this.componentDef);
            // Determine a tag name used for creating host elements when this component is created
            // dynamically. Default to 'div' if this component did not specify any tag name in its selector.
            const elementName = this.componentDef.selectors[0][0] || 'div';
            const hostRNode = rootSelectorOrNode ?
                locateHostElement(hostRenderer, rootSelectorOrNode, this.componentDef.encapsulation) :
                createElementNode(rendererFactory.createRenderer(null, this.componentDef), elementName, getNamespace(elementName));
            const rootFlags = this.componentDef.onPush ? 64 /* Dirty */ | 512 /* IsRoot */ :
                16 /* CheckAlways */ | 512 /* IsRoot */;
            const rootContext = createRootContext();
            // Create the root view. Uses empty TView and ContentTemplate.
            const rootTView = createTView(0 /* Root */, null, null, 1, 0, null, null, null, null, null);
            const rootLView = createLView(null, rootTView, rootContext, rootFlags, null, null, rendererFactory, hostRenderer, sanitizer, rootViewInjector);
            // rootView is the parent when bootstrapping
            // TODO(misko): it looks like we are entering view here but we don't really need to as
            // `renderView` does that. However as the code is written it is needed because
            // `createRootComponentView` and `createRootComponent` both read global state. Fixing those
            // issues would allow us to drop this.
            enterView(rootLView);
            let component;
            let tElementNode;
            try {
                const componentView = createRootComponentView(hostRNode, this.componentDef, rootLView, rendererFactory, hostRenderer);
                if (hostRNode) {
                    if (rootSelectorOrNode) {
                        setUpAttributes(hostRenderer, hostRNode, ['ng-version', VERSION$2.full]);
                    }
                    else {
                        // If host element is created as a part of this function call (i.e. `rootSelectorOrNode`
                        // is not defined), also apply attributes and classes extracted from component selector.
                        // Extract attributes and classes from the first selector only to match VE behavior.
                        const { attrs, classes } = extractAttrsAndClassesFromSelector(this.componentDef.selectors[0]);
                        if (attrs) {
                            setUpAttributes(hostRenderer, hostRNode, attrs);
                        }
                        if (classes && classes.length > 0) {
                            writeDirectClass(hostRenderer, hostRNode, classes.join(' '));
                        }
                    }
                }
                tElementNode = getTNode(rootTView, HEADER_OFFSET);
                if (projectableNodes !== undefined) {
                    const projection = tElementNode.projection = [];
                    for (let i = 0; i < this.ngContentSelectors.length; i++) {
                        const nodesforSlot = projectableNodes[i];
                        // Projectable nodes can be passed as array of arrays or an array of iterables (ngUpgrade
                        // case). Here we do normalize passed data structure to be an array of arrays to avoid
                        // complex checks down the line.
                        // We also normalize the length of the passed in projectable nodes (to match the number of
                        // <ng-container> slots defined by a component).
                        projection.push(nodesforSlot != null ? Array.from(nodesforSlot) : null);
                    }
                }
                // TODO: should LifecycleHooksFeature and other host features be generated by the compiler and
                // executed here?
                // Angular 5 reference: https://stackblitz.com/edit/lifecycle-hooks-vcref
                component = createRootComponent(componentView, this.componentDef, rootLView, rootContext, [LifecycleHooksFeature]);
                renderView(rootTView, rootLView, null);
            }
            finally {
                leaveView();
            }
            return new ComponentRef$1(this.componentType, component, createElementRef(tElementNode, rootLView), rootLView, tElementNode);
        }
    }
    const componentFactoryResolver = new ComponentFactoryResolver$1();
    /**
     * Represents an instance of a Component created via a {@link ComponentFactory}.
     *
     * `ComponentRef` provides access to the Component Instance as well other objects related to this
     * Component Instance and allows you to destroy the Component Instance via the {@link #destroy}
     * method.
     *
     */
    class ComponentRef$1 extends ComponentRef {
        constructor(componentType, instance, location, _rootLView, _tNode) {
            super();
            this.location = location;
            this._rootLView = _rootLView;
            this._tNode = _tNode;
            this.instance = instance;
            this.hostView = this.changeDetectorRef = new RootViewRef(_rootLView);
            this.componentType = componentType;
        }
        get injector() {
            return new NodeInjector(this._tNode, this._rootLView);
        }
        destroy() {
            this.hostView.destroy();
        }
        onDestroy(callback) {
            this.hostView.onDestroy(callback);
        }
    }

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */
    function isFunction(x) {
        return typeof x === 'function';
    }

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */
    var _enable_super_gross_mode_that_will_cause_bad_things = false;
    var config = {
        Promise: undefined,
        set useDeprecatedSynchronousErrorHandling(value) {
            if (value) {
                var error = /*@__PURE__*/ new Error();
                /*@__PURE__*/ console.warn('DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n' + error.stack);
            }
            _enable_super_gross_mode_that_will_cause_bad_things = value;
        },
        get useDeprecatedSynchronousErrorHandling() {
            return _enable_super_gross_mode_that_will_cause_bad_things;
        },
    };

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */
    function hostReportError(err) {
        setTimeout(function () { throw err; }, 0);
    }

    /** PURE_IMPORTS_START _config,_util_hostReportError PURE_IMPORTS_END */
    var empty = {
        closed: true,
        next: function (value) { },
        error: function (err) {
            if (config.useDeprecatedSynchronousErrorHandling) {
                throw err;
            }
            else {
                hostReportError(err);
            }
        },
        complete: function () { }
    };

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */
    var isArray = /*@__PURE__*/ (function () { return Array.isArray || (function (x) { return x && typeof x.length === 'number'; }); })();

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */
    function isObject(x) {
        return x !== null && typeof x === 'object';
    }

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */
    var UnsubscriptionErrorImpl = /*@__PURE__*/ (function () {
        function UnsubscriptionErrorImpl(errors) {
            Error.call(this);
            this.message = errors ?
                errors.length + " errors occurred during unsubscription:\n" + errors.map(function (err, i) { return i + 1 + ") " + err.toString(); }).join('\n  ') : '';
            this.name = 'UnsubscriptionError';
            this.errors = errors;
            return this;
        }
        UnsubscriptionErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);
        return UnsubscriptionErrorImpl;
    })();
    var UnsubscriptionError = UnsubscriptionErrorImpl;

    /** PURE_IMPORTS_START _util_isArray,_util_isObject,_util_isFunction,_util_UnsubscriptionError PURE_IMPORTS_END */
    var Subscription = /*@__PURE__*/ (function () {
        function Subscription(unsubscribe) {
            this.closed = false;
            this._parentOrParents = null;
            this._subscriptions = null;
            if (unsubscribe) {
                this._ctorUnsubscribe = true;
                this._unsubscribe = unsubscribe;
            }
        }
        Subscription.prototype.unsubscribe = function () {
            var errors;
            if (this.closed) {
                return;
            }
            var _a = this, _parentOrParents = _a._parentOrParents, _ctorUnsubscribe = _a._ctorUnsubscribe, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
            this.closed = true;
            this._parentOrParents = null;
            this._subscriptions = null;
            if (_parentOrParents instanceof Subscription) {
                _parentOrParents.remove(this);
            }
            else if (_parentOrParents !== null) {
                for (var index = 0; index < _parentOrParents.length; ++index) {
                    var parent_1 = _parentOrParents[index];
                    parent_1.remove(this);
                }
            }
            if (isFunction(_unsubscribe)) {
                if (_ctorUnsubscribe) {
                    this._unsubscribe = undefined;
                }
                try {
                    _unsubscribe.call(this);
                }
                catch (e) {
                    errors = e instanceof UnsubscriptionError ? flattenUnsubscriptionErrors(e.errors) : [e];
                }
            }
            if (isArray(_subscriptions)) {
                var index = -1;
                var len = _subscriptions.length;
                while (++index < len) {
                    var sub = _subscriptions[index];
                    if (isObject(sub)) {
                        try {
                            sub.unsubscribe();
                        }
                        catch (e) {
                            errors = errors || [];
                            if (e instanceof UnsubscriptionError) {
                                errors = errors.concat(flattenUnsubscriptionErrors(e.errors));
                            }
                            else {
                                errors.push(e);
                            }
                        }
                    }
                }
            }
            if (errors) {
                throw new UnsubscriptionError(errors);
            }
        };
        Subscription.prototype.add = function (teardown) {
            var subscription = teardown;
            if (!teardown) {
                return Subscription.EMPTY;
            }
            switch (typeof teardown) {
                case 'function':
                    subscription = new Subscription(teardown);
                case 'object':
                    if (subscription === this || subscription.closed || typeof subscription.unsubscribe !== 'function') {
                        return subscription;
                    }
                    else if (this.closed) {
                        subscription.unsubscribe();
                        return subscription;
                    }
                    else if (!(subscription instanceof Subscription)) {
                        var tmp = subscription;
                        subscription = new Subscription();
                        subscription._subscriptions = [tmp];
                    }
                    break;
                default: {
                    throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
                }
            }
            var _parentOrParents = subscription._parentOrParents;
            if (_parentOrParents === null) {
                subscription._parentOrParents = this;
            }
            else if (_parentOrParents instanceof Subscription) {
                if (_parentOrParents === this) {
                    return subscription;
                }
                subscription._parentOrParents = [_parentOrParents, this];
            }
            else if (_parentOrParents.indexOf(this) === -1) {
                _parentOrParents.push(this);
            }
            else {
                return subscription;
            }
            var subscriptions = this._subscriptions;
            if (subscriptions === null) {
                this._subscriptions = [subscription];
            }
            else {
                subscriptions.push(subscription);
            }
            return subscription;
        };
        Subscription.prototype.remove = function (subscription) {
            var subscriptions = this._subscriptions;
            if (subscriptions) {
                var subscriptionIndex = subscriptions.indexOf(subscription);
                if (subscriptionIndex !== -1) {
                    subscriptions.splice(subscriptionIndex, 1);
                }
            }
        };
        Subscription.EMPTY = (function (empty) {
            empty.closed = true;
            return empty;
        }(new Subscription()));
        return Subscription;
    }());
    function flattenUnsubscriptionErrors(errors) {
        return errors.reduce(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError) ? err.errors : err); }, []);
    }

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */
    var rxSubscriber = /*@__PURE__*/ (function () {
        return typeof Symbol === 'function'
            ? /*@__PURE__*/ Symbol('rxSubscriber')
            : '@@rxSubscriber_' + /*@__PURE__*/ Math.random();
    })();

    /** PURE_IMPORTS_START tslib,_util_isFunction,_Observer,_Subscription,_internal_symbol_rxSubscriber,_config,_util_hostReportError PURE_IMPORTS_END */
    var Subscriber = /*@__PURE__*/ (function (_super) {
        __extends(Subscriber, _super);
        function Subscriber(destinationOrNext, error, complete) {
            var _this = _super.call(this) || this;
            _this.syncErrorValue = null;
            _this.syncErrorThrown = false;
            _this.syncErrorThrowable = false;
            _this.isStopped = false;
            switch (arguments.length) {
                case 0:
                    _this.destination = empty;
                    break;
                case 1:
                    if (!destinationOrNext) {
                        _this.destination = empty;
                        break;
                    }
                    if (typeof destinationOrNext === 'object') {
                        if (destinationOrNext instanceof Subscriber) {
                            _this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
                            _this.destination = destinationOrNext;
                            destinationOrNext.add(_this);
                        }
                        else {
                            _this.syncErrorThrowable = true;
                            _this.destination = new SafeSubscriber(_this, destinationOrNext);
                        }
                        break;
                    }
                default:
                    _this.syncErrorThrowable = true;
                    _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);
                    break;
            }
            return _this;
        }
        Subscriber.prototype[rxSubscriber] = function () { return this; };
        Subscriber.create = function (next, error, complete) {
            var subscriber = new Subscriber(next, error, complete);
            subscriber.syncErrorThrowable = false;
            return subscriber;
        };
        Subscriber.prototype.next = function (value) {
            if (!this.isStopped) {
                this._next(value);
            }
        };
        Subscriber.prototype.error = function (err) {
            if (!this.isStopped) {
                this.isStopped = true;
                this._error(err);
            }
        };
        Subscriber.prototype.complete = function () {
            if (!this.isStopped) {
                this.isStopped = true;
                this._complete();
            }
        };
        Subscriber.prototype.unsubscribe = function () {
            if (this.closed) {
                return;
            }
            this.isStopped = true;
            _super.prototype.unsubscribe.call(this);
        };
        Subscriber.prototype._next = function (value) {
            this.destination.next(value);
        };
        Subscriber.prototype._error = function (err) {
            this.destination.error(err);
            this.unsubscribe();
        };
        Subscriber.prototype._complete = function () {
            this.destination.complete();
            this.unsubscribe();
        };
        Subscriber.prototype._unsubscribeAndRecycle = function () {
            var _parentOrParents = this._parentOrParents;
            this._parentOrParents = null;
            this.unsubscribe();
            this.closed = false;
            this.isStopped = false;
            this._parentOrParents = _parentOrParents;
            return this;
        };
        return Subscriber;
    }(Subscription));
    var SafeSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(SafeSubscriber, _super);
        function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
            var _this = _super.call(this) || this;
            _this._parentSubscriber = _parentSubscriber;
            var next;
            var context = _this;
            if (isFunction(observerOrNext)) {
                next = observerOrNext;
            }
            else if (observerOrNext) {
                next = observerOrNext.next;
                error = observerOrNext.error;
                complete = observerOrNext.complete;
                if (observerOrNext !== empty) {
                    context = Object.create(observerOrNext);
                    if (isFunction(context.unsubscribe)) {
                        _this.add(context.unsubscribe.bind(context));
                    }
                    context.unsubscribe = _this.unsubscribe.bind(_this);
                }
            }
            _this._context = context;
            _this._next = next;
            _this._error = error;
            _this._complete = complete;
            return _this;
        }
        SafeSubscriber.prototype.next = function (value) {
            if (!this.isStopped && this._next) {
                var _parentSubscriber = this._parentSubscriber;
                if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(this._next, value);
                }
                else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
                    this.unsubscribe();
                }
            }
        };
        SafeSubscriber.prototype.error = function (err) {
            if (!this.isStopped) {
                var _parentSubscriber = this._parentSubscriber;
                var useDeprecatedSynchronousErrorHandling = config.useDeprecatedSynchronousErrorHandling;
                if (this._error) {
                    if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                        this.__tryOrUnsub(this._error, err);
                        this.unsubscribe();
                    }
                    else {
                        this.__tryOrSetError(_parentSubscriber, this._error, err);
                        this.unsubscribe();
                    }
                }
                else if (!_parentSubscriber.syncErrorThrowable) {
                    this.unsubscribe();
                    if (useDeprecatedSynchronousErrorHandling) {
                        throw err;
                    }
                    hostReportError(err);
                }
                else {
                    if (useDeprecatedSynchronousErrorHandling) {
                        _parentSubscriber.syncErrorValue = err;
                        _parentSubscriber.syncErrorThrown = true;
                    }
                    else {
                        hostReportError(err);
                    }
                    this.unsubscribe();
                }
            }
        };
        SafeSubscriber.prototype.complete = function () {
            var _this = this;
            if (!this.isStopped) {
                var _parentSubscriber = this._parentSubscriber;
                if (this._complete) {
                    var wrappedComplete = function () { return _this._complete.call(_this._context); };
                    if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                        this.__tryOrUnsub(wrappedComplete);
                        this.unsubscribe();
                    }
                    else {
                        this.__tryOrSetError(_parentSubscriber, wrappedComplete);
                        this.unsubscribe();
                    }
                }
                else {
                    this.unsubscribe();
                }
            }
        };
        SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
            try {
                fn.call(this._context, value);
            }
            catch (err) {
                this.unsubscribe();
                if (config.useDeprecatedSynchronousErrorHandling) {
                    throw err;
                }
                else {
                    hostReportError(err);
                }
            }
        };
        SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
            if (!config.useDeprecatedSynchronousErrorHandling) {
                throw new Error('bad call');
            }
            try {
                fn.call(this._context, value);
            }
            catch (err) {
                if (config.useDeprecatedSynchronousErrorHandling) {
                    parent.syncErrorValue = err;
                    parent.syncErrorThrown = true;
                    return true;
                }
                else {
                    hostReportError(err);
                    return true;
                }
            }
            return false;
        };
        SafeSubscriber.prototype._unsubscribe = function () {
            var _parentSubscriber = this._parentSubscriber;
            this._context = null;
            this._parentSubscriber = null;
            _parentSubscriber.unsubscribe();
        };
        return SafeSubscriber;
    }(Subscriber));

    /** PURE_IMPORTS_START _Subscriber PURE_IMPORTS_END */
    function canReportError(observer) {
        while (observer) {
            var _a = observer, closed_1 = _a.closed, destination = _a.destination, isStopped = _a.isStopped;
            if (closed_1 || isStopped) {
                return false;
            }
            else if (destination && destination instanceof Subscriber) {
                observer = destination;
            }
            else {
                observer = null;
            }
        }
        return true;
    }

    /** PURE_IMPORTS_START _Subscriber,_symbol_rxSubscriber,_Observer PURE_IMPORTS_END */
    function toSubscriber(nextOrObserver, error, complete) {
        if (nextOrObserver) {
            if (nextOrObserver instanceof Subscriber) {
                return nextOrObserver;
            }
            if (nextOrObserver[rxSubscriber]) {
                return nextOrObserver[rxSubscriber]();
            }
        }
        if (!nextOrObserver && !error && !complete) {
            return new Subscriber(empty);
        }
        return new Subscriber(nextOrObserver, error, complete);
    }

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */
    var observable = /*@__PURE__*/ (function () { return typeof Symbol === 'function' && Symbol.observable || '@@observable'; })();

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */
    function identity(x) {
        return x;
    }

    /** PURE_IMPORTS_START _identity PURE_IMPORTS_END */
    function pipeFromArray(fns) {
        if (fns.length === 0) {
            return identity;
        }
        if (fns.length === 1) {
            return fns[0];
        }
        return function piped(input) {
            return fns.reduce(function (prev, fn) { return fn(prev); }, input);
        };
    }

    /** PURE_IMPORTS_START _util_canReportError,_util_toSubscriber,_symbol_observable,_util_pipe,_config PURE_IMPORTS_END */
    var Observable = /*@__PURE__*/ (function () {
        function Observable(subscribe) {
            this._isScalar = false;
            if (subscribe) {
                this._subscribe = subscribe;
            }
        }
        Observable.prototype.lift = function (operator) {
            var observable = new Observable();
            observable.source = this;
            observable.operator = operator;
            return observable;
        };
        Observable.prototype.subscribe = function (observerOrNext, error, complete) {
            var operator = this.operator;
            var sink = toSubscriber(observerOrNext, error, complete);
            if (operator) {
                sink.add(operator.call(sink, this.source));
            }
            else {
                sink.add(this.source || (config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable) ?
                    this._subscribe(sink) :
                    this._trySubscribe(sink));
            }
            if (config.useDeprecatedSynchronousErrorHandling) {
                if (sink.syncErrorThrowable) {
                    sink.syncErrorThrowable = false;
                    if (sink.syncErrorThrown) {
                        throw sink.syncErrorValue;
                    }
                }
            }
            return sink;
        };
        Observable.prototype._trySubscribe = function (sink) {
            try {
                return this._subscribe(sink);
            }
            catch (err) {
                if (config.useDeprecatedSynchronousErrorHandling) {
                    sink.syncErrorThrown = true;
                    sink.syncErrorValue = err;
                }
                if (canReportError(sink)) {
                    sink.error(err);
                }
                else {
                    console.warn(err);
                }
            }
        };
        Observable.prototype.forEach = function (next, promiseCtor) {
            var _this = this;
            promiseCtor = getPromiseCtor(promiseCtor);
            return new promiseCtor(function (resolve, reject) {
                var subscription;
                subscription = _this.subscribe(function (value) {
                    try {
                        next(value);
                    }
                    catch (err) {
                        reject(err);
                        if (subscription) {
                            subscription.unsubscribe();
                        }
                    }
                }, reject, resolve);
            });
        };
        Observable.prototype._subscribe = function (subscriber) {
            var source = this.source;
            return source && source.subscribe(subscriber);
        };
        Observable.prototype[observable] = function () {
            return this;
        };
        Observable.prototype.pipe = function () {
            var operations = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                operations[_i] = arguments[_i];
            }
            if (operations.length === 0) {
                return this;
            }
            return pipeFromArray(operations)(this);
        };
        Observable.prototype.toPromise = function (promiseCtor) {
            var _this = this;
            promiseCtor = getPromiseCtor(promiseCtor);
            return new promiseCtor(function (resolve, reject) {
                var value;
                _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve(value); });
            });
        };
        Observable.create = function (subscribe) {
            return new Observable(subscribe);
        };
        return Observable;
    }());
    function getPromiseCtor(promiseCtor) {
        if (!promiseCtor) {
            promiseCtor =  Promise;
        }
        if (!promiseCtor) {
            throw new Error('no Promise impl found');
        }
        return promiseCtor;
    }

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */
    var ObjectUnsubscribedErrorImpl = /*@__PURE__*/ (function () {
        function ObjectUnsubscribedErrorImpl() {
            Error.call(this);
            this.message = 'object unsubscribed';
            this.name = 'ObjectUnsubscribedError';
            return this;
        }
        ObjectUnsubscribedErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);
        return ObjectUnsubscribedErrorImpl;
    })();
    var ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl;

    /** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */
    var SubjectSubscription = /*@__PURE__*/ (function (_super) {
        __extends(SubjectSubscription, _super);
        function SubjectSubscription(subject, subscriber) {
            var _this = _super.call(this) || this;
            _this.subject = subject;
            _this.subscriber = subscriber;
            _this.closed = false;
            return _this;
        }
        SubjectSubscription.prototype.unsubscribe = function () {
            if (this.closed) {
                return;
            }
            this.closed = true;
            var subject = this.subject;
            var observers = subject.observers;
            this.subject = null;
            if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
                return;
            }
            var subscriberIndex = observers.indexOf(this.subscriber);
            if (subscriberIndex !== -1) {
                observers.splice(subscriberIndex, 1);
            }
        };
        return SubjectSubscription;
    }(Subscription));

    /** PURE_IMPORTS_START tslib,_Observable,_Subscriber,_Subscription,_util_ObjectUnsubscribedError,_SubjectSubscription,_internal_symbol_rxSubscriber PURE_IMPORTS_END */
    var SubjectSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(SubjectSubscriber, _super);
        function SubjectSubscriber(destination) {
            var _this = _super.call(this, destination) || this;
            _this.destination = destination;
            return _this;
        }
        return SubjectSubscriber;
    }(Subscriber));
    var Subject = /*@__PURE__*/ (function (_super) {
        __extends(Subject, _super);
        function Subject() {
            var _this = _super.call(this) || this;
            _this.observers = [];
            _this.closed = false;
            _this.isStopped = false;
            _this.hasError = false;
            _this.thrownError = null;
            return _this;
        }
        Subject.prototype[rxSubscriber] = function () {
            return new SubjectSubscriber(this);
        };
        Subject.prototype.lift = function (operator) {
            var subject = new AnonymousSubject(this, this);
            subject.operator = operator;
            return subject;
        };
        Subject.prototype.next = function (value) {
            if (this.closed) {
                throw new ObjectUnsubscribedError();
            }
            if (!this.isStopped) {
                var observers = this.observers;
                var len = observers.length;
                var copy = observers.slice();
                for (var i = 0; i < len; i++) {
                    copy[i].next(value);
                }
            }
        };
        Subject.prototype.error = function (err) {
            if (this.closed) {
                throw new ObjectUnsubscribedError();
            }
            this.hasError = true;
            this.thrownError = err;
            this.isStopped = true;
            var observers = this.observers;
            var len = observers.length;
            var copy = observers.slice();
            for (var i = 0; i < len; i++) {
                copy[i].error(err);
            }
            this.observers.length = 0;
        };
        Subject.prototype.complete = function () {
            if (this.closed) {
                throw new ObjectUnsubscribedError();
            }
            this.isStopped = true;
            var observers = this.observers;
            var len = observers.length;
            var copy = observers.slice();
            for (var i = 0; i < len; i++) {
                copy[i].complete();
            }
            this.observers.length = 0;
        };
        Subject.prototype.unsubscribe = function () {
            this.isStopped = true;
            this.closed = true;
            this.observers = null;
        };
        Subject.prototype._trySubscribe = function (subscriber) {
            if (this.closed) {
                throw new ObjectUnsubscribedError();
            }
            else {
                return _super.prototype._trySubscribe.call(this, subscriber);
            }
        };
        Subject.prototype._subscribe = function (subscriber) {
            if (this.closed) {
                throw new ObjectUnsubscribedError();
            }
            else if (this.hasError) {
                subscriber.error(this.thrownError);
                return Subscription.EMPTY;
            }
            else if (this.isStopped) {
                subscriber.complete();
                return Subscription.EMPTY;
            }
            else {
                this.observers.push(subscriber);
                return new SubjectSubscription(this, subscriber);
            }
        };
        Subject.prototype.asObservable = function () {
            var observable = new Observable();
            observable.source = this;
            return observable;
        };
        Subject.create = function (destination, source) {
            return new AnonymousSubject(destination, source);
        };
        return Subject;
    }(Observable));
    var AnonymousSubject = /*@__PURE__*/ (function (_super) {
        __extends(AnonymousSubject, _super);
        function AnonymousSubject(destination, source) {
            var _this = _super.call(this) || this;
            _this.destination = destination;
            _this.source = source;
            return _this;
        }
        AnonymousSubject.prototype.next = function (value) {
            var destination = this.destination;
            if (destination && destination.next) {
                destination.next(value);
            }
        };
        AnonymousSubject.prototype.error = function (err) {
            var destination = this.destination;
            if (destination && destination.error) {
                this.destination.error(err);
            }
        };
        AnonymousSubject.prototype.complete = function () {
            var destination = this.destination;
            if (destination && destination.complete) {
                this.destination.complete();
            }
        };
        AnonymousSubject.prototype._subscribe = function (subscriber) {
            var source = this.source;
            if (source) {
                return this.source.subscribe(subscriber);
            }
            else {
                return Subscription.EMPTY;
            }
        };
        return AnonymousSubject;
    }(Subject));

    /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
    function refCount() {
        return function refCountOperatorFunction(source) {
            return source.lift(new RefCountOperator(source));
        };
    }
    var RefCountOperator = /*@__PURE__*/ (function () {
        function RefCountOperator(connectable) {
            this.connectable = connectable;
        }
        RefCountOperator.prototype.call = function (subscriber, source) {
            var connectable = this.connectable;
            connectable._refCount++;
            var refCounter = new RefCountSubscriber(subscriber, connectable);
            var subscription = source.subscribe(refCounter);
            if (!refCounter.closed) {
                refCounter.connection = connectable.connect();
            }
            return subscription;
        };
        return RefCountOperator;
    }());
    var RefCountSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(RefCountSubscriber, _super);
        function RefCountSubscriber(destination, connectable) {
            var _this = _super.call(this, destination) || this;
            _this.connectable = connectable;
            return _this;
        }
        RefCountSubscriber.prototype._unsubscribe = function () {
            var connectable = this.connectable;
            if (!connectable) {
                this.connection = null;
                return;
            }
            this.connectable = null;
            var refCount = connectable._refCount;
            if (refCount <= 0) {
                this.connection = null;
                return;
            }
            connectable._refCount = refCount - 1;
            if (refCount > 1) {
                this.connection = null;
                return;
            }
            var connection = this.connection;
            var sharedConnection = connectable._connection;
            this.connection = null;
            if (sharedConnection && (!connection || sharedConnection === connection)) {
                sharedConnection.unsubscribe();
            }
        };
        return RefCountSubscriber;
    }(Subscriber));

    /** PURE_IMPORTS_START tslib,_Subject,_Observable,_Subscriber,_Subscription,_operators_refCount PURE_IMPORTS_END */
    var ConnectableObservable = /*@__PURE__*/ (function (_super) {
        __extends(ConnectableObservable, _super);
        function ConnectableObservable(source, subjectFactory) {
            var _this = _super.call(this) || this;
            _this.source = source;
            _this.subjectFactory = subjectFactory;
            _this._refCount = 0;
            _this._isComplete = false;
            return _this;
        }
        ConnectableObservable.prototype._subscribe = function (subscriber) {
            return this.getSubject().subscribe(subscriber);
        };
        ConnectableObservable.prototype.getSubject = function () {
            var subject = this._subject;
            if (!subject || subject.isStopped) {
                this._subject = this.subjectFactory();
            }
            return this._subject;
        };
        ConnectableObservable.prototype.connect = function () {
            var connection = this._connection;
            if (!connection) {
                this._isComplete = false;
                connection = this._connection = new Subscription();
                connection.add(this.source
                    .subscribe(new ConnectableSubscriber(this.getSubject(), this)));
                if (connection.closed) {
                    this._connection = null;
                    connection = Subscription.EMPTY;
                }
            }
            return connection;
        };
        ConnectableObservable.prototype.refCount = function () {
            return refCount()(this);
        };
        return ConnectableObservable;
    }(Observable));
    var connectableObservableDescriptor = /*@__PURE__*/ (function () {
        var connectableProto = ConnectableObservable.prototype;
        return {
            operator: { value: null },
            _refCount: { value: 0, writable: true },
            _subject: { value: null, writable: true },
            _connection: { value: null, writable: true },
            _subscribe: { value: connectableProto._subscribe },
            _isComplete: { value: connectableProto._isComplete, writable: true },
            getSubject: { value: connectableProto.getSubject },
            connect: { value: connectableProto.connect },
            refCount: { value: connectableProto.refCount }
        };
    })();
    var ConnectableSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(ConnectableSubscriber, _super);
        function ConnectableSubscriber(destination, connectable) {
            var _this = _super.call(this, destination) || this;
            _this.connectable = connectable;
            return _this;
        }
        ConnectableSubscriber.prototype._error = function (err) {
            this._unsubscribe();
            _super.prototype._error.call(this, err);
        };
        ConnectableSubscriber.prototype._complete = function () {
            this.connectable._isComplete = true;
            this._unsubscribe();
            _super.prototype._complete.call(this);
        };
        ConnectableSubscriber.prototype._unsubscribe = function () {
            var connectable = this.connectable;
            if (connectable) {
                this.connectable = null;
                var connection = connectable._connection;
                connectable._refCount = 0;
                connectable._subject = null;
                connectable._connection = null;
                if (connection) {
                    connection.unsubscribe();
                }
            }
        };
        return ConnectableSubscriber;
    }(SubjectSubscriber));

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */
    function isScheduler(value) {
        return value && typeof value.schedule === 'function';
    }

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */
    var subscribeToArray = function (array) {
        return function (subscriber) {
            for (var i = 0, len = array.length; i < len && !subscriber.closed; i++) {
                subscriber.next(array[i]);
            }
            subscriber.complete();
        };
    };

    /** PURE_IMPORTS_START _Observable,_Subscription PURE_IMPORTS_END */
    function scheduleArray(input, scheduler) {
        return new Observable(function (subscriber) {
            var sub = new Subscription();
            var i = 0;
            sub.add(scheduler.schedule(function () {
                if (i === input.length) {
                    subscriber.complete();
                    return;
                }
                subscriber.next(input[i++]);
                if (!subscriber.closed) {
                    sub.add(this.schedule());
                }
            }));
            return sub;
        });
    }

    /** PURE_IMPORTS_START _Observable,_util_subscribeToArray,_scheduled_scheduleArray PURE_IMPORTS_END */
    function fromArray(input, scheduler) {
        if (!scheduler) {
            return new Observable(subscribeToArray(input));
        }
        else {
            return scheduleArray(input, scheduler);
        }
    }

    /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
    function map(project, thisArg) {
        return function mapOperation(source) {
            if (typeof project !== 'function') {
                throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
            }
            return source.lift(new MapOperator(project, thisArg));
        };
    }
    var MapOperator = /*@__PURE__*/ (function () {
        function MapOperator(project, thisArg) {
            this.project = project;
            this.thisArg = thisArg;
        }
        MapOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
        };
        return MapOperator;
    }());
    var MapSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(MapSubscriber, _super);
        function MapSubscriber(destination, project, thisArg) {
            var _this = _super.call(this, destination) || this;
            _this.project = project;
            _this.count = 0;
            _this.thisArg = thisArg || _this;
            return _this;
        }
        MapSubscriber.prototype._next = function (value) {
            var result;
            try {
                result = this.project.call(this.thisArg, value, this.count++);
            }
            catch (err) {
                this.destination.error(err);
                return;
            }
            this.destination.next(result);
        };
        return MapSubscriber;
    }(Subscriber));

    /** PURE_IMPORTS_START _hostReportError PURE_IMPORTS_END */
    var subscribeToPromise = function (promise) {
        return function (subscriber) {
            promise.then(function (value) {
                if (!subscriber.closed) {
                    subscriber.next(value);
                    subscriber.complete();
                }
            }, function (err) { return subscriber.error(err); })
                .then(null, hostReportError);
            return subscriber;
        };
    };

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */
    function getSymbolIterator$1() {
        if (typeof Symbol !== 'function' || !Symbol.iterator) {
            return '@@iterator';
        }
        return Symbol.iterator;
    }
    var iterator = /*@__PURE__*/ getSymbolIterator$1();

    /** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */
    var subscribeToIterable = function (iterable) {
        return function (subscriber) {
            var iterator$1 = iterable[iterator]();
            do {
                var item = void 0;
                try {
                    item = iterator$1.next();
                }
                catch (err) {
                    subscriber.error(err);
                    return subscriber;
                }
                if (item.done) {
                    subscriber.complete();
                    break;
                }
                subscriber.next(item.value);
                if (subscriber.closed) {
                    break;
                }
            } while (true);
            if (typeof iterator$1.return === 'function') {
                subscriber.add(function () {
                    if (iterator$1.return) {
                        iterator$1.return();
                    }
                });
            }
            return subscriber;
        };
    };

    /** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */
    var subscribeToObservable = function (obj) {
        return function (subscriber) {
            var obs = obj[observable]();
            if (typeof obs.subscribe !== 'function') {
                throw new TypeError('Provided object does not correctly implement Symbol.observable');
            }
            else {
                return obs.subscribe(subscriber);
            }
        };
    };

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */
    var isArrayLike = (function (x) { return x && typeof x.length === 'number' && typeof x !== 'function'; });

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */
    function isPromise$2(value) {
        return !!value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
    }

    /** PURE_IMPORTS_START _subscribeToArray,_subscribeToPromise,_subscribeToIterable,_subscribeToObservable,_isArrayLike,_isPromise,_isObject,_symbol_iterator,_symbol_observable PURE_IMPORTS_END */
    var subscribeTo = function (result) {
        if (!!result && typeof result[observable] === 'function') {
            return subscribeToObservable(result);
        }
        else if (isArrayLike(result)) {
            return subscribeToArray(result);
        }
        else if (isPromise$2(result)) {
            return subscribeToPromise(result);
        }
        else if (!!result && typeof result[iterator] === 'function') {
            return subscribeToIterable(result);
        }
        else {
            var value = isObject(result) ? 'an invalid object' : "'" + result + "'";
            var msg = "You provided " + value + " where a stream was expected."
                + ' You can provide an Observable, Promise, Array, or Iterable.';
            throw new TypeError(msg);
        }
    };

    /** PURE_IMPORTS_START _Observable,_Subscription,_symbol_observable PURE_IMPORTS_END */
    function scheduleObservable(input, scheduler) {
        return new Observable(function (subscriber) {
            var sub = new Subscription();
            sub.add(scheduler.schedule(function () {
                var observable$1 = input[observable]();
                sub.add(observable$1.subscribe({
                    next: function (value) { sub.add(scheduler.schedule(function () { return subscriber.next(value); })); },
                    error: function (err) { sub.add(scheduler.schedule(function () { return subscriber.error(err); })); },
                    complete: function () { sub.add(scheduler.schedule(function () { return subscriber.complete(); })); },
                }));
            }));
            return sub;
        });
    }

    /** PURE_IMPORTS_START _Observable,_Subscription PURE_IMPORTS_END */
    function schedulePromise(input, scheduler) {
        return new Observable(function (subscriber) {
            var sub = new Subscription();
            sub.add(scheduler.schedule(function () {
                return input.then(function (value) {
                    sub.add(scheduler.schedule(function () {
                        subscriber.next(value);
                        sub.add(scheduler.schedule(function () { return subscriber.complete(); }));
                    }));
                }, function (err) {
                    sub.add(scheduler.schedule(function () { return subscriber.error(err); }));
                });
            }));
            return sub;
        });
    }

    /** PURE_IMPORTS_START _Observable,_Subscription,_symbol_iterator PURE_IMPORTS_END */
    function scheduleIterable(input, scheduler) {
        if (!input) {
            throw new Error('Iterable cannot be null');
        }
        return new Observable(function (subscriber) {
            var sub = new Subscription();
            var iterator$1;
            sub.add(function () {
                if (iterator$1 && typeof iterator$1.return === 'function') {
                    iterator$1.return();
                }
            });
            sub.add(scheduler.schedule(function () {
                iterator$1 = input[iterator]();
                sub.add(scheduler.schedule(function () {
                    if (subscriber.closed) {
                        return;
                    }
                    var value;
                    var done;
                    try {
                        var result = iterator$1.next();
                        value = result.value;
                        done = result.done;
                    }
                    catch (err) {
                        subscriber.error(err);
                        return;
                    }
                    if (done) {
                        subscriber.complete();
                    }
                    else {
                        subscriber.next(value);
                        this.schedule();
                    }
                }));
            }));
            return sub;
        });
    }

    /** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */
    function isInteropObservable(input) {
        return input && typeof input[observable] === 'function';
    }

    /** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */
    function isIterable(input) {
        return input && typeof input[iterator] === 'function';
    }

    /** PURE_IMPORTS_START _scheduleObservable,_schedulePromise,_scheduleArray,_scheduleIterable,_util_isInteropObservable,_util_isPromise,_util_isArrayLike,_util_isIterable PURE_IMPORTS_END */
    function scheduled(input, scheduler) {
        if (input != null) {
            if (isInteropObservable(input)) {
                return scheduleObservable(input, scheduler);
            }
            else if (isPromise$2(input)) {
                return schedulePromise(input, scheduler);
            }
            else if (isArrayLike(input)) {
                return scheduleArray(input, scheduler);
            }
            else if (isIterable(input) || typeof input === 'string') {
                return scheduleIterable(input, scheduler);
            }
        }
        throw new TypeError((input !== null && typeof input || input) + ' is not observable');
    }

    /** PURE_IMPORTS_START _Observable,_util_subscribeTo,_scheduled_scheduled PURE_IMPORTS_END */
    function from(input, scheduler) {
        if (!scheduler) {
            if (input instanceof Observable) {
                return input;
            }
            return new Observable(subscribeTo(input));
        }
        else {
            return scheduled(input, scheduler);
        }
    }

    /** PURE_IMPORTS_START tslib,_Subscriber,_Observable,_util_subscribeTo PURE_IMPORTS_END */
    var SimpleInnerSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(SimpleInnerSubscriber, _super);
        function SimpleInnerSubscriber(parent) {
            var _this = _super.call(this) || this;
            _this.parent = parent;
            return _this;
        }
        SimpleInnerSubscriber.prototype._next = function (value) {
            this.parent.notifyNext(value);
        };
        SimpleInnerSubscriber.prototype._error = function (error) {
            this.parent.notifyError(error);
            this.unsubscribe();
        };
        SimpleInnerSubscriber.prototype._complete = function () {
            this.parent.notifyComplete();
            this.unsubscribe();
        };
        return SimpleInnerSubscriber;
    }(Subscriber));
    var SimpleOuterSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(SimpleOuterSubscriber, _super);
        function SimpleOuterSubscriber() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        SimpleOuterSubscriber.prototype.notifyNext = function (innerValue) {
            this.destination.next(innerValue);
        };
        SimpleOuterSubscriber.prototype.notifyError = function (err) {
            this.destination.error(err);
        };
        SimpleOuterSubscriber.prototype.notifyComplete = function () {
            this.destination.complete();
        };
        return SimpleOuterSubscriber;
    }(Subscriber));
    function innerSubscribe(result, innerSubscriber) {
        if (innerSubscriber.closed) {
            return undefined;
        }
        if (result instanceof Observable) {
            return result.subscribe(innerSubscriber);
        }
        var subscription;
        try {
            subscription = subscribeTo(result)(innerSubscriber);
        }
        catch (error) {
            innerSubscriber.error(error);
        }
        return subscription;
    }

    /** PURE_IMPORTS_START tslib,_map,_observable_from,_innerSubscribe PURE_IMPORTS_END */
    function mergeMap(project, resultSelector, concurrent) {
        if (concurrent === void 0) {
            concurrent = Number.POSITIVE_INFINITY;
        }
        if (typeof resultSelector === 'function') {
            return function (source) { return source.pipe(mergeMap(function (a, i) { return from(project(a, i)).pipe(map(function (b, ii) { return resultSelector(a, b, i, ii); })); }, concurrent)); };
        }
        else if (typeof resultSelector === 'number') {
            concurrent = resultSelector;
        }
        return function (source) { return source.lift(new MergeMapOperator(project, concurrent)); };
    }
    var MergeMapOperator = /*@__PURE__*/ (function () {
        function MergeMapOperator(project, concurrent) {
            if (concurrent === void 0) {
                concurrent = Number.POSITIVE_INFINITY;
            }
            this.project = project;
            this.concurrent = concurrent;
        }
        MergeMapOperator.prototype.call = function (observer, source) {
            return source.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));
        };
        return MergeMapOperator;
    }());
    var MergeMapSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(MergeMapSubscriber, _super);
        function MergeMapSubscriber(destination, project, concurrent) {
            if (concurrent === void 0) {
                concurrent = Number.POSITIVE_INFINITY;
            }
            var _this = _super.call(this, destination) || this;
            _this.project = project;
            _this.concurrent = concurrent;
            _this.hasCompleted = false;
            _this.buffer = [];
            _this.active = 0;
            _this.index = 0;
            return _this;
        }
        MergeMapSubscriber.prototype._next = function (value) {
            if (this.active < this.concurrent) {
                this._tryNext(value);
            }
            else {
                this.buffer.push(value);
            }
        };
        MergeMapSubscriber.prototype._tryNext = function (value) {
            var result;
            var index = this.index++;
            try {
                result = this.project(value, index);
            }
            catch (err) {
                this.destination.error(err);
                return;
            }
            this.active++;
            this._innerSub(result);
        };
        MergeMapSubscriber.prototype._innerSub = function (ish) {
            var innerSubscriber = new SimpleInnerSubscriber(this);
            var destination = this.destination;
            destination.add(innerSubscriber);
            var innerSubscription = innerSubscribe(ish, innerSubscriber);
            if (innerSubscription !== innerSubscriber) {
                destination.add(innerSubscription);
            }
        };
        MergeMapSubscriber.prototype._complete = function () {
            this.hasCompleted = true;
            if (this.active === 0 && this.buffer.length === 0) {
                this.destination.complete();
            }
            this.unsubscribe();
        };
        MergeMapSubscriber.prototype.notifyNext = function (innerValue) {
            this.destination.next(innerValue);
        };
        MergeMapSubscriber.prototype.notifyComplete = function () {
            var buffer = this.buffer;
            this.active--;
            if (buffer.length > 0) {
                this._next(buffer.shift());
            }
            else if (this.active === 0 && this.hasCompleted) {
                this.destination.complete();
            }
        };
        return MergeMapSubscriber;
    }(SimpleOuterSubscriber));

    /** PURE_IMPORTS_START _mergeMap,_util_identity PURE_IMPORTS_END */
    function mergeAll(concurrent) {
        if (concurrent === void 0) {
            concurrent = Number.POSITIVE_INFINITY;
        }
        return mergeMap(identity, concurrent);
    }

    /** PURE_IMPORTS_START _Observable,_util_isScheduler,_operators_mergeAll,_fromArray PURE_IMPORTS_END */
    function merge$1() {
        var observables = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            observables[_i] = arguments[_i];
        }
        var concurrent = Number.POSITIVE_INFINITY;
        var scheduler = null;
        var last = observables[observables.length - 1];
        if (isScheduler(last)) {
            scheduler = observables.pop();
            if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {
                concurrent = observables.pop();
            }
        }
        else if (typeof last === 'number') {
            concurrent = observables.pop();
        }
        if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable) {
            return observables[0];
        }
        return mergeAll(concurrent)(fromArray(observables, scheduler));
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class EventEmitter_ extends Subject {
        constructor(isAsync = false) {
            super();
            this.__isAsync = isAsync;
        }
        emit(value) {
            super.next(value);
        }
        subscribe(observerOrNext, error, complete) {
            var _a, _b, _c;
            let nextFn = observerOrNext;
            let errorFn = error || (() => null);
            let completeFn = complete;
            if (observerOrNext && typeof observerOrNext === 'object') {
                const observer = observerOrNext;
                nextFn = (_a = observer.next) === null || _a === void 0 ? void 0 : _a.bind(observer);
                errorFn = (_b = observer.error) === null || _b === void 0 ? void 0 : _b.bind(observer);
                completeFn = (_c = observer.complete) === null || _c === void 0 ? void 0 : _c.bind(observer);
            }
            if (this.__isAsync) {
                errorFn = _wrapInTimeout(errorFn);
                if (nextFn) {
                    nextFn = _wrapInTimeout(nextFn);
                }
                if (completeFn) {
                    completeFn = _wrapInTimeout(completeFn);
                }
            }
            const sink = super.subscribe({ next: nextFn, error: errorFn, complete: completeFn });
            if (observerOrNext instanceof Subscription) {
                observerOrNext.add(sink);
            }
            return sink;
        }
    }
    function _wrapInTimeout(fn) {
        return (value) => {
            setTimeout(fn, undefined, value);
        };
    }
    /**
     * @publicApi
     */
    const EventEmitter = EventEmitter_;

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const Éµ0$9 = (dir = {}) => dir, Éµ1$1 = (type, meta) => SWITCH_COMPILE_DIRECTIVE(type, meta);
    /**
     * Type of the Directive metadata.
     *
     * @publicApi
     */
    const Directive = makeDecorator('Directive', Éµ0$9, undefined, undefined, Éµ1$1);
    const Éµ2$1 = (c = {}) => (Object.assign({ changeDetection: ChangeDetectionStrategy$1.Default }, c)), Éµ3$1 = (type, meta) => SWITCH_COMPILE_COMPONENT(type, meta);
    /**
     * Component decorator and metadata.
     *
     * @Annotation
     * @publicApi
     */
    const Component = makeDecorator('Component', Éµ2$1, Directive, undefined, Éµ3$1);
    const Éµ4 = (p) => (Object.assign({ pure: true }, p)), Éµ5 = (type, meta) => SWITCH_COMPILE_PIPE(type, meta);
    /**
     * @Annotation
     * @publicApi
     */
    const Pipe = makeDecorator('Pipe', Éµ4, undefined, undefined, Éµ5);
    const Éµ6 = (bindingPropertyName) => ({ bindingPropertyName });
    /**
     * @Annotation
     * @publicApi
     */
    const Input = makePropDecorator('Input', Éµ6);
    const Éµ7 = (bindingPropertyName) => ({ bindingPropertyName });
    /**
     * @Annotation
     * @publicApi
     */
    const Output = makePropDecorator('Output', Éµ7);
    const Éµ8 = (hostPropertyName) => ({ hostPropertyName });
    /**
     * @Annotation
     * @publicApi
     */
    const HostBinding = makePropDecorator('HostBinding', Éµ8);
    const Éµ9 = (eventName, args) => ({ eventName, args });
    /**
     * Decorator that binds a DOM event to a host listener and supplies configuration metadata.
     * Angular invokes the supplied handler method when the host element emits the specified event,
     * and updates the bound element with the result.
     *
     * If the handler method returns false, applies `preventDefault` on the bound element.
     *
     * @usageNotes
     *
     * The following example declares a directive
     * that attaches a click listener to a button and counts clicks.
     *
     * ```ts
     * @Directive({selector: 'button[counting]'})
     * class CountClicks {
     *   numberOfClicks = 0;
     *
     *   @HostListener('click', ['$event.target'])
     *   onClick(btn) {
     *     console.log('button', btn, 'number of clicks:', this.numberOfClicks++);
     *  }
     * }
     *
     * @Component({
     *   selector: 'app',
     *   template: '<button counting>Increment</button>',
     * })
     * class App {}
     *
     * ```
     *
     * The following example registers another DOM event handler that listens for key-press events.
     * ``` ts
     * import { HostListener, Component } from "@angular/core";
     *
     * @Component({
     *   selector: 'app',
     *   template: `<h1>Hello, you have pressed keys {{counter}} number of times!</h1> Press any key to
     * increment the counter.
     *   <button (click)="resetCounter()">Reset Counter</button>`
     * })
     * class AppComponent {
     *   counter = 0;
     *   @HostListener('window:keydown', ['$event'])
     *   handleKeyDown(event: KeyboardEvent) {
     *     this.counter++;
     *   }
     *   resetCounter() {
     *     this.counter = 0;
     *   }
     * }
     * ```
     *
     * @Annotation
     * @publicApi
     */
    const HostListener = makePropDecorator('HostListener', Éµ9);
    const SWITCH_COMPILE_COMPONENT__PRE_R3__ = noop;
    const SWITCH_COMPILE_DIRECTIVE__PRE_R3__ = noop;
    const SWITCH_COMPILE_PIPE__PRE_R3__ = noop;
    const SWITCH_COMPILE_COMPONENT = SWITCH_COMPILE_COMPONENT__PRE_R3__;
    const SWITCH_COMPILE_DIRECTIVE = SWITCH_COMPILE_DIRECTIVE__PRE_R3__;
    const SWITCH_COMPILE_PIPE = SWITCH_COMPILE_PIPE__PRE_R3__;

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const Éµ0$a = (ngModule) => ngModule, Éµ1$2 = 
    /**
     * Decorator that marks the following class as an NgModule, and supplies
     * configuration metadata for it.
     *
     * * The `declarations` and `entryComponents` options configure the compiler
     * with information about what belongs to the NgModule.
     * * The `providers` options configures the NgModule's injector to provide
     * dependencies the NgModule members.
     * * The `imports` and `exports` options bring in members from other modules, and make
     * this module's members available to others.
     */
    (type, meta) => SWITCH_COMPILE_NGMODULE(type, meta);
    /**
     * @Annotation
     * @publicApi
     */
    const NgModule = makeDecorator('NgModule', Éµ0$a, undefined, undefined, Éµ1$2);
    function preR3NgModuleCompile(moduleType, metadata) {
        let imports = (metadata && metadata.imports) || [];
        if (metadata && metadata.exports) {
            imports = [...imports, metadata.exports];
        }
        const moduleInjectorType = moduleType;
        moduleInjectorType.Éµfac = convertInjectableProviderToFactory(moduleType, { useClass: moduleType });
        moduleInjectorType.Éµinj =
            ÉµÉµdefineInjector({ providers: metadata && metadata.providers, imports: imports });
    }
    const SWITCH_COMPILE_NGMODULE__PRE_R3__ = preR3NgModuleCompile;
    const SWITCH_COMPILE_NGMODULE = SWITCH_COMPILE_NGMODULE__PRE_R3__;

    /** PURE_IMPORTS_START _observable_ConnectableObservable PURE_IMPORTS_END */
    function multicast(subjectOrSubjectFactory, selector) {
        return function multicastOperatorFunction(source) {
            var subjectFactory;
            if (typeof subjectOrSubjectFactory === 'function') {
                subjectFactory = subjectOrSubjectFactory;
            }
            else {
                subjectFactory = function subjectFactory() {
                    return subjectOrSubjectFactory;
                };
            }
            if (typeof selector === 'function') {
                return source.lift(new MulticastOperator(subjectFactory, selector));
            }
            var connectable = Object.create(source, connectableObservableDescriptor);
            connectable.source = source;
            connectable.subjectFactory = subjectFactory;
            return connectable;
        };
    }
    var MulticastOperator = /*@__PURE__*/ (function () {
        function MulticastOperator(subjectFactory, selector) {
            this.subjectFactory = subjectFactory;
            this.selector = selector;
        }
        MulticastOperator.prototype.call = function (subscriber, source) {
            var selector = this.selector;
            var subject = this.subjectFactory();
            var subscription = selector(subject).subscribe(subscriber);
            subscription.add(source.subscribe(subject));
            return subscription;
        };
        return MulticastOperator;
    }());

    /** PURE_IMPORTS_START _multicast,_refCount,_Subject PURE_IMPORTS_END */
    function shareSubjectFactory() {
        return new Subject();
    }
    function share() {
        return function (source) { return refCount()(multicast(shareSubjectFactory)(source)); };
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A [DI token](guide/glossary#di-token "DI token definition") that you can use to provide
     * one or more initialization functions.
     *
     * The provided functions are injected at application startup and executed during
     * app initialization. If any of these functions returns a Promise or an Observable, initialization
     * does not complete until the Promise is resolved or the Observable is completed.
     *
     * You can, for example, create a factory function that loads language data
     * or an external configuration, and provide that function to the `APP_INITIALIZER` token.
     * The function is executed during the application bootstrap process,
     * and the needed data is available on startup.
     *
     * @see `ApplicationInitStatus`
     *
     * @usageNotes
     *
     * The following example illustrates how to configure a multi-provider using `APP_INITIALIZER` token
     * and a function returning a promise.
     *
     * ```
     *  function initializeApp(): Promise<any> {
     *    return new Promise((resolve, reject) => {
     *      // Do some asynchronous stuff
     *      resolve();
     *    });
     *  }
     *
     *  @NgModule({
     *   imports: [BrowserModule],
     *   declarations: [AppComponent],
     *   bootstrap: [AppComponent],
     *   providers: [{
     *     provide: APP_INITIALIZER,
     *     useFactory: () => initializeApp,
     *     multi: true
     *    }]
     *   })
     *  export class AppModule {}
     * ```
     *
     * It's also possible to configure a multi-provider using `APP_INITIALIZER` token and a function
     * returning an observable, see an example below. Note: the `HttpClient` in this example is used for
     * demo purposes to illustrate how the factory function can work with other providers available
     * through DI.
     *
     * ```
     *  function initializeAppFactory(httpClient: HttpClient): () => Observable<any> {
     *   return () => httpClient.get("https://someUrl.com/api/user")
     *     .pipe(
     *        tap(user => { ... })
     *     );
     *  }
     *
     *  @NgModule({
     *    imports: [BrowserModule, HttpClientModule],
     *    declarations: [AppComponent],
     *    bootstrap: [AppComponent],
     *    providers: [{
     *      provide: APP_INITIALIZER,
     *      useFactory: initializeAppFactory,
     *      deps: [HttpClient],
     *      multi: true
     *    }]
     *  })
     *  export class AppModule {}
     * ```
     *
     * @publicApi
     */
    const APP_INITIALIZER = new InjectionToken('Application Initializer');
    /**
     * A class that reflects the state of running {@link APP_INITIALIZER} functions.
     *
     * @publicApi
     */
    class ApplicationInitStatus {
        constructor(appInits) {
            this.appInits = appInits;
            this.resolve = noop;
            this.reject = noop;
            this.initialized = false;
            this.done = false;
            this.donePromise = new Promise((res, rej) => {
                this.resolve = res;
                this.reject = rej;
            });
        }
        /** @internal */
        runInitializers() {
            if (this.initialized) {
                return;
            }
            const asyncInitPromises = [];
            const complete = () => {
                this.done = true;
                this.resolve();
            };
            if (this.appInits) {
                for (let i = 0; i < this.appInits.length; i++) {
                    const initResult = this.appInits[i]();
                    if (isPromise$1(initResult)) {
                        asyncInitPromises.push(initResult);
                    }
                    else if (isObservable(initResult)) {
                        const observableAsPromise = new Promise((resolve, reject) => {
                            initResult.subscribe({ complete: resolve, error: reject });
                        });
                        asyncInitPromises.push(observableAsPromise);
                    }
                }
            }
            Promise.all(asyncInitPromises)
                .then(() => {
                complete();
            })
                .catch(e => {
                this.reject(e);
            });
            if (asyncInitPromises.length === 0) {
                complete();
            }
            this.initialized = true;
        }
    }
    ApplicationInitStatus.decorators = [
        { type: Injectable }
    ];
    ApplicationInitStatus.ctorParameters = () => [
        { type: undefined, decorators: [{ type: Inject, args: [APP_INITIALIZER,] }, { type: Optional }] }
    ];

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A [DI token](guide/glossary#di-token "DI token definition") representing a unique string ID, used
     * primarily for prefixing application attributes and CSS styles when
     * {@link ViewEncapsulation#Emulated ViewEncapsulation.Emulated} is being used.
     *
     * BY default, the value is randomly generated and assigned to the application by Angular.
     * To provide a custom ID value, use a DI provider <!-- TODO: provider --> to configure
     * the root {@link Injector} that uses this token.
     *
     * @publicApi
     */
    const APP_ID = new InjectionToken('AppId');
    function _appIdRandomProviderFactory() {
        return `${_randomChar()}${_randomChar()}${_randomChar()}`;
    }
    /**
     * Providers that generate a random `APP_ID_TOKEN`.
     * @publicApi
     */
    const APP_ID_RANDOM_PROVIDER = {
        provide: APP_ID,
        useFactory: _appIdRandomProviderFactory,
        deps: [],
    };
    function _randomChar() {
        return String.fromCharCode(97 + Math.floor(Math.random() * 25));
    }
    /**
     * A function that is executed when a platform is initialized.
     * @publicApi
     */
    const PLATFORM_INITIALIZER = new InjectionToken('Platform Initializer');
    /**
     * A token that indicates an opaque platform ID.
     * @publicApi
     */
    const PLATFORM_ID = new InjectionToken('Platform ID');
    /**
     * A [DI token](guide/glossary#di-token "DI token definition") that provides a set of callbacks to
     * be called for every component that is bootstrapped.
     *
     * Each callback must take a `ComponentRef` instance and return nothing.
     *
     * `(componentRef: ComponentRef) => void`
     *
     * @publicApi
     */
    const APP_BOOTSTRAP_LISTENER = new InjectionToken('appBootstrapListener');
    /**
     * A [DI token](guide/glossary#di-token "DI token definition") that indicates the root directory of
     * the application
     * @publicApi
     */
    const PACKAGE_ROOT_URL = new InjectionToken('Application Packages Root URL');

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class Console {
        log(message) {
            // tslint:disable-next-line:no-console
            console.log(message);
        }
        // Note: for reporting errors use `DOM.logError()` as it is platform specific
        warn(message) {
            // tslint:disable-next-line:no-console
            console.warn(message);
        }
    }
    Console.decorators = [
        { type: Injectable }
    ];

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Provide this token to set the locale of your application.
     * It is used for i18n extraction, by i18n pipes (DatePipe, I18nPluralPipe, CurrencyPipe,
     * DecimalPipe and PercentPipe) and by ICU expressions.
     *
     * See the [i18n guide](guide/i18n-common-locale-id) for more information.
     *
     * @usageNotes
     * ### Example
     *
     * ```typescript
     * import { LOCALE_ID } from '@angular/core';
     * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
     * import { AppModule } from './app/app.module';
     *
     * platformBrowserDynamic().bootstrapModule(AppModule, {
     *   providers: [{provide: LOCALE_ID, useValue: 'en-US' }]
     * });
     * ```
     *
     * @publicApi
     */
    const LOCALE_ID$1 = new InjectionToken('LocaleId');
    /**
     * Provide this token to set the default currency code your application uses for
     * CurrencyPipe when there is no currency code passed into it. This is only used by
     * CurrencyPipe and has no relation to locale currency. Defaults to USD if not configured.
     *
     * See the [i18n guide](guide/i18n-common-locale-id) for more information.
     *
     * <div class="alert is-helpful">
     *
     * **Deprecation notice:**
     *
     * The default currency code is currently always `USD` but this is deprecated from v9.
     *
     * **In v10 the default currency code will be taken from the current locale.**
     *
     * If you need the previous behavior then set it by creating a `DEFAULT_CURRENCY_CODE` provider in
     * your application `NgModule`:
     *
     * ```ts
     * {provide: DEFAULT_CURRENCY_CODE, useValue: 'USD'}
     * ```
     *
     * </div>
     *
     * @usageNotes
     * ### Example
     *
     * ```typescript
     * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
     * import { AppModule } from './app/app.module';
     *
     * platformBrowserDynamic().bootstrapModule(AppModule, {
     *   providers: [{provide: DEFAULT_CURRENCY_CODE, useValue: 'EUR' }]
     * });
     * ```
     *
     * @publicApi
     */
    const DEFAULT_CURRENCY_CODE = new InjectionToken('DefaultCurrencyCode');
    /**
     * Use this token at bootstrap to provide the content of your translation file (`xtb`,
     * `xlf` or `xlf2`) when you want to translate your application in another language.
     *
     * See the [i18n guide](guide/i18n-common-merge) for more information.
     *
     * @usageNotes
     * ### Example
     *
     * ```typescript
     * import { TRANSLATIONS } from '@angular/core';
     * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
     * import { AppModule } from './app/app.module';
     *
     * // content of your translation file
     * const translations = '....';
     *
     * platformBrowserDynamic().bootstrapModule(AppModule, {
     *   providers: [{provide: TRANSLATIONS, useValue: translations }]
     * });
     * ```
     *
     * @publicApi
     */
    const TRANSLATIONS = new InjectionToken('Translations');
    /**
     * Provide this token at bootstrap to set the format of your {@link TRANSLATIONS}: `xtb`,
     * `xlf` or `xlf2`.
     *
     * See the [i18n guide](guide/i18n-common-merge) for more information.
     *
     * @usageNotes
     * ### Example
     *
     * ```typescript
     * import { TRANSLATIONS_FORMAT } from '@angular/core';
     * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
     * import { AppModule } from './app/app.module';
     *
     * platformBrowserDynamic().bootstrapModule(AppModule, {
     *   providers: [{provide: TRANSLATIONS_FORMAT, useValue: 'xlf' }]
     * });
     * ```
     *
     * @publicApi
     */
    const TRANSLATIONS_FORMAT = new InjectionToken('TranslationsFormat');
    /**
     * Use this enum at bootstrap as an option of `bootstrapModule` to define the strategy
     * that the compiler should use in case of missing translations:
     * - Error: throw if you have missing translations.
     * - Warning (default): show a warning in the console and/or shell.
     * - Ignore: do nothing.
     *
     * See the [i18n guide](guide/i18n-common-merge#report-missing-translations) for more information.
     *
     * @usageNotes
     * ### Example
     * ```typescript
     * import { MissingTranslationStrategy } from '@angular/core';
     * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
     * import { AppModule } from './app/app.module';
     *
     * platformBrowserDynamic().bootstrapModule(AppModule, {
     *   missingTranslation: MissingTranslationStrategy.Error
     * });
     * ```
     *
     * @publicApi
     */
    var MissingTranslationStrategy$1;
    (function (MissingTranslationStrategy) {
        MissingTranslationStrategy[MissingTranslationStrategy["Error"] = 0] = "Error";
        MissingTranslationStrategy[MissingTranslationStrategy["Warning"] = 1] = "Warning";
        MissingTranslationStrategy[MissingTranslationStrategy["Ignore"] = 2] = "Ignore";
    })(MissingTranslationStrategy$1 || (MissingTranslationStrategy$1 = {}));

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const SWITCH_IVY_ENABLED__PRE_R3__ = false;
    const ivyEnabled = SWITCH_IVY_ENABLED__PRE_R3__;

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function _throwError() {
        throw new Error(`Runtime compiler is not loaded`);
    }
    const Compiler_compileModuleSync__PRE_R3__ = _throwError;
    const Compiler_compileModuleSync = Compiler_compileModuleSync__PRE_R3__;
    const Compiler_compileModuleAsync__PRE_R3__ = _throwError;
    const Compiler_compileModuleAsync = Compiler_compileModuleAsync__PRE_R3__;
    const Compiler_compileModuleAndAllComponentsSync__PRE_R3__ = _throwError;
    const Compiler_compileModuleAndAllComponentsSync = Compiler_compileModuleAndAllComponentsSync__PRE_R3__;
    const Compiler_compileModuleAndAllComponentsAsync__PRE_R3__ = _throwError;
    const Compiler_compileModuleAndAllComponentsAsync = Compiler_compileModuleAndAllComponentsAsync__PRE_R3__;
    /**
     * Low-level service for running the angular compiler during runtime
     * to create {@link ComponentFactory}s, which
     * can later be used to create and render a Component instance.
     *
     * Each `@NgModule` provides an own `Compiler` to its injector,
     * that will use the directives/pipes of the ng module for compilation
     * of components.
     *
     * @publicApi
     */
    class Compiler {
        constructor() {
            /**
             * Compiles the given NgModule and all of its components. All templates of the components listed
             * in `entryComponents` have to be inlined.
             */
            this.compileModuleSync = Compiler_compileModuleSync;
            /**
             * Compiles the given NgModule and all of its components
             */
            this.compileModuleAsync = Compiler_compileModuleAsync;
            /**
             * Same as {@link #compileModuleSync} but also creates ComponentFactories for all components.
             */
            this.compileModuleAndAllComponentsSync = Compiler_compileModuleAndAllComponentsSync;
            /**
             * Same as {@link #compileModuleAsync} but also creates ComponentFactories for all components.
             */
            this.compileModuleAndAllComponentsAsync = Compiler_compileModuleAndAllComponentsAsync;
        }
        /**
         * Clears all caches.
         */
        clearCache() { }
        /**
         * Clears the cache for the given component/ngModule.
         */
        clearCacheFor(type) { }
        /**
         * Returns the id for a given NgModule, if one is defined and known to the compiler.
         */
        getModuleId(moduleType) {
            return undefined;
        }
    }
    Compiler.decorators = [
        { type: Injectable }
    ];
    /**
     * Token to provide CompilerOptions in the platform injector.
     *
     * @publicApi
     */
    const COMPILER_OPTIONS = new InjectionToken('compilerOptions');
    /**
     * A factory for creating a Compiler
     *
     * @publicApi
     */
    class CompilerFactory {
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const promise = (() => Promise.resolve(0))();
    function scheduleMicroTask(fn) {
        if (typeof Zone === 'undefined') {
            // use promise to schedule microTask instead of use Zone
            promise.then(() => {
                fn && fn.apply(null, null);
            });
        }
        else {
            Zone.current.scheduleMicroTask('scheduleMicrotask', fn);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function getNativeRequestAnimationFrame() {
        let nativeRequestAnimationFrame = _global$1['requestAnimationFrame'];
        let nativeCancelAnimationFrame = _global$1['cancelAnimationFrame'];
        if (typeof Zone !== 'undefined' && nativeRequestAnimationFrame && nativeCancelAnimationFrame) {
            // use unpatched version of requestAnimationFrame(native delegate) if possible
            // to avoid another Change detection
            const unpatchedRequestAnimationFrame = nativeRequestAnimationFrame[Zone.__symbol__('OriginalDelegate')];
            if (unpatchedRequestAnimationFrame) {
                nativeRequestAnimationFrame = unpatchedRequestAnimationFrame;
            }
            const unpatchedCancelAnimationFrame = nativeCancelAnimationFrame[Zone.__symbol__('OriginalDelegate')];
            if (unpatchedCancelAnimationFrame) {
                nativeCancelAnimationFrame = unpatchedCancelAnimationFrame;
            }
        }
        return { nativeRequestAnimationFrame, nativeCancelAnimationFrame };
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * An injectable service for executing work inside or outside of the Angular zone.
     *
     * The most common use of this service is to optimize performance when starting a work consisting of
     * one or more asynchronous tasks that don't require UI updates or error handling to be handled by
     * Angular. Such tasks can be kicked off via {@link #runOutsideAngular} and if needed, these tasks
     * can reenter the Angular zone via {@link #run}.
     *
     * <!-- TODO: add/fix links to:
     *   - docs explaining zones and the use of zones in Angular and change-detection
     *   - link to runOutsideAngular/run (throughout this file!)
     *   -->
     *
     * @usageNotes
     * ### Example
     *
     * ```
     * import {Component, NgZone} from '@angular/core';
     * import {NgIf} from '@angular/common';
     *
     * @Component({
     *   selector: 'ng-zone-demo',
     *   template: `
     *     <h2>Demo: NgZone</h2>
     *
     *     <p>Progress: {{progress}}%</p>
     *     <p *ngIf="progress >= 100">Done processing {{label}} of Angular zone!</p>
     *
     *     <button (click)="processWithinAngularZone()">Process within Angular zone</button>
     *     <button (click)="processOutsideOfAngularZone()">Process outside of Angular zone</button>
     *   `,
     * })
     * export class NgZoneDemo {
     *   progress: number = 0;
     *   label: string;
     *
     *   constructor(private _ngZone: NgZone) {}
     *
     *   // Loop inside the Angular zone
     *   // so the UI DOES refresh after each setTimeout cycle
     *   processWithinAngularZone() {
     *     this.label = 'inside';
     *     this.progress = 0;
     *     this._increaseProgress(() => console.log('Inside Done!'));
     *   }
     *
     *   // Loop outside of the Angular zone
     *   // so the UI DOES NOT refresh after each setTimeout cycle
     *   processOutsideOfAngularZone() {
     *     this.label = 'outside';
     *     this.progress = 0;
     *     this._ngZone.runOutsideAngular(() => {
     *       this._increaseProgress(() => {
     *         // reenter the Angular zone and display done
     *         this._ngZone.run(() => { console.log('Outside Done!'); });
     *       });
     *     });
     *   }
     *
     *   _increaseProgress(doneCallback: () => void) {
     *     this.progress += 1;
     *     console.log(`Current progress: ${this.progress}%`);
     *
     *     if (this.progress < 100) {
     *       window.setTimeout(() => this._increaseProgress(doneCallback), 10);
     *     } else {
     *       doneCallback();
     *     }
     *   }
     * }
     * ```
     *
     * @publicApi
     */
    class NgZone {
        constructor({ enableLongStackTrace = false, shouldCoalesceEventChangeDetection = false, shouldCoalesceRunChangeDetection = false }) {
            this.hasPendingMacrotasks = false;
            this.hasPendingMicrotasks = false;
            /**
             * Whether there are no outstanding microtasks or macrotasks.
             */
            this.isStable = true;
            /**
             * Notifies when code enters Angular Zone. This gets fired first on VM Turn.
             */
            this.onUnstable = new EventEmitter(false);
            /**
             * Notifies when there is no more microtasks enqueued in the current VM Turn.
             * This is a hint for Angular to do change detection, which may enqueue more microtasks.
             * For this reason this event can fire multiple times per VM Turn.
             */
            this.onMicrotaskEmpty = new EventEmitter(false);
            /**
             * Notifies when the last `onMicrotaskEmpty` has run and there are no more microtasks, which
             * implies we are about to relinquish VM turn.
             * This event gets called just once.
             */
            this.onStable = new EventEmitter(false);
            /**
             * Notifies that an error has been delivered.
             */
            this.onError = new EventEmitter(false);
            if (typeof Zone == 'undefined') {
                throw new Error(`In this configuration Angular requires Zone.js`);
            }
            Zone.assertZonePatched();
            const self = this;
            self._nesting = 0;
            self._outer = self._inner = Zone.current;
            if (Zone['TaskTrackingZoneSpec']) {
                self._inner = self._inner.fork(new Zone['TaskTrackingZoneSpec']);
            }
            if (enableLongStackTrace && Zone['longStackTraceZoneSpec']) {
                self._inner = self._inner.fork(Zone['longStackTraceZoneSpec']);
            }
            // if shouldCoalesceRunChangeDetection is true, all tasks including event tasks will be
            // coalesced, so shouldCoalesceEventChangeDetection option is not necessary and can be skipped.
            self.shouldCoalesceEventChangeDetection =
                !shouldCoalesceRunChangeDetection && shouldCoalesceEventChangeDetection;
            self.shouldCoalesceRunChangeDetection = shouldCoalesceRunChangeDetection;
            self.lastRequestAnimationFrameId = -1;
            self.nativeRequestAnimationFrame = getNativeRequestAnimationFrame().nativeRequestAnimationFrame;
            forkInnerZoneWithAngularBehavior(self);
        }
        static isInAngularZone() {
            return Zone.current.get('isAngularZone') === true;
        }
        static assertInAngularZone() {
            if (!NgZone.isInAngularZone()) {
                throw new Error('Expected to be in Angular Zone, but it is not!');
            }
        }
        static assertNotInAngularZone() {
            if (NgZone.isInAngularZone()) {
                throw new Error('Expected to not be in Angular Zone, but it is!');
            }
        }
        /**
         * Executes the `fn` function synchronously within the Angular zone and returns value returned by
         * the function.
         *
         * Running functions via `run` allows you to reenter Angular zone from a task that was executed
         * outside of the Angular zone (typically started via {@link #runOutsideAngular}).
         *
         * Any future tasks or microtasks scheduled from within this function will continue executing from
         * within the Angular zone.
         *
         * If a synchronous error happens it will be rethrown and not reported via `onError`.
         */
        run(fn, applyThis, applyArgs) {
            return this._inner.run(fn, applyThis, applyArgs);
        }
        /**
         * Executes the `fn` function synchronously within the Angular zone as a task and returns value
         * returned by the function.
         *
         * Running functions via `run` allows you to reenter Angular zone from a task that was executed
         * outside of the Angular zone (typically started via {@link #runOutsideAngular}).
         *
         * Any future tasks or microtasks scheduled from within this function will continue executing from
         * within the Angular zone.
         *
         * If a synchronous error happens it will be rethrown and not reported via `onError`.
         */
        runTask(fn, applyThis, applyArgs, name) {
            const zone = this._inner;
            const task = zone.scheduleEventTask('NgZoneEvent: ' + name, fn, EMPTY_PAYLOAD, noop, noop);
            try {
                return zone.runTask(task, applyThis, applyArgs);
            }
            finally {
                zone.cancelTask(task);
            }
        }
        /**
         * Same as `run`, except that synchronous errors are caught and forwarded via `onError` and not
         * rethrown.
         */
        runGuarded(fn, applyThis, applyArgs) {
            return this._inner.runGuarded(fn, applyThis, applyArgs);
        }
        /**
         * Executes the `fn` function synchronously in Angular's parent zone and returns value returned by
         * the function.
         *
         * Running functions via {@link #runOutsideAngular} allows you to escape Angular's zone and do
         * work that
         * doesn't trigger Angular change-detection or is subject to Angular's error handling.
         *
         * Any future tasks or microtasks scheduled from within this function will continue executing from
         * outside of the Angular zone.
         *
         * Use {@link #run} to reenter the Angular zone and do work that updates the application model.
         */
        runOutsideAngular(fn) {
            return this._outer.run(fn);
        }
    }
    const EMPTY_PAYLOAD = {};
    function checkStable(zone) {
        // TODO: @JiaLiPassion, should check zone.isCheckStableRunning to prevent
        // re-entry. The case is:
        //
        // @Component({...})
        // export class AppComponent {
        // constructor(private ngZone: NgZone) {
        //   this.ngZone.onStable.subscribe(() => {
        //     this.ngZone.run(() => console.log('stable'););
        //   });
        // }
        //
        // The onStable subscriber run another function inside ngZone
        // which causes `checkStable()` re-entry.
        // But this fix causes some issues in g3, so this fix will be
        // launched in another PR.
        if (zone._nesting == 0 && !zone.hasPendingMicrotasks && !zone.isStable) {
            try {
                zone._nesting++;
                zone.onMicrotaskEmpty.emit(null);
            }
            finally {
                zone._nesting--;
                if (!zone.hasPendingMicrotasks) {
                    try {
                        zone.runOutsideAngular(() => zone.onStable.emit(null));
                    }
                    finally {
                        zone.isStable = true;
                    }
                }
            }
        }
    }
    function delayChangeDetectionForEvents(zone) {
        /**
         * We also need to check _nesting here
         * Consider the following case with shouldCoalesceRunChangeDetection = true
         *
         * ngZone.run(() => {});
         * ngZone.run(() => {});
         *
         * We want the two `ngZone.run()` only trigger one change detection
         * when shouldCoalesceRunChangeDetection is true.
         * And because in this case, change detection run in async way(requestAnimationFrame),
         * so we also need to check the _nesting here to prevent multiple
         * change detections.
         */
        if (zone.isCheckStableRunning || zone.lastRequestAnimationFrameId !== -1) {
            return;
        }
        zone.lastRequestAnimationFrameId = zone.nativeRequestAnimationFrame.call(_global$1, () => {
            // This is a work around for https://github.com/angular/angular/issues/36839.
            // The core issue is that when event coalescing is enabled it is possible for microtasks
            // to get flushed too early (As is the case with `Promise.then`) between the
            // coalescing eventTasks.
            //
            // To workaround this we schedule a "fake" eventTask before we process the
            // coalescing eventTasks. The benefit of this is that the "fake" container eventTask
            //  will prevent the microtasks queue from getting drained in between the coalescing
            // eventTask execution.
            if (!zone.fakeTopEventTask) {
                zone.fakeTopEventTask = Zone.root.scheduleEventTask('fakeTopEventTask', () => {
                    zone.lastRequestAnimationFrameId = -1;
                    updateMicroTaskStatus(zone);
                    zone.isCheckStableRunning = true;
                    checkStable(zone);
                    zone.isCheckStableRunning = false;
                }, undefined, () => { }, () => { });
            }
            zone.fakeTopEventTask.invoke();
        });
        updateMicroTaskStatus(zone);
    }
    function forkInnerZoneWithAngularBehavior(zone) {
        const delayChangeDetectionForEventsDelegate = () => {
            delayChangeDetectionForEvents(zone);
        };
        zone._inner = zone._inner.fork({
            name: 'angular',
            properties: { 'isAngularZone': true },
            onInvokeTask: (delegate, current, target, task, applyThis, applyArgs) => {
                try {
                    onEnter(zone);
                    return delegate.invokeTask(target, task, applyThis, applyArgs);
                }
                finally {
                    if ((zone.shouldCoalesceEventChangeDetection && task.type === 'eventTask') ||
                        zone.shouldCoalesceRunChangeDetection) {
                        delayChangeDetectionForEventsDelegate();
                    }
                    onLeave(zone);
                }
            },
            onInvoke: (delegate, current, target, callback, applyThis, applyArgs, source) => {
                try {
                    onEnter(zone);
                    return delegate.invoke(target, callback, applyThis, applyArgs, source);
                }
                finally {
                    if (zone.shouldCoalesceRunChangeDetection) {
                        delayChangeDetectionForEventsDelegate();
                    }
                    onLeave(zone);
                }
            },
            onHasTask: (delegate, current, target, hasTaskState) => {
                delegate.hasTask(target, hasTaskState);
                if (current === target) {
                    // We are only interested in hasTask events which originate from our zone
                    // (A child hasTask event is not interesting to us)
                    if (hasTaskState.change == 'microTask') {
                        zone._hasPendingMicrotasks = hasTaskState.microTask;
                        updateMicroTaskStatus(zone);
                        checkStable(zone);
                    }
                    else if (hasTaskState.change == 'macroTask') {
                        zone.hasPendingMacrotasks = hasTaskState.macroTask;
                    }
                }
            },
            onHandleError: (delegate, current, target, error) => {
                delegate.handleError(target, error);
                zone.runOutsideAngular(() => zone.onError.emit(error));
                return false;
            }
        });
    }
    function updateMicroTaskStatus(zone) {
        if (zone._hasPendingMicrotasks ||
            ((zone.shouldCoalesceEventChangeDetection || zone.shouldCoalesceRunChangeDetection) &&
                zone.lastRequestAnimationFrameId !== -1)) {
            zone.hasPendingMicrotasks = true;
        }
        else {
            zone.hasPendingMicrotasks = false;
        }
    }
    function onEnter(zone) {
        zone._nesting++;
        if (zone.isStable) {
            zone.isStable = false;
            zone.onUnstable.emit(null);
        }
    }
    function onLeave(zone) {
        zone._nesting--;
        checkStable(zone);
    }
    /**
     * Provides a noop implementation of `NgZone` which does nothing. This zone requires explicit calls
     * to framework to perform rendering.
     */
    class NoopNgZone {
        constructor() {
            this.hasPendingMicrotasks = false;
            this.hasPendingMacrotasks = false;
            this.isStable = true;
            this.onUnstable = new EventEmitter();
            this.onMicrotaskEmpty = new EventEmitter();
            this.onStable = new EventEmitter();
            this.onError = new EventEmitter();
        }
        run(fn, applyThis, applyArgs) {
            return fn.apply(applyThis, applyArgs);
        }
        runGuarded(fn, applyThis, applyArgs) {
            return fn.apply(applyThis, applyArgs);
        }
        runOutsideAngular(fn) {
            return fn();
        }
        runTask(fn, applyThis, applyArgs, name) {
            return fn.apply(applyThis, applyArgs);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * The Testability service provides testing hooks that can be accessed from
     * the browser. Each bootstrapped Angular application on the page will have
     * an instance of Testability.
     * @publicApi
     */
    class Testability {
        constructor(_ngZone) {
            this._ngZone = _ngZone;
            this._pendingCount = 0;
            this._isZoneStable = true;
            /**
             * Whether any work was done since the last 'whenStable' callback. This is
             * useful to detect if this could have potentially destabilized another
             * component while it is stabilizing.
             * @internal
             */
            this._didWork = false;
            this._callbacks = [];
            this.taskTrackingZone = null;
            this._watchAngularEvents();
            _ngZone.run(() => {
                this.taskTrackingZone =
                    typeof Zone == 'undefined' ? null : Zone.current.get('TaskTrackingZone');
            });
        }
        _watchAngularEvents() {
            this._ngZone.onUnstable.subscribe({
                next: () => {
                    this._didWork = true;
                    this._isZoneStable = false;
                }
            });
            this._ngZone.runOutsideAngular(() => {
                this._ngZone.onStable.subscribe({
                    next: () => {
                        NgZone.assertNotInAngularZone();
                        scheduleMicroTask(() => {
                            this._isZoneStable = true;
                            this._runCallbacksIfReady();
                        });
                    }
                });
            });
        }
        /**
         * Increases the number of pending request
         * @deprecated pending requests are now tracked with zones.
         */
        increasePendingRequestCount() {
            this._pendingCount += 1;
            this._didWork = true;
            return this._pendingCount;
        }
        /**
         * Decreases the number of pending request
         * @deprecated pending requests are now tracked with zones
         */
        decreasePendingRequestCount() {
            this._pendingCount -= 1;
            if (this._pendingCount < 0) {
                throw new Error('pending async requests below zero');
            }
            this._runCallbacksIfReady();
            return this._pendingCount;
        }
        /**
         * Whether an associated application is stable
         */
        isStable() {
            return this._isZoneStable && this._pendingCount === 0 && !this._ngZone.hasPendingMacrotasks;
        }
        _runCallbacksIfReady() {
            if (this.isStable()) {
                // Schedules the call backs in a new frame so that it is always async.
                scheduleMicroTask(() => {
                    while (this._callbacks.length !== 0) {
                        let cb = this._callbacks.pop();
                        clearTimeout(cb.timeoutId);
                        cb.doneCb(this._didWork);
                    }
                    this._didWork = false;
                });
            }
            else {
                // Still not stable, send updates.
                let pending = this.getPendingTasks();
                this._callbacks = this._callbacks.filter((cb) => {
                    if (cb.updateCb && cb.updateCb(pending)) {
                        clearTimeout(cb.timeoutId);
                        return false;
                    }
                    return true;
                });
                this._didWork = true;
            }
        }
        getPendingTasks() {
            if (!this.taskTrackingZone) {
                return [];
            }
            // Copy the tasks data so that we don't leak tasks.
            return this.taskTrackingZone.macroTasks.map((t) => {
                return {
                    source: t.source,
                    // From TaskTrackingZone:
                    // https://github.com/angular/zone.js/blob/master/lib/zone-spec/task-tracking.ts#L40
                    creationLocation: t.creationLocation,
                    data: t.data
                };
            });
        }
        addCallback(cb, timeout, updateCb) {
            let timeoutId = -1;
            if (timeout && timeout > 0) {
                timeoutId = setTimeout(() => {
                    this._callbacks = this._callbacks.filter((cb) => cb.timeoutId !== timeoutId);
                    cb(this._didWork, this.getPendingTasks());
                }, timeout);
            }
            this._callbacks.push({ doneCb: cb, timeoutId: timeoutId, updateCb: updateCb });
        }
        /**
         * Wait for the application to be stable with a timeout. If the timeout is reached before that
         * happens, the callback receives a list of the macro tasks that were pending, otherwise null.
         *
         * @param doneCb The callback to invoke when Angular is stable or the timeout expires
         *    whichever comes first.
         * @param timeout Optional. The maximum time to wait for Angular to become stable. If not
         *    specified, whenStable() will wait forever.
         * @param updateCb Optional. If specified, this callback will be invoked whenever the set of
         *    pending macrotasks changes. If this callback returns true doneCb will not be invoked
         *    and no further updates will be issued.
         */
        whenStable(doneCb, timeout, updateCb) {
            if (updateCb && !this.taskTrackingZone) {
                throw new Error('Task tracking zone is required when passing an update callback to ' +
                    'whenStable(). Is "zone.js/plugins/task-tracking" loaded?');
            }
            // These arguments are 'Function' above to keep the public API simple.
            this.addCallback(doneCb, timeout, updateCb);
            this._runCallbacksIfReady();
        }
        /**
         * Get the number of pending requests
         * @deprecated pending requests are now tracked with zones
         */
        getPendingRequestCount() {
            return this._pendingCount;
        }
        /**
         * Find providers by name
         * @param using The root element to search from
         * @param provider The name of binding variable
         * @param exactMatch Whether using exactMatch
         */
        findProviders(using, provider, exactMatch) {
            // TODO(juliemr): implement.
            return [];
        }
    }
    Testability.decorators = [
        { type: Injectable }
    ];
    Testability.ctorParameters = () => [
        { type: NgZone }
    ];
    /**
     * A global registry of {@link Testability} instances for specific elements.
     * @publicApi
     */
    class TestabilityRegistry {
        constructor() {
            /** @internal */
            this._applications = new Map();
            _testabilityGetter.addToWindow(this);
        }
        /**
         * Registers an application with a testability hook so that it can be tracked
         * @param token token of application, root element
         * @param testability Testability hook
         */
        registerApplication(token, testability) {
            this._applications.set(token, testability);
        }
        /**
         * Unregisters an application.
         * @param token token of application, root element
         */
        unregisterApplication(token) {
            this._applications.delete(token);
        }
        /**
         * Unregisters all applications
         */
        unregisterAllApplications() {
            this._applications.clear();
        }
        /**
         * Get a testability hook associated with the application
         * @param elem root element
         */
        getTestability(elem) {
            return this._applications.get(elem) || null;
        }
        /**
         * Get all registered testabilities
         */
        getAllTestabilities() {
            return Array.from(this._applications.values());
        }
        /**
         * Get all registered applications(root elements)
         */
        getAllRootElements() {
            return Array.from(this._applications.keys());
        }
        /**
         * Find testability of a node in the Tree
         * @param elem node
         * @param findInAncestors whether finding testability in ancestors if testability was not found in
         * current node
         */
        findTestabilityInTree(elem, findInAncestors = true) {
            return _testabilityGetter.findTestabilityInTree(this, elem, findInAncestors);
        }
    }
    TestabilityRegistry.decorators = [
        { type: Injectable }
    ];
    TestabilityRegistry.ctorParameters = () => [];
    class _NoopGetTestability {
        addToWindow(registry) { }
        findTestabilityInTree(registry, elem, findInAncestors) {
            return null;
        }
    }
    let _testabilityGetter = new _NoopGetTestability();

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * This file is used to control if the default rendering pipeline should be `ViewEngine` or `Ivy`.
     *
     * For more information on how to run and debug tests with either Ivy or View Engine (legacy),
     * please see [BAZEL.md](./docs/BAZEL.md).
     */
    let _devMode = true;
    /**
     * Returns whether Angular is in development mode. After called once,
     * the value is locked and won't change any more.
     *
     * By default, this is true, unless a user calls `enableProdMode` before calling this.
     *
     * @publicApi
     */
    function isDevMode() {
        return _devMode;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    let _platform;
    let compileNgModuleFactory = compileNgModuleFactory__PRE_R3__;
    function compileNgModuleFactory__PRE_R3__(injector, options, moduleType) {
        const compilerFactory = injector.get(CompilerFactory);
        const compiler = compilerFactory.createCompiler([options]);
        return compiler.compileModuleAsync(moduleType);
    }
    let isBoundToModule = isBoundToModule__PRE_R3__;
    function isBoundToModule__PRE_R3__(cf) {
        return cf instanceof ComponentFactoryBoundToModule;
    }
    const ALLOW_MULTIPLE_PLATFORMS = new InjectionToken('AllowMultipleToken');
    /**
     * Creates a platform.
     * Platforms must be created on launch using this function.
     *
     * @publicApi
     */
    function createPlatform(injector) {
        if (_platform && !_platform.destroyed &&
            !_platform.injector.get(ALLOW_MULTIPLE_PLATFORMS, false)) {
            throw new Error('There can be only one platform. Destroy the previous one to create a new one.');
        }
        _platform = injector.get(PlatformRef);
        const inits = injector.get(PLATFORM_INITIALIZER, null);
        if (inits)
            inits.forEach((init) => init());
        return _platform;
    }
    /**
     * Creates a factory for a platform. Can be used to provide or override `Providers` specific to
     * your application's runtime needs, such as `PLATFORM_INITIALIZER` and `PLATFORM_ID`.
     * @param parentPlatformFactory Another platform factory to modify. Allows you to compose factories
     * to build up configurations that might be required by different libraries or parts of the
     * application.
     * @param name Identifies the new platform factory.
     * @param providers A set of dependency providers for platforms created with the new factory.
     *
     * @publicApi
     */
    function createPlatformFactory(parentPlatformFactory, name, providers = []) {
        const desc = `Platform: ${name}`;
        const marker = new InjectionToken(desc);
        return (extraProviders = []) => {
            let platform = getPlatform();
            if (!platform || platform.injector.get(ALLOW_MULTIPLE_PLATFORMS, false)) {
                if (parentPlatformFactory) {
                    parentPlatformFactory(providers.concat(extraProviders).concat({ provide: marker, useValue: true }));
                }
                else {
                    const injectedProviders = providers.concat(extraProviders).concat({ provide: marker, useValue: true }, {
                        provide: INJECTOR_SCOPE,
                        useValue: 'platform'
                    });
                    createPlatform(Injector.create({ providers: injectedProviders, name: desc }));
                }
            }
            return assertPlatform(marker);
        };
    }
    /**
     * Checks that there is currently a platform that contains the given token as a provider.
     *
     * @publicApi
     */
    function assertPlatform(requiredToken) {
        const platform = getPlatform();
        if (!platform) {
            throw new Error('No platform exists!');
        }
        if (!platform.injector.get(requiredToken, null)) {
            throw new Error('A platform with a different configuration has been created. Please destroy it first.');
        }
        return platform;
    }
    /**
     * Returns the current platform.
     *
     * @publicApi
     */
    function getPlatform() {
        return _platform && !_platform.destroyed ? _platform : null;
    }
    /**
     * The Angular platform is the entry point for Angular on a web page.
     * Each page has exactly one platform. Services (such as reflection) which are common
     * to every Angular application running on the page are bound in its scope.
     * A page's platform is initialized implicitly when a platform is created using a platform
     * factory such as `PlatformBrowser`, or explicitly by calling the `createPlatform()` function.
     *
     * @publicApi
     */
    class PlatformRef {
        /** @internal */
        constructor(_injector) {
            this._injector = _injector;
            this._modules = [];
            this._destroyListeners = [];
            this._destroyed = false;
        }
        /**
         * Creates an instance of an `@NgModule` for the given platform for offline compilation.
         *
         * @usageNotes
         *
         * The following example creates the NgModule for a browser platform.
         *
         * ```typescript
         * my_module.ts:
         *
         * @NgModule({
         *   imports: [BrowserModule]
         * })
         * class MyModule {}
         *
         * main.ts:
         * import {MyModuleNgFactory} from './my_module.ngfactory';
         * import {platformBrowser} from '@angular/platform-browser';
         *
         * let moduleRef = platformBrowser().bootstrapModuleFactory(MyModuleNgFactory);
         * ```
         */
        bootstrapModuleFactory(moduleFactory, options) {
            // Note: We need to create the NgZone _before_ we instantiate the module,
            // as instantiating the module creates some providers eagerly.
            // So we create a mini parent injector that just contains the new NgZone and
            // pass that as parent to the NgModuleFactory.
            const ngZoneOption = options ? options.ngZone : undefined;
            const ngZoneEventCoalescing = (options && options.ngZoneEventCoalescing) || false;
            const ngZoneRunCoalescing = (options && options.ngZoneRunCoalescing) || false;
            const ngZone = getNgZone(ngZoneOption, { ngZoneEventCoalescing, ngZoneRunCoalescing });
            const providers = [{ provide: NgZone, useValue: ngZone }];
            // Note: Create ngZoneInjector within ngZone.run so that all of the instantiated services are
            // created within the Angular zone
            // Do not try to replace ngZone.run with ApplicationRef#run because ApplicationRef would then be
            // created outside of the Angular zone.
            return ngZone.run(() => {
                const ngZoneInjector = Injector.create({ providers: providers, parent: this.injector, name: moduleFactory.moduleType.name });
                const moduleRef = moduleFactory.create(ngZoneInjector);
                const exceptionHandler = moduleRef.injector.get(ErrorHandler, null);
                if (!exceptionHandler) {
                    throw new Error('No ErrorHandler. Is platform module (BrowserModule) included?');
                }
                ngZone.runOutsideAngular(() => {
                    const subscription = ngZone.onError.subscribe({
                        next: (error) => {
                            exceptionHandler.handleError(error);
                        }
                    });
                    moduleRef.onDestroy(() => {
                        remove(this._modules, moduleRef);
                        subscription.unsubscribe();
                    });
                });
                return _callAndReportToErrorHandler(exceptionHandler, ngZone, () => {
                    const initStatus = moduleRef.injector.get(ApplicationInitStatus);
                    initStatus.runInitializers();
                    return initStatus.donePromise.then(() => {
                        if (ivyEnabled) {
                            // If the `LOCALE_ID` provider is defined at bootstrap then we set the value for ivy
                            const localeId = moduleRef.injector.get(LOCALE_ID$1, DEFAULT_LOCALE_ID);
                            setLocaleId(localeId || DEFAULT_LOCALE_ID);
                        }
                        this._moduleDoBootstrap(moduleRef);
                        return moduleRef;
                    });
                });
            });
        }
        /**
         * Creates an instance of an `@NgModule` for a given platform using the given runtime compiler.
         *
         * @usageNotes
         * ### Simple Example
         *
         * ```typescript
         * @NgModule({
         *   imports: [BrowserModule]
         * })
         * class MyModule {}
         *
         * let moduleRef = platformBrowser().bootstrapModule(MyModule);
         * ```
         *
         */
        bootstrapModule(moduleType, compilerOptions = []) {
            const options = optionsReducer({}, compilerOptions);
            return compileNgModuleFactory(this.injector, options, moduleType)
                .then(moduleFactory => this.bootstrapModuleFactory(moduleFactory, options));
        }
        _moduleDoBootstrap(moduleRef) {
            const appRef = moduleRef.injector.get(ApplicationRef);
            if (moduleRef._bootstrapComponents.length > 0) {
                moduleRef._bootstrapComponents.forEach(f => appRef.bootstrap(f));
            }
            else if (moduleRef.instance.ngDoBootstrap) {
                moduleRef.instance.ngDoBootstrap(appRef);
            }
            else {
                throw new Error(`The module ${stringify$1(moduleRef.instance
                .constructor)} was bootstrapped, but it does not declare "@NgModule.bootstrap" components nor a "ngDoBootstrap" method. ` +
                    `Please define one of these.`);
            }
            this._modules.push(moduleRef);
        }
        /**
         * Registers a listener to be called when the platform is destroyed.
         */
        onDestroy(callback) {
            this._destroyListeners.push(callback);
        }
        /**
         * Retrieves the platform {@link Injector}, which is the parent injector for
         * every Angular application on the page and provides singleton providers.
         */
        get injector() {
            return this._injector;
        }
        /**
         * Destroys the current Angular platform and all Angular applications on the page.
         * Destroys all modules and listeners registered with the platform.
         */
        destroy() {
            if (this._destroyed) {
                throw new Error('The platform has already been destroyed!');
            }
            this._modules.slice().forEach(module => module.destroy());
            this._destroyListeners.forEach(listener => listener());
            this._destroyed = true;
        }
        get destroyed() {
            return this._destroyed;
        }
    }
    PlatformRef.decorators = [
        { type: Injectable }
    ];
    PlatformRef.ctorParameters = () => [
        { type: Injector }
    ];
    function getNgZone(ngZoneOption, extra) {
        let ngZone;
        if (ngZoneOption === 'noop') {
            ngZone = new NoopNgZone();
        }
        else {
            ngZone = (ngZoneOption === 'zone.js' ? undefined : ngZoneOption) || new NgZone({
                enableLongStackTrace: isDevMode(),
                shouldCoalesceEventChangeDetection: !!(extra === null || extra === void 0 ? void 0 : extra.ngZoneEventCoalescing),
                shouldCoalesceRunChangeDetection: !!(extra === null || extra === void 0 ? void 0 : extra.ngZoneRunCoalescing)
            });
        }
        return ngZone;
    }
    function _callAndReportToErrorHandler(errorHandler, ngZone, callback) {
        try {
            const result = callback();
            if (isPromise$1(result)) {
                return result.catch((e) => {
                    ngZone.runOutsideAngular(() => errorHandler.handleError(e));
                    // rethrow as the exception handler might not do it
                    throw e;
                });
            }
            return result;
        }
        catch (e) {
            ngZone.runOutsideAngular(() => errorHandler.handleError(e));
            // rethrow as the exception handler might not do it
            throw e;
        }
    }
    function optionsReducer(dst, objs) {
        if (Array.isArray(objs)) {
            dst = objs.reduce(optionsReducer, dst);
        }
        else {
            dst = Object.assign(Object.assign({}, dst), objs);
        }
        return dst;
    }
    /**
     * A reference to an Angular application running on a page.
     *
     * @usageNotes
     *
     * {@a is-stable-examples}
     * ### isStable examples and caveats
     *
     * Note two important points about `isStable`, demonstrated in the examples below:
     * - the application will never be stable if you start any kind
     * of recurrent asynchronous task when the application starts
     * (for example for a polling process, started with a `setInterval`, a `setTimeout`
     * or using RxJS operators like `interval`);
     * - the `isStable` Observable runs outside of the Angular zone.
     *
     * Let's imagine that you start a recurrent task
     * (here incrementing a counter, using RxJS `interval`),
     * and at the same time subscribe to `isStable`.
     *
     * ```
     * constructor(appRef: ApplicationRef) {
     *   appRef.isStable.pipe(
     *      filter(stable => stable)
     *   ).subscribe(() => console.log('App is stable now');
     *   interval(1000).subscribe(counter => console.log(counter));
     * }
     * ```
     * In this example, `isStable` will never emit `true`,
     * and the trace "App is stable now" will never get logged.
     *
     * If you want to execute something when the app is stable,
     * you have to wait for the application to be stable
     * before starting your polling process.
     *
     * ```
     * constructor(appRef: ApplicationRef) {
     *   appRef.isStable.pipe(
     *     first(stable => stable),
     *     tap(stable => console.log('App is stable now')),
     *     switchMap(() => interval(1000))
     *   ).subscribe(counter => console.log(counter));
     * }
     * ```
     * In this example, the trace "App is stable now" will be logged
     * and then the counter starts incrementing every second.
     *
     * Note also that this Observable runs outside of the Angular zone,
     * which means that the code in the subscription
     * to this Observable will not trigger the change detection.
     *
     * Let's imagine that instead of logging the counter value,
     * you update a field of your component
     * and display it in its template.
     *
     * ```
     * constructor(appRef: ApplicationRef) {
     *   appRef.isStable.pipe(
     *     first(stable => stable),
     *     switchMap(() => interval(1000))
     *   ).subscribe(counter => this.value = counter);
     * }
     * ```
     * As the `isStable` Observable runs outside the zone,
     * the `value` field will be updated properly,
     * but the template will not be refreshed!
     *
     * You'll have to manually trigger the change detection to update the template.
     *
     * ```
     * constructor(appRef: ApplicationRef, cd: ChangeDetectorRef) {
     *   appRef.isStable.pipe(
     *     first(stable => stable),
     *     switchMap(() => interval(1000))
     *   ).subscribe(counter => {
     *     this.value = counter;
     *     cd.detectChanges();
     *   });
     * }
     * ```
     *
     * Or make the subscription callback run inside the zone.
     *
     * ```
     * constructor(appRef: ApplicationRef, zone: NgZone) {
     *   appRef.isStable.pipe(
     *     first(stable => stable),
     *     switchMap(() => interval(1000))
     *   ).subscribe(counter => zone.run(() => this.value = counter));
     * }
     * ```
     *
     * @publicApi
     */
    class ApplicationRef {
        /** @internal */
        constructor(_zone, _injector, _exceptionHandler, _componentFactoryResolver, _initStatus) {
            this._zone = _zone;
            this._injector = _injector;
            this._exceptionHandler = _exceptionHandler;
            this._componentFactoryResolver = _componentFactoryResolver;
            this._initStatus = _initStatus;
            /** @internal */
            this._bootstrapListeners = [];
            this._views = [];
            this._runningTick = false;
            this._stable = true;
            /**
             * Get a list of component types registered to this application.
             * This list is populated even before the component is created.
             */
            this.componentTypes = [];
            /**
             * Get a list of components registered to this application.
             */
            this.components = [];
            this._onMicrotaskEmptySubscription = this._zone.onMicrotaskEmpty.subscribe({
                next: () => {
                    this._zone.run(() => {
                        this.tick();
                    });
                }
            });
            const isCurrentlyStable = new Observable((observer) => {
                this._stable = this._zone.isStable && !this._zone.hasPendingMacrotasks &&
                    !this._zone.hasPendingMicrotasks;
                this._zone.runOutsideAngular(() => {
                    observer.next(this._stable);
                    observer.complete();
                });
            });
            const isStable = new Observable((observer) => {
                // Create the subscription to onStable outside the Angular Zone so that
                // the callback is run outside the Angular Zone.
                let stableSub;
                this._zone.runOutsideAngular(() => {
                    stableSub = this._zone.onStable.subscribe(() => {
                        NgZone.assertNotInAngularZone();
                        // Check whether there are no pending macro/micro tasks in the next tick
                        // to allow for NgZone to update the state.
                        scheduleMicroTask(() => {
                            if (!this._stable && !this._zone.hasPendingMacrotasks &&
                                !this._zone.hasPendingMicrotasks) {
                                this._stable = true;
                                observer.next(true);
                            }
                        });
                    });
                });
                const unstableSub = this._zone.onUnstable.subscribe(() => {
                    NgZone.assertInAngularZone();
                    if (this._stable) {
                        this._stable = false;
                        this._zone.runOutsideAngular(() => {
                            observer.next(false);
                        });
                    }
                });
                return () => {
                    stableSub.unsubscribe();
                    unstableSub.unsubscribe();
                };
            });
            this.isStable =
                merge$1(isCurrentlyStable, isStable.pipe(share()));
        }
        /**
         * Bootstrap a component onto the element identified by its selector or, optionally, to a
         * specified element.
         *
         * @usageNotes
         * ### Bootstrap process
         *
         * When bootstrapping a component, Angular mounts it onto a target DOM element
         * and kicks off automatic change detection. The target DOM element can be
         * provided using the `rootSelectorOrNode` argument.
         *
         * If the target DOM element is not provided, Angular tries to find one on a page
         * using the `selector` of the component that is being bootstrapped
         * (first matched element is used).
         *
         * ### Example
         *
         * Generally, we define the component to bootstrap in the `bootstrap` array of `NgModule`,
         * but it requires us to know the component while writing the application code.
         *
         * Imagine a situation where we have to wait for an API call to decide about the component to
         * bootstrap. We can use the `ngDoBootstrap` hook of the `NgModule` and call this method to
         * dynamically bootstrap a component.
         *
         * {@example core/ts/platform/platform.ts region='componentSelector'}
         *
         * Optionally, a component can be mounted onto a DOM element that does not match the
         * selector of the bootstrapped component.
         *
         * In the following example, we are providing a CSS selector to match the target element.
         *
         * {@example core/ts/platform/platform.ts region='cssSelector'}
         *
         * While in this example, we are providing reference to a DOM node.
         *
         * {@example core/ts/platform/platform.ts region='domNode'}
         */
        bootstrap(componentOrFactory, rootSelectorOrNode) {
            if (!this._initStatus.done) {
                throw new Error('Cannot bootstrap as there are still asynchronous initializers running. Bootstrap components in the `ngDoBootstrap` method of the root module.');
            }
            let componentFactory;
            if (componentOrFactory instanceof ComponentFactory) {
                componentFactory = componentOrFactory;
            }
            else {
                componentFactory =
                    this._componentFactoryResolver.resolveComponentFactory(componentOrFactory);
            }
            this.componentTypes.push(componentFactory.componentType);
            // Create a factory associated with the current module if it's not bound to some other
            const ngModule = isBoundToModule(componentFactory) ? undefined : this._injector.get(NgModuleRef);
            const selectorOrNode = rootSelectorOrNode || componentFactory.selector;
            const compRef = componentFactory.create(Injector.NULL, [], selectorOrNode, ngModule);
            const nativeElement = compRef.location.nativeElement;
            const testability = compRef.injector.get(Testability, null);
            const testabilityRegistry = testability && compRef.injector.get(TestabilityRegistry);
            if (testability && testabilityRegistry) {
                testabilityRegistry.registerApplication(nativeElement, testability);
            }
            compRef.onDestroy(() => {
                this.detachView(compRef.hostView);
                remove(this.components, compRef);
                if (testabilityRegistry) {
                    testabilityRegistry.unregisterApplication(nativeElement);
                }
            });
            this._loadComponent(compRef);
            // Note that we have still left the `isDevMode()` condition in order to avoid
            // creating a breaking change for projects that still use the View Engine.
            if ((typeof ngDevMode === 'undefined' || ngDevMode) && isDevMode()) {
                const _console = this._injector.get(Console);
                _console.log(`Angular is running in development mode. Call enableProdMode() to enable production mode.`);
            }
            return compRef;
        }
        /**
         * Invoke this method to explicitly process change detection and its side-effects.
         *
         * In development mode, `tick()` also performs a second change detection cycle to ensure that no
         * further changes are detected. If additional changes are picked up during this second cycle,
         * bindings in the app have side-effects that cannot be resolved in a single change detection
         * pass.
         * In this case, Angular throws an error, since an Angular application can only have one change
         * detection pass during which all change detection must complete.
         */
        tick() {
            if (this._runningTick) {
                throw new Error('ApplicationRef.tick is called recursively');
            }
            try {
                this._runningTick = true;
                for (let view of this._views) {
                    view.detectChanges();
                }
                // Note that we have still left the `isDevMode()` condition in order to avoid
                // creating a breaking change for projects that still use the View Engine.
                if ((typeof ngDevMode === 'undefined' || ngDevMode) && isDevMode()) {
                    for (let view of this._views) {
                        view.checkNoChanges();
                    }
                }
            }
            catch (e) {
                // Attention: Don't rethrow as it could cancel subscriptions to Observables!
                this._zone.runOutsideAngular(() => this._exceptionHandler.handleError(e));
            }
            finally {
                this._runningTick = false;
            }
        }
        /**
         * Attaches a view so that it will be dirty checked.
         * The view will be automatically detached when it is destroyed.
         * This will throw if the view is already attached to a ViewContainer.
         */
        attachView(viewRef) {
            const view = viewRef;
            this._views.push(view);
            view.attachToAppRef(this);
        }
        /**
         * Detaches a view from dirty checking again.
         */
        detachView(viewRef) {
            const view = viewRef;
            remove(this._views, view);
            view.detachFromAppRef();
        }
        _loadComponent(componentRef) {
            this.attachView(componentRef.hostView);
            this.tick();
            this.components.push(componentRef);
            // Get the listeners lazily to prevent DI cycles.
            const listeners = this._injector.get(APP_BOOTSTRAP_LISTENER, []).concat(this._bootstrapListeners);
            listeners.forEach((listener) => listener(componentRef));
        }
        /** @internal */
        ngOnDestroy() {
            this._views.slice().forEach((view) => view.destroy());
            this._onMicrotaskEmptySubscription.unsubscribe();
        }
        /**
         * Returns the number of attached views.
         */
        get viewCount() {
            return this._views.length;
        }
    }
    ApplicationRef.decorators = [
        { type: Injectable }
    ];
    ApplicationRef.ctorParameters = () => [
        { type: NgZone },
        { type: Injector },
        { type: ErrorHandler },
        { type: ComponentFactoryResolver },
        { type: ApplicationInitStatus }
    ];
    function remove(list, el) {
        const index = list.indexOf(el);
        if (index > -1) {
            list.splice(index, 1);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const _CORE_PLATFORM_PROVIDERS = [
        // Set a default platform name for platforms that don't set it explicitly.
        { provide: PLATFORM_ID, useValue: 'unknown' },
        { provide: PlatformRef, deps: [Injector] },
        { provide: TestabilityRegistry, deps: [] },
        { provide: Console, deps: [] },
    ];
    /**
     * This platform has to be included in any other platform
     *
     * @publicApi
     */
    const platformCore = createPlatformFactory(null, 'core', _CORE_PLATFORM_PROVIDERS);

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function _iterableDiffersFactory() {
        return defaultIterableDiffers;
    }
    function _keyValueDiffersFactory() {
        return defaultKeyValueDiffers;
    }
    function _localeFactory(locale) {
        locale = locale || getGlobalLocale();
        return locale;
    }
    /**
     * Work out the locale from the potential global properties.
     *
     * * Closure Compiler: use `goog.getLocale()`.
     * * Ivy enabled: use `$localize.locale`
     */
    function getGlobalLocale() {
        if (typeof ngI18nClosureMode !== 'undefined' && ngI18nClosureMode &&
            typeof goog !== 'undefined' && goog.getLocale() !== 'en') {
            // * The default `goog.getLocale()` value is `en`, while Angular used `en-US`.
            // * In order to preserve backwards compatibility, we use Angular default value over
            //   Closure Compiler's one.
            return goog.getLocale();
        }
        else {
            // KEEP `typeof $localize !== 'undefined' && $localize.locale` IN SYNC WITH THE LOCALIZE
            // COMPILE-TIME INLINER.
            //
            // * During compile time inlining of translations the expression will be replaced
            //   with a string literal that is the current locale. Other forms of this expression are not
            //   guaranteed to be replaced.
            //
            // * During runtime translation evaluation, the developer is required to set `$localize.locale`
            //   if required, or just to provide their own `LOCALE_ID` provider.
            return             DEFAULT_LOCALE_ID;
        }
    }
    const Éµ0$b = USD_CURRENCY_CODE;
    /**
     * A built-in [dependency injection token](guide/glossary#di-token)
     * that is used to configure the root injector for bootstrapping.
     */
    const APPLICATION_MODULE_PROVIDERS = [
        {
            provide: ApplicationRef,
            useClass: ApplicationRef,
            deps: [NgZone, Injector, ErrorHandler, ComponentFactoryResolver, ApplicationInitStatus]
        },
        { provide: SCHEDULER, deps: [NgZone], useFactory: zoneSchedulerFactory },
        {
            provide: ApplicationInitStatus,
            useClass: ApplicationInitStatus,
            deps: [[new Optional(), APP_INITIALIZER]]
        },
        { provide: Compiler, useClass: Compiler, deps: [] },
        APP_ID_RANDOM_PROVIDER,
        { provide: IterableDiffers, useFactory: _iterableDiffersFactory, deps: [] },
        { provide: KeyValueDiffers, useFactory: _keyValueDiffersFactory, deps: [] },
        {
            provide: LOCALE_ID$1,
            useFactory: _localeFactory,
            deps: [[new Inject(LOCALE_ID$1), new Optional(), new SkipSelf()]]
        },
        { provide: DEFAULT_CURRENCY_CODE, useValue: Éµ0$b },
    ];
    /**
     * Schedule work at next available slot.
     *
     * In Ivy this is just `requestAnimationFrame`. For compatibility reasons when bootstrapped
     * using `platformRef.bootstrap` we need to use `NgZone.onStable` as the scheduling mechanism.
     * This overrides the scheduling mechanism in Ivy to `NgZone.onStable`.
     *
     * @param ngZone NgZone to use for scheduling.
     */
    function zoneSchedulerFactory(ngZone) {
        let queue = [];
        ngZone.onStable.subscribe(() => {
            while (queue.length) {
                queue.pop()();
            }
        });
        return function (fn) {
            queue.push(fn);
        };
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var ViewAction;
    (function (ViewAction) {
        ViewAction[ViewAction["CreateViewNodes"] = 0] = "CreateViewNodes";
        ViewAction[ViewAction["CheckNoChanges"] = 1] = "CheckNoChanges";
        ViewAction[ViewAction["CheckNoChangesProjectedViews"] = 2] = "CheckNoChangesProjectedViews";
        ViewAction[ViewAction["CheckAndUpdate"] = 3] = "CheckAndUpdate";
        ViewAction[ViewAction["CheckAndUpdateProjectedViews"] = 4] = "CheckAndUpdateProjectedViews";
        ViewAction[ViewAction["Destroy"] = 5] = "Destroy";
    })(ViewAction || (ViewAction = {}));

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var DebugAction;
    (function (DebugAction) {
        DebugAction[DebugAction["create"] = 0] = "create";
        DebugAction[DebugAction["detectChanges"] = 1] = "detectChanges";
        DebugAction[DebugAction["checkNoChanges"] = 2] = "checkNoChanges";
        DebugAction[DebugAction["destroy"] = 3] = "destroy";
        DebugAction[DebugAction["handleEvent"] = 4] = "handleEvent";
    })(DebugAction || (DebugAction = {}));

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    if (typeof ngDevMode !== 'undefined' && ngDevMode) {
        // This helper is to give a reasonable error message to people upgrading to v9 that have not yet
        // installed `@angular/localize` in their app.
        // tslint:disable-next-line: no-toplevel-property-access
        _global$1.$localize = _global$1.$localize || function () {
            throw new Error('It looks like your application or one of its dependencies is using i18n.\n' +
                'Angular 9 introduced a global `$localize()` function that needs to be loaded.\n' +
                'Please run `ng add @angular/localize` from the Angular CLI.\n' +
                '(For non-CLI projects, add `import \'@angular/localize/init\';` to your `polyfills.ts` file.\n' +
                'For server-side rendering applications add the import to your `main.server.ts` file.)');
        };
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    // Metadata Schema
    // If you make a backwards incompatible change to the schema, increment the METADTA_VERSION number.
    // If you make a backwards compatible change to the metadata (such as adding an option field) then
    // leave METADATA_VERSION the same. If possible, supply as many versions of the metadata that can
    // represent the semantics of the file in an array. For example, when generating a version 2 file,
    // if version 1 can accurately represent the metadata, generate both version 1 and version 2 in
    // an array.
    const METADATA_VERSION = 4;
    function isClassMetadata(value) {
        return value && value.__symbolic === 'class';
    }
    function isMethodMetadata(value) {
        return value && (value.__symbolic === 'constructor' || value.__symbolic === 'method');
    }
    function isConstructorMetadata(value) {
        return value && value.__symbolic === 'constructor';
    }
    function isFunctionMetadata(value) {
        return value && value.__symbolic === 'function';
    }
    function isMetadataSymbolicExpression(value) {
        if (value) {
            switch (value.__symbolic) {
                case 'binary':
                case 'call':
                case 'index':
                case 'new':
                case 'pre':
                case 'reference':
                case 'select':
                case 'spread':
                case 'if':
                    return true;
            }
        }
        return false;
    }
    function isMetadataGlobalReferenceExpression(value) {
        return value && value.name && !value.module && isMetadataSymbolicReferenceExpression(value);
    }
    function isMetadataModuleReferenceExpression(value) {
        return value && value.module && !value.name && !value.default &&
            isMetadataSymbolicReferenceExpression(value);
    }
    function isMetadataImportedSymbolReferenceExpression(value) {
        return value && value.module && !!value.name && isMetadataSymbolicReferenceExpression(value);
    }
    function isMetadataImportDefaultReference(value) {
        return value && value.module && value.default && isMetadataSymbolicReferenceExpression(value);
    }
    function isMetadataSymbolicReferenceExpression(value) {
        return value && value.__symbolic === 'reference';
    }
    function isMetadataSymbolicSelectExpression(value) {
        return value && value.__symbolic === 'select';
    }
    function isMetadataSymbolicSpreadExpression(value) {
        return value && value.__symbolic === 'spread';
    }
    function isMetadataError$1(value) {
        return value && value.__symbolic === 'error';
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    // In TypeScript 2.1 the spread element kind was renamed.
    const spreadElementSyntaxKind = ts.SyntaxKind.SpreadElement || ts.SyntaxKind.SpreadElementExpression;
    function isMethodCallOf(callExpression, memberName) {
        const expression = callExpression.expression;
        if (expression.kind === ts.SyntaxKind.PropertyAccessExpression) {
            const propertyAccessExpression = expression;
            const name = propertyAccessExpression.name;
            if (name.kind == ts.SyntaxKind.Identifier) {
                return name.text === memberName;
            }
        }
        return false;
    }
    function isCallOf(callExpression, ident) {
        const expression = callExpression.expression;
        if (expression.kind === ts.SyntaxKind.Identifier) {
            const identifier = expression;
            return identifier.text === ident;
        }
        return false;
    }
    /* @internal */
    function recordMapEntry(entry, node, nodeMap, sourceFile) {
        if (!nodeMap.has(entry)) {
            nodeMap.set(entry, node);
            if (node &&
                (isMetadataImportedSymbolReferenceExpression(entry) ||
                    isMetadataImportDefaultReference(entry)) &&
                entry.line == null) {
                const info = sourceInfo(node, sourceFile);
                if (info.line != null)
                    entry.line = info.line;
                if (info.character != null)
                    entry.character = info.character;
            }
        }
        return entry;
    }
    /**
     * ts.forEachChild stops iterating children when the callback return a truthy value.
     * This method inverts this to implement an `every` style iterator. It will return
     * true if every call to `cb` returns `true`.
     */
    function everyNodeChild(node, cb) {
        return !ts.forEachChild(node, node => !cb(node));
    }
    function isPrimitive$1(value) {
        return Object(value) !== value;
    }
    function isDefined$1(obj) {
        return obj !== undefined;
    }
    function getSourceFileOfNode(node) {
        while (node && node.kind != ts.SyntaxKind.SourceFile) {
            node = node.parent;
        }
        return node;
    }
    /* @internal */
    function sourceInfo(node, sourceFile) {
        if (node) {
            sourceFile = sourceFile || getSourceFileOfNode(node);
            if (sourceFile) {
                return ts.getLineAndCharacterOfPosition(sourceFile, node.getStart(sourceFile));
            }
        }
        return {};
    }
    /* @internal */
    function errorSymbol(message, node, context, sourceFile) {
        const result = Object.assign({ __symbolic: 'error', message }, sourceInfo(node, sourceFile));
        if (context) {
            result.context = context;
        }
        return result;
    }
    /**
     * Produce a symbolic representation of an expression folding values into their final value when
     * possible.
     */
    class Evaluator {
        constructor(symbols, nodeMap, options = {}, recordExport) {
            this.symbols = symbols;
            this.nodeMap = nodeMap;
            this.options = options;
            this.recordExport = recordExport;
        }
        nameOf(node) {
            if (node && node.kind == ts.SyntaxKind.Identifier) {
                return node.text;
            }
            const result = node && this.evaluateNode(node);
            if (isMetadataError$1(result) || typeof result === 'string') {
                return result;
            }
            else {
                return errorSymbol('Name expected', node, { received: (node && node.getText()) || '<missing>' });
            }
        }
        /**
         * Returns true if the expression represented by `node` can be folded into a literal expression.
         *
         * For example, a literal is always foldable. This means that literal expressions such as `1.2`
         * `"Some value"` `true` `false` are foldable.
         *
         * - An object literal is foldable if all the properties in the literal are foldable.
         * - An array literal is foldable if all the elements are foldable.
         * - A call is foldable if it is a call to a Array.prototype.concat or a call to CONST_EXPR.
         * - A property access is foldable if the object is foldable.
         * - A array index is foldable if index expression is foldable and the array is foldable.
         * - Binary operator expressions are foldable if the left and right expressions are foldable and
         *   it is one of '+', '-', '*', '/', '%', '||', and '&&'.
         * - An identifier is foldable if a value can be found for its symbol in the evaluator symbol
         *   table.
         */
        isFoldable(node) {
            return this.isFoldableWorker(node, new Map());
        }
        isFoldableWorker(node, folding) {
            if (node) {
                switch (node.kind) {
                    case ts.SyntaxKind.ObjectLiteralExpression:
                        return everyNodeChild(node, child => {
                            if (child.kind === ts.SyntaxKind.PropertyAssignment) {
                                const propertyAssignment = child;
                                return this.isFoldableWorker(propertyAssignment.initializer, folding);
                            }
                            return false;
                        });
                    case ts.SyntaxKind.ArrayLiteralExpression:
                        return everyNodeChild(node, child => this.isFoldableWorker(child, folding));
                    case ts.SyntaxKind.CallExpression:
                        const callExpression = node;
                        // We can fold a <array>.concat(<v>).
                        if (isMethodCallOf(callExpression, 'concat') &&
                            arrayOrEmpty(callExpression.arguments).length === 1) {
                            const arrayNode = callExpression.expression.expression;
                            if (this.isFoldableWorker(arrayNode, folding) &&
                                this.isFoldableWorker(callExpression.arguments[0], folding)) {
                                // It needs to be an array.
                                const arrayValue = this.evaluateNode(arrayNode);
                                if (arrayValue && Array.isArray(arrayValue)) {
                                    return true;
                                }
                            }
                        }
                        // We can fold a call to CONST_EXPR
                        if (isCallOf(callExpression, 'CONST_EXPR') &&
                            arrayOrEmpty(callExpression.arguments).length === 1)
                            return this.isFoldableWorker(callExpression.arguments[0], folding);
                        return false;
                    case ts.SyntaxKind.NoSubstitutionTemplateLiteral:
                    case ts.SyntaxKind.StringLiteral:
                    case ts.SyntaxKind.NumericLiteral:
                    case ts.SyntaxKind.NullKeyword:
                    case ts.SyntaxKind.TrueKeyword:
                    case ts.SyntaxKind.FalseKeyword:
                    case ts.SyntaxKind.TemplateHead:
                    case ts.SyntaxKind.TemplateMiddle:
                    case ts.SyntaxKind.TemplateTail:
                        return true;
                    case ts.SyntaxKind.ParenthesizedExpression:
                        const parenthesizedExpression = node;
                        return this.isFoldableWorker(parenthesizedExpression.expression, folding);
                    case ts.SyntaxKind.BinaryExpression:
                        const binaryExpression = node;
                        switch (binaryExpression.operatorToken.kind) {
                            case ts.SyntaxKind.PlusToken:
                            case ts.SyntaxKind.MinusToken:
                            case ts.SyntaxKind.AsteriskToken:
                            case ts.SyntaxKind.SlashToken:
                            case ts.SyntaxKind.PercentToken:
                            case ts.SyntaxKind.AmpersandAmpersandToken:
                            case ts.SyntaxKind.BarBarToken:
                                return this.isFoldableWorker(binaryExpression.left, folding) &&
                                    this.isFoldableWorker(binaryExpression.right, folding);
                            default:
                                return false;
                        }
                    case ts.SyntaxKind.PropertyAccessExpression:
                        const propertyAccessExpression = node;
                        return this.isFoldableWorker(propertyAccessExpression.expression, folding);
                    case ts.SyntaxKind.ElementAccessExpression:
                        const elementAccessExpression = node;
                        return this.isFoldableWorker(elementAccessExpression.expression, folding) &&
                            this.isFoldableWorker(elementAccessExpression.argumentExpression, folding);
                    case ts.SyntaxKind.Identifier:
                        let identifier = node;
                        let reference = this.symbols.resolve(identifier.text);
                        if (reference !== undefined && isPrimitive$1(reference)) {
                            return true;
                        }
                        break;
                    case ts.SyntaxKind.TemplateExpression:
                        const templateExpression = node;
                        return templateExpression.templateSpans.every(span => this.isFoldableWorker(span.expression, folding));
                }
            }
            return false;
        }
        /**
         * Produce a JSON serialiable object representing `node`. The foldable values in the expression
         * tree are folded. For example, a node representing `1 + 2` is folded into `3`.
         */
        evaluateNode(node, preferReference) {
            const t = this;
            let error;
            function recordEntry(entry, node) {
                if (t.options.substituteExpression) {
                    const newEntry = t.options.substituteExpression(entry, node);
                    if (t.recordExport && newEntry != entry && isMetadataGlobalReferenceExpression(newEntry)) {
                        t.recordExport(newEntry.name, entry);
                    }
                    entry = newEntry;
                }
                return recordMapEntry(entry, node, t.nodeMap);
            }
            function isFoldableError(value) {
                return !t.options.verboseInvalidExpression && isMetadataError$1(value);
            }
            const resolveName = (name, preferReference) => {
                const reference = this.symbols.resolve(name, preferReference);
                if (reference === undefined) {
                    // Encode as a global reference. StaticReflector will check the reference.
                    return recordEntry({ __symbolic: 'reference', name }, node);
                }
                if (reference && isMetadataSymbolicReferenceExpression(reference)) {
                    return recordEntry(Object.assign({}, reference), node);
                }
                return reference;
            };
            switch (node.kind) {
                case ts.SyntaxKind.ObjectLiteralExpression:
                    let obj = {};
                    let quoted = [];
                    ts.forEachChild(node, child => {
                        switch (child.kind) {
                            case ts.SyntaxKind.ShorthandPropertyAssignment:
                            case ts.SyntaxKind.PropertyAssignment:
                                const assignment = child;
                                if (assignment.name.kind == ts.SyntaxKind.StringLiteral) {
                                    const name = assignment.name.text;
                                    quoted.push(name);
                                }
                                const propertyName = this.nameOf(assignment.name);
                                if (isFoldableError(propertyName)) {
                                    error = propertyName;
                                    return true;
                                }
                                const propertyValue = isPropertyAssignment(assignment) ?
                                    this.evaluateNode(assignment.initializer, /* preferReference */ true) :
                                    resolveName(propertyName, /* preferReference */ true);
                                if (isFoldableError(propertyValue)) {
                                    error = propertyValue;
                                    return true; // Stop the forEachChild.
                                }
                                else {
                                    obj[propertyName] = isPropertyAssignment(assignment) ?
                                        recordEntry(propertyValue, assignment.initializer) :
                                        propertyValue;
                                }
                        }
                    });
                    if (error)
                        return error;
                    if (this.options.quotedNames && quoted.length) {
                        obj['$quoted$'] = quoted;
                    }
                    return recordEntry(obj, node);
                case ts.SyntaxKind.ArrayLiteralExpression:
                    let arr = [];
                    ts.forEachChild(node, child => {
                        const value = this.evaluateNode(child, /* preferReference */ true);
                        // Check for error
                        if (isFoldableError(value)) {
                            error = value;
                            return true; // Stop the forEachChild.
                        }
                        // Handle spread expressions
                        if (isMetadataSymbolicSpreadExpression(value)) {
                            if (Array.isArray(value.expression)) {
                                for (const spreadValue of value.expression) {
                                    arr.push(spreadValue);
                                }
                                return;
                            }
                        }
                        arr.push(value);
                    });
                    if (error)
                        return error;
                    return recordEntry(arr, node);
                case spreadElementSyntaxKind:
                    let spreadExpression = this.evaluateNode(node.expression);
                    return recordEntry({ __symbolic: 'spread', expression: spreadExpression }, node);
                case ts.SyntaxKind.CallExpression:
                    const callExpression = node;
                    if (isCallOf(callExpression, 'forwardRef') &&
                        arrayOrEmpty(callExpression.arguments).length === 1) {
                        const firstArgument = callExpression.arguments[0];
                        if (firstArgument.kind == ts.SyntaxKind.ArrowFunction) {
                            const arrowFunction = firstArgument;
                            return recordEntry(this.evaluateNode(arrowFunction.body), node);
                        }
                    }
                    const args = arrayOrEmpty(callExpression.arguments).map(arg => this.evaluateNode(arg));
                    if (this.isFoldable(callExpression)) {
                        if (isMethodCallOf(callExpression, 'concat')) {
                            const arrayValue = this.evaluateNode(callExpression.expression.expression);
                            if (isFoldableError(arrayValue))
                                return arrayValue;
                            return arrayValue.concat(args[0]);
                        }
                    }
                    // Always fold a CONST_EXPR even if the argument is not foldable.
                    if (isCallOf(callExpression, 'CONST_EXPR') &&
                        arrayOrEmpty(callExpression.arguments).length === 1) {
                        return recordEntry(args[0], node);
                    }
                    const expression = this.evaluateNode(callExpression.expression);
                    if (isFoldableError(expression)) {
                        return recordEntry(expression, node);
                    }
                    let result = { __symbolic: 'call', expression: expression };
                    if (args && args.length) {
                        result.arguments = args;
                    }
                    return recordEntry(result, node);
                case ts.SyntaxKind.NewExpression:
                    const newExpression = node;
                    const newArgs = arrayOrEmpty(newExpression.arguments).map(arg => this.evaluateNode(arg));
                    const newTarget = this.evaluateNode(newExpression.expression);
                    if (isMetadataError$1(newTarget)) {
                        return recordEntry(newTarget, node);
                    }
                    const call = { __symbolic: 'new', expression: newTarget };
                    if (newArgs.length) {
                        call.arguments = newArgs;
                    }
                    return recordEntry(call, node);
                case ts.SyntaxKind.PropertyAccessExpression: {
                    const propertyAccessExpression = node;
                    const expression = this.evaluateNode(propertyAccessExpression.expression);
                    if (isFoldableError(expression)) {
                        return recordEntry(expression, node);
                    }
                    const member = this.nameOf(propertyAccessExpression.name);
                    if (isFoldableError(member)) {
                        return recordEntry(member, node);
                    }
                    if (expression && this.isFoldable(propertyAccessExpression.expression))
                        return expression[member];
                    if (isMetadataModuleReferenceExpression(expression)) {
                        // A select into a module reference and be converted into a reference to the symbol
                        // in the module
                        return recordEntry({ __symbolic: 'reference', module: expression.module, name: member }, node);
                    }
                    return recordEntry({ __symbolic: 'select', expression, member }, node);
                }
                case ts.SyntaxKind.ElementAccessExpression: {
                    const elementAccessExpression = node;
                    const expression = this.evaluateNode(elementAccessExpression.expression);
                    if (isFoldableError(expression)) {
                        return recordEntry(expression, node);
                    }
                    if (!elementAccessExpression.argumentExpression) {
                        return recordEntry(errorSymbol('Expression form not supported', node), node);
                    }
                    const index = this.evaluateNode(elementAccessExpression.argumentExpression);
                    if (isFoldableError(expression)) {
                        return recordEntry(expression, node);
                    }
                    if (this.isFoldable(elementAccessExpression.expression) &&
                        this.isFoldable(elementAccessExpression.argumentExpression))
                        return expression[index];
                    return recordEntry({ __symbolic: 'index', expression, index }, node);
                }
                case ts.SyntaxKind.Identifier:
                    const identifier = node;
                    const name = identifier.text;
                    return resolveName(name, preferReference);
                case ts.SyntaxKind.TypeReference:
                    const typeReferenceNode = node;
                    const typeNameNode = typeReferenceNode.typeName;
                    const getReference = node => {
                        if (typeNameNode.kind === ts.SyntaxKind.QualifiedName) {
                            const qualifiedName = node;
                            const left = this.evaluateNode(qualifiedName.left);
                            if (isMetadataModuleReferenceExpression(left)) {
                                return recordEntry({
                                    __symbolic: 'reference',
                                    module: left.module,
                                    name: qualifiedName.right.text
                                }, node);
                            }
                            // Record a type reference to a declared type as a select.
                            return { __symbolic: 'select', expression: left, member: qualifiedName.right.text };
                        }
                        else {
                            const identifier = typeNameNode;
                            const symbol = this.symbols.resolve(identifier.text);
                            if (isFoldableError(symbol) || isMetadataSymbolicReferenceExpression(symbol)) {
                                return recordEntry(symbol, node);
                            }
                            return recordEntry(errorSymbol('Could not resolve type', node, { typeName: identifier.text }), node);
                        }
                    };
                    const typeReference = getReference(typeNameNode);
                    if (isFoldableError(typeReference)) {
                        return recordEntry(typeReference, node);
                    }
                    if (!isMetadataModuleReferenceExpression(typeReference) &&
                        typeReferenceNode.typeArguments && typeReferenceNode.typeArguments.length) {
                        const args = typeReferenceNode.typeArguments.map(element => this.evaluateNode(element));
                        // TODO: Remove typecast when upgraded to 2.0 as it will be correctly inferred.
                        // Some versions of 1.9 do not infer this correctly.
                        typeReference.arguments = args;
                    }
                    return recordEntry(typeReference, node);
                case ts.SyntaxKind.UnionType:
                    const unionType = node;
                    // Remove null and undefined from the list of unions.
                    const references = unionType.types
                        .filter(n => n.kind !== ts.SyntaxKind.UndefinedKeyword &&
                        !(ts.isLiteralTypeNode(n) && n.literal.kind === ts.SyntaxKind.NullKeyword))
                        .map(n => this.evaluateNode(n));
                    // The remmaining reference must be the same. If two have type arguments consider them
                    // different even if the type arguments are the same.
                    let candidate = null;
                    for (let i = 0; i < references.length; i++) {
                        const reference = references[i];
                        if (isMetadataSymbolicReferenceExpression(reference)) {
                            if (candidate) {
                                if (reference.name == candidate.name &&
                                    reference.module == candidate.module && !reference.arguments) {
                                    candidate = reference;
                                }
                            }
                            else {
                                candidate = reference;
                            }
                        }
                        else {
                            return reference;
                        }
                    }
                    if (candidate)
                        return candidate;
                    break;
                case ts.SyntaxKind.NoSubstitutionTemplateLiteral:
                case ts.SyntaxKind.StringLiteral:
                case ts.SyntaxKind.TemplateHead:
                case ts.SyntaxKind.TemplateTail:
                case ts.SyntaxKind.TemplateMiddle:
                    return node.text;
                case ts.SyntaxKind.NumericLiteral:
                    return parseFloat(node.text);
                case ts.SyntaxKind.AnyKeyword:
                    return recordEntry({ __symbolic: 'reference', name: 'any' }, node);
                case ts.SyntaxKind.StringKeyword:
                    return recordEntry({ __symbolic: 'reference', name: 'string' }, node);
                case ts.SyntaxKind.NumberKeyword:
                    return recordEntry({ __symbolic: 'reference', name: 'number' }, node);
                case ts.SyntaxKind.BooleanKeyword:
                    return recordEntry({ __symbolic: 'reference', name: 'boolean' }, node);
                case ts.SyntaxKind.ArrayType:
                    const arrayTypeNode = node;
                    return recordEntry({
                        __symbolic: 'reference',
                        name: 'Array',
                        arguments: [this.evaluateNode(arrayTypeNode.elementType)]
                    }, node);
                case ts.SyntaxKind.NullKeyword:
                    return null;
                case ts.SyntaxKind.TrueKeyword:
                    return true;
                case ts.SyntaxKind.FalseKeyword:
                    return false;
                case ts.SyntaxKind.ParenthesizedExpression:
                    const parenthesizedExpression = node;
                    return this.evaluateNode(parenthesizedExpression.expression);
                case ts.SyntaxKind.TypeAssertionExpression:
                    const typeAssertion = node;
                    return this.evaluateNode(typeAssertion.expression);
                case ts.SyntaxKind.PrefixUnaryExpression:
                    const prefixUnaryExpression = node;
                    const operand = this.evaluateNode(prefixUnaryExpression.operand);
                    if (isDefined$1(operand) && isPrimitive$1(operand)) {
                        switch (prefixUnaryExpression.operator) {
                            case ts.SyntaxKind.PlusToken:
                                return +operand;
                            case ts.SyntaxKind.MinusToken:
                                return -operand;
                            case ts.SyntaxKind.TildeToken:
                                return ~operand;
                            case ts.SyntaxKind.ExclamationToken:
                                return !operand;
                        }
                    }
                    let operatorText;
                    switch (prefixUnaryExpression.operator) {
                        case ts.SyntaxKind.PlusToken:
                            operatorText = '+';
                            break;
                        case ts.SyntaxKind.MinusToken:
                            operatorText = '-';
                            break;
                        case ts.SyntaxKind.TildeToken:
                            operatorText = '~';
                            break;
                        case ts.SyntaxKind.ExclamationToken:
                            operatorText = '!';
                            break;
                        default:
                            return undefined;
                    }
                    return recordEntry({ __symbolic: 'pre', operator: operatorText, operand: operand }, node);
                case ts.SyntaxKind.BinaryExpression:
                    const binaryExpression = node;
                    const left = this.evaluateNode(binaryExpression.left);
                    const right = this.evaluateNode(binaryExpression.right);
                    if (isDefined$1(left) && isDefined$1(right)) {
                        if (isPrimitive$1(left) && isPrimitive$1(right))
                            switch (binaryExpression.operatorToken.kind) {
                                case ts.SyntaxKind.BarBarToken:
                                    return left || right;
                                case ts.SyntaxKind.AmpersandAmpersandToken:
                                    return left && right;
                                case ts.SyntaxKind.AmpersandToken:
                                    return left & right;
                                case ts.SyntaxKind.BarToken:
                                    return left | right;
                                case ts.SyntaxKind.CaretToken:
                                    return left ^ right;
                                case ts.SyntaxKind.EqualsEqualsToken:
                                    return left == right;
                                case ts.SyntaxKind.ExclamationEqualsToken:
                                    return left != right;
                                case ts.SyntaxKind.EqualsEqualsEqualsToken:
                                    return left === right;
                                case ts.SyntaxKind.ExclamationEqualsEqualsToken:
                                    return left !== right;
                                case ts.SyntaxKind.LessThanToken:
                                    return left < right;
                                case ts.SyntaxKind.GreaterThanToken:
                                    return left > right;
                                case ts.SyntaxKind.LessThanEqualsToken:
                                    return left <= right;
                                case ts.SyntaxKind.GreaterThanEqualsToken:
                                    return left >= right;
                                case ts.SyntaxKind.LessThanLessThanToken:
                                    return left << right;
                                case ts.SyntaxKind.GreaterThanGreaterThanToken:
                                    return left >> right;
                                case ts.SyntaxKind.GreaterThanGreaterThanGreaterThanToken:
                                    return left >>> right;
                                case ts.SyntaxKind.PlusToken:
                                    return left + right;
                                case ts.SyntaxKind.MinusToken:
                                    return left - right;
                                case ts.SyntaxKind.AsteriskToken:
                                    return left * right;
                                case ts.SyntaxKind.SlashToken:
                                    return left / right;
                                case ts.SyntaxKind.PercentToken:
                                    return left % right;
                            }
                        return recordEntry({
                            __symbolic: 'binop',
                            operator: binaryExpression.operatorToken.getText(),
                            left: left,
                            right: right
                        }, node);
                    }
                    break;
                case ts.SyntaxKind.ConditionalExpression:
                    const conditionalExpression = node;
                    const condition = this.evaluateNode(conditionalExpression.condition);
                    const thenExpression = this.evaluateNode(conditionalExpression.whenTrue);
                    const elseExpression = this.evaluateNode(conditionalExpression.whenFalse);
                    if (isPrimitive$1(condition)) {
                        return condition ? thenExpression : elseExpression;
                    }
                    return recordEntry({ __symbolic: 'if', condition, thenExpression, elseExpression }, node);
                case ts.SyntaxKind.FunctionExpression:
                case ts.SyntaxKind.ArrowFunction:
                    return recordEntry(errorSymbol('Lambda not supported', node), node);
                case ts.SyntaxKind.TaggedTemplateExpression:
                    return recordEntry(errorSymbol('Tagged template expressions are not supported in metadata', node), node);
                case ts.SyntaxKind.TemplateExpression:
                    const templateExpression = node;
                    if (this.isFoldable(node)) {
                        return templateExpression.templateSpans.reduce((previous, current) => previous + this.evaluateNode(current.expression) +
                            this.evaluateNode(current.literal), this.evaluateNode(templateExpression.head));
                    }
                    else {
                        return templateExpression.templateSpans.reduce((previous, current) => {
                            const expr = this.evaluateNode(current.expression);
                            const literal = this.evaluateNode(current.literal);
                            if (isFoldableError(expr))
                                return expr;
                            if (isFoldableError(literal))
                                return literal;
                            if (typeof previous === 'string' && typeof expr === 'string' &&
                                typeof literal === 'string') {
                                return previous + expr + literal;
                            }
                            let result = expr;
                            if (previous !== '') {
                                result = { __symbolic: 'binop', operator: '+', left: previous, right: expr };
                            }
                            if (literal != '') {
                                result = { __symbolic: 'binop', operator: '+', left: result, right: literal };
                            }
                            return result;
                        }, this.evaluateNode(templateExpression.head));
                    }
                case ts.SyntaxKind.AsExpression:
                    const asExpression = node;
                    return this.evaluateNode(asExpression.expression);
                case ts.SyntaxKind.ClassExpression:
                    return { __symbolic: 'class' };
            }
            return recordEntry(errorSymbol('Expression form not supported', node), node);
        }
    }
    function isPropertyAssignment(node) {
        return node.kind == ts.SyntaxKind.PropertyAssignment;
    }
    const empty$1 = ts.createNodeArray();
    function arrayOrEmpty(v) {
        return v || empty$1;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class Symbols {
        constructor(sourceFile) {
            this.sourceFile = sourceFile;
            this.references = new Map();
        }
        resolve(name, preferReference) {
            return (preferReference && this.references.get(name)) || this.symbols.get(name);
        }
        define(name, value) {
            this.symbols.set(name, value);
        }
        defineReference(name, value) {
            this.references.set(name, value);
        }
        has(name) {
            return this.symbols.has(name);
        }
        get symbols() {
            let result = this._symbols;
            if (!result) {
                result = this._symbols = new Map();
                populateBuiltins(result);
                this.buildImports();
            }
            return result;
        }
        buildImports() {
            const symbols = this._symbols;
            // Collect the imported symbols into this.symbols
            const stripQuotes = (s) => s.replace(/^['"]|['"]$/g, '');
            const visit = (node) => {
                switch (node.kind) {
                    case ts.SyntaxKind.ImportEqualsDeclaration:
                        const importEqualsDeclaration = node;
                        if (importEqualsDeclaration.moduleReference.kind ===
                            ts.SyntaxKind.ExternalModuleReference) {
                            const externalReference = importEqualsDeclaration.moduleReference;
                            if (externalReference.expression) {
                                // An `import <identifier> = require(<module-specifier>);
                                if (!externalReference.expression.parent) {
                                    // The `parent` field of a node is set by the TypeScript binder (run as
                                    // part of the type checker). Setting it here allows us to call `getText()`
                                    // even if the `SourceFile` was not type checked (which looks for `SourceFile`
                                    // in the parent chain). This doesn't damage the node as the binder unconditionally
                                    // sets the parent.
                                    externalReference.expression.parent = externalReference;
                                    externalReference.parent = this.sourceFile;
                                }
                                const from = stripQuotes(externalReference.expression.getText());
                                symbols.set(importEqualsDeclaration.name.text, { __symbolic: 'reference', module: from });
                                break;
                            }
                        }
                        symbols.set(importEqualsDeclaration.name.text, { __symbolic: 'error', message: `Unsupported import syntax` });
                        break;
                    case ts.SyntaxKind.ImportDeclaration:
                        const importDecl = node;
                        if (!importDecl.importClause) {
                            // An `import <module-specifier>` clause which does not bring symbols into scope.
                            break;
                        }
                        if (!importDecl.moduleSpecifier.parent) {
                            // See note above in the `ImportEqualDeclaration` case.
                            importDecl.moduleSpecifier.parent = importDecl;
                            importDecl.parent = this.sourceFile;
                        }
                        const from = stripQuotes(importDecl.moduleSpecifier.getText());
                        if (importDecl.importClause.name) {
                            // An `import <identifier> form <module-specifier>` clause. Record the default symbol.
                            symbols.set(importDecl.importClause.name.text, { __symbolic: 'reference', module: from, default: true });
                        }
                        const bindings = importDecl.importClause.namedBindings;
                        if (bindings) {
                            switch (bindings.kind) {
                                case ts.SyntaxKind.NamedImports:
                                    // An `import { [<identifier> [, <identifier>] } from <module-specifier>` clause
                                    for (const binding of bindings.elements) {
                                        symbols.set(binding.name.text, {
                                            __symbolic: 'reference',
                                            module: from,
                                            name: binding.propertyName ? binding.propertyName.text : binding.name.text
                                        });
                                    }
                                    break;
                                case ts.SyntaxKind.NamespaceImport:
                                    // An `input * as <identifier> from <module-specifier>` clause.
                                    symbols.set(bindings.name.text, { __symbolic: 'reference', module: from });
                                    break;
                            }
                        }
                        break;
                }
                ts.forEachChild(node, visit);
            };
            if (this.sourceFile) {
                ts.forEachChild(this.sourceFile, visit);
            }
        }
    }
    function populateBuiltins(symbols) {
        // From lib.core.d.ts (all "define const")
        ['Object', 'Function', 'String', 'Number', 'Array', 'Boolean', 'Map', 'NaN', 'Infinity', 'Math',
            'Date', 'RegExp', 'Error', 'Error', 'EvalError', 'RangeError', 'ReferenceError', 'SyntaxError',
            'TypeError', 'URIError', 'JSON', 'ArrayBuffer', 'DataView', 'Int8Array', 'Uint8Array',
            'Uint8ClampedArray', 'Uint16Array', 'Int16Array', 'Int32Array', 'Uint32Array', 'Float32Array',
            'Float64Array']
            .forEach(name => symbols.set(name, { __symbolic: 'reference', name }));
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const isStatic = (node) => ts.getCombinedModifierFlags(node) & ts.ModifierFlags.Static;
    /**
     * Collect decorator metadata from a TypeScript module.
     */
    class MetadataCollector {
        constructor(options = {}) {
            this.options = options;
        }
        /**
         * Returns a JSON.stringify friendly form describing the decorators of the exported classes from
         * the source file that is expected to correspond to a module.
         */
        getMetadata(sourceFile, strict = false, substituteExpression) {
            const locals = new Symbols(sourceFile);
            const nodeMap = new Map();
            const composedSubstituter = substituteExpression && this.options.substituteExpression ?
                (value, node) => this.options.substituteExpression(substituteExpression(value, node), node) :
                substituteExpression;
            const evaluatorOptions = substituteExpression ? Object.assign(Object.assign({}, this.options), { substituteExpression: composedSubstituter }) :
                this.options;
            let metadata;
            const evaluator = new Evaluator(locals, nodeMap, evaluatorOptions, (name, value) => {
                if (!metadata)
                    metadata = {};
                metadata[name] = value;
            });
            let exports = undefined;
            function objFromDecorator(decoratorNode) {
                return evaluator.evaluateNode(decoratorNode.expression);
            }
            function recordEntry(entry, node) {
                if (composedSubstituter) {
                    entry = composedSubstituter(entry, node);
                }
                return recordMapEntry(entry, node, nodeMap, sourceFile);
            }
            function errorSym(message, node, context) {
                return errorSymbol(message, node, context, sourceFile);
            }
            function maybeGetSimpleFunction(functionDeclaration) {
                if (functionDeclaration.name && functionDeclaration.name.kind == ts.SyntaxKind.Identifier) {
                    const nameNode = functionDeclaration.name;
                    const functionName = nameNode.text;
                    const functionBody = functionDeclaration.body;
                    if (functionBody && functionBody.statements.length == 1) {
                        const statement = functionBody.statements[0];
                        if (statement.kind === ts.SyntaxKind.ReturnStatement) {
                            const returnStatement = statement;
                            if (returnStatement.expression) {
                                const func = {
                                    __symbolic: 'function',
                                    parameters: namesOf(functionDeclaration.parameters),
                                    value: evaluator.evaluateNode(returnStatement.expression)
                                };
                                if (functionDeclaration.parameters.some(p => p.initializer != null)) {
                                    func.defaults = functionDeclaration.parameters.map(p => p.initializer && evaluator.evaluateNode(p.initializer));
                                }
                                return recordEntry({ func, name: functionName }, functionDeclaration);
                            }
                        }
                    }
                }
            }
            function classMetadataOf(classDeclaration) {
                const result = { __symbolic: 'class' };
                function getDecorators(decorators) {
                    if (decorators && decorators.length)
                        return decorators.map(decorator => objFromDecorator(decorator));
                    return undefined;
                }
                function referenceFrom(node) {
                    const result = evaluator.evaluateNode(node);
                    if (isMetadataError$1(result) || isMetadataSymbolicReferenceExpression(result) ||
                        isMetadataSymbolicSelectExpression(result)) {
                        return result;
                    }
                    else {
                        return errorSym('Symbol reference expected', node);
                    }
                }
                // Add class parents
                if (classDeclaration.heritageClauses) {
                    classDeclaration.heritageClauses.forEach((hc) => {
                        if (hc.token === ts.SyntaxKind.ExtendsKeyword && hc.types) {
                            hc.types.forEach(type => result.extends = referenceFrom(type.expression));
                        }
                    });
                }
                // Add arity if the type is generic
                const typeParameters = classDeclaration.typeParameters;
                if (typeParameters && typeParameters.length) {
                    result.arity = typeParameters.length;
                }
                // Add class decorators
                if (classDeclaration.decorators) {
                    result.decorators = getDecorators(classDeclaration.decorators);
                }
                // member decorators
                let members = null;
                function recordMember(name, metadata) {
                    if (!members)
                        members = {};
                    const data = members.hasOwnProperty(name) ? members[name] : [];
                    data.push(metadata);
                    members[name] = data;
                }
                // static member
                let statics = null;
                function recordStaticMember(name, value) {
                    if (!statics)
                        statics = {};
                    statics[name] = value;
                }
                for (const member of classDeclaration.members) {
                    let isConstructor = false;
                    switch (member.kind) {
                        case ts.SyntaxKind.Constructor:
                        case ts.SyntaxKind.MethodDeclaration:
                            isConstructor = member.kind === ts.SyntaxKind.Constructor;
                            const method = member;
                            if (isStatic(method)) {
                                const maybeFunc = maybeGetSimpleFunction(method);
                                if (maybeFunc) {
                                    recordStaticMember(maybeFunc.name, maybeFunc.func);
                                }
                                continue;
                            }
                            const methodDecorators = getDecorators(method.decorators);
                            const parameters = method.parameters;
                            const parameterDecoratorData = [];
                            const parametersData = [];
                            let hasDecoratorData = false;
                            let hasParameterData = false;
                            for (const parameter of parameters) {
                                const parameterData = getDecorators(parameter.decorators);
                                parameterDecoratorData.push(parameterData);
                                hasDecoratorData = hasDecoratorData || !!parameterData;
                                if (isConstructor) {
                                    if (parameter.type) {
                                        parametersData.push(referenceFrom(parameter.type));
                                    }
                                    else {
                                        parametersData.push(null);
                                    }
                                    hasParameterData = true;
                                }
                            }
                            const data = { __symbolic: isConstructor ? 'constructor' : 'method' };
                            const name = isConstructor ? '__ctor__' : evaluator.nameOf(member.name);
                            if (methodDecorators) {
                                data.decorators = methodDecorators;
                            }
                            if (hasDecoratorData) {
                                data.parameterDecorators = parameterDecoratorData;
                            }
                            if (hasParameterData) {
                                data.parameters = parametersData;
                            }
                            if (!isMetadataError$1(name)) {
                                recordMember(name, data);
                            }
                            break;
                        case ts.SyntaxKind.PropertyDeclaration:
                        case ts.SyntaxKind.GetAccessor:
                        case ts.SyntaxKind.SetAccessor:
                            const property = member;
                            if (isStatic(property)) {
                                const name = evaluator.nameOf(property.name);
                                if (!isMetadataError$1(name) && !shouldIgnoreStaticMember(name)) {
                                    if (property.initializer) {
                                        const value = evaluator.evaluateNode(property.initializer);
                                        recordStaticMember(name, value);
                                    }
                                    else {
                                        recordStaticMember(name, errorSym('Variable not initialized', property.name));
                                    }
                                }
                            }
                            const propertyDecorators = getDecorators(property.decorators);
                            if (propertyDecorators) {
                                const name = evaluator.nameOf(property.name);
                                if (!isMetadataError$1(name)) {
                                    recordMember(name, { __symbolic: 'property', decorators: propertyDecorators });
                                }
                            }
                            break;
                    }
                }
                if (members) {
                    result.members = members;
                }
                if (statics) {
                    result.statics = statics;
                }
                return recordEntry(result, classDeclaration);
            }
            // Collect all exported symbols from an exports clause.
            const exportMap = new Map();
            ts.forEachChild(sourceFile, node => {
                switch (node.kind) {
                    case ts.SyntaxKind.ExportDeclaration:
                        const exportDeclaration = node;
                        const { moduleSpecifier, exportClause } = exportDeclaration;
                        if (!moduleSpecifier && exportClause && ts.isNamedExports(exportClause)) {
                            // If there is a module specifier there is also an exportClause
                            exportClause.elements.forEach(spec => {
                                const exportedAs = spec.name.text;
                                const name = (spec.propertyName || spec.name).text;
                                exportMap.set(name, exportedAs);
                            });
                        }
                }
            });
            const isExport = (node) => sourceFile.isDeclarationFile ||
                ts.getCombinedModifierFlags(node) & ts.ModifierFlags.Export;
            const isExportedIdentifier = (identifier) => identifier && exportMap.has(identifier.text);
            const isExported = (node) => isExport(node) || isExportedIdentifier(node.name);
            const exportedIdentifierName = (identifier) => identifier && (exportMap.get(identifier.text) || identifier.text);
            const exportedName = (node) => exportedIdentifierName(node.name);
            // Pre-declare classes and functions
            ts.forEachChild(sourceFile, node => {
                switch (node.kind) {
                    case ts.SyntaxKind.ClassDeclaration:
                        const classDeclaration = node;
                        if (classDeclaration.name) {
                            const className = classDeclaration.name.text;
                            if (isExported(classDeclaration)) {
                                locals.define(className, { __symbolic: 'reference', name: exportedName(classDeclaration) });
                            }
                            else {
                                locals.define(className, errorSym('Reference to non-exported class', node, { className }));
                            }
                        }
                        break;
                    case ts.SyntaxKind.InterfaceDeclaration:
                        const interfaceDeclaration = node;
                        if (interfaceDeclaration.name) {
                            const interfaceName = interfaceDeclaration.name.text;
                            // All references to interfaces should be converted to references to `any`.
                            locals.define(interfaceName, { __symbolic: 'reference', name: 'any' });
                        }
                        break;
                    case ts.SyntaxKind.FunctionDeclaration:
                        const functionDeclaration = node;
                        if (!isExported(functionDeclaration)) {
                            // Report references to this function as an error.
                            const nameNode = functionDeclaration.name;
                            if (nameNode && nameNode.text) {
                                locals.define(nameNode.text, errorSym('Reference to a non-exported function', nameNode, { name: nameNode.text }));
                            }
                        }
                        break;
                }
            });
            ts.forEachChild(sourceFile, node => {
                switch (node.kind) {
                    case ts.SyntaxKind.ExportDeclaration:
                        // Record export declarations
                        const exportDeclaration = node;
                        const { moduleSpecifier, exportClause } = exportDeclaration;
                        if (!moduleSpecifier) {
                            // no module specifier -> export {propName as name};
                            if (exportClause && ts.isNamedExports(exportClause)) {
                                exportClause.elements.forEach(spec => {
                                    const name = spec.name.text;
                                    // If the symbol was not already exported, export a reference since it is a
                                    // reference to an import
                                    if (!metadata || !metadata[name]) {
                                        const propNode = spec.propertyName || spec.name;
                                        const value = evaluator.evaluateNode(propNode);
                                        if (!metadata)
                                            metadata = {};
                                        metadata[name] = recordEntry(value, node);
                                    }
                                });
                            }
                        }
                        if (moduleSpecifier && moduleSpecifier.kind == ts.SyntaxKind.StringLiteral) {
                            // Ignore exports that don't have string literals as exports.
                            // This is allowed by the syntax but will be flagged as an error by the type checker.
                            const from = moduleSpecifier.text;
                            const moduleExport = { from };
                            if (exportClause && ts.isNamedExports(exportClause)) {
                                moduleExport.export = exportClause.elements.map(spec => spec.propertyName ? { name: spec.propertyName.text, as: spec.name.text } :
                                    spec.name.text);
                            }
                            if (!exports)
                                exports = [];
                            exports.push(moduleExport);
                        }
                        break;
                    case ts.SyntaxKind.ClassDeclaration:
                        const classDeclaration = node;
                        if (classDeclaration.name) {
                            if (isExported(classDeclaration)) {
                                const name = exportedName(classDeclaration);
                                if (name) {
                                    if (!metadata)
                                        metadata = {};
                                    metadata[name] = classMetadataOf(classDeclaration);
                                }
                            }
                        }
                        // Otherwise don't record metadata for the class.
                        break;
                    case ts.SyntaxKind.TypeAliasDeclaration:
                        const typeDeclaration = node;
                        if (typeDeclaration.name && isExported(typeDeclaration)) {
                            const name = exportedName(typeDeclaration);
                            if (name) {
                                if (!metadata)
                                    metadata = {};
                                metadata[name] = { __symbolic: 'interface' };
                            }
                        }
                        break;
                    case ts.SyntaxKind.InterfaceDeclaration:
                        const interfaceDeclaration = node;
                        if (interfaceDeclaration.name && isExported(interfaceDeclaration)) {
                            const name = exportedName(interfaceDeclaration);
                            if (name) {
                                if (!metadata)
                                    metadata = {};
                                metadata[name] = { __symbolic: 'interface' };
                            }
                        }
                        break;
                    case ts.SyntaxKind.FunctionDeclaration:
                        // Record functions that return a single value. Record the parameter
                        // names substitution will be performed by the StaticReflector.
                        const functionDeclaration = node;
                        if (isExported(functionDeclaration) && functionDeclaration.name) {
                            const name = exportedName(functionDeclaration);
                            const maybeFunc = maybeGetSimpleFunction(functionDeclaration);
                            if (name) {
                                if (!metadata)
                                    metadata = {};
                                // TODO(alxhub): The literal here is not valid FunctionMetadata.
                                metadata[name] =
                                    maybeFunc ? recordEntry(maybeFunc.func, node) : { __symbolic: 'function' };
                            }
                        }
                        break;
                    case ts.SyntaxKind.EnumDeclaration:
                        const enumDeclaration = node;
                        if (isExported(enumDeclaration)) {
                            const enumValueHolder = {};
                            const enumName = exportedName(enumDeclaration);
                            let nextDefaultValue = 0;
                            let writtenMembers = 0;
                            for (const member of enumDeclaration.members) {
                                let enumValue;
                                if (!member.initializer) {
                                    enumValue = nextDefaultValue;
                                }
                                else {
                                    enumValue = evaluator.evaluateNode(member.initializer);
                                }
                                let name = undefined;
                                if (member.name.kind == ts.SyntaxKind.Identifier) {
                                    const identifier = member.name;
                                    name = identifier.text;
                                    enumValueHolder[name] = enumValue;
                                    writtenMembers++;
                                }
                                if (typeof enumValue === 'number') {
                                    nextDefaultValue = enumValue + 1;
                                }
                                else if (name) {
                                    // TODO(alxhub): 'left' here has a name propery which is not valid for
                                    // MetadataSymbolicSelectExpression.
                                    nextDefaultValue = {
                                        __symbolic: 'binary',
                                        operator: '+',
                                        left: {
                                            __symbolic: 'select',
                                            expression: recordEntry({ __symbolic: 'reference', name: enumName }, node),
                                            name
                                        },
                                    };
                                }
                                else {
                                    nextDefaultValue =
                                        recordEntry(errorSym('Unsupported enum member name', member.name), node);
                                }
                            }
                            if (writtenMembers) {
                                if (enumName) {
                                    if (!metadata)
                                        metadata = {};
                                    metadata[enumName] = recordEntry(enumValueHolder, node);
                                }
                            }
                        }
                        break;
                    case ts.SyntaxKind.VariableStatement:
                        const variableStatement = node;
                        for (const variableDeclaration of variableStatement.declarationList.declarations) {
                            if (variableDeclaration.name.kind == ts.SyntaxKind.Identifier) {
                                const nameNode = variableDeclaration.name;
                                let varValue;
                                if (variableDeclaration.initializer) {
                                    varValue = evaluator.evaluateNode(variableDeclaration.initializer);
                                }
                                else {
                                    varValue = recordEntry(errorSym('Variable not initialized', nameNode), nameNode);
                                }
                                let exported = false;
                                if (isExport(variableStatement) || isExport(variableDeclaration) ||
                                    isExportedIdentifier(nameNode)) {
                                    const name = exportedIdentifierName(nameNode);
                                    if (name) {
                                        if (!metadata)
                                            metadata = {};
                                        metadata[name] = recordEntry(varValue, node);
                                    }
                                    exported = true;
                                }
                                if (typeof varValue == 'string' || typeof varValue == 'number' ||
                                    typeof varValue == 'boolean') {
                                    locals.define(nameNode.text, varValue);
                                    if (exported) {
                                        locals.defineReference(nameNode.text, { __symbolic: 'reference', name: nameNode.text });
                                    }
                                }
                                else if (!exported) {
                                    if (varValue && !isMetadataError$1(varValue)) {
                                        locals.define(nameNode.text, recordEntry(varValue, node));
                                    }
                                    else {
                                        locals.define(nameNode.text, recordEntry(errorSym('Reference to a local symbol', nameNode, { name: nameNode.text }), node));
                                    }
                                }
                            }
                            else {
                                // Destructuring (or binding) declarations are not supported,
                                // var {<identifier>[, <identifier>]+} = <expression>;
                                //   or
                                // var [<identifier>[, <identifier}+] = <expression>;
                                // are not supported.
                                const report = (nameNode) => {
                                    switch (nameNode.kind) {
                                        case ts.SyntaxKind.Identifier:
                                            const name = nameNode;
                                            const varValue = errorSym('Destructuring not supported', name);
                                            locals.define(name.text, varValue);
                                            if (isExport(node)) {
                                                if (!metadata)
                                                    metadata = {};
                                                metadata[name.text] = varValue;
                                            }
                                            break;
                                        case ts.SyntaxKind.BindingElement:
                                            const bindingElement = nameNode;
                                            report(bindingElement.name);
                                            break;
                                        case ts.SyntaxKind.ObjectBindingPattern:
                                        case ts.SyntaxKind.ArrayBindingPattern:
                                            const bindings = nameNode;
                                            bindings.elements.forEach(report);
                                            break;
                                    }
                                };
                                report(variableDeclaration.name);
                            }
                        }
                        break;
                }
            });
            if (metadata || exports) {
                if (!metadata)
                    metadata = {};
                else if (strict) {
                    validateMetadata(sourceFile, nodeMap, metadata);
                }
                const result = {
                    __symbolic: 'module',
                    version: this.options.version || METADATA_VERSION,
                    metadata
                };
                if (sourceFile.moduleName)
                    result.importAs = sourceFile.moduleName;
                if (exports)
                    result.exports = exports;
                return result;
            }
        }
    }
    // This will throw if the metadata entry given contains an error node.
    function validateMetadata(sourceFile, nodeMap, metadata) {
        let locals = new Set(['Array', 'Object', 'Set', 'Map', 'string', 'number', 'any']);
        function validateExpression(expression) {
            if (!expression) {
                return;
            }
            else if (Array.isArray(expression)) {
                expression.forEach(validateExpression);
            }
            else if (typeof expression === 'object' && !expression.hasOwnProperty('__symbolic')) {
                Object.getOwnPropertyNames(expression).forEach(v => validateExpression(expression[v]));
            }
            else if (isMetadataError$1(expression)) {
                reportError(expression);
            }
            else if (isMetadataGlobalReferenceExpression(expression)) {
                if (!locals.has(expression.name)) {
                    const reference = metadata[expression.name];
                    if (reference) {
                        validateExpression(reference);
                    }
                }
            }
            else if (isFunctionMetadata(expression)) {
                validateFunction(expression);
            }
            else if (isMetadataSymbolicExpression(expression)) {
                switch (expression.__symbolic) {
                    case 'binary':
                        const binaryExpression = expression;
                        validateExpression(binaryExpression.left);
                        validateExpression(binaryExpression.right);
                        break;
                    case 'call':
                    case 'new':
                        const callExpression = expression;
                        validateExpression(callExpression.expression);
                        if (callExpression.arguments)
                            callExpression.arguments.forEach(validateExpression);
                        break;
                    case 'index':
                        const indexExpression = expression;
                        validateExpression(indexExpression.expression);
                        validateExpression(indexExpression.index);
                        break;
                    case 'pre':
                        const prefixExpression = expression;
                        validateExpression(prefixExpression.operand);
                        break;
                    case 'select':
                        const selectExpression = expression;
                        validateExpression(selectExpression.expression);
                        break;
                    case 'spread':
                        const spreadExpression = expression;
                        validateExpression(spreadExpression.expression);
                        break;
                    case 'if':
                        const ifExpression = expression;
                        validateExpression(ifExpression.condition);
                        validateExpression(ifExpression.elseExpression);
                        validateExpression(ifExpression.thenExpression);
                        break;
                }
            }
        }
        function validateMember(classData, member) {
            if (member.decorators) {
                member.decorators.forEach(validateExpression);
            }
            if (isMethodMetadata(member) && member.parameterDecorators) {
                member.parameterDecorators.forEach(validateExpression);
            }
            // Only validate parameters of classes for which we know that are used with our DI
            if (classData.decorators && isConstructorMetadata(member) && member.parameters) {
                member.parameters.forEach(validateExpression);
            }
        }
        function validateClass(classData) {
            if (classData.decorators) {
                classData.decorators.forEach(validateExpression);
            }
            if (classData.members) {
                Object.getOwnPropertyNames(classData.members)
                    .forEach(name => classData.members[name].forEach((m) => validateMember(classData, m)));
            }
            if (classData.statics) {
                Object.getOwnPropertyNames(classData.statics).forEach(name => {
                    const staticMember = classData.statics[name];
                    if (isFunctionMetadata(staticMember)) {
                        validateExpression(staticMember.value);
                    }
                    else {
                        validateExpression(staticMember);
                    }
                });
            }
        }
        function validateFunction(functionDeclaration) {
            if (functionDeclaration.value) {
                const oldLocals = locals;
                if (functionDeclaration.parameters) {
                    locals = new Set(oldLocals.values());
                    if (functionDeclaration.parameters)
                        functionDeclaration.parameters.forEach(n => locals.add(n));
                }
                validateExpression(functionDeclaration.value);
                locals = oldLocals;
            }
        }
        function shouldReportNode(node) {
            if (node) {
                const nodeStart = node.getStart();
                return !(node.pos != nodeStart &&
                    sourceFile.text.substring(node.pos, nodeStart).indexOf('@dynamic') >= 0);
            }
            return true;
        }
        function reportError(error) {
            const node = nodeMap.get(error);
            if (shouldReportNode(node)) {
                const lineInfo = error.line != undefined ? error.character != undefined ?
                    `:${error.line + 1}:${error.character + 1}` :
                    `:${error.line + 1}` :
                    '';
                throw new Error(`${sourceFile.fileName}${lineInfo}: Metadata collected contains an error that will be reported at runtime: ${expandedMessage$1(error)}.\n  ${JSON.stringify(error)}`);
            }
        }
        Object.getOwnPropertyNames(metadata).forEach(name => {
            const entry = metadata[name];
            try {
                if (isClassMetadata(entry)) {
                    validateClass(entry);
                }
            }
            catch (e) {
                const node = nodeMap.get(entry);
                if (shouldReportNode(node)) {
                    if (node) {
                        const { line, character } = sourceFile.getLineAndCharacterOfPosition(node.getStart());
                        throw new Error(`${sourceFile.fileName}:${line + 1}:${character + 1}: Error encountered in metadata generated for exported symbol '${name}': \n ${e.message}`);
                    }
                    throw new Error(`Error encountered in metadata generated for exported symbol ${name}: \n ${e.message}`);
                }
            }
        });
    }
    // Collect parameter names from a function.
    function namesOf(parameters) {
        const result = [];
        function addNamesOf(name) {
            if (name.kind == ts.SyntaxKind.Identifier) {
                const identifier = name;
                result.push(identifier.text);
            }
            else {
                const bindingPattern = name;
                for (const element of bindingPattern.elements) {
                    const name = element.name;
                    if (name) {
                        addNamesOf(name);
                    }
                }
            }
        }
        for (const parameter of parameters) {
            addNamesOf(parameter.name);
        }
        return result;
    }
    function shouldIgnoreStaticMember(memberName) {
        return memberName.startsWith('ngAcceptInputType_') || memberName.startsWith('ngTemplateGuard_');
    }
    function expandedMessage$1(error) {
        switch (error.message) {
            case 'Reference to non-exported class':
                if (error.context && error.context.className) {
                    return `Reference to a non-exported class ${error.context.className}. Consider exporting the class`;
                }
                break;
            case 'Variable not initialized':
                return 'Only initialized variables and constants can be referenced because the value of this variable is needed by the template compiler';
            case 'Destructuring not supported':
                return 'Referencing an exported destructured variable or constant is not supported by the template compiler. Consider simplifying this to avoid destructuring';
            case 'Could not resolve type':
                if (error.context && error.context.typeName) {
                    return `Could not resolve type ${error.context.typeName}`;
                }
                break;
            case 'Function call not supported':
                let prefix = error.context && error.context.name ? `Calling function '${error.context.name}', f` : 'F';
                return prefix +
                    'unction calls are not supported. Consider replacing the function or lambda with a reference to an exported function';
            case 'Reference to a local symbol':
                if (error.context && error.context.name) {
                    return `Reference to a local (non-exported) symbol '${error.context.name}'. Consider exporting the symbol`;
                }
        }
        return error.message;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var EmitFlags;
    (function (EmitFlags) {
        EmitFlags[EmitFlags["DTS"] = 1] = "DTS";
        EmitFlags[EmitFlags["JS"] = 2] = "JS";
        EmitFlags[EmitFlags["Metadata"] = 4] = "Metadata";
        EmitFlags[EmitFlags["I18nBundle"] = 8] = "I18nBundle";
        EmitFlags[EmitFlags["Codegen"] = 16] = "Codegen";
        EmitFlags[EmitFlags["Default"] = 19] = "Default";
        EmitFlags[EmitFlags["All"] = 31] = "All";
    })(EmitFlags || (EmitFlags = {}));

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const DTS = /\.d\.ts$/;

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function createMetadataReaderCache() {
        const data = new Map();
        return { data };
    }
    function readMetadata(filePath, host, cache) {
        let metadatas = cache && cache.data.get(filePath);
        if (metadatas) {
            return metadatas;
        }
        if (host.fileExists(filePath)) {
            // If the file doesn't exists then we cannot return metadata for the file.
            // This will occur if the user referenced a declared module for which no file
            // exists for the module (i.e. jQuery or angularjs).
            if (DTS.test(filePath)) {
                metadatas = readMetadataFile(host, filePath);
                if (!metadatas) {
                    // If there is a .d.ts file but no metadata file we need to produce a
                    // metadata from the .d.ts file as metadata files capture reexports
                    // (starting with v3).
                    metadatas = [upgradeMetadataWithDtsData(host, { '__symbolic': 'module', 'version': 1, 'metadata': {} }, filePath)];
                }
            }
            else {
                const metadata = host.getSourceFileMetadata(filePath);
                metadatas = metadata ? [metadata] : [];
            }
        }
        if (cache && (!host.cacheMetadata || host.cacheMetadata(filePath))) {
            cache.data.set(filePath, metadatas);
        }
        return metadatas;
    }
    function readMetadataFile(host, dtsFilePath) {
        const metadataPath = dtsFilePath.replace(DTS, '.metadata.json');
        if (!host.fileExists(metadataPath)) {
            return undefined;
        }
        try {
            const metadataOrMetadatas = JSON.parse(host.readFile(metadataPath));
            const metadatas = metadataOrMetadatas ?
                (Array.isArray(metadataOrMetadatas) ? metadataOrMetadatas : [metadataOrMetadatas]) :
                [];
            if (metadatas.length) {
                let maxMetadata = metadatas.reduce((p, c) => p.version > c.version ? p : c);
                if (maxMetadata.version < METADATA_VERSION) {
                    metadatas.push(upgradeMetadataWithDtsData(host, maxMetadata, dtsFilePath));
                }
            }
            return metadatas;
        }
        catch (e) {
            console.error(`Failed to read JSON file ${metadataPath}`);
            throw e;
        }
    }
    function upgradeMetadataWithDtsData(host, oldMetadata, dtsFilePath) {
        // patch v1 to v3 by adding exports and the `extends` clause.
        // patch v3 to v4 by adding `interface` symbols for TypeAlias
        let newMetadata = {
            '__symbolic': 'module',
            'version': METADATA_VERSION,
            'metadata': Object.assign({}, oldMetadata.metadata),
        };
        if (oldMetadata.exports) {
            newMetadata.exports = oldMetadata.exports;
        }
        if (oldMetadata.importAs) {
            newMetadata.importAs = oldMetadata.importAs;
        }
        if (oldMetadata.origins) {
            newMetadata.origins = oldMetadata.origins;
        }
        const dtsMetadata = host.getSourceFileMetadata(dtsFilePath);
        if (dtsMetadata) {
            for (let prop in dtsMetadata.metadata) {
                if (!newMetadata.metadata[prop]) {
                    newMetadata.metadata[prop] = dtsMetadata.metadata[prop];
                }
            }
            if (dtsMetadata['importAs'])
                newMetadata['importAs'] = dtsMetadata['importAs'];
            // Only copy exports from exports from metadata prior to version 3.
            // Starting with version 3 the collector began collecting exports and
            // this should be redundant. Also, with bundler will rewrite the exports
            // which will hoist the exports from modules referenced indirectly causing
            // the imports to be different than the .d.ts files and using the .d.ts file
            // exports would cause the StaticSymbolResolver to redirect symbols to the
            // incorrect location.
            if ((!oldMetadata.version || oldMetadata.version < 3) && dtsMetadata.exports) {
                newMetadata.exports = dtsMetadata.exports;
            }
        }
        return newMetadata;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class ReflectorModuleModuleResolutionHost {
        constructor(tsLSHost, getProgram) {
            this.tsLSHost = tsLSHost;
            this.getProgram = getProgram;
            this.metadataCollector = new MetadataCollector({
                // Note: verboseInvalidExpressions is important so that
                // the collector will collect errors instead of throwing
                verboseInvalidExpression: true,
            });
            if (tsLSHost.directoryExists) {
                this.directoryExists = directoryName => tsLSHost.directoryExists(directoryName);
            }
            if (tsLSHost.realpath) {
                this.realpath = path => tsLSHost.realpath(path);
            }
        }
        fileExists(fileName) {
            // TypeScript resolution logic walks through the following sequence in order:
            // package.json (read "types" field) -> .ts -> .tsx -> .d.ts
            // For more info, see
            // https://www.typescriptlang.org/docs/handbook/module-resolution.html
            // For Angular specifically, we can skip .tsx lookup
            if (fileName.endsWith('.tsx')) {
                return false;
            }
            if (this.tsLSHost.fileExists) {
                return this.tsLSHost.fileExists(fileName);
            }
            return !!this.tsLSHost.getScriptSnapshot(fileName);
        }
        readFile(fileName) {
            // readFile() is used by TypeScript to read package.json during module
            // resolution, and it's used by Angular to read metadata.json during
            // metadata resolution.
            if (this.tsLSHost.readFile) {
                return this.tsLSHost.readFile(fileName);
            }
            // As a fallback, read the JSON files from the editor snapshot.
            const snapshot = this.tsLSHost.getScriptSnapshot(fileName);
            if (!snapshot) {
                // MetadataReaderHost readFile() declaration should be
                // `readFile(fileName: string): string | undefined`
                return undefined;
            }
            return snapshot.getText(0, snapshot.getLength());
        }
        getSourceFileMetadata(fileName) {
            const sf = this.getProgram().getSourceFile(fileName);
            return sf ? this.metadataCollector.getMetadata(sf) : undefined;
        }
        cacheMetadata(fileName) {
            // Don't cache the metadata for .ts files as they might change in the editor!
            return fileName.endsWith('.d.ts');
        }
    }
    class ReflectorHost {
        constructor(getProgram, tsLSHost) {
            this.tsLSHost = tsLSHost;
            this.metadataReaderCache = createMetadataReaderCache();
            // tsLSHost.getCurrentDirectory() returns the directory where tsconfig.json
            // is located. This is not the same as process.cwd() because the language
            // service host sets the "project root path" as its current directory.
            const currentDir = tsLSHost.getCurrentDirectory();
            this.fakeContainingPath = currentDir ? path.join(currentDir, 'fakeContainingFile.ts') : '';
            this.hostAdapter = new ReflectorModuleModuleResolutionHost(tsLSHost, getProgram);
            this.moduleResolutionCache = ts.createModuleResolutionCache(currentDir, s => s, // getCanonicalFileName
            tsLSHost.getCompilationSettings());
        }
        getMetadataFor(modulePath) {
            return readMetadata(modulePath, this.hostAdapter, this.metadataReaderCache);
        }
        moduleNameToFileName(moduleName, containingFile) {
            if (!containingFile) {
                if (moduleName.startsWith('.')) {
                    throw new Error('Resolution of relative paths requires a containing file.');
                }
                if (!this.fakeContainingPath) {
                    // If current directory is empty then the file must belong to an inferred
                    // project (no tsconfig.json), in which case it's not possible to resolve
                    // the module without the caller explicitly providing a containing file.
                    throw new Error(`Could not resolve '${moduleName}' without a containing file.`);
                }
                containingFile = this.fakeContainingPath;
            }
            const compilerOptions = this.tsLSHost.getCompilationSettings();
            const resolved = ts.resolveModuleName(moduleName, containingFile, compilerOptions, this.hostAdapter, this.moduleResolutionCache)
                .resolvedModule;
            return resolved ? resolved.resolvedFileName : null;
        }
        getOutputName(filePath) {
            return filePath;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * The language service never needs the normalized versions of the metadata. To avoid parsing
     * the content and resolving references, return an empty file. This also allows normalizing
     * template that are syntatically incorrect which is required to provide completions in
     * syntactically incorrect templates.
     */
    class DummyHtmlParser extends HtmlParser {
        parse() {
            return new ParseTreeResult([], []);
        }
    }
    /**
     * Avoid loading resources in the language servcie by using a dummy loader.
     */
    class DummyResourceLoader extends ResourceLoader {
        get(_url) {
            return Promise.resolve('');
        }
    }
    /**
     * An implementation of a `LanguageServiceHost` for a TypeScript project.
     *
     * The `TypeScriptServiceHost` implements the Angular `LanguageServiceHost` using
     * the TypeScript language services.
     *
     * @publicApi
     */
    class TypeScriptServiceHost {
        constructor(tsLsHost, tsLS) {
            this.tsLsHost = tsLsHost;
            this.tsLS = tsLS;
            this.staticSymbolCache = new StaticSymbolCache();
            /**
             * Key of the `fileToComponent` map must be TS internal normalized path (path
             * separator must be `/`), value of the map is the StaticSymbol for the
             * Component class declaration.
             */
            this.fileToComponent = new Map();
            this.collectedErrors = new Map();
            this.fileVersions = new Map();
            this.lastProgram = undefined;
            this.analyzedModules = {
                files: [],
                ngModuleByPipeOrDirective: new Map(),
                ngModules: [],
            };
            this.summaryResolver = new AotSummaryResolver({
                loadSummary(_filePath) {
                    return null;
                },
                isSourceFile(_sourceFilePath) {
                    return true;
                },
                toSummaryFileName(sourceFilePath) {
                    return sourceFilePath;
                },
                fromSummaryFileName(filePath) {
                    return filePath;
                },
            }, this.staticSymbolCache);
            this.reflectorHost = new ReflectorHost(() => this.program, tsLsHost);
            this.staticSymbolResolver = new StaticSymbolResolver(this.reflectorHost, this.staticSymbolCache, this.summaryResolver, (e, filePath) => this.collectError(e, filePath));
            this.urlResolver = {
                resolve: (baseUrl, url) => {
                    // In practice, `directoryExists` is always defined.
                    // https://github.com/microsoft/TypeScript/blob/0b6c9254a850dd07056259d4eefca7721745af75/src/server/project.ts#L1608-L1614
                    if (tsLsHost.directoryExists(baseUrl)) {
                        return path.resolve(baseUrl, url);
                    }
                    return path.resolve(path.dirname(baseUrl), url);
                }
            };
        }
        /**
         * Return the singleton instance of the MetadataResolver.
         */
        get resolver() {
            if (this._resolver) {
                return this._resolver;
            }
            // StaticReflector keeps its own private caches that are not clearable.
            // We have no choice but to create a new instance to invalidate the caches.
            // TODO: Revisit this when language service gets rewritten for Ivy.
            const staticReflector = new StaticReflector(this.summaryResolver, this.staticSymbolResolver, [], // knownMetadataClasses
            [], // knownMetadataFunctions
            (e, filePath) => this.collectError(e, filePath));
            // Because static reflector above is changed, we need to create a new
            // resolver.
            const moduleResolver = new NgModuleResolver(staticReflector);
            const directiveResolver = new DirectiveResolver(staticReflector);
            const pipeResolver = new PipeResolver(staticReflector);
            const elementSchemaRegistry = new DomElementSchemaRegistry();
            const resourceLoader = new DummyResourceLoader();
            const htmlParser = new DummyHtmlParser();
            // This tracks the CompileConfig in codegen.ts. Currently these options
            // are hard-coded.
            const config = new CompilerConfig({
                defaultEncapsulation: ViewEncapsulation$1.Emulated,
                useJit: false,
            });
            const directiveNormalizer = new DirectiveNormalizer(resourceLoader, this.urlResolver, htmlParser, config);
            this._resolver = new CompileMetadataResolver(config, htmlParser, moduleResolver, directiveResolver, pipeResolver, new JitSummaryResolver(), elementSchemaRegistry, directiveNormalizer, new Console(), this.staticSymbolCache, staticReflector, (error, type) => this.collectError(error, type && type.filePath));
            return this._resolver;
        }
        /**
         * Return the singleton instance of the StaticReflector hosted in the
         * MetadataResolver.
         */
        get reflector() {
            return this.resolver.getReflector();
        }
        /**
         * Return all known external templates.
         */
        getExternalTemplates() {
            return [...this.fileToComponent.keys()];
        }
        /**
         * Checks whether the program has changed and returns all analyzed modules.
         * If program has changed, invalidate all caches and update fileToComponent
         * and templateReferences.
         * In addition to returning information about NgModules, this method plays the
         * same role as 'synchronizeHostData' in tsserver.
         */
        getAnalyzedModules() {
            if (this.upToDate()) {
                return this.analyzedModules;
            }
            // Invalidate caches
            this.fileToComponent.clear();
            this.collectedErrors.clear();
            this.resolver.clearCache();
            const analyzeHost = {
                isSourceFile(_filePath) {
                    return true;
                }
            };
            const programFiles = this.program.getSourceFiles().map(sf => sf.fileName);
            try {
                this.analyzedModules =
                    analyzeNgModules(programFiles, analyzeHost, this.staticSymbolResolver, this.resolver);
            }
            catch (e) {
                // Analyzing modules may throw; in that case, reuse the old modules.
                this.error(`Analyzing NgModules failed. ${e}`);
                return this.analyzedModules;
            }
            // update template references and fileToComponent
            for (const ngModule of this.analyzedModules.ngModules) {
                for (const directive of ngModule.declaredDirectives) {
                    const { metadata } = this.resolver.getNonNormalizedDirectiveMetadata(directive.reference);
                    if (metadata.isComponent && metadata.template && metadata.template.templateUrl) {
                        const templateName = this.urlResolver.resolve(this.reflector.componentModuleUrl(directive.reference), metadata.template.templateUrl);
                        this.fileToComponent.set(tss.server.toNormalizedPath(templateName), directive.reference);
                    }
                }
            }
            return this.analyzedModules;
        }
        /**
         * Checks whether the program has changed, and invalidate static symbols in
         * the source files that have changed.
         * Returns true if modules are up-to-date, false otherwise.
         * This should only be called by getAnalyzedModules().
         */
        upToDate() {
            const { lastProgram, program } = this;
            if (lastProgram === program) {
                return true;
            }
            this.lastProgram = program;
            // Even though the program has changed, it could be the case that none of
            // the source files have changed. If all source files remain the same, then
            // program is still up-to-date, and we should not invalidate caches.
            let filesAdded = 0;
            const filesChangedOrRemoved = [];
            // Check if any source files have been added / changed since last computation.
            const seen = new Set();
            const ANGULAR_CORE = '@angular/core';
            const corePath = this.reflectorHost.moduleNameToFileName(ANGULAR_CORE);
            for (const { fileName } of program.getSourceFiles()) {
                // If `@angular/core` is edited, the language service would have to be
                // restarted, so ignore changes to `@angular/core`.
                // When the StaticReflector is initialized at startup, it loads core
                // symbols from @angular/core by calling initializeConversionMap(). This
                // is only done once. If the file is invalidated, some of the core symbols
                // will be lost permanently.
                if (fileName === corePath) {
                    continue;
                }
                seen.add(fileName);
                const version = this.tsLsHost.getScriptVersion(fileName);
                const lastVersion = this.fileVersions.get(fileName);
                if (lastVersion === undefined) {
                    filesAdded++;
                    this.fileVersions.set(fileName, version);
                }
                else if (version !== lastVersion) {
                    filesChangedOrRemoved.push(fileName); // changed
                    this.fileVersions.set(fileName, version);
                }
            }
            // Check if any source files have been removed since last computation.
            for (const [fileName] of this.fileVersions) {
                if (!seen.has(fileName)) {
                    filesChangedOrRemoved.push(fileName); // removed
                    // Because Maps are iterated in insertion order, it is safe to delete
                    // entries from the same map while iterating.
                    // See https://stackoverflow.com/questions/35940216 and
                    // https://www.ecma-international.org/ecma-262/10.0/index.html#sec-map.prototype.foreach
                    this.fileVersions.delete(fileName);
                }
            }
            for (const fileName of filesChangedOrRemoved) {
                const symbols = this.staticSymbolResolver.invalidateFile(fileName);
                this.reflector.invalidateSymbols(symbols);
            }
            // Program is up-to-date iff no files are added, changed, or removed.
            return filesAdded === 0 && filesChangedOrRemoved.length === 0;
        }
        /**
         * Find all templates in the specified `file`.
         * @param fileName TS or HTML file
         */
        getTemplates(fileName) {
            const results = [];
            if (fileName.endsWith('.ts')) {
                // Find every template string in the file
                const visit = (child) => {
                    const template = this.getInternalTemplate(child);
                    if (template) {
                        results.push(template);
                    }
                    else {
                        tss.forEachChild(child, visit);
                    }
                };
                const sourceFile = this.getSourceFile(fileName);
                if (sourceFile) {
                    tss.forEachChild(sourceFile, visit);
                }
            }
            else {
                const template = this.getExternalTemplate(fileName);
                if (template) {
                    results.push(template);
                }
            }
            return results;
        }
        /**
         * Return metadata about all class declarations in the file that are Angular
         * directives. Potential matches are `@NgModule`, `@Component`, `@Directive`,
         * `@Pipes`, etc. class declarations.
         *
         * @param fileName TS file
         */
        getDeclarations(fileName) {
            if (!fileName.endsWith('.ts')) {
                return [];
            }
            const sourceFile = this.getSourceFile(fileName);
            if (!sourceFile) {
                return [];
            }
            const results = [];
            const visit = (child) => {
                const candidate = getDirectiveClassLike(child);
                if (candidate) {
                    const { classId } = candidate;
                    const declarationSpan = spanOf$2(classId);
                    const className = classId.getText();
                    const classSymbol = this.reflector.getStaticSymbol(sourceFile.fileName, className);
                    // Ask the resolver to check if candidate is actually Angular directive
                    if (!this.resolver.isDirective(classSymbol)) {
                        return;
                    }
                    const data = this.resolver.getNonNormalizedDirectiveMetadata(classSymbol);
                    if (!data) {
                        return;
                    }
                    results.push({
                        type: classSymbol,
                        declarationSpan,
                        metadata: data.metadata,
                        errors: this.getCollectedErrors(declarationSpan, sourceFile),
                    });
                }
                else {
                    child.forEachChild(visit);
                }
            };
            tss.forEachChild(sourceFile, visit);
            return results;
        }
        getSourceFile(fileName) {
            if (!fileName.endsWith('.ts')) {
                throw new Error(`Non-TS source file requested: ${fileName}`);
            }
            return this.program.getSourceFile(fileName);
        }
        get program() {
            const program = this.tsLS.getProgram();
            if (!program) {
                // Program is very very unlikely to be undefined.
                throw new Error('No program in language service!');
            }
            return program;
        }
        /**
         * Return the TemplateSource if `node` is a template node.
         *
         * For example,
         *
         * @Component({
         *   template: '<div></div>' <-- template node
         * })
         * class AppComponent {}
         *           ^---- class declaration node
         *
         * @param node Potential template node
         */
        getInternalTemplate(node) {
            if (!tss.isStringLiteralLike(node)) {
                return;
            }
            const tmplAsgn = getPropertyAssignmentFromValue(node, 'template');
            if (!tmplAsgn) {
                return;
            }
            const classDecl = getClassDeclFromDecoratorProp(tmplAsgn);
            if (!classDecl || !classDecl.name) { // Does not handle anonymous class
                return;
            }
            const fileName = node.getSourceFile().fileName;
            const classSymbol = this.reflector.getStaticSymbol(fileName, classDecl.name.text);
            return new InlineTemplate(node, classDecl, classSymbol, this);
        }
        /**
         * Return the external template for `fileName`.
         * @param fileName HTML file
         */
        getExternalTemplate(fileName) {
            // First get the text for the template
            const snapshot = this.tsLsHost.getScriptSnapshot(fileName);
            if (!snapshot) {
                return;
            }
            const source = snapshot.getText(0, snapshot.getLength());
            // Next find the component class symbol
            const classSymbol = this.fileToComponent.get(tss.server.toNormalizedPath(fileName));
            if (!classSymbol) {
                return;
            }
            // Then use the class symbol to find the actual ts.ClassDeclaration node
            const sourceFile = this.getSourceFile(classSymbol.filePath);
            if (!sourceFile) {
                return;
            }
            // TODO: This only considers top-level class declarations in a source file.
            // This would not find a class declaration in a namespace, for example.
            const classDecl = sourceFile.forEachChild((child) => {
                if (tss.isClassDeclaration(child) && child.name && child.name.text === classSymbol.name) {
                    return child;
                }
            });
            if (!classDecl) {
                return;
            }
            return new ExternalTemplate(source, fileName, classDecl, classSymbol, this);
        }
        collectError(error, filePath) {
            if (filePath) {
                let errors = this.collectedErrors.get(filePath);
                if (!errors) {
                    errors = [];
                    this.collectedErrors.set(filePath, errors);
                }
                errors.push(error);
            }
        }
        getCollectedErrors(defaultSpan, sourceFile) {
            const errors = this.collectedErrors.get(sourceFile.fileName);
            if (!errors) {
                return [];
            }
            // TODO: Add better typings for the errors
            return errors.map((e) => {
                const line = e.line || (e.position && e.position.line);
                const column = e.column || (e.position && e.position.column);
                const span = spanAt$1(sourceFile, line, column) || defaultSpan;
                if (isFormattedError(e)) {
                    return errorToDiagnosticWithChain(e, span);
                }
                return { message: e.message, span };
            });
        }
        /**
         * Return the parsed template for the template at the specified `position`.
         * @param fileName TS or HTML file
         * @param position Position of the template in the TS file, otherwise ignored.
         */
        getTemplateAstAtPosition(fileName, position) {
            let template;
            if (fileName.endsWith('.ts')) {
                const sourceFile = this.getSourceFile(fileName);
                if (!sourceFile) {
                    return;
                }
                // Find the node that most closely matches the position
                const node = findTightestNode(sourceFile, position);
                if (!node) {
                    return;
                }
                template = this.getInternalTemplate(node);
            }
            else {
                template = this.getExternalTemplate(fileName);
            }
            if (!template) {
                return;
            }
            return this.getTemplateAst(template);
        }
        /**
         * Find the NgModule which the directive associated with the `classSymbol`
         * belongs to, then return its schema and transitive directives and pipes.
         * @param classSymbol Angular Symbol that defines a directive
         */
        getModuleMetadataForDirective(classSymbol) {
            const result = {
                directives: [],
                pipes: [],
                schemas: [],
            };
            // First find which NgModule the directive belongs to.
            const ngModule = this.analyzedModules.ngModuleByPipeOrDirective.get(classSymbol) ||
                findSuitableDefaultModule(this.analyzedModules);
            if (!ngModule) {
                return result;
            }
            // Then gather all transitive directives and pipes.
            const { directives, pipes } = ngModule.transitiveModule;
            for (const directive of directives) {
                const data = this.resolver.getNonNormalizedDirectiveMetadata(directive.reference);
                if (data) {
                    result.directives.push(data.metadata.toSummary());
                }
            }
            for (const pipe of pipes) {
                const metadata = this.resolver.getOrLoadPipeMetadata(pipe.reference);
                result.pipes.push(metadata.toSummary());
            }
            result.schemas.push(...ngModule.schemas);
            return result;
        }
        /**
         * Parse the `template` and return its AST, if any.
         * @param template template to be parsed
         */
        getTemplateAst(template) {
            const { type: classSymbol, fileName } = template;
            const data = this.resolver.getNonNormalizedDirectiveMetadata(classSymbol);
            if (!data) {
                return;
            }
            const htmlParser = new HtmlParser();
            const expressionParser = new Parser$1(new Lexer());
            const parser = new TemplateParser(new CompilerConfig(), this.reflector, expressionParser, new DomElementSchemaRegistry(), htmlParser, null, // console
            [] // tranforms
            );
            const htmlResult = htmlParser.parse(template.source, fileName, {
                tokenizeExpansionForms: true,
                preserveLineEndings: true, // do not convert CRLF to LF
            });
            const { directives, pipes, schemas } = this.getModuleMetadataForDirective(classSymbol);
            const parseResult = parser.tryParseHtml(htmlResult, data.metadata, directives, pipes, schemas);
            if (!parseResult.templateAst) {
                return;
            }
            return {
                htmlAst: htmlResult.rootNodes,
                templateAst: parseResult.templateAst,
                directive: data.metadata,
                directives,
                pipes,
                parseErrors: parseResult.errors,
                expressionParser,
                template,
            };
        }
        /**
         * Log the specified `msg` to file at INFO level. If logging is not enabled
         * this method is a no-op.
         * @param msg Log message
         */
        log(msg) {
            if (this.tsLsHost.log) {
                this.tsLsHost.log(msg);
            }
        }
        /**
         * Log the specified `msg` to file at ERROR level. If logging is not enabled
         * this method is a no-op.
         * @param msg error message
         */
        error(msg) {
            if (this.tsLsHost.error) {
                this.tsLsHost.error(msg);
            }
        }
        /**
         * Log debugging info to file at INFO level, only if verbose setting is turned
         * on. Otherwise, this method is a no-op.
         * @param msg debugging message
         */
        debug(msg) {
            const project = this.tsLsHost;
            if (!project.projectService) {
                // tsLsHost is not a Project
                return;
            }
            const { logger } = project.projectService;
            if (logger.hasLevel(tss.server.LogLevel.verbose)) {
                logger.info(msg);
            }
        }
    }
    function findSuitableDefaultModule(modules) {
        let result = undefined;
        let resultSize = 0;
        for (const module of modules.ngModules) {
            const moduleSize = module.transitiveModule.directives.length;
            if (moduleSize > resultSize) {
                result = module;
                resultSize = moduleSize;
            }
        }
        return result;
    }
    function spanOf$2(node) {
        return { start: node.getStart(), end: node.getEnd() };
    }
    function spanAt$1(sourceFile, line, column) {
        if (line != null && column != null) {
            const position = tss.getPositionOfLineAndCharacter(sourceFile, line, column);
            const findChild = function findChild(node) {
                if (node.kind > tss.SyntaxKind.LastToken && node.pos <= position && node.end > position) {
                    const betterNode = tss.forEachChild(node, findChild);
                    return betterNode || node;
                }
            };
            const node = tss.forEachChild(sourceFile, findChild);
            if (node) {
                return { start: node.getStart(), end: node.getEnd() };
            }
        }
    }
    function convertChain(chain) {
        return { message: chain.message, next: chain.next ? chain.next.map(convertChain) : undefined };
    }
    function errorToDiagnosticWithChain(error, span) {
        return { message: error.chain ? convertChain(error.chain) : error.message, span };
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    // Use a WeakMap to keep track of Project to Host mapping so that when Project
    // is deleted Host could be garbage collected.
    const PROJECT_MAP = new WeakMap();
    /**
     * This function is called by tsserver to retrieve the external (non-TS) files
     * that should belong to the specified `project`. For Angular, these files are
     * external templates. This is called once when the project is loaded, then
     * every time when the program is updated.
     * @param project Project for which external files should be retrieved.
     */
    function getExternalFiles(project) {
        if (!project.hasRoots()) {
            // During project initialization where there is no root files yet we should
            // not do any work.
            return [];
        }
        const ngLsHost = PROJECT_MAP.get(project);
        if (ngLsHost === undefined) {
            return [];
        }
        ngLsHost.getAnalyzedModules();
        return ngLsHost.getExternalTemplates().filter(fileName => {
            // TODO(kyliau): Remove this when the following PR lands on the version of
            // TypeScript used in this repo.
            // https://github.com/microsoft/TypeScript/pull/41737
            return project.fileExists(fileName);
        });
    }
    function create(info) {
        const { languageService: tsLS, languageServiceHost: tsLSHost, config, project } = info;
        // This plugin could operate under two different modes:
        // 1. TS + Angular
        //    Plugin augments TS language service to provide additional Angular
        //    information. This only works with inline templates and is meant to be
        //    used as a local plugin (configured via tsconfig.json)
        // 2. Angular only
        //    Plugin only provides information on Angular templates, no TS info at all.
        //    This effectively disables native TS features and is meant for internal
        //    use only.
        const angularOnly = config ? config.angularOnly === true : false;
        const ngLSHost = new TypeScriptServiceHost(tsLSHost, tsLS);
        const ngLS = createLanguageService(ngLSHost);
        PROJECT_MAP.set(project, ngLSHost);
        function getCompletionsAtPosition(fileName, position, options) {
            if (!angularOnly) {
                const results = tsLS.getCompletionsAtPosition(fileName, position, options);
                if (results && results.entries.length) {
                    // If TS could answer the query, then return results immediately.
                    return results;
                }
            }
            return ngLS.getCompletionsAtPosition(fileName, position, options);
        }
        function getQuickInfoAtPosition(fileName, position) {
            if (!angularOnly) {
                const result = tsLS.getQuickInfoAtPosition(fileName, position);
                if (result) {
                    // If TS could answer the query, then return results immediately.
                    return result;
                }
            }
            return ngLS.getQuickInfoAtPosition(fileName, position);
        }
        function getSemanticDiagnostics(fileName) {
            const results = [];
            if (!angularOnly) {
                results.push(...tsLS.getSemanticDiagnostics(fileName));
            }
            // For semantic diagnostics we need to combine both TS + Angular results
            results.push(...ngLS.getSemanticDiagnostics(fileName));
            return results;
        }
        function getDefinitionAtPosition(fileName, position) {
            if (!angularOnly) {
                const results = tsLS.getDefinitionAtPosition(fileName, position);
                if (results) {
                    // If TS could answer the query, then return results immediately.
                    return results;
                }
            }
            const result = ngLS.getDefinitionAndBoundSpan(fileName, position);
            if (!result || !result.definitions || !result.definitions.length) {
                return;
            }
            return result.definitions;
        }
        function getDefinitionAndBoundSpan(fileName, position) {
            if (!angularOnly) {
                const result = tsLS.getDefinitionAndBoundSpan(fileName, position);
                if (result) {
                    // If TS could answer the query, then return results immediately.
                    return result;
                }
            }
            return ngLS.getDefinitionAndBoundSpan(fileName, position);
        }
        function getTcb(fileName, position) {
            // Not implemented in VE Language Service
            return undefined;
        }
        function getComponentLocationsForTemplate(fileName) {
            // Not implemented in VE Language Service
            return [];
        }
        return Object.assign(Object.assign({}, tsLS), { 
            // Then override the methods supported by Angular language service
            getCompletionsAtPosition,
            getQuickInfoAtPosition,
            getSemanticDiagnostics,
            getDefinitionAtPosition,
            getDefinitionAndBoundSpan,
            getTcb,
            getComponentLocationsForTemplate });
    }

    exports.create = create;
    exports.getExternalFiles = getExternalFiles;

    Object.defineProperty(exports, '__esModule', { value: true });

});
//# sourceMappingURL=language-service.js.map
